/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/include/espeak-ng/espeak_ng.h:
    1|       |/* eSpeak NG API.
    2|       | *
    3|       | * Copyright (C) 2015-2017 Reece H. Dunn
    4|       | *
    5|       | * This program is free software: you can redistribute it and/or modify
    6|       | * it under the terms of the GNU General Public License as published by
    7|       | * the Free Software Foundation, either version 3 of the License, or
    8|       | * (at your option) any later version.
    9|       | *
   10|       | * This program is distributed in the hope that it will be useful,
   11|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   12|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   13|       | * GNU General Public License for more details.
   14|       | *
   15|       | * You should have received a copy of the GNU General Public License
   16|       | * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   17|       | */
   18|       |
   19|       |#ifndef ESPEAK_NG_H
   20|       |#define ESPEAK_NG_H
   21|       |
   22|       |#include <espeak-ng/speak_lib.h>
   23|       |
   24|       |#ifdef __cplusplus
   25|       |extern "C"
   26|       |{
   27|       |#endif
   28|       |
   29|       |#if defined(_WIN32) || defined(_WIN64)
   30|       |#ifdef LIBESPEAK_NG_EXPORT
   31|       |#define ESPEAK_NG_API __declspec(dllexport)
   32|       |#else
   33|       |#define ESPEAK_NG_API __declspec(dllimport)
   34|       |#endif
   35|       |#else
   36|       |#define ESPEAK_NG_API
   37|       |#endif
   38|       |
   39|      0|#define ESPEAKNG_DEFAULT_VOICE "en"
   40|       |
   41|       |typedef enum {
   42|       |	ENS_GROUP_MASK               = 0x70000000,
   43|       |	ENS_GROUP_ERRNO              = 0x00000000, /* Values 0-255 map to errno error codes. */
   44|       |	ENS_GROUP_ESPEAK_NG          = 0x10000000, /* eSpeak NG error codes. */
   45|       |
   46|       |	/* eSpeak NG 1.49.0 */
   47|       |	ENS_OK                       = 0,
   48|       |	ENS_COMPILE_ERROR            = 0x100001FF,
   49|       |	ENS_VERSION_MISMATCH         = 0x100002FF,
   50|       |	ENS_FIFO_BUFFER_FULL         = 0x100003FF,
   51|       |	ENS_NOT_INITIALIZED          = 0x100004FF,
   52|       |	ENS_AUDIO_ERROR              = 0x100005FF,
   53|       |	ENS_VOICE_NOT_FOUND          = 0x100006FF,
   54|       |	ENS_MBROLA_NOT_FOUND         = 0x100007FF,
   55|       |	ENS_MBROLA_VOICE_NOT_FOUND   = 0x100008FF,
   56|       |	ENS_EVENT_BUFFER_FULL        = 0x100009FF,
   57|       |	ENS_NOT_SUPPORTED            = 0x10000AFF,
   58|       |	ENS_UNSUPPORTED_PHON_FORMAT  = 0x10000BFF,
   59|       |	ENS_NO_SPECT_FRAMES          = 0x10000CFF,
   60|       |	ENS_EMPTY_PHONEME_MANIFEST   = 0x10000DFF,
   61|       |	ENS_SPEECH_STOPPED           = 0x10000EFF,
   62|       |
   63|       |	/* eSpeak NG 1.49.2 */
   64|       |	ENS_UNKNOWN_PHONEME_FEATURE  = 0x10000FFF,
   65|       |	ENS_UNKNOWN_TEXT_ENCODING    = 0x100010FF,
   66|       |} espeak_ng_STATUS;
   67|       |
   68|       |typedef enum {
   69|       |	ENOUTPUT_MODE_SYNCHRONOUS = 0x0001,
   70|       |	ENOUTPUT_MODE_SPEAK_AUDIO = 0x0002,
   71|       |} espeak_ng_OUTPUT_MODE;
   72|       |
   73|       |typedef enum {
   74|       |	ENGENDER_UNKNOWN = 0,
   75|       |	ENGENDER_MALE = 1,
   76|       |	ENGENDER_FEMALE = 2,
   77|       |	ENGENDER_NEUTRAL = 3,
   78|       |} espeak_ng_VOICE_GENDER;
   79|       |
   80|       |typedef struct
   81|       |{
   82|       |  void (*outputPhoSymbol)(char* pho_code,int pho_type);
   83|       |  void (*outputSilence)(short echo_tail);
   84|       |  void (*outputVoiced)(short sample);
   85|       |  void (*outputUnvoiced)(short sample);
   86|       |} espeak_ng_OUTPUT_HOOKS;
   87|       |
   88|       |/* eSpeak NG 1.49.0 */
   89|       |
   90|       |typedef struct espeak_ng_ERROR_CONTEXT_ *espeak_ng_ERROR_CONTEXT;
   91|       |
   92|       |ESPEAK_NG_API void
   93|       |espeak_ng_ClearErrorContext(espeak_ng_ERROR_CONTEXT *context);
   94|       |
   95|       |ESPEAK_NG_API void
   96|       |espeak_ng_GetStatusCodeMessage(espeak_ng_STATUS status,
   97|       |                               char *buffer,
   98|       |                               size_t length);
   99|       |
  100|       |ESPEAK_NG_API void
  101|       |espeak_ng_PrintStatusCodeMessage(espeak_ng_STATUS status,
  102|       |                                 FILE *out,
  103|       |                                 espeak_ng_ERROR_CONTEXT context);
  104|       |
  105|       |ESPEAK_NG_API void
  106|       |espeak_ng_InitializePath(const char *path);
  107|       |
  108|       |ESPEAK_NG_API espeak_ng_STATUS
  109|       |espeak_ng_Initialize(espeak_ng_ERROR_CONTEXT *context);
  110|       |
  111|       |ESPEAK_NG_API espeak_ng_STATUS
  112|       |espeak_ng_InitializeOutput(espeak_ng_OUTPUT_MODE output_mode,
  113|       |                           int buffer_length,
  114|       |                           const char *device);
  115|       |
  116|       |ESPEAK_NG_API int
  117|       |espeak_ng_GetSampleRate(void);
  118|       |
  119|       |ESPEAK_NG_API espeak_ng_STATUS
  120|       |espeak_ng_SetParameter(espeak_PARAMETER parameter,
  121|       |                       int value,
  122|       |                       int relative);
  123|       |
  124|       |ESPEAK_NG_API espeak_ng_STATUS
  125|       |espeak_ng_SetPunctuationList(const wchar_t *punctlist);
  126|       |
  127|       |ESPEAK_NG_API espeak_ng_STATUS
  128|       |espeak_ng_SetVoiceByName(const char *name);
  129|       |
  130|       |ESPEAK_NG_API espeak_ng_STATUS
  131|       |espeak_ng_SetVoiceByFile(const char *filename);
  132|       |
  133|       |ESPEAK_NG_API espeak_ng_STATUS
  134|       |espeak_ng_SetVoiceByProperties(espeak_VOICE *voice_selector);
  135|       |
  136|       |ESPEAK_NG_API espeak_ng_STATUS
  137|       |espeak_ng_Synthesize(const void *text,
  138|       |                     size_t size,
  139|       |                     unsigned int position,
  140|       |                     espeak_POSITION_TYPE position_type,
  141|       |                     unsigned int end_position,
  142|       |                     unsigned int flags,
  143|       |                     unsigned int *unique_identifier,
  144|       |                     void *user_data);
  145|       |
  146|       |ESPEAK_NG_API espeak_ng_STATUS
  147|       |espeak_ng_SynthesizeMark(const void *text,
  148|       |                         size_t size,
  149|       |                         const char *index_mark,
  150|       |                         unsigned int end_position,
  151|       |                         unsigned int flags,
  152|       |                         unsigned int *unique_identifier,
  153|       |                         void *user_data);
  154|       |
  155|       |ESPEAK_NG_API espeak_ng_STATUS
  156|       |espeak_ng_SpeakKeyName(const char *key_name);
  157|       |
  158|       |ESPEAK_NG_API espeak_ng_STATUS
  159|       |espeak_ng_SpeakCharacter(wchar_t character);
  160|       |
  161|       |ESPEAK_NG_API espeak_ng_STATUS
  162|       |espeak_ng_Cancel(void);
  163|       |
  164|       |ESPEAK_NG_API espeak_ng_STATUS
  165|       |espeak_ng_Synchronize(void);
  166|       |
  167|       |ESPEAK_NG_API espeak_ng_STATUS
  168|       |espeak_ng_Terminate(void);
  169|       |
  170|       |ESPEAK_NG_API espeak_ng_STATUS
  171|       |espeak_ng_CompileDictionary(const char *dsource,
  172|       |                            const char *dict_name,
  173|       |                            FILE *log,
  174|       |                            int flags,
  175|       |                            espeak_ng_ERROR_CONTEXT *context);
  176|       |
  177|       |ESPEAK_NG_API espeak_ng_STATUS
  178|       |espeak_ng_CompileMbrolaVoice(const char *path,
  179|       |                             FILE *log,
  180|       |                             espeak_ng_ERROR_CONTEXT *context);
  181|       |
  182|       |ESPEAK_NG_API espeak_ng_STATUS
  183|       |espeak_ng_CompilePhonemeData(long rate,
  184|       |                             FILE *log,
  185|       |                             espeak_ng_ERROR_CONTEXT *context);
  186|       |
  187|       |ESPEAK_NG_API espeak_ng_STATUS
  188|       |espeak_ng_CompileIntonation(FILE *log,
  189|       |                            espeak_ng_ERROR_CONTEXT *context);
  190|       |
  191|       |/* eSpeak NG 1.49.1 */
  192|       |
  193|       |ESPEAK_NG_API espeak_ng_STATUS
  194|       |espeak_ng_CompilePhonemeDataPath(long rate,
  195|       |                                 const char *source_path,
  196|       |                                 const char *destination_path,
  197|       |                                 FILE *log,
  198|       |                                 espeak_ng_ERROR_CONTEXT *context);
  199|       |                                 
  200|       |ESPEAK_NG_API espeak_ng_STATUS
  201|       |espeak_ng_SetOutputHooks(espeak_ng_OUTPUT_HOOKS* hooks);
  202|       |ESPEAK_NG_API espeak_ng_STATUS
  203|       |espeak_ng_SetConstF0(int f0);
  204|       |
  205|       |
  206|       |#ifdef __cplusplus
  207|       |}
  208|       |#endif
  209|       |
  210|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/include/espeak-ng/speak_lib.h:
    1|       |#ifndef SPEAK_LIB_H
    2|       |#define SPEAK_LIB_H
    3|       |/***************************************************************************
    4|       | *   Copyright (C) 2005 to 2012 by Jonathan Duddington                     *
    5|       | *   email: jonsd@users.sourceforge.net                                    *
    6|       | *                                                                         *
    7|       | *   This program is free software; you can redistribute it and/or modify  *
    8|       | *   it under the terms of the GNU General Public License as published by  *
    9|       | *   the Free Software Foundation; either version 3 of the License, or     *
   10|       | *   (at your option) any later version.                                   *
   11|       | *                                                                         *
   12|       | *   This program is distributed in the hope that it will be useful,       *
   13|       | *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
   14|       | *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
   15|       | *   GNU General Public License for more details.                          *
   16|       | *                                                                         *
   17|       | *   You should have received a copy of the GNU General Public License     *
   18|       | *   along with this program; if not, see:                                 *
   19|       | *               <http://www.gnu.org/licenses/>.                           *
   20|       | ***************************************************************************/
   21|       |
   22|       |
   23|       |/*************************************************************/
   24|       |/* This is the header file for the library version of espeak */
   25|       |/*                                                           */
   26|       |/*************************************************************/
   27|       |
   28|       |#include <stdio.h>
   29|       |#include <stddef.h>
   30|       |
   31|       |#if defined(_WIN32) || defined(_WIN64)
   32|       |#ifdef LIBESPEAK_NG_EXPORT
   33|       |#define ESPEAK_API __declspec(dllexport)
   34|       |#else
   35|       |#define ESPEAK_API __declspec(dllimport)
   36|       |#endif
   37|       |#else
   38|       |#define ESPEAK_API
   39|       |#endif
   40|       |
   41|       |#define ESPEAK_API_REVISION  12
   42|       |/*
   43|       |Revision 2
   44|       |   Added parameter "options" to eSpeakInitialize()
   45|       |
   46|       |Revision 3
   47|       |   Added espeakWORDGAP to  espeak_PARAMETER
   48|       |
   49|       |Revision 4
   50|       |   Added flags parameter to espeak_CompileDictionary()
   51|       |
   52|       |Revision 5
   53|       |   Added espeakCHARS_16BIT
   54|       |
   55|       |Revision 6
   56|       |  Added macros: espeakRATE_MINIMUM, espeakRATE_MAXIMUM, espeakRATE_NORMAL
   57|       |
   58|       |Revision 7  24.Dec.2011
   59|       |  Changed espeak_EVENT structure to add id.string[] for phoneme mnemonics.
   60|       |  Added espeakINITIALIZE_PHONEME_IPA option for espeak_Initialize() to report phonemes as IPA names.
   61|       |
   62|       |Revision 8  26.Apr.2013
   63|       |  Added function espeak_TextToPhonemes().
   64|       |
   65|       |Revision 9  30.May.2013
   66|       |  Changed function espeak_TextToPhonemes().
   67|       |
   68|       |Revision 10 29.Aug.2014
   69|       |  Changed phonememode parameter to espeak_TextToPhonemes() and espeak_SetPhonemeTrace
   70|       |
   71|       |Revision 11 (espeak-ng)
   72|       |  Made ESPEAK_API import/export symbols correctly on Windows.
   73|       |
   74|       |Revision 12 (espeak-ng)
   75|       |  Exposed espeak_SetPhonemeCallback. This is available in eSpeak, but was not exposed in this header.
   76|       |
   77|       |*/
   78|       |         /********************/
   79|       |         /*  Initialization  */
   80|       |         /********************/
   81|       |
   82|       |// values for 'value' in espeak_SetParameter(espeakRATE, value, 0), nominally in words-per-minute
   83|      0|#define espeakRATE_MINIMUM  80
   84|      0|#define espeakRATE_MAXIMUM  450
   85|      0|#define espeakRATE_NORMAL   175
   86|       |
   87|       |
   88|       |typedef enum {
   89|       |  espeakEVENT_LIST_TERMINATED = 0, // Retrieval mode: terminates the event list.
   90|       |  espeakEVENT_WORD = 1,            // Start of word
   91|       |  espeakEVENT_SENTENCE = 2,        // Start of sentence
   92|       |  espeakEVENT_MARK = 3,            // Mark
   93|       |  espeakEVENT_PLAY = 4,            // Audio element
   94|       |  espeakEVENT_END = 5,             // End of sentence or clause
   95|       |  espeakEVENT_MSG_TERMINATED = 6,  // End of message
   96|       |  espeakEVENT_PHONEME = 7,         // Phoneme, if enabled in espeak_Initialize()
   97|       |  espeakEVENT_SAMPLERATE = 8       // internal use, set sample rate
   98|       |} espeak_EVENT_TYPE;
   99|       |
  100|       |
  101|       |
  102|       |typedef struct {
  103|       |	espeak_EVENT_TYPE type;
  104|       |	unsigned int unique_identifier; // message identifier (or 0 for key or character)
  105|       |	int text_position;    // the number of characters from the start of the text
  106|       |	int length;           // word length, in characters (for espeakEVENT_WORD)
  107|       |	int audio_position;   // the time in mS within the generated speech output data
  108|       |	int sample;           // sample id (internal use)
  109|       |	void* user_data;      // pointer supplied by the calling program
  110|       |	union {
  111|       |		int number;        // used for WORD and SENTENCE events.
  112|       |		const char *name;  // used for MARK and PLAY events.  UTF8 string
  113|       |		char string[8];    // used for phoneme names (UTF8). Terminated by a zero byte unless the name needs the full 8 bytes.
  114|       |	} id;
  115|       |} espeak_EVENT;
  116|       |/*
  117|       |   When a message is supplied to espeak_synth, the request is buffered and espeak_synth returns. When the message is really processed, the callback function will be repetedly called.
  118|       |
  119|       |
  120|       |   In RETRIEVAL mode, the callback function supplies to the calling program the audio data and an event list terminated by 0 (LIST_TERMINATED).
  121|       |
  122|       |   In PLAYBACK mode, the callback function is called as soon as an event happens.
  123|       |
  124|       |   For example suppose that the following message is supplied to espeak_Synth:
  125|       |   "hello, hello."
  126|       |
  127|       |
  128|       |   * Once processed in RETRIEVAL mode, it could lead to 3 calls of the callback function :
  129|       |
  130|       |   ** Block 1:
  131|       |   <audio data> +
  132|       |   List of events: SENTENCE + WORD + LIST_TERMINATED
  133|       |
  134|       |   ** Block 2:
  135|       |   <audio data> +
  136|       |   List of events: WORD + END + LIST_TERMINATED
  137|       |
  138|       |   ** Block 3:
  139|       |   no audio data
  140|       |   List of events: MSG_TERMINATED + LIST_TERMINATED
  141|       |
  142|       |
  143|       |   * Once processed in PLAYBACK mode, it could lead to 5 calls of the callback function:
  144|       |
  145|       |   ** SENTENCE
  146|       |   ** WORD (call when the sounds are actually played)
  147|       |   ** WORD
  148|       |   ** END (call when the end of sentence is actually played.)
  149|       |   ** MSG_TERMINATED
  150|       |
  151|       |
  152|       |   The MSG_TERMINATED event is the last event. It can inform the calling program to clear the user data related to the message.
  153|       |   So if the synthesis must be stopped, the callback function is called for each pending message with the MSG_TERMINATED event.
  154|       |
  155|       |   A MARK event indicates a <mark> element in the text.
  156|       |   A PLAY event indicates an <audio> element in the text, for which the calling program should play the named sound file.
  157|       |*/
  158|       |
  159|       |
  160|       |
  161|       |typedef enum {
  162|       |	POS_CHARACTER = 1,
  163|       |	POS_WORD,
  164|       |	POS_SENTENCE
  165|       |} espeak_POSITION_TYPE;
  166|       |
  167|       |
  168|       |typedef enum {
  169|       |	/* PLAYBACK mode: plays the audio data, supplies events to the calling program*/
  170|       |	AUDIO_OUTPUT_PLAYBACK,
  171|       |
  172|       |	/* RETRIEVAL mode: supplies audio data and events to the calling program */
  173|       |	AUDIO_OUTPUT_RETRIEVAL,
  174|       |
  175|       |	/* SYNCHRONOUS mode: as RETRIEVAL but doesn't return until synthesis is completed */
  176|       |	AUDIO_OUTPUT_SYNCHRONOUS,
  177|       |
  178|       |	/* Synchronous playback */
  179|       |	AUDIO_OUTPUT_SYNCH_PLAYBACK
  180|       |
  181|       |} espeak_AUDIO_OUTPUT;
  182|       |
  183|       |
  184|       |typedef enum {
  185|       |	EE_OK=0,
  186|       |	EE_INTERNAL_ERROR=-1,
  187|       |	EE_BUFFER_FULL=1,
  188|       |	EE_NOT_FOUND=2
  189|       |} espeak_ERROR;
  190|       |
  191|      0|#define espeakINITIALIZE_PHONEME_EVENTS 0x0001
  192|       |#define espeakINITIALIZE_PHONEME_IPA   0x0002
  193|      0|#define espeakINITIALIZE_DONT_EXIT     0x8000
  194|       |
  195|       |#ifdef __cplusplus
  196|       |extern "C"
  197|       |#endif
  198|       |ESPEAK_API int espeak_Initialize(espeak_AUDIO_OUTPUT output, int buflength, const char *path, int options);
  199|       |/* Must be called before any synthesis functions are called.
  200|       |   output: the audio data can either be played by eSpeak or passed back by the SynthCallback function.
  201|       |
  202|       |   buflength:  The length in mS of sound buffers passed to the SynthCallback function.
  203|       |            Value=0 gives a default of 60mS.
  204|       |            This parameter is only used for AUDIO_OUTPUT_RETRIEVAL and AUDIO_OUTPUT_SYNCHRONOUS modes.
  205|       |
  206|       |   path: The directory which contains the espeak-ng-data directory, or NULL for the default location.
  207|       |
  208|       |   options: bit 0:  1=allow espeakEVENT_PHONEME events.
  209|       |            bit 1:  1= espeakEVENT_PHONEME events give IPA phoneme names, not eSpeak phoneme names
  210|       |            bit 15: 1=don't exit if espeak_data is not found (used for --help)
  211|       |
  212|       |   Returns: sample rate in Hz, or -1 (EE_INTERNAL_ERROR).
  213|       |*/
  214|       |
  215|       |typedef int (t_espeak_callback)(short*, int, espeak_EVENT*);
  216|       |
  217|       |#ifdef __cplusplus
  218|       |extern "C"
  219|       |#endif
  220|       |ESPEAK_API void espeak_SetSynthCallback(t_espeak_callback* SynthCallback);
  221|       |/* Must be called before any synthesis functions are called.
  222|       |   This specifies a function in the calling program which is called when a buffer of
  223|       |   speech sound data has been produced.
  224|       |
  225|       |
  226|       |   The callback function is of the form:
  227|       |
  228|       |int SynthCallback(short *wav, int numsamples, espeak_EVENT *events);
  229|       |
  230|       |   wav:  is the speech sound data which has been produced.
  231|       |      NULL indicates that the synthesis has been completed.
  232|       |
  233|       |   numsamples: is the number of entries in wav.  This number may vary, may be less than
  234|       |      the value implied by the buflength parameter given in espeak_Initialize, and may
  235|       |      sometimes be zero (which does NOT indicate end of synthesis).
  236|       |
  237|       |   events: an array of espeak_EVENT items which indicate word and sentence events, and
  238|       |      also the occurrence if <mark> and <audio> elements within the text.  The list of
  239|       |      events is terminated by an event of type = 0.
  240|       |
  241|       |
  242|       |   Callback returns: 0=continue synthesis,  1=abort synthesis.
  243|       |*/
  244|       |
  245|       |#ifdef __cplusplus
  246|       |extern "C"
  247|       |#endif
  248|       |ESPEAK_API void espeak_SetUriCallback(int (*UriCallback)(int, const char*, const char*));
  249|       |/* This function may be called before synthesis functions are used, in order to deal with
  250|       |   <audio> tags.  It specifies a callback function which is called when an <audio> element is
  251|       |   encountered and allows the calling program to indicate whether the sound file which
  252|       |   is specified in the <audio> element is available and is to be played.
  253|       |
  254|       |   The callback function is of the form:
  255|       |
  256|       |int UriCallback(int type, const char *uri, const char *base);
  257|       |
  258|       |   type:  type of callback event.  Currently only 1= <audio> element
  259|       |
  260|       |   uri:   the "src" attribute from the <audio> element
  261|       |
  262|       |   base:  the "xml:base" attribute (if any) from the <speak> element
  263|       |
  264|       |   Return: 1=don't play the sound, but speak the text alternative.
  265|       |           0=place a PLAY event in the event list at the point where the <audio> element
  266|       |             occurs.  The calling program can then play the sound at that point.
  267|       |*/
  268|       |
  269|       |#ifdef __cplusplus
  270|       |extern "C"
  271|       |#endif
  272|       |ESPEAK_API void espeak_SetPhonemeCallback(int (*PhonemeCallback)(const char *));
  273|       |
  274|       |
  275|       |         /********************/
  276|       |         /*    Synthesis     */
  277|       |         /********************/
  278|       |
  279|       |
  280|      0|#define espeakCHARS_AUTO   0
  281|      0|#define espeakCHARS_UTF8   1
  282|      0|#define espeakCHARS_8BIT   2
  283|      0|#define espeakCHARS_WCHAR  3
  284|      0|#define espeakCHARS_16BIT  4
  285|       |
  286|      0|#define espeakSSML        0x10
  287|      0|#define espeakPHONEMES    0x100
  288|      0|#define espeakENDPAUSE    0x1000
  289|      0|#define espeakKEEP_NAMEDATA 0x2000
  290|       |
  291|       |#ifdef __cplusplus
  292|       |extern "C"
  293|       |#endif
  294|       |ESPEAK_API espeak_ERROR espeak_Synth(const void *text,
  295|       |	size_t size,
  296|       |	unsigned int position,
  297|       |	espeak_POSITION_TYPE position_type,
  298|       |	unsigned int end_position,
  299|       |	unsigned int flags,
  300|       |	unsigned int* unique_identifier,
  301|       |	void* user_data);
  302|       |/* Synthesize speech for the specified text.  The speech sound data is passed to the calling
  303|       |   program in buffers by means of the callback function specified by espeak_SetSynthCallback(). The command is asynchronous: it is internally buffered and returns as soon as possible. If espeak_Initialize was previously called with AUDIO_OUTPUT_PLAYBACK as argument, the sound data are played by eSpeak.
  304|       |
  305|       |   text: The text to be spoken, terminated by a zero character. It may be either 8-bit characters,
  306|       |      wide characters (wchar_t), or UTF8 encoding.  Which of these is determined by the "flags"
  307|       |      parameter.
  308|       |
  309|       |   size: Equal to (or greatrer than) the size of the text data, in bytes.  This is used in order
  310|       |      to allocate internal storage space for the text.  This value is not used for
  311|       |      AUDIO_OUTPUT_SYNCHRONOUS mode.
  312|       |
  313|       |   position:  The position in the text where speaking starts. Zero indicates speak from the
  314|       |      start of the text.
  315|       |
  316|       |   position_type:  Determines whether "position" is a number of characters, words, or sentences.
  317|       |      Values:
  318|       |
  319|       |   end_position:  If set, this gives a character position at which speaking will stop.  A value
  320|       |      of zero indicates no end position.
  321|       |
  322|       |   flags:  These may be OR'd together:
  323|       |      Type of character codes, one of:
  324|       |         espeakCHARS_UTF8     UTF8 encoding
  325|       |         espeakCHARS_8BIT     The 8 bit ISO-8859 character set for the particular language.
  326|       |         espeakCHARS_AUTO     8 bit or UTF8  (this is the default)
  327|       |         espeakCHARS_WCHAR    Wide characters (wchar_t)
  328|       |         espeakCHARS_16BIT    16 bit characters.
  329|       |
  330|       |      espeakSSML   Elements within < > are treated as SSML elements, or if not recognised are ignored.
  331|       |
  332|       |      espeakPHONEMES  Text within [[ ]] is treated as phonemes codes (in espeak's Kirshenbaum encoding).
  333|       |
  334|       |      espeakENDPAUSE  If set then a sentence pause is added at the end of the text.  If not set then
  335|       |         this pause is suppressed.
  336|       |
  337|       |   unique_identifier: This must be either NULL, or point to an integer variable to
  338|       |       which eSpeak writes a message identifier number.
  339|       |       eSpeak includes this number in espeak_EVENT messages which are the result of
  340|       |       this call of espeak_Synth().
  341|       |
  342|       |   user_data: a pointer (or NULL) which will be passed to the callback function in
  343|       |       espeak_EVENT messages.
  344|       |
  345|       |   Return: EE_OK: operation achieved
  346|       |           EE_BUFFER_FULL: the command can not be buffered;
  347|       |             you may try after a while to call the function again.
  348|       |	   EE_INTERNAL_ERROR.
  349|       |*/
  350|       |
  351|       |#ifdef __cplusplus
  352|       |extern "C"
  353|       |#endif
  354|       |ESPEAK_API espeak_ERROR espeak_Synth_Mark(const void *text,
  355|       |	size_t size,
  356|       |	const char *index_mark,
  357|       |	unsigned int end_position,
  358|       |	unsigned int flags,
  359|       |	unsigned int* unique_identifier,
  360|       |	void* user_data);
  361|       |/* Synthesize speech for the specified text.  Similar to espeak_Synth() but the start position is
  362|       |   specified by the name of a <mark> element in the text.
  363|       |
  364|       |   index_mark:  The "name" attribute of a <mark> element within the text which specified the
  365|       |      point at which synthesis starts.  UTF8 string.
  366|       |
  367|       |   For the other parameters, see espeak_Synth()
  368|       |
  369|       |   Return: EE_OK: operation achieved
  370|       |           EE_BUFFER_FULL: the command can not be buffered;
  371|       |             you may try after a while to call the function again.
  372|       |	   EE_INTERNAL_ERROR.
  373|       |*/
  374|       |
  375|       |#ifdef __cplusplus
  376|       |extern "C"
  377|       |#endif
  378|       |ESPEAK_API espeak_ERROR espeak_Key(const char *key_name);
  379|       |/* Speak the name of a keyboard key.
  380|       |   If key_name is a single character, it speaks the name of the character.
  381|       |   Otherwise, it speaks key_name as a text string.
  382|       |
  383|       |   Return: EE_OK: operation achieved
  384|       |           EE_BUFFER_FULL: the command can not be buffered;
  385|       |             you may try after a while to call the function again.
  386|       |	   EE_INTERNAL_ERROR.
  387|       |*/
  388|       |
  389|       |#ifdef __cplusplus
  390|       |extern "C"
  391|       |#endif
  392|       |ESPEAK_API espeak_ERROR espeak_Char(wchar_t character);
  393|       |/* Speak the name of the given character
  394|       |
  395|       |   Return: EE_OK: operation achieved
  396|       |           EE_BUFFER_FULL: the command can not be buffered;
  397|       |             you may try after a while to call the function again.
  398|       |	   EE_INTERNAL_ERROR.
  399|       |*/
  400|       |
  401|       |
  402|       |
  403|       |
  404|       |         /***********************/
  405|       |         /*  Speech Parameters  */
  406|       |         /***********************/
  407|       |
  408|       |typedef enum {
  409|       |  espeakSILENCE=0, /* internal use */
  410|       |  espeakRATE=1,
  411|       |  espeakVOLUME=2,
  412|       |  espeakPITCH=3,
  413|       |  espeakRANGE=4,
  414|       |  espeakPUNCTUATION=5,
  415|       |  espeakCAPITALS=6,
  416|       |  espeakWORDGAP=7,
  417|       |  espeakOPTIONS=8,   // reserved for misc. options.  not yet used
  418|       |  espeakINTONATION=9,
  419|       |
  420|       |  espeakRESERVED1=10,
  421|       |  espeakRESERVED2=11,
  422|       |  espeakEMPHASIS,   /* internal use */
  423|       |  espeakLINELENGTH, /* internal use */
  424|       |  espeakVOICETYPE,  // internal, 1=mbrola
  425|       |  N_SPEECH_PARAM    /* last enum */
  426|       |} espeak_PARAMETER;
  427|       |
  428|       |typedef enum {
  429|       |  espeakPUNCT_NONE=0,
  430|       |  espeakPUNCT_ALL=1,
  431|       |  espeakPUNCT_SOME=2
  432|       |} espeak_PUNCT_TYPE;
  433|       |
  434|       |#ifdef __cplusplus
  435|       |extern "C"
  436|       |#endif
  437|       |ESPEAK_API espeak_ERROR espeak_SetParameter(espeak_PARAMETER parameter, int value, int relative);
  438|       |/* Sets the value of the specified parameter.
  439|       |   relative=0   Sets the absolute value of the parameter.
  440|       |   relative=1   Sets a relative value of the parameter.
  441|       |
  442|       |   parameter:
  443|       |      espeakRATE:    speaking speed in word per minute.  Values 80 to 450.
  444|       |
  445|       |      espeakVOLUME:  volume in range 0-200 or more.
  446|       |                     0=silence, 100=normal full volume, greater values may produce amplitude compression or distortion
  447|       |
  448|       |      espeakPITCH:   base pitch, range 0-100.  50=normal
  449|       |
  450|       |      espeakRANGE:   pitch range, range 0-100. 0-monotone, 50=normal
  451|       |
  452|       |      espeakPUNCTUATION:  which punctuation characters to announce:
  453|       |         value in espeak_PUNCT_TYPE (none, all, some),
  454|       |         see espeak_GetParameter() to specify which characters are announced.
  455|       |
  456|       |      espeakCAPITALS: announce capital letters by:
  457|       |         0=none,
  458|       |         1=sound icon,
  459|       |         2=spelling,
  460|       |         3 or higher, by raising pitch.  This values gives the amount in Hz by which the pitch
  461|       |            of a word raised to indicate it has a capital letter.
  462|       |
  463|       |      espeakWORDGAP:  pause between words, units of 10mS (at the default speed)
  464|       |
  465|       |   Return: EE_OK: operation achieved
  466|       |           EE_BUFFER_FULL: the command can not be buffered;
  467|       |             you may try after a while to call the function again.
  468|       |	   EE_INTERNAL_ERROR.
  469|       |*/
  470|       |
  471|       |#ifdef __cplusplus
  472|       |extern "C"
  473|       |#endif
  474|       |ESPEAK_API int espeak_GetParameter(espeak_PARAMETER parameter, int current);
  475|       |/* current=0  Returns the default value of the specified parameter.
  476|       |   current=1  Returns the current value of the specified parameter, as set by SetParameter()
  477|       |*/
  478|       |
  479|       |#ifdef __cplusplus
  480|       |extern "C"
  481|       |#endif
  482|       |ESPEAK_API espeak_ERROR espeak_SetPunctuationList(const wchar_t *punctlist);
  483|       |/* Specified a list of punctuation characters whose names are to be spoken when the
  484|       |   value of the Punctuation parameter is set to "some".
  485|       |
  486|       |   punctlist:  A list of character codes, terminated by a zero character.
  487|       |
  488|       |   Return: EE_OK: operation achieved
  489|       |           EE_BUFFER_FULL: the command can not be buffered;
  490|       |             you may try after a while to call the function again.
  491|       |	   EE_INTERNAL_ERROR.
  492|       |*/
  493|       |
  494|       |#define espeakPHONEMES_SHOW    0x01
  495|      0|#define espeakPHONEMES_IPA     0x02
  496|      0|#define espeakPHONEMES_TRACE   0x08
  497|      0|#define espeakPHONEMES_MBROLA  0x10
  498|      0|#define espeakPHONEMES_TIE     0x80
  499|       |
  500|       |#ifdef __cplusplus
  501|       |extern "C"
  502|       |#endif
  503|       |ESPEAK_API void espeak_SetPhonemeTrace(int phonememode, FILE *stream);
  504|       |/* phonememode:  Controls the output of phoneme symbols for the text
  505|       |      bits 0-2:
  506|       |         value=0  No phoneme output (default)
  507|       |         value=1  Output the translated phoneme symbols for the text
  508|       |         value=2  as (1), but produces IPA phoneme names rather than ascii
  509|       |      bit 3:   output a trace of how the translation was done (showing the matching rules and list entries)
  510|       |      bit 4:   produce pho data for mbrola
  511|       |      bit 7:   use (bits 8-23) as a tie within multi-letter phonemes names
  512|       |      bits 8-23:  separator character, between phoneme names
  513|       |
  514|       |   stream   output stream for the phoneme symbols (and trace).  If stream=NULL then it uses stdout.
  515|       |*/
  516|       |
  517|       |#ifdef __cplusplus
  518|       |extern "C"
  519|       |#endif
  520|       |ESPEAK_API const char *espeak_TextToPhonemes(const void **textptr, int textmode, int phonememode);
  521|       |/* Translates text into phonemes.  Call espeak_SetVoiceByName() first, to select a language.
  522|       |
  523|       |   It returns a pointer to a character string which contains the phonemes for the text up to
  524|       |   end of a sentence, or comma, semicolon, colon, or similar punctuation.
  525|       |
  526|       |   textptr: The address of a pointer to the input text which is terminated by a zero character.
  527|       |      On return, the pointer has been advanced past the text which has been translated, or else set
  528|       |      to NULL to indicate that the end of the text has been reached.
  529|       |
  530|       |   textmode: Type of character codes, one of:
  531|       |         espeakCHARS_UTF8     UTF8 encoding
  532|       |         espeakCHARS_8BIT     The 8 bit ISO-8859 character set for the particular language.
  533|       |         espeakCHARS_AUTO     8 bit or UTF8  (this is the default)
  534|       |         espeakCHARS_WCHAR    Wide characters (wchar_t)
  535|       |         espeakCHARS_16BIT    16 bit characters.
  536|       |
  537|       |   phoneme_mode
  538|       |	    bit 1:   0=eSpeak's ascii phoneme names, 1= International Phonetic Alphabet (as UTF-8 characters).
  539|       |        bit 7:   use (bits 8-23) as a tie within multi-letter phonemes names
  540|       |        bits 8-23:  separator character, between phoneme names
  541|       |
  542|       |*/
  543|       |
  544|       |#ifdef __cplusplus
  545|       |extern "C"
  546|       |#endif
  547|       |ESPEAK_API void espeak_CompileDictionary(const char *path, FILE *log, int flags);
  548|       |/* Compile pronunciation dictionary for a language which corresponds to the currently
  549|       |   selected voice.  The required voice should be selected before calling this function.
  550|       |
  551|       |   path:  The directory which contains the language's '_rules' and '_list' files.
  552|       |          'path' should end with a path separator character ('/').
  553|       |   log:   Stream for error reports and statistics information. If log=NULL then stderr will be used.
  554|       |
  555|       |   flags:  Bit 0: include source line information for debug purposes (This is displayed with the
  556|       |          -X command line option).
  557|       |*/
  558|       |         /***********************/
  559|       |         /*   Voice Selection   */
  560|       |         /***********************/
  561|       |
  562|       |
  563|       |// voice table
  564|       |typedef struct {
  565|       |	const char *name;      // a given name for this voice. UTF8 string.
  566|       |	const char *languages;       // list of pairs of (byte) priority + (string) language (and dialect qualifier)
  567|       |	const char *identifier;      // the filename for this voice within espeak-ng-data/voices
  568|       |	unsigned char gender;  // 0=none 1=male, 2=female,
  569|       |	unsigned char age;     // 0=not specified, or age in years
  570|       |	unsigned char variant; // only used when passed as a parameter to espeak_SetVoiceByProperties
  571|       |	unsigned char xx1;     // for internal use
  572|       |	int score;       // for internal use
  573|       |	void *spare;     // for internal use
  574|       |} espeak_VOICE;
  575|       |
  576|       |/* Note: The espeak_VOICE structure is used for two purposes:
  577|       |  1.  To return the details of the available voices.
  578|       |  2.  As a parameter to  espeak_SetVoiceByProperties() in order to specify selection criteria.
  579|       |
  580|       |   In (1), the "languages" field consists of a list of (UTF8) language names for which this voice
  581|       |   may be used, each language name in the list is terminated by a zero byte and is also preceded by
  582|       |   a single byte which gives a "priority" number.  The list of languages is terminated by an
  583|       |   additional zero byte.
  584|       |
  585|       |   A language name consists of a language code, optionally followed by one or more qualifier (dialect)
  586|       |   names separated by hyphens (eg. "en-uk").  A voice might, for example, have languages "en-uk" and
  587|       |   "en".  Even without "en" listed, voice would still be selected for the "en" language (because
  588|       |   "en-uk" is related) but at a lower priority.
  589|       |
  590|       |   The priority byte indicates how the voice is preferred for the language. A low number indicates a
  591|       |   more preferred voice, a higher number indicates a less preferred voice.
  592|       |
  593|       |   In (2), the "languages" field consists simply of a single (UTF8) language name, with no preceding
  594|       |   priority byte.
  595|       |*/
  596|       |
  597|       |#ifdef __cplusplus
  598|       |extern "C"
  599|       |#endif
  600|       |ESPEAK_API const espeak_VOICE **espeak_ListVoices(espeak_VOICE *voice_spec);
  601|       |/* Reads the voice files from espeak-ng-data/voices and creates an array of espeak_VOICE pointers.
  602|       |   The list is terminated by a NULL pointer
  603|       |
  604|       |   If voice_spec is NULL then all voices are listed.
  605|       |   If voice spec is given, then only the voices which are compatible with the voice_spec
  606|       |   are listed, and they are listed in preference order.
  607|       |*/
  608|       |
  609|       |#ifdef __cplusplus
  610|       |extern "C"
  611|       |#endif
  612|       |ESPEAK_API espeak_ERROR espeak_SetVoiceByFile(const char *filename);
  613|       |/* Loads a voice given the file path.  Language is not considered.
  614|       |   "filename" is a UTF8 string.
  615|       |
  616|       |   Return: EE_OK: operation achieved
  617|       |           EE_BUFFER_FULL: the command can not be buffered;
  618|       |             you may try after a while to call the function again.
  619|       |	   EE_INTERNAL_ERROR.
  620|       |*/
  621|       |
  622|       |#ifdef __cplusplus
  623|       |extern "C"
  624|       |#endif
  625|       |ESPEAK_API espeak_ERROR espeak_SetVoiceByName(const char *name);
  626|       |/* Searches for a voice with a matching "name" field.  Language is not considered.
  627|       |   "name" is a UTF8 string.
  628|       |
  629|       |   Return: EE_OK: operation achieved
  630|       |           EE_BUFFER_FULL: the command can not be buffered;
  631|       |             you may try after a while to call the function again.
  632|       |	   EE_INTERNAL_ERROR.
  633|       |*/
  634|       |
  635|       |#ifdef __cplusplus
  636|       |extern "C"
  637|       |#endif
  638|       |ESPEAK_API espeak_ERROR espeak_SetVoiceByProperties(espeak_VOICE *voice_spec);
  639|       |/* An espeak_VOICE structure is used to pass criteria to select a voice.  Any of the following
  640|       |   fields may be set:
  641|       |
  642|       |   name     NULL, or a voice name
  643|       |
  644|       |   languages  NULL, or a single language string (with optional dialect), eg. "en-uk", or "en"
  645|       |
  646|       |   gender   0=not specified, 1=male, 2=female
  647|       |
  648|       |   age      0=not specified, or an age in years
  649|       |
  650|       |   variant  After a list of candidates is produced, scored and sorted, "variant" is used to index
  651|       |            that list and choose a voice.
  652|       |            variant=0 takes the top voice (i.e. best match). variant=1 takes the next voice, etc
  653|       |*/
  654|       |
  655|       |#ifdef __cplusplus
  656|       |extern "C"
  657|       |#endif
  658|       |ESPEAK_API espeak_VOICE *espeak_GetCurrentVoice(void);
  659|       |/* Returns the espeak_VOICE data for the currently selected voice.
  660|       |   This is not affected by temporary voice changes caused by SSML elements such as <voice> and <s>
  661|       |*/
  662|       |
  663|       |#ifdef __cplusplus
  664|       |extern "C"
  665|       |#endif
  666|       |ESPEAK_API espeak_ERROR espeak_Cancel(void);
  667|       |/* Stop immediately synthesis and audio output of the current text. When this
  668|       |   function returns, the audio output is fully stopped and the synthesizer is ready to
  669|       |   synthesize a new message.
  670|       |
  671|       |   Return: EE_OK: operation achieved
  672|       |	   EE_INTERNAL_ERROR.
  673|       |*/
  674|       |
  675|       |
  676|       |#ifdef __cplusplus
  677|       |extern "C"
  678|       |#endif
  679|       |ESPEAK_API int espeak_IsPlaying(void);
  680|       |/* Returns 1 if audio is played, 0 otherwise.
  681|       |*/
  682|       |
  683|       |#ifdef __cplusplus
  684|       |extern "C"
  685|       |#endif
  686|       |ESPEAK_API espeak_ERROR espeak_Synchronize(void);
  687|       |/* This function returns when all data have been spoken.
  688|       |   Return: EE_OK: operation achieved
  689|       |	   EE_INTERNAL_ERROR.
  690|       |*/
  691|       |
  692|       |#ifdef __cplusplus
  693|       |extern "C"
  694|       |#endif
  695|       |ESPEAK_API espeak_ERROR espeak_Terminate(void);
  696|       |/* last function to be called.
  697|       |   Return: EE_OK: operation achieved
  698|       |	   EE_INTERNAL_ERROR.
  699|       |*/
  700|       |
  701|       |
  702|       |#ifdef __cplusplus
  703|       |extern "C"
  704|       |#endif
  705|       |ESPEAK_API const char *espeak_Info(const char **path_data);
  706|       |/* Returns the version number string.
  707|       |   path_data  returns the path to espeak_data
  708|       |*/
  709|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/compiledict.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2014 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2017 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, write see:
   18|       | *             <http://www.gnu.org/licenses/>.
   19|       | */
   20|       |
   21|       |#include "config.h"
   22|       |
   23|       |#include <ctype.h>
   24|       |#include <errno.h>
   25|       |#include <stdbool.h>
   26|       |#include <stdint.h>
   27|       |#include <stdio.h>
   28|       |#include <stdlib.h>
   29|       |#include <string.h>
   30|       |#include <wctype.h>
   31|       |
   32|       |#include <espeak-ng/espeak_ng.h>
   33|       |#include <espeak-ng/speak_lib.h>
   34|       |#include <espeak-ng/encoding.h>
   35|       |
   36|       |#include "compiledict.h"
   37|       |#include "dictionary.h"           // for EncodePhonemes, strncpy0, HashDicti...
   38|       |#include "error.h"                // for create_file_error_context
   39|       |#include "mnemonics.h"               // for LookupMnemName, MNEM_TAB
   40|       |#include "phoneme.h"              // for PHONEME_TAB_LIST, phonSWITCH, phone...
   41|       |#include "readclause.h"           // for towlower2
   42|       |#include "speech.h"		// for path_home
   43|       |#include "synthesize.h"           // for Write4Bytes
   44|       |#include "translate.h"            // for isspace2, IsDigit09, utf8_in, utf8_out
   45|       |
   46|       |static FILE *f_log = NULL;
   47|       |
   48|       |extern char word_phonemes[N_WORD_PHONEMES];    // a word translated into phoneme codes
   49|       |
   50|       |static int linenum;
   51|       |static int error_count;
   52|       |static bool text_mode = false;
   53|       |static int debug_flag = 0;
   54|       |static int error_need_dictionary = 0;
   55|       |
   56|       |// A hash chain is a linked-list of hash chain entry objects:
   57|       |//     struct hash_chain_entry {
   58|       |//         hash_chain_entry *next_entry;
   59|       |//         // dict_line output from compile_line:
   60|       |//         uint8_t length;
   61|       |//         char contents[length];
   62|       |//     };
   63|       |static char *hash_chains[N_HASH_DICT];
   64|       |
   65|       |static char letterGroupsDefined[N_LETTER_GROUPS];
   66|       |
   67|       |MNEM_TAB mnem_rules[] = {
   68|       |	{ "unpr",     DOLLAR_UNPR },
   69|       |	{ "noprefix", DOLLAR_NOPREFIX },  // rule fails if a prefix has been removed
   70|       |	{ "list",     DOLLAR_LIST },    // a pronunciation is given in the *_list file
   71|       |
   72|       |	{ "w_alt1", 0x11 },
   73|       |	{ "w_alt2", 0x12 },
   74|       |	{ "w_alt3", 0x13 },
   75|       |	{ "w_alt4", 0x14 },
   76|       |	{ "w_alt5", 0x15 },
   77|       |	{ "w_alt6", 0x16 },
   78|       |	{ "w_alt",  0x11 }, // note: put longer names before their sub-strings
   79|       |
   80|       |	{ "p_alt1", 0x21 },
   81|       |	{ "p_alt2", 0x22 },
   82|       |	{ "p_alt3", 0x23 },
   83|       |	{ "p_alt4", 0x24 },
   84|       |	{ "p_alt5", 0x25 },
   85|       |	{ "p_alt6", 0x26 },
   86|       |	{ "p_alt",  0x21 },
   87|       |
   88|       |	{ NULL, -1 }
   89|       |};
   90|       |
   91|       |MNEM_TAB mnem_flags[] = {
   92|       |	// these in the first group put a value in bits0-3 of dictionary_flags
   93|       |	{ "$1",   0x41 }, // stress on 1st syllable
   94|       |	{ "$2",   0x42 }, // stress on 2nd syllable
   95|       |	{ "$3",   0x43 },
   96|       |	{ "$4",   0x44 },
   97|       |	{ "$5",   0x45 },
   98|       |	{ "$6",   0x46 },
   99|       |	{ "$7",   0x47 },
  100|       |	{ "$u",   0x48 }, // reduce to unstressed
  101|       |	{ "$u1",  0x49 },
  102|       |	{ "$u2",  0x4a },
  103|       |	{ "$u3",  0x4b },
  104|       |	{ "$u+",  0x4c }, // reduce to unstressed, but stress at end of clause
  105|       |	{ "$u1+", 0x4d },
  106|       |	{ "$u2+", 0x4e },
  107|       |	{ "$u3+", 0x4f },
  108|       |
  109|       |	// these set the corresponding numbered bit if dictionary_flags
  110|       |	{ "$pause",          8 }, // ensure pause before this word
  111|       |	{ "$strend",         9 }, // full stress if at end of clause
  112|       |	{ "$strend2",       10 }, // full stress if at end of clause, or only followed by unstressed
  113|       |	{ "$unstressend",   11 }, // reduce stress at end of clause
  114|       |	{ "$accent_before", 12 }, // used with accent names, say this accent name before the letter name
  115|       |	{ "$abbrev",        13 }, // use this pronuciation rather than split into letters
  116|       |
  117|       |	// language specific
  118|       |	{ "$double",        14 }, // IT double the initial consonant of next word
  119|       |	{ "$alt",           15 }, // use alternative pronunciation
  120|       |	{ "$alt1",          15 }, // synonym for $alt
  121|       |	{ "$alt2",          16 },
  122|       |	{ "$alt3",          17 },
  123|       |	{ "$alt4",          18 },
  124|       |	{ "$alt5",          19 },
  125|       |	{ "$alt6",          20 },
  126|       |	{ "$alt7",          21 },
  127|       |
  128|       |	{ "$combine",       23 }, // Combine with the next word
  129|       |
  130|       |	{ "$dot",           24 }, // ignore '.' after this word (abbreviation)
  131|       |	{ "$hasdot",        25 }, // use this pronunciation if there is a dot after the word
  132|       |
  133|       |	{ "$max3",          27 }, // limit to 3 repetitions
  134|       |	{ "$brk",           28 }, // a shorter $pause
  135|       |	{ "$text",          29 }, // word translates to replcement text, not phonemes
  136|       |
  137|       |	// flags in dictionary word 2
  138|       |	{ "$verbf",      0x20 }, // verb follows
  139|       |	{ "$verbsf",     0x21 }, // verb follows, allow -s suffix
  140|       |	{ "$nounf",      0x22 }, // noun follows
  141|       |	{ "$pastf",      0x23 }, // past tense follows
  142|       |	{ "$verb",       0x24 }, // use this pronunciation when its a verb
  143|       |	{ "$noun",       0x25 }, // use this pronunciation when its a noun
  144|       |	{ "$past",       0x26 }, // use this pronunciation when its past tense
  145|       |	{ "$verbextend", 0x28 }, // extend influence of 'verb follows'
  146|       |	{ "$capital",    0x29 }, // use this pronunciation if initial letter is upper case
  147|       |	{ "$allcaps",    0x2a }, // use this pronunciation if initial letter is upper case
  148|       |	{ "$accent",     0x2b }, // character name is base-character name + accent name
  149|       |	{ "$sentence",   0x2d }, // only if this clause is a sentence (i.e. terminator is {. ? !} not {, ; :}
  150|       |	{ "$only",       0x2e }, // only match on this word without suffix
  151|       |	{ "$onlys",      0x2f }, // only match with none, or with 's' suffix
  152|       |	{ "$stem",       0x30 }, // must have a suffix
  153|       |	{ "$atend",      0x31 }, // use this pronunciation if at end of clause
  154|       |	{ "$atstart",    0x32 }, // use this pronunciation at start of clause
  155|       |	{ "$native",     0x33 }, // not if we've switched translators
  156|       |
  157|       |	// doesn't set dictionary_flags
  158|       |	{ "$?",           100 }, // conditional rule, followed by byte giving the condition number
  159|       |
  160|       |	{ "$textmode",    200 },
  161|       |	{ "$phonememode", 201 },
  162|       |
  163|       |	{ NULL, -1 }
  164|       |};
  165|       |
  166|      0|#define LEN_GROUP_NAME  12
  167|       |
  168|       |typedef struct {
  169|       |	char name[LEN_GROUP_NAME+1];
  170|       |	unsigned int start;
  171|       |	unsigned int length;
  172|       |	int group3_ix;
  173|       |} RGROUP;
  174|       |
  175|       |void print_dictionary_flags(unsigned int *flags, char *buf, int buf_len)
  176|      0|{
  177|      0|	int stress;
  178|      0|	int ix;
  179|      0|	const char *name;
  180|      0|	int len;
  181|      0|	int total = 0;
  182|      0|
  183|      0|	buf[0] = 0;
  184|      0|	if ((stress = flags[0] & 0xf) != 0) {
  185|      0|		sprintf(buf, "%s", LookupMnemName(mnem_flags, stress + 0x40));
  186|      0|		total = strlen(buf);
  187|      0|		buf += total;
  188|      0|	}
  189|      0|
  190|      0|	for (ix = 8; ix < 64; ix++) {
  191|      0|		if (((ix < 30) && (flags[0] & (1 << ix))) || ((ix >= 0x20) && (flags[1] & (1 << (ix-0x20))))) {
  192|      0|			name = LookupMnemName(mnem_flags, ix);
  193|      0|			len = strlen(name) + 1;
  194|      0|			total += len;
  195|      0|			if (total >= buf_len)
  196|      0|				continue;
  197|      0|			sprintf(buf, " %s", name);
  198|      0|			buf += len;
  199|      0|		}
  200|      0|	}
  201|      0|}
  202|       |
  203|       |char *DecodeRule(const char *group_chars, int group_length, char *rule, int control)
  204|      0|{
  205|      0|	// Convert compiled match template to ascii
  206|      0|
  207|      0|	unsigned char rb;
  208|      0|	unsigned char c;
  209|      0|	char *p;
  210|      0|	char *p_end;
  211|      0|	int ix;
  212|      0|	int match_type;
  213|      0|	bool finished = false;
  214|      0|	int value;
  215|      0|	int linenum = 0;
  216|      0|	int flags;
  217|      0|	int suffix_char;
  218|      0|	int condition_num = 0;
  219|      0|	bool at_start = false;
  220|      0|	const char *name;
  221|      0|	char buf[200];
  222|      0|	char buf_pre[200];
  223|      0|	char suffix[20];
  224|      0|	static char output[80];
  225|      0|
  226|      0|	static char symbols[] = {
  227|      0|		' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
  228|      0|		'&', '%', '+', '#', 'S', 'D', 'Z', 'A', 'L', '!',
  229|      0|		' ', '@', '?', 'J', 'N', 'K', 'V', '?', 'T', 'X',
  230|      0|		'?', 'W'
  231|      0|	};
  232|      0|
  233|      0|	static char symbols_lg[] = { 'A', 'B', 'C', 'H', 'F', 'G', 'Y' };
  234|      0|
  235|      0|	match_type = 0;
  236|      0|	buf_pre[0] = 0;
  237|      0|
  238|      0|	for (ix = 0; ix < group_length; ix++)
  239|      0|		buf[ix] = group_chars[ix];
  240|      0|	buf[ix] = 0;
  241|      0|
  242|      0|	p = &buf[strlen(buf)];
  243|      0|	while (!finished) {
  244|      0|		rb = *rule++;
  245|      0|
  246|      0|		if (rb <= RULE_LINENUM) {
  247|      0|			switch (rb)
  248|      0|			{
  249|      0|			case 0:
  250|      0|			case RULE_PHONEMES:
  251|      0|				finished = true;
  252|      0|				break;
  253|      0|			case RULE_PRE_ATSTART:
  254|      0|				at_start = true;
  255|      0|				// fallthrough:
  256|      0|			case RULE_PRE:
  257|      0|				match_type = RULE_PRE;
  258|      0|				*p = 0;
  259|      0|				p = buf_pre;
  260|      0|				break;
  261|      0|			case RULE_POST:
  262|      0|				match_type = RULE_POST;
  263|      0|				*p = 0;
  264|      0|				strcat(buf, " (");
  265|      0|				p = &buf[strlen(buf)];
  266|      0|				break;
  267|      0|			case RULE_PH_COMMON:
  268|      0|				break;
  269|      0|			case RULE_CONDITION:
  270|      0|				// conditional rule, next byte gives condition number
  271|      0|				condition_num = *rule++;
  272|      0|				break;
  273|      0|			case RULE_LINENUM:
  274|      0|				value = (rule[1] & 0xff) - 1;
  275|      0|				linenum = (rule[0] & 0xff) - 1 + (value * 255);
  276|      0|				rule += 2;
  277|      0|				break;
  278|      0|			}
  279|      0|			continue;
  280|      0|		}
  281|      0|
  282|      0|		if (rb == RULE_DOLLAR) {
  283|      0|			value = *rule++ & 0xff;
  284|      0|			if ((value != 0x01) || (control & FLAG_UNPRON_TEST)) {
  285|      0|				// TODO write the string backwards if in RULE_PRE
  286|      0|				p[0] = '$';
  287|      0|				name = LookupMnemName(mnem_rules, value);
  288|      0|				strcpy(&p[1], name);
  289|      0|				p += (strlen(name)+1);
  290|      0|			}
  291|      0|			c = ' ';
  292|      0|		} else if (rb == RULE_ENDING) {
  293|      0|			static const char *flag_chars = "eipvdfq tba ";
  294|      0|			flags = ((rule[0] & 0x7f)<< 8) + (rule[1] & 0x7f);
  295|      0|			suffix_char = 'S';
  296|      0|			if (flags & (SUFX_P >> 8))
  297|      0|				suffix_char = 'P';
  298|      0|			sprintf(suffix, "%c%d", suffix_char, rule[2] & 0x7f);
  299|      0|			rule += 3;
  300|      0|			for (ix = 0; ix < 9; ix++) {
  301|      0|				if (flags & 1)
  302|      0|					sprintf(&suffix[strlen(suffix)], "%c", flag_chars[ix]);
  303|      0|				flags = (flags >> 1);
  304|      0|			}
  305|      0|			strcpy(p, suffix);
  306|      0|			p += strlen(suffix);
  307|      0|			c = ' ';
  308|      0|		} else if (rb == RULE_LETTERGP)
  309|      0|			c = symbols_lg[*rule++ - 'A'];
  310|      0|		else if (rb == RULE_LETTERGP2) {
  311|      0|			value = *rule++ - 'A';
  312|      0|			if (value < 0)
  313|      0|				value += 256;
  314|      0|			p[0] = 'L';
  315|      0|			p[1] = (value / 10) + '0';
  316|      0|			c = (value % 10) + '0';
  317|      0|
  318|      0|			if (match_type == RULE_PRE) {
  319|      0|				p[0] = c;
  320|      0|				c = 'L';
  321|      0|			}
  322|      0|			p += 2;
  323|      0|		} else if (rb <= RULE_LAST_RULE)
  324|      0|			c = symbols[rb];
  325|      0|		else if (rb == RULE_SPACE)
  326|      0|			c = '_';
  327|      0|		else
  328|      0|			c = rb;
  329|      0|		*p++ = c;
  330|      0|	}
  331|      0|	*p = 0;
  332|      0|
  333|      0|	p = output;
  334|      0|	p_end = p + sizeof(output) - 1;
  335|      0|
  336|      0|	if (linenum > 0) {
  337|      0|		sprintf(p, "%5d:\t", linenum);
  338|      0|		p += 7;
  339|      0|	}
  340|      0|	if (condition_num > 0) {
  341|      0|		sprintf(p, "?%d ", condition_num);
  342|      0|		p = &p[strlen(p)];
  343|      0|	}
  344|      0|	if (((ix = strlen(buf_pre)) > 0) || at_start) {
  345|      0|		if (at_start)
  346|      0|			*p++ = '_';
  347|      0|		while ((--ix >= 0) && (p < p_end-3))
  348|      0|			*p++ = buf_pre[ix];
  349|      0|		*p++ = ')';
  350|      0|		*p++ = ' ';
  351|      0|	}
  352|      0|	*p = 0;
  353|      0|
  354|      0|	buf[p_end - p] = 0; // prevent overflow in output[]
  355|      0|	strcat(p, buf);
  356|      0|	ix = strlen(output);
  357|      0|	while (ix < 8)
  358|      0|		output[ix++] = ' ';
  359|      0|	output[ix] = 0;
  360|      0|	return output;
  361|      0|}
  362|       |
  363|       |typedef enum
  364|       |{
  365|       |	LINE_PARSER_WORD = 0,
  366|       |	LINE_PARSER_END_OF_WORD = 1,
  367|       |	LINE_PARSER_MULTIPLE_WORDS = 2,
  368|       |	LINE_PARSER_END_OF_WORDS = 3,
  369|       |	LINE_PARSER_PRONUNCIATION = 4,
  370|       |	LINE_PARSER_END_OF_PRONUNCIATION = 5,
  371|       |} LINE_PARSER_STATES;
  372|       |
  373|       |static int compile_line(char *linebuf, char *dict_line, int n_dict_line, int *hash)
  374|      0|{
  375|      0|	// Compile a line in the language_list file
  376|      0|	unsigned char c;
  377|      0|	char *p;
  378|      0|	char *word;
  379|      0|	char *phonetic;
  380|      0|	char *phonetic_end;
  381|      0|	unsigned int ix;
  382|      0|	LINE_PARSER_STATES step;
  383|      0|	unsigned int n_flag_codes = 0;
  384|      0|	int flagnum;
  385|      0|	int flag_offset;
  386|      0|	int length;
  387|      0|	int multiple_words = 0;
  388|      0|	bool multiple_numeric_hyphen = false;
  389|      0|	char *multiple_string = NULL;
  390|      0|	char *multiple_string_end = NULL;
  391|      0|
  392|      0|	int len_word;
  393|      0|	int len_phonetic;
  394|      0|	bool text_not_phonemes = false; // this word specifies replacement text, not phonemes
  395|      0|	unsigned int wc;
  396|      0|	bool all_upper_case;
  397|      0|
  398|      0|	char *mnemptr;
  399|      0|	unsigned char flag_codes[100];
  400|      0|	char encoded_ph[200];
  401|      0|	char bad_phoneme_str[4];
  402|      0|	int bad_phoneme;
  403|      0|	static char nullstring[] = { 0 };
  404|      0|
  405|      0|	phonetic = word = nullstring;
  406|      0|
  407|      0|	p = linebuf;
  408|      0|
  409|      0|	step = LINE_PARSER_WORD;
  410|      0|
  411|      0|	c = *p;
  412|      0|	while (c != '\n' && c != '\0') {
  413|      0|		c = *p;
  414|      0|
  415|      0|		if ((c == '?') && (step == 0)) {
  416|      0|			// conditional rule, allow only if the numbered condition is set for the voice
  417|      0|			flag_offset = 100;
  418|      0|
  419|      0|			p++;
  420|      0|			if (*p == '!') {
  421|      0|				// allow only if the numbered condition is NOT set
  422|      0|				flag_offset = 132;
  423|      0|				p++;
  424|      0|			}
  425|      0|
  426|      0|			ix = 0;
  427|      0|			if (IsDigit09(*p)) {
  428|      0|				ix += (*p-'0');
  429|      0|				p++;
  430|      0|			}
  431|      0|			if (IsDigit09(*p)) {
  432|      0|				ix = ix*10 + (*p-'0');
  433|      0|				p++;
  434|      0|			}
  435|      0|			flag_codes[n_flag_codes++] = ix + flag_offset;
  436|      0|			c = *p;
  437|      0|		}
  438|      0|
  439|      0|		if ((c == '$') && isalnum(p[1])) {
  440|      0|			// read keyword parameter
  441|      0|			mnemptr = p;
  442|      0|			while (!isspace2(c = *p)) p++;
  443|      0|			*p = 0;
  444|      0|
  445|      0|			flagnum = LookupMnem(mnem_flags, mnemptr);
  446|      0|			if (flagnum > 0) {
  447|      0|				if (flagnum == 200)
  448|      0|					text_mode = true;
  449|      0|				else if (flagnum == 201)
  450|      0|					text_mode = false;
  451|      0|				else if (flagnum == BITNUM_FLAG_TEXTMODE)
  452|      0|					text_not_phonemes = true;
  453|      0|				else
  454|      0|					flag_codes[n_flag_codes++] = flagnum;
  455|      0|			} else {
  456|      0|				fprintf(f_log, "%5d: Unknown keyword: %s\n", linenum, mnemptr);
  457|      0|				error_count++;
  458|      0|			}
  459|      0|		}
  460|      0|
  461|      0|		if ((c == '/') && (p[1] == '/') && (multiple_words == 0))
  462|      0|			c = '\n'; // "//" treat comment as end of line
  463|      0|
  464|      0|		switch (step)
  465|      0|		{
  466|      0|		case LINE_PARSER_WORD:
  467|      0|			if (c == '(') {
  468|      0|				multiple_words = 1;
  469|      0|				word = p+1;
  470|      0|				step = LINE_PARSER_END_OF_WORD;
  471|      0|			} else if (!isspace2(c)) {
  472|      0|				word = p;
  473|      0|				step = LINE_PARSER_END_OF_WORD;
  474|      0|			}
  475|      0|			break;
  476|      0|		case LINE_PARSER_END_OF_WORD:
  477|      0|			if ((c == '-') && multiple_words) {
  478|      0|				if (IsDigit09(word[0]))
  479|      0|					multiple_numeric_hyphen = true;
  480|      0|				flag_codes[n_flag_codes++] = BITNUM_FLAG_HYPHENATED;
  481|      0|				c = ' ';
  482|      0|			}
  483|      0|			if (isspace2(c)) {
  484|      0|				p[0] = 0; // terminate english word
  485|      0|
  486|      0|				if (multiple_words) {
  487|      0|					multiple_string = multiple_string_end = p+1;
  488|      0|					step = LINE_PARSER_MULTIPLE_WORDS;
  489|      0|				} else
  490|      0|					step = LINE_PARSER_END_OF_WORDS;
  491|      0|			} else if (c == ')') {
  492|      0|				if (multiple_words) {
  493|      0|					p[0] = 0;
  494|      0|					multiple_words = 0;
  495|      0|					step = LINE_PARSER_END_OF_WORDS;
  496|      0|				} else if (word[0] != '_') {
  497|      0|					fprintf(f_log, "%5d: Missing '('\n", linenum);
  498|      0|					error_count++;
  499|      0|					step = LINE_PARSER_END_OF_WORDS;
  500|      0|				}
  501|      0|			}
  502|      0|			break;
  503|      0|		case LINE_PARSER_MULTIPLE_WORDS:
  504|      0|			if (isspace2(c))
  505|      0|				multiple_words++;
  506|      0|			else if (c == ')') {
  507|      0|				p[0] = ' '; // terminate extra string
  508|      0|				multiple_string_end = p+1;
  509|      0|				step = LINE_PARSER_END_OF_WORDS;
  510|      0|			}
  511|      0|			break;
  512|      0|		case LINE_PARSER_END_OF_WORDS:
  513|      0|			if (!isspace2(c)) {
  514|      0|				phonetic = p;
  515|      0|				step = LINE_PARSER_PRONUNCIATION;
  516|      0|			}
  517|      0|			break;
  518|      0|		case LINE_PARSER_PRONUNCIATION:
  519|      0|			if (isspace2(c)) {
  520|      0|				phonetic_end = p;
  521|      0|				p[0] = 0; // terminate phonetic
  522|      0|				step = LINE_PARSER_END_OF_PRONUNCIATION;
  523|      0|			}
  524|      0|			break;
  525|      0|		case LINE_PARSER_END_OF_PRONUNCIATION:
  526|      0|			if (!isspace2(c)) {
  527|      0|				*phonetic_end = ' ';
  528|      0|				step = LINE_PARSER_PRONUNCIATION;
  529|      0|			}
  530|      0|			break;
  531|      0|		}
  532|      0|		p++;
  533|      0|	}
  534|      0|
  535|      0|	if (word[0] == 0)
  536|      0|		return 0; // blank line
  537|      0|
  538|      0|	if (text_mode)
  539|      0|		text_not_phonemes = true;
  540|      0|
  541|      0|	if (text_not_phonemes) {
  542|      0|		if (word[0] == '_') {
  543|      0|			// This is a special word, used by eSpeak.  Translate this into phonemes now
  544|      0|			strcat(phonetic, " "); // need a space to indicate word-boundary
  545|      0|
  546|      0|			// PROBLEM  vowel reductions are not applied to the translated phonemes
  547|      0|			// condition rules are not applied
  548|      0|			TranslateWord(translator, phonetic, NULL, NULL);
  549|      0|			text_not_phonemes = false;
  550|      0|			strncpy0(encoded_ph, word_phonemes, N_WORD_BYTES-4);
  551|      0|
  552|      0|			if ((word_phonemes[0] == 0) && (error_need_dictionary < 3)) {
  553|      0|				// the dictionary was not loaded, we need a second attempt
  554|      0|				error_need_dictionary++;
  555|      0|				fprintf(f_log, "%5d: Need to compile dictionary again\n", linenum);
  556|      0|			}
  557|      0|		} else
  558|      0|			// this is replacement text, so don't encode as phonemes. Restrict the length of the replacement word
  559|      0|			strncpy0(encoded_ph, phonetic, N_WORD_BYTES-4);
  560|      0|	} else {
  561|      0|		EncodePhonemes(phonetic, encoded_ph, &bad_phoneme);
  562|      0|		if (strchr(encoded_ph, phonSWITCH) != 0)
  563|      0|			flag_codes[n_flag_codes++] = BITNUM_FLAG_ONLY_S;  // don't match on suffixes (except 's') when switching languages
  564|      0|
  565|      0|		// check for errors in the phonemes codes
  566|      0|		if (bad_phoneme != 0) {
  567|      0|			// unrecognised phoneme, report error
  568|      0|			bad_phoneme_str[utf8_out(bad_phoneme, bad_phoneme_str)] = 0;
  569|      0|			fprintf(f_log, "%5d: Bad phoneme [%s] (U+%x) in: %s  %s\n", linenum, bad_phoneme_str, bad_phoneme, word, phonetic);
  570|      0|			error_count++;
  571|      0|		}
  572|      0|	}
  573|      0|
  574|      0|	if (text_not_phonemes != translator->langopts.textmode)
  575|      0|		flag_codes[n_flag_codes++] = BITNUM_FLAG_TEXTMODE;
  576|      0|
  577|      0|	if (sscanf(word, "U+%x", &wc) == 1) {
  578|      0|		// Character code
  579|      0|		ix = utf8_out(wc, word);
  580|      0|		word[ix] = 0;
  581|      0|	} else if (word[0] != '_') {
  582|      0|		// convert to lower case, and note if the word is all-capitals
  583|      0|		int c2;
  584|      0|
  585|      0|		all_upper_case = true;
  586|      0|		for (p = word;;) {
  587|      0|			// this assumes that the lower case char is the same length as the upper case char
  588|      0|			// OK, except for Turkish "I", but use towlower() rather than towlower2()
  589|      0|			ix = utf8_in(&c2, p);
  590|      0|			if (c2 == 0)
  591|      0|				break;
  592|      0|			if (iswupper(c2))
  593|      0|				utf8_out(towlower2(c2, translator), p);
  594|      0|			else
  595|      0|				all_upper_case = false;
  596|      0|			p += ix;
  597|      0|		}
  598|      0|		if (all_upper_case)
  599|      0|			flag_codes[n_flag_codes++] = BITNUM_FLAG_ALLCAPS;
  600|      0|	}
  601|      0|
  602|      0|	len_word = strlen(word);
  603|      0|
  604|      0|	if (translator->transpose_min > 0)
  605|      0|		len_word = TransposeAlphabet(translator, word);
  606|      0|
  607|      0|	*hash = HashDictionary(word);
  608|      0|	len_phonetic = strlen(encoded_ph);
  609|      0|
  610|      0|	dict_line[1] = len_word; // bit 6 indicates whether the word has been compressed
  611|      0|	len_word &= 0x3f;
  612|      0|
  613|      0|	memcpy(&dict_line[2], word, len_word);
  614|      0|
  615|      0|	if (len_phonetic == 0) {
  616|      0|		// no phonemes specified. set bit 7
  617|      0|		dict_line[1] |= 0x80;
  618|      0|		length = len_word + 2;
  619|      0|	} else {
  620|      0|		length = len_word + len_phonetic + 3;
  621|      0|		if (length < n_dict_line) {
  622|      0|			strcpy(&dict_line[(len_word)+2], encoded_ph);
  623|      0|		} else {
  624|      0|			fprintf(f_log, "%5d: Dictionary line length would overflow the data buffer: %d\n", linenum, length);
  625|      0|			error_count++;
  626|      0|			// no phonemes specified. set bit 7
  627|      0|			dict_line[1] |= 0x80;
  628|      0|			length = len_word + 2;
  629|      0|		}
  630|      0|	}
  631|      0|
  632|      0|	for (ix = 0; ix < n_flag_codes; ix++)
  633|      0|		dict_line[ix+length] = flag_codes[ix];
  634|      0|	length += n_flag_codes;
  635|      0|
  636|      0|	if ((multiple_string != NULL) && (multiple_words > 0)) {
  637|      0|		if (multiple_words > 10) {
  638|      0|			fprintf(f_log, "%5d: Two many parts in a multi-word entry: %d\n", linenum, multiple_words);
  639|      0|			error_count++;
  640|      0|		} else {
  641|      0|			dict_line[length++] = 80 + multiple_words;
  642|      0|			ix = multiple_string_end - multiple_string;
  643|      0|			if (multiple_numeric_hyphen)
  644|      0|				dict_line[length++] = ' ';   // ???
  645|      0|			memcpy(&dict_line[length], multiple_string, ix);
  646|      0|			length += ix;
  647|      0|		}
  648|      0|	}
  649|      0|	*((uint8_t *)dict_line) = (uint8_t)length;
  650|      0|
  651|      0|	return length;
  652|      0|}
  653|       |
  654|       |static void compile_dictlist_start(void)
  655|      0|{
  656|      0|	// initialise dictionary list
  657|      0|	int ix;
  658|      0|	char *p;
  659|      0|	char *p2;
  660|      0|
  661|      0|	for (ix = 0; ix < N_HASH_DICT; ix++) {
  662|      0|		p = hash_chains[ix];
  663|      0|		while (p != NULL) {
  664|      0|			memcpy(&p2, p, sizeof(char *));
  665|      0|			free(p);
  666|      0|			p = p2;
  667|      0|		}
  668|      0|		hash_chains[ix] = NULL;
  669|      0|	}
  670|      0|}
  671|       |
  672|       |static void compile_dictlist_end(FILE *f_out)
  673|      0|{
  674|      0|	// Write out the compiled dictionary list
  675|      0|	int hash;
  676|      0|	int length;
  677|      0|	char *p;
  678|      0|
  679|      0|	for (hash = 0; hash < N_HASH_DICT; hash++) {
  680|      0|		p = hash_chains[hash];
  681|      0|
  682|      0|		while (p != NULL) {
  683|      0|			length = *(uint8_t *)(p+sizeof(char *));
  684|      0|			fwrite(p+sizeof(char *), length, 1, f_out);
  685|      0|			memcpy(&p, p, sizeof(char *));
  686|      0|		}
  687|      0|		fputc(0, f_out);
  688|      0|	}
  689|      0|}
  690|       |
  691|       |static int compile_dictlist_file(const char *path, const char *filename)
  692|      0|{
  693|      0|	int length;
  694|      0|	int hash;
  695|      0|	char *p;
  696|      0|	int count = 0;
  697|      0|	FILE *f_in;
  698|      0|	char buf[200];
  699|      0|	char fname[sizeof(path_home)+45];
  700|      0|	char dict_line[256]; // length is uint8_t, so an entry can't take up more than 256 bytes
  701|      0|
  702|      0|	text_mode = false;
  703|      0|
  704|      0|	// try with and without '.txt' extension
  705|      0|	sprintf(fname, "%s%s.txt", path, filename);
  706|      0|	if ((f_in = fopen(fname, "r")) == NULL) {
  707|      0|		sprintf(fname, "%s%s", path, filename);
  708|      0|		if ((f_in = fopen(fname, "r")) == NULL)
  709|      0|			return -1;
  710|      0|	}
  711|      0|
  712|      0|	if (f_log != NULL)
  713|      0|		fprintf(f_log, "Compiling: '%s'\n", fname);
  714|      0|
  715|      0|	linenum = 0;
  716|      0|
  717|      0|	while (fgets(buf, sizeof(buf), f_in) != NULL) {
  718|      0|		linenum++;
  719|      0|
  720|      0|		length = compile_line(buf, dict_line, sizeof(dict_line), &hash);
  721|      0|		if (length == 0)  continue; // blank line
  722|      0|
  723|      0|		p = (char *)malloc(length+sizeof(char *));
  724|      0|		if (p == NULL) {
  725|      0|			if (f_log != NULL) {
  726|      0|				fprintf(f_log, "Can't allocate memory\n");
  727|      0|				error_count++;
  728|      0|			}
  729|      0|			break;
  730|      0|		}
  731|      0|
  732|      0|		memcpy(p, &hash_chains[hash], sizeof(char *));
  733|      0|		hash_chains[hash] = p;
  734|      0|		// NOTE: dict_line[0] is the entry length (0-255)
  735|      0|		memcpy(p+sizeof(char *), dict_line, length);
  736|      0|		count++;
  737|      0|	}
  738|      0|
  739|      0|	if (f_log != NULL)
  740|      0|		fprintf(f_log, "\t%d entries\n", count);
  741|      0|	fclose(f_in);
  742|      0|	return 0;
  743|      0|}
  744|       |
  745|       |static char rule_cond[80];
  746|       |static char rule_pre[80];
  747|       |static char rule_post[80];
  748|       |static char rule_match[80];
  749|       |static char rule_phonemes[80];
  750|       |static char group_name[LEN_GROUP_NAME+1];
  751|       |static int group3_ix;
  752|       |
  753|      0|#define N_RULES 3000 // max rules for each group
  754|       |
  755|       |static int isHexDigit(int c)
  756|      0|{
  757|      0|	if ((c >= '0') && (c <= '9'))
  758|      0|		return c - '0';
  759|      0|	if ((c >= 'a') && (c <= 'f'))
  760|      0|		return c - 'a' + 10;
  761|      0|	if ((c >= 'A') && (c <= 'F'))
  762|      0|		return c - 'A' + 10;
  763|      0|	return -1;
  764|      0|}
  765|       |
  766|       |static void copy_rule_string(char *string, int *state_out)
  767|      0|{
  768|      0|	// state 0: conditional, 1=pre, 2=match, 3=post, 4=phonemes
  769|      0|	static char *outbuf[5] = { rule_cond, rule_pre, rule_match, rule_post, rule_phonemes };
  770|      0|	static int next_state[5] = { 2, 2, 4, 4, 4 };
  771|      0|	char *output;
  772|      0|	char *p;
  773|      0|	int ix;
  774|      0|	int len;
  775|      0|	char c;
  776|      0|	int c2, c3;
  777|      0|	int sxflags;
  778|      0|	int value;
  779|      0|	bool literal;
  780|      0|	bool hexdigit_input = false;
  781|      0|	int state = *state_out;
  782|      0|	MNEM_TAB *mr;
  783|      0|
  784|      0|	if (string[0] == 0) return;
  785|      0|
  786|      0|	output = outbuf[state];
  787|      0|	if (state == 4) {
  788|      0|		// append to any previous phoneme string, i.e. allow spaces in the phoneme string
  789|      0|		len = strlen(rule_phonemes);
  790|      0|		if (len > 0)
  791|      0|			rule_phonemes[len++] = ' ';
  792|      0|		output = &rule_phonemes[len];
  793|      0|	}
  794|      0|	sxflags = 0x808000; // to ensure non-zero bytes
  795|      0|
  796|      0|	for (p = string, ix = 0;;) {
  797|      0|		literal = false;
  798|      0|		c = *p++;
  799|      0|		if ((c == '0') && (p[0] == 'x') && (isHexDigit(p[1]) >= 0) && (isHexDigit(p[2]) >= 0)) {
  800|      0|			hexdigit_input = true;
  801|      0|			c = p[1];
  802|      0|			p += 2;
  803|      0|		}
  804|      0|		if (c == '\\') {
  805|      0|			c = *p++; // treat next character literally
  806|      0|			if ((c >= '0') && (c <= '3') && (p[0] >= '0') && (p[0] <= '7') && (p[1] >= '0') && (p[1] <= '7')) {
  807|      0|				// character code given by 3 digit octal value;
  808|      0|				c = (c-'0')*64 + (p[0]-'0')*8 + (p[1]-'0');
  809|      0|				p += 2;
  810|      0|			}
  811|      0|			literal = true;
  812|      0|		}
  813|      0|		if (hexdigit_input) {
  814|      0|			if (((c2 = isHexDigit(c)) >= 0) && ((c3 = isHexDigit(p[0])) >= 0)) {
  815|      0|				c = c2 * 16 + c3;
  816|      0|				literal = true;
  817|      0|				p++;
  818|      0|			} else
  819|      0|				hexdigit_input = false;
  820|      0|		}
  821|      0|		if ((state == 1) || (state == 3)) {
  822|      0|			// replace special characters (note: 'E' is reserved for a replaced silent 'e')
  823|      0|			if (literal == false) {
  824|      0|				static const char lettergp_letters[9] = { LETTERGP_A, LETTERGP_B, LETTERGP_C, 0, 0, LETTERGP_F, LETTERGP_G, LETTERGP_H, LETTERGP_Y };
  825|      0|				switch (c)
  826|      0|				{
  827|      0|				case '_':
  828|      0|					c = RULE_SPACE;
  829|      0|					break;
  830|      0|
  831|      0|				case 'Y':
  832|      0|					c = 'I';
  833|      0|					// fallthrough:
  834|      0|				case 'A': // vowel
  835|      0|				case 'B':
  836|      0|				case 'C':
  837|      0|				case 'H':
  838|      0|				case 'F':
  839|      0|				case 'G':
  840|      0|					if (state == 1) {
  841|      0|						// pre-rule, put the number before the RULE_LETTERGP;
  842|      0|						output[ix++] = lettergp_letters[c-'A'] + 'A';
  843|      0|						c = RULE_LETTERGP;
  844|      0|					} else {
  845|      0|						output[ix++] = RULE_LETTERGP;
  846|      0|						c = lettergp_letters[c-'A'] + 'A';
  847|      0|					}
  848|      0|					break;
  849|      0|				case 'D':
  850|      0|					c = RULE_DIGIT;
  851|      0|					break;
  852|      0|				case 'K':
  853|      0|					c = RULE_NOTVOWEL;
  854|      0|					break;
  855|      0|				case 'N':
  856|      0|					c = RULE_NO_SUFFIX;
  857|      0|					break;
  858|      0|				case 'V':
  859|      0|					c = RULE_IFVERB;
  860|      0|					break;
  861|      0|				case 'Z':
  862|      0|					c = RULE_NONALPHA;
  863|      0|					break;
  864|      0|				case '+':
  865|      0|					c = RULE_INC_SCORE;
  866|      0|					break;
  867|      0|				case '<': // Can't use - as opposite for + because it is used literally as part of word
  868|      0|					c = RULE_DEC_SCORE;
  869|      0|					break;
  870|      0|				case '@':
  871|      0|					c = RULE_SYLLABLE;
  872|      0|					break;
  873|      0|				case '&':
  874|      0|					c = RULE_STRESSED;
  875|      0|					break;
  876|      0|				case '%':
  877|      0|					c = RULE_DOUBLE;
  878|      0|					break;
  879|      0|				case '#':
  880|      0|					c = RULE_DEL_FWD;
  881|      0|					break;
  882|      0|				case '!':
  883|      0|					c = RULE_CAPITAL;
  884|      0|					break;
  885|      0|				case 'T':
  886|      0|					output[ix++] = RULE_DOLLAR;
  887|      0|					c = 0x11;
  888|      0|					break;
  889|      0|				case 'W':
  890|      0|					c = RULE_SPELLING;
  891|      0|					break;
  892|      0|				case 'X':
  893|      0|					c = RULE_NOVOWELS;
  894|      0|					break;
  895|      0|				case 'J':
  896|      0|					c = RULE_SKIPCHARS;
  897|      0|					break;
  898|      0|				case 'L':
  899|      0|					// expect two digits
  900|      0|					c = *p++ - '0';
  901|      0|					value = *p++ - '0';
  902|      0|					c = c * 10 + value;
  903|      0|					if ((value < 0) || (value > 9)) {
  904|      0|						c = 0;
  905|      0|						fprintf(f_log, "%5d: Expected 2 digits after 'L'\n", linenum);
  906|      0|						error_count++;
  907|      0|					} else if ((c <= 0) || (c >= N_LETTER_GROUPS) || (letterGroupsDefined[(int)c] == 0)) {
  908|      0|						fprintf(f_log, "%5d: Letter group L%.2d not defined\n", linenum, c);
  909|      0|						error_count++;
  910|      0|					}
  911|      0|					c += 'A';
  912|      0|					if (state == 1) {
  913|      0|						// pre-rule, put the group number before the RULE_LETTERGP command
  914|      0|						output[ix++] = c;
  915|      0|						c = RULE_LETTERGP2;
  916|      0|					} else
  917|      0|						output[ix++] = RULE_LETTERGP2;
  918|      0|					break;
  919|      0|				case '$':
  920|      0|					value = 0;
  921|      0|					mr = mnem_rules;
  922|      0|					while (mr->mnem != NULL) {
  923|      0|						len = strlen(mr->mnem);
  924|      0|						if (memcmp(p, mr->mnem, len) == 0) {
  925|      0|							value = mr->value;
  926|      0|							p += len;
  927|      0|							break;
  928|      0|						}
  929|      0|						mr++;
  930|      0|					}
  931|      0|
  932|      0|					if (state == 1) {
  933|      0|						// pre-rule, put the number before the RULE_DOLLAR
  934|      0|						output[ix++] = value;
  935|      0|						c = RULE_DOLLAR;
  936|      0|					} else {
  937|      0|						output[ix++] = RULE_DOLLAR;
  938|      0|						c = value;
  939|      0|					}
  940|      0|
  941|      0|					if (value == 0) {
  942|      0|						fprintf(f_log, "%5d: $ command not recognized\n", linenum);
  943|      0|						error_count++;
  944|      0|					}
  945|      0|					break;
  946|      0|				case 'P': // Prefix
  947|      0|					sxflags |= SUFX_P;
  948|      0|					// fallthrough
  949|      0|				case 'S': // Suffix
  950|      0|					output[ix++] = RULE_ENDING;
  951|      0|					value = 0;
  952|      0|					while (!isspace2(c = *p++) && (c != 0)) {
  953|      0|						switch (c)
  954|      0|						{
  955|      0|						case 'e':
  956|      0|							sxflags |= SUFX_E;
  957|      0|							break;
  958|      0|						case 'i':
  959|      0|							sxflags |= SUFX_I;
  960|      0|							break;
  961|      0|						case 'p': // obsolete, replaced by 'P' above
  962|      0|							sxflags |= SUFX_P;
  963|      0|							break;
  964|      0|						case 'v':
  965|      0|							sxflags |= SUFX_V;
  966|      0|							break;
  967|      0|						case 'd':
  968|      0|							sxflags |= SUFX_D;
  969|      0|							break;
  970|      0|						case 'f':
  971|      0|							sxflags |= SUFX_F;
  972|      0|							break;
  973|      0|						case 'q':
  974|      0|							sxflags |= SUFX_Q;
  975|      0|							break;
  976|      0|						case 't':
  977|      0|							sxflags |= SUFX_T;
  978|      0|							break;
  979|      0|						case 'b':
  980|      0|							sxflags |= SUFX_B;
  981|      0|							break;
  982|      0|						case 'a':
  983|      0|							sxflags |= SUFX_A;
  984|      0|							break;
  985|      0|						case 'm':
  986|      0|							sxflags |= SUFX_M;
  987|      0|							break;
  988|      0|						default:
  989|      0|							if (IsDigit09(c))
  990|      0|								value = (value*10) + (c - '0');
  991|      0|							break;
  992|      0|						}
  993|      0|					}
  994|      0|					p--;
  995|      0|					output[ix++] = sxflags >> 16;
  996|      0|					output[ix++] = sxflags >> 8;
  997|      0|					c = value | 0x80;
  998|      0|					break;
  999|      0|				}
 1000|      0|			}
 1001|      0|		}
 1002|      0|		output[ix++] = c;
 1003|      0|		if (c == 0) break;
 1004|      0|	}
 1005|      0|
 1006|      0|	*state_out = next_state[state];
 1007|      0|}
 1008|       |
 1009|       |static char *compile_rule(char *input)
 1010|      0|{
 1011|      0|	int ix;
 1012|      0|	unsigned char c;
 1013|      0|	int wc;
 1014|      0|	char *p;
 1015|      0|	char *prule;
 1016|      0|	int len;
 1017|      0|	int len_name;
 1018|      0|	int start;
 1019|      0|	int state = 2;
 1020|      0|	bool finish = false;
 1021|      0|	char buf[80];
 1022|      0|	char output[150];
 1023|      0|	int bad_phoneme;
 1024|      0|	char bad_phoneme_str[4];
 1025|      0|
 1026|      0|	buf[0] = 0;
 1027|      0|	rule_cond[0] = 0;
 1028|      0|	rule_pre[0] = 0;
 1029|      0|	rule_post[0] = 0;
 1030|      0|	rule_match[0] = 0;
 1031|      0|	rule_phonemes[0] = 0;
 1032|      0|
 1033|      0|	p = buf;
 1034|      0|
 1035|      0|	for (ix = 0; finish == false; ix++) {
 1036|      0|		switch (c = input[ix])
 1037|      0|		{
 1038|      0|		case ')': // end of prefix section
 1039|      0|			*p = 0;
 1040|      0|			state = 1;
 1041|      0|			copy_rule_string(buf, &state);
 1042|      0|			p = buf;
 1043|      0|			break;
 1044|      0|		case '(': // start of suffix section
 1045|      0|			*p = 0;
 1046|      0|			state = 2;
 1047|      0|			copy_rule_string(buf, &state);
 1048|      0|			state = 3;
 1049|      0|			p = buf;
 1050|      0|			if (input[ix+1] == ' ') {
 1051|      0|				fprintf(f_log, "%5d: Syntax error. Space after (, or negative score for previous rule\n", linenum);
 1052|      0|				error_count++;
 1053|      0|			}
 1054|      0|			break;
 1055|      0|		case '\n': // end of line
 1056|      0|		case '\r':
 1057|      0|		case 0:    // end of line
 1058|      0|			*p = 0;
 1059|      0|			copy_rule_string(buf, &state);
 1060|      0|			finish = true;
 1061|      0|			break;
 1062|      0|		case '\t': // end of section section
 1063|      0|		case ' ':
 1064|      0|			*p = 0;
 1065|      0|			copy_rule_string(buf, &state);
 1066|      0|			p = buf;
 1067|      0|			break;
 1068|      0|		case '?':
 1069|      0|			if (state == 2)
 1070|      0|				state = 0;
 1071|      0|			else
 1072|      0|				*p++ = c;
 1073|      0|			break;
 1074|      0|		default:
 1075|      0|			*p++ = c;
 1076|      0|			break;
 1077|      0|		}
 1078|      0|	}
 1079|      0|
 1080|      0|	if (strcmp(rule_match, "$group") == 0)
 1081|      0|		strcpy(rule_match, group_name);
 1082|      0|
 1083|      0|	if (rule_match[0] == 0) {
 1084|      0|		if (rule_post[0] != 0) {
 1085|      0|			fprintf(f_log, "%5d: Syntax error\n", linenum);
 1086|      0|			error_count++;
 1087|      0|		}
 1088|      0|		return NULL;
 1089|      0|	}
 1090|      0|
 1091|      0|	EncodePhonemes(rule_phonemes, buf, &bad_phoneme);
 1092|      0|	if (bad_phoneme != 0) {
 1093|      0|		bad_phoneme_str[utf8_out(bad_phoneme, bad_phoneme_str)] = 0;
 1094|      0|		fprintf(f_log, "%5d: Bad phoneme [%s] (U+%x) in: %s\n", linenum, bad_phoneme_str, bad_phoneme, input);
 1095|      0|		error_count++;
 1096|      0|	}
 1097|      0|	strcpy(output, buf);
 1098|      0|	len = strlen(buf)+1;
 1099|      0|
 1100|      0|	len_name = strlen(group_name);
 1101|      0|	if ((len_name > 0) && (memcmp(rule_match, group_name, len_name) != 0)) {
 1102|      0|		utf8_in(&wc, rule_match);
 1103|      0|		if ((group_name[0] == '9') && IsDigit(wc)) {
 1104|      0|			// numeric group, rule_match starts with a digit, so OK
 1105|      0|		} else {
 1106|      0|			fprintf(f_log, "%5d: Wrong initial letters '%s' for group '%s'\n", linenum, rule_match, group_name);
 1107|      0|			error_count++;
 1108|      0|		}
 1109|      0|	}
 1110|      0|	strcpy(&output[len], rule_match);
 1111|      0|	len += strlen(rule_match);
 1112|      0|
 1113|      0|	if (debug_flag) {
 1114|      0|		output[len] = RULE_LINENUM;
 1115|      0|		output[len+1] = (linenum % 255) + 1;
 1116|      0|		output[len+2] = (linenum / 255) + 1;
 1117|      0|		len += 3;
 1118|      0|	}
 1119|      0|
 1120|      0|	if (rule_cond[0] != 0) {
 1121|      0|		if (rule_cond[0] == '!') {
 1122|      0|			// allow the rule only if the condition number is NOT set for the voice
 1123|      0|			ix = atoi(&rule_cond[1]) + 32;
 1124|      0|		} else {
 1125|      0|			// allow the rule only if the condition number is set for the voice
 1126|      0|			ix = atoi(rule_cond);
 1127|      0|		}
 1128|      0|
 1129|      0|		if ((ix > 0) && (ix < 255)) {
 1130|      0|			output[len++] = RULE_CONDITION;
 1131|      0|			output[len++] = ix;
 1132|      0|		} else {
 1133|      0|			fprintf(f_log, "%5d: bad condition number ?%d\n", linenum, ix);
 1134|      0|			error_count++;
 1135|      0|		}
 1136|      0|	}
 1137|      0|	if (rule_pre[0] != 0) {
 1138|      0|		start = 0;
 1139|      0|		if (rule_pre[0] == RULE_SPACE) {
 1140|      0|			// omit '_' at the beginning of the pre-string and imply it by using RULE_PRE_ATSTART
 1141|      0|			c = RULE_PRE_ATSTART;
 1142|      0|			start = 1;
 1143|      0|		} else
 1144|      0|			c = RULE_PRE;
 1145|      0|		output[len++] = c;
 1146|      0|
 1147|      0|		// output PRE string in reverse order
 1148|      0|		for (ix = strlen(rule_pre)-1; ix >= start; ix--)
 1149|      0|			output[len++] = rule_pre[ix];
 1150|      0|	}
 1151|      0|
 1152|      0|	if (rule_post[0] != 0) {
 1153|      0|		sprintf(&output[len], "%c%s", RULE_POST, rule_post);
 1154|      0|		len += (strlen(rule_post)+1);
 1155|      0|	}
 1156|      0|	output[len++] = 0;
 1157|      0|	if ((prule = (char *)malloc(len)) != NULL)
 1158|      0|		memcpy(prule, output, len);
 1159|      0|	return prule;
 1160|      0|}
 1161|       |
 1162|       |static int __cdecl string_sorter(char **a, char **b)
 1163|      0|{
 1164|      0|	char *pa, *pb;
 1165|      0|	int ix;
 1166|      0|
 1167|      0|	if ((ix = strcmp(pa = *a, pb = *b)) != 0)
 1168|      0|		return ix;
 1169|      0|	pa += (strlen(pa)+1);
 1170|      0|	pb += (strlen(pb)+1);
 1171|      0|	return strcmp(pa, pb);
 1172|      0|}
 1173|       |
 1174|       |static int __cdecl rgroup_sorter(RGROUP *a, RGROUP *b)
 1175|      0|{
 1176|      0|	// Sort long names before short names
 1177|      0|	int ix;
 1178|      0|	ix = strlen(b->name) - strlen(a->name);
 1179|      0|	if (ix != 0) return ix;
 1180|      0|	ix = strcmp(a->name, b->name);
 1181|      0|	if (ix != 0) return ix;
 1182|      0|	return a->start-b->start;
 1183|      0|}
 1184|       |
 1185|       |static void output_rule_group(FILE *f_out, int n_rules, char **rules, char *name)
 1186|      0|{
 1187|      0|	int ix;
 1188|      0|	int len1;
 1189|      0|	int len2;
 1190|      0|	int len_name;
 1191|      0|	char *p;
 1192|      0|	char *p2, *p3;
 1193|      0|	const char *common;
 1194|      0|
 1195|      0|	short nextchar_count[256];
 1196|      0|	memset(nextchar_count, 0, sizeof(nextchar_count));
 1197|      0|
 1198|      0|	len_name = strlen(name);
 1199|      0|
 1200|      0|	// sort the rules in this group by their phoneme string
 1201|      0|	common = "";
 1202|      0|	qsort((void *)rules, n_rules, sizeof(char *), (int(__cdecl *)(const void *, const void *))string_sorter);
 1203|      0|
 1204|      0|	if (strcmp(name, "9") == 0)
 1205|      0|		len_name = 0; //  don't remove characters from numeric match strings
 1206|      0|
 1207|      0|	for (ix = 0; ix < n_rules; ix++) {
 1208|      0|		p = rules[ix];
 1209|      0|		len1 = strlen(p) + 1; // phoneme string
 1210|      0|		p3 = &p[len1];
 1211|      0|		p2 = p3 + len_name; // remove group name from start of match string
 1212|      0|		len2 = strlen(p2);
 1213|      0|
 1214|      0|		nextchar_count[(unsigned char)(p2[0])]++; // the next byte after the group name
 1215|      0|
 1216|      0|		if ((common[0] != 0) && (strcmp(p, common) == 0)) {
 1217|      0|			fwrite(p2, len2, 1, f_out);
 1218|      0|			fputc(0, f_out); // no phoneme string, it's the same as previous rule
 1219|      0|		} else {
 1220|      0|			if ((ix < n_rules-1) && (strcmp(p, rules[ix+1]) == 0)) {
 1221|      0|				common = rules[ix]; // phoneme string is same as next, set as common
 1222|      0|				fputc(RULE_PH_COMMON, f_out);
 1223|      0|			}
 1224|      0|
 1225|      0|			fwrite(p2, len2, 1, f_out);
 1226|      0|			fputc(RULE_PHONEMES, f_out);
 1227|      0|			fwrite(p, len1, 1, f_out);
 1228|      0|		}
 1229|      0|	}
 1230|      0|}
 1231|       |
 1232|       |static int compile_lettergroup(char *input, FILE *f_out)
 1233|      0|{
 1234|      0|	char *p;
 1235|      0|	char *p_start;
 1236|      0|	int group;
 1237|      0|	int ix;
 1238|      0|	int n_items;
 1239|      0|	int length;
 1240|      0|	int max_length = 0;
 1241|      0|
 1242|      0|	#define N_LETTERGP_ITEMS 200
 1243|      0|	char *items[N_LETTERGP_ITEMS];
 1244|      0|	char item_length[N_LETTERGP_ITEMS];
 1245|      0|
 1246|      0|	p = input;
 1247|      0|	if (!IsDigit09(p[0]) || !IsDigit09(p[1])) {
 1248|      0|		fprintf(f_log, "%5d: Expected 2 digits after '.L'\n", linenum);
 1249|      0|		error_count++;
 1250|      0|		return 1;
 1251|      0|	}
 1252|      0|
 1253|      0|	group = atoi(&p[0]);
 1254|      0|	if (group >= N_LETTER_GROUPS) {
 1255|      0|		fprintf(f_log, "%5d: lettergroup out of range (01-%.2d)\n", linenum, N_LETTER_GROUPS-1);
 1256|      0|		error_count++;
 1257|      0|		return 1;
 1258|      0|	}
 1259|      0|
 1260|      0|	while (!isspace2(*p)) p++;
 1261|      0|
 1262|      0|	fputc(RULE_GROUP_START, f_out);
 1263|      0|	fputc(RULE_LETTERGP2, f_out);
 1264|      0|	fputc(group + 'A', f_out);
 1265|      0|	if (letterGroupsDefined[group] != 0) {
 1266|      0|		fprintf(f_log, "%5d: lettergroup L%.2d is already defined\n", linenum, group);
 1267|      0|		error_count++;
 1268|      0|	}
 1269|      0|	letterGroupsDefined[group] = 1;
 1270|      0|
 1271|      0|	n_items = 0;
 1272|      0|	while (n_items < N_LETTERGP_ITEMS) {
 1273|      0|		while (isspace2(*p)) p++;
 1274|      0|		if (*p == 0)
 1275|      0|			break;
 1276|      0|
 1277|      0|		items[n_items] = p_start = p;
 1278|      0|		while ((*p & 0xff) > ' ') {
 1279|      0|			if (*p == '_') *p = ' '; // allow '_' for word break
 1280|      0|			p++;
 1281|      0|		}
 1282|      0|		*p++ = 0;
 1283|      0|		length = p - p_start;
 1284|      0|		if (length > max_length)
 1285|      0|			max_length = length;
 1286|      0|		item_length[n_items++] = length;
 1287|      0|	}
 1288|      0|
 1289|      0|	// write out the items, longest first
 1290|      0|	while (max_length > 1) {
 1291|      0|		for (ix = 0; ix < n_items; ix++) {
 1292|      0|			if (item_length[ix] == max_length)
 1293|      0|				fwrite(items[ix], 1, max_length, f_out);
 1294|      0|		}
 1295|      0|		max_length--;
 1296|      0|	}
 1297|      0|
 1298|      0|	fputc(RULE_GROUP_END, f_out);
 1299|      0|
 1300|      0|	return 0;
 1301|      0|}
 1302|       |
 1303|       |static void free_rules(char **rules, int n_rules)
 1304|      0|{
 1305|      0|	for (int i = 0; i < n_rules; ++i) {
 1306|      0|		free(*rules);
 1307|      0|		*rules++ = NULL;
 1308|      0|	}
 1309|      0|}
 1310|       |
 1311|       |static espeak_ng_STATUS compile_dictrules(FILE *f_in, FILE *f_out, char *fname_temp, espeak_ng_ERROR_CONTEXT *context)
 1312|      0|{
 1313|      0|	char *prule;
 1314|      0|	unsigned char *p;
 1315|      0|	int ix;
 1316|      0|	int c;
 1317|      0|	int gp;
 1318|      0|	FILE *f_temp;
 1319|      0|	int n_rules = 0;
 1320|      0|	int count = 0;
 1321|      0|	int different;
 1322|      0|	int wc;
 1323|      0|	int err_n_rules = 0;
 1324|      0|	const char *prev_rgroup_name;
 1325|      0|	unsigned int char_code;
 1326|      0|	int compile_mode = 0;
 1327|      0|	char *buf;
 1328|      0|	char buf1[500];
 1329|      0|	char *rules[N_RULES];
 1330|      0|
 1331|      0|	int n_rgroups = 0;
 1332|      0|	int n_groups3 = 0;
 1333|      0|	RGROUP rgroup[N_RULE_GROUP2];
 1334|      0|
 1335|      0|	linenum = 0;
 1336|      0|	group_name[0] = 0;
 1337|      0|
 1338|      0|	if ((f_temp = fopen(fname_temp, "wb")) == NULL)
 1339|      0|		return create_file_error_context(context, errno, fname_temp);
 1340|      0|
 1341|      0|	for (;;) {
 1342|      0|		linenum++;
 1343|      0|		buf = fgets(buf1, sizeof(buf1), f_in);
 1344|      0|		if (buf != NULL) {
 1345|      0|			if ((p = (unsigned char *)strstr(buf, "//")) != NULL)
 1346|      0|				*p = 0;
 1347|      0|
 1348|      0|			if (buf[0] == '\r') buf++; // ignore extra \r in \r\n
 1349|      0|		}
 1350|      0|
 1351|      0|		if ((buf == NULL) || (buf[0] == '.')) {
 1352|      0|			// next .group or end of file, write out the previous group
 1353|      0|
 1354|      0|			if (n_rules > 0) {
 1355|      0|				strcpy(rgroup[n_rgroups].name, group_name);
 1356|      0|				rgroup[n_rgroups].group3_ix = group3_ix;
 1357|      0|				rgroup[n_rgroups].start = ftell(f_temp);
 1358|      0|				output_rule_group(f_temp, n_rules, rules, group_name);
 1359|      0|				rgroup[n_rgroups].length = ftell(f_temp) - rgroup[n_rgroups].start;
 1360|      0|				n_rgroups++;
 1361|      0|
 1362|      0|				count += n_rules;
 1363|      0|				free_rules(rules, n_rules);
 1364|      0|			}
 1365|      0|			n_rules = 0;
 1366|      0|			err_n_rules = 0;
 1367|      0|
 1368|      0|			if (compile_mode == 2) {
 1369|      0|				// end of the character replacements section
 1370|      0|				fwrite(&n_rules, 1, 4, f_out); // write a zero word to terminate the replacemenmt list
 1371|      0|				fputc(RULE_GROUP_END, f_out);
 1372|      0|				compile_mode = 0;
 1373|      0|			}
 1374|      0|
 1375|      0|			if (buf == NULL) break; // end of file
 1376|      0|
 1377|      0|			if (memcmp(buf, ".L", 2) == 0) {
 1378|      0|				compile_lettergroup(&buf[2], f_out);
 1379|      0|				continue;
 1380|      0|			}
 1381|      0|
 1382|      0|			if (memcmp(buf, ".replace", 8) == 0) {
 1383|      0|				compile_mode = 2;
 1384|      0|				fputc(RULE_GROUP_START, f_out);
 1385|      0|				fputc(RULE_REPLACEMENTS, f_out);
 1386|      0|
 1387|      0|				// advance to next word boundary
 1388|      0|				while ((ftell(f_out) & 3) != 0)
 1389|      0|					fputc(0, f_out);
 1390|      0|			}
 1391|      0|
 1392|      0|			if (memcmp(buf, ".group", 6) == 0) {
 1393|      0|				compile_mode = 1;
 1394|      0|
 1395|      0|				p = (unsigned char *)&buf[6];
 1396|      0|				while ((p[0] == ' ') || (p[0] == '\t')) p++; // Note: Windows isspace(0xe1) gives TRUE !
 1397|      0|				ix = 0;
 1398|      0|				while ((*p > ' ') && (ix < LEN_GROUP_NAME))
 1399|      0|					group_name[ix++] = *p++;
 1400|      0|				group_name[ix] = 0;
 1401|      0|				group3_ix = 0;
 1402|      0|
 1403|      0|				if (sscanf(group_name, "0x%x", &char_code) == 1) {
 1404|      0|					// group character is given as a character code (max 16 bits)
 1405|      0|					p = (unsigned char *)group_name;
 1406|      0|
 1407|      0|					if (char_code > 0x100)
 1408|      0|						*p++ = (char_code >> 8);
 1409|      0|					*p++ = char_code;
 1410|      0|					*p = 0;
 1411|      0|				} else {
 1412|      0|					if (translator->letter_bits_offset > 0) {
 1413|      0|						utf8_in(&wc, group_name);
 1414|      0|						if (((ix = (wc - translator->letter_bits_offset)) >= 0) && (ix < 128))
 1415|      0|							group3_ix = ix+1; // not zero
 1416|      0|					}
 1417|      0|				}
 1418|      0|
 1419|      0|				if ((group3_ix == 0) && (strlen(group_name) > 2)) {
 1420|      0|					if (utf8_in(&c, group_name) < 2) {
 1421|      0|						fprintf(f_log, "%5d: Group name longer than 2 bytes (UTF8)", linenum);
 1422|      0|						error_count++;
 1423|      0|					}
 1424|      0|
 1425|      0|					group_name[2] = 0;
 1426|      0|				}
 1427|      0|			}
 1428|      0|
 1429|      0|			continue;
 1430|      0|		}
 1431|      0|
 1432|      0|		switch (compile_mode)
 1433|      0|		{
 1434|      0|		case 1: //  .group
 1435|      0|			prule = compile_rule(buf);
 1436|      0|			if (prule != NULL) {
 1437|      0|				if (n_rules < N_RULES)
 1438|      0|					rules[n_rules++] = prule;
 1439|      0|				else {
 1440|      0|					if (err_n_rules == 0) {
 1441|      0|						fprintf(stderr, "\nExceeded limit of rules (%d) in group '%s'\n", N_RULES, group_name);
 1442|      0|						error_count++;
 1443|      0|						err_n_rules = 1;
 1444|      0|					}
 1445|      0|				}
 1446|      0|
 1447|      0|			}
 1448|      0|			break;
 1449|      0|		case 2: //  .replace
 1450|      0|			p = (unsigned char *)buf;
 1451|      0|
 1452|      0|			while (isspace2(*p)) p++;
 1453|      0|			if ((unsigned char)(*p) > 0x20) {
 1454|      0|				while ((unsigned char)(*p) > 0x20) { // not space or zero-byte
 1455|      0|					fputc(*p, f_out);
 1456|      0|					p++;
 1457|      0|				}
 1458|      0|				fputc(0, f_out);
 1459|      0|
 1460|      0|				while (isspace2(*p)) p++;
 1461|      0|				while ((unsigned char)(*p) > 0x20) {
 1462|      0|					fputc(*p, f_out);
 1463|      0|					p++;
 1464|      0|				}
 1465|      0|				fputc(0, f_out);
 1466|      0|			}
 1467|      0|			break;
 1468|      0|		}
 1469|      0|	}
 1470|      0|	fclose(f_temp);
 1471|      0|
 1472|      0|	qsort((void *)rgroup, n_rgroups, sizeof(rgroup[0]), (int(__cdecl *)(const void *, const void *))rgroup_sorter);
 1473|      0|
 1474|      0|	if ((f_temp = fopen(fname_temp, "rb")) == NULL) {
 1475|      0|		free_rules(rules, n_rules);
 1476|      0|		return create_file_error_context(context, errno, fname_temp);
 1477|      0|	}
 1478|      0|
 1479|      0|	prev_rgroup_name = "\n";
 1480|      0|
 1481|      0|	for (gp = 0; gp < n_rgroups; gp++) {
 1482|      0|		fseek(f_temp, rgroup[gp].start, SEEK_SET);
 1483|      0|
 1484|      0|		if ((different = strcmp(rgroup[gp].name, prev_rgroup_name)) != 0) {
 1485|      0|			// not the same as the previous group
 1486|      0|			if (gp > 0)
 1487|      0|				fputc(RULE_GROUP_END, f_out);
 1488|      0|			fputc(RULE_GROUP_START, f_out);
 1489|      0|
 1490|      0|			if (rgroup[gp].group3_ix != 0) {
 1491|      0|				n_groups3++;
 1492|      0|				fputc(1, f_out);
 1493|      0|				fputc(rgroup[gp].group3_ix, f_out);
 1494|      0|			} else
 1495|      0|				fprintf(f_out, "%s", prev_rgroup_name = rgroup[gp].name);
 1496|      0|			fputc(0, f_out);
 1497|      0|		}
 1498|      0|
 1499|      0|		for (ix = rgroup[gp].length; ix > 0; ix--) {
 1500|      0|			c = fgetc(f_temp);
 1501|      0|			fputc(c, f_out);
 1502|      0|		}
 1503|      0|	}
 1504|      0|	fputc(RULE_GROUP_END, f_out);
 1505|      0|	fputc(0, f_out);
 1506|      0|
 1507|      0|	fclose(f_temp);
 1508|      0|	remove(fname_temp);
 1509|      0|
 1510|      0|	fprintf(f_log, "\t%d rules, %d groups (%d)\n\n", count, n_rgroups, n_groups3);
 1511|      0|	free_rules(rules, n_rules);
 1512|      0|	return ENS_OK;
 1513|      0|}
 1514|       |
 1515|       |#pragma GCC visibility push(default)
 1516|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_CompileDictionary(const char *dsource, const char *dict_name, FILE *log, int flags, espeak_ng_ERROR_CONTEXT *context)
 1517|      0|{
 1518|      0|	if (!log) log = stderr;
 1519|      0|	if (!dict_name) dict_name = dictionary_name;
 1520|      0|
 1521|      0|	// fname:  space to write the filename in case of error
 1522|      0|	// flags: bit 0:  include source line number information, for debug purposes.
 1523|      0|
 1524|      0|	FILE *f_in;
 1525|      0|	FILE *f_out;
 1526|      0|	int offset_rules = 0;
 1527|      0|	int value;
 1528|      0|	char fname_in[sizeof(path_home)+45];
 1529|      0|	char fname_out[sizeof(path_home)+15];
 1530|      0|	char fname_temp[sizeof(path_home)+15];
 1531|      0|	char path[sizeof(path_home)+40];       // path_dsource+20
 1532|      0|
 1533|      0|	error_count = 0;
 1534|      0|	error_need_dictionary = 0;
 1535|      0|	memset(letterGroupsDefined, 0, sizeof(letterGroupsDefined));
 1536|      0|
 1537|      0|	debug_flag = flags & 1;
 1538|      0|
 1539|      0|	if (dsource == NULL)
 1540|      0|		dsource = "";
 1541|      0|
 1542|      0|	f_log = log;
 1543|      0|	if (f_log == NULL)
 1544|      0|		f_log = stderr;
 1545|      0|
 1546|      0|	// try with and without '.txt' extension
 1547|      0|	sprintf(path, "%s%s_", dsource, dict_name);
 1548|      0|	sprintf(fname_in, "%srules.txt", path);
 1549|      0|	if ((f_in = fopen(fname_in, "r")) == NULL) {
 1550|      0|		sprintf(fname_in, "%srules", path);
 1551|      0|		if ((f_in = fopen(fname_in, "r")) == NULL)
 1552|      0|			return create_file_error_context(context, errno, fname_in);
 1553|      0|	}
 1554|      0|
 1555|      0|	sprintf(fname_out, "%s%c%s_dict", path_home, PATHSEP, dict_name);
 1556|      0|	if ((f_out = fopen(fname_out, "wb+")) == NULL) {
 1557|      0|		int error = errno;
 1558|      0|		fclose(f_in);
 1559|      0|		return create_file_error_context(context, error, fname_out);
 1560|      0|	}
 1561|      0|	/* Use dictionary-specific temp names to allow parallel compilation
 1562|      0|	 * of multiple ductionaries. */
 1563|      0|	sprintf(fname_temp, "%s%c%stemp", path_home, PATHSEP, dict_name);
 1564|      0|
 1565|      0|	value = N_HASH_DICT;
 1566|      0|	Write4Bytes(f_out, value);
 1567|      0|	Write4Bytes(f_out, offset_rules);
 1568|      0|
 1569|      0|	compile_dictlist_start();
 1570|      0|
 1571|      0|	fprintf(f_log, "Using phonemetable: '%s'\n", phoneme_tab_list[phoneme_tab_number].name);
 1572|      0|	compile_dictlist_file(path, "roots");
 1573|      0|	if (translator->langopts.listx) {
 1574|      0|		compile_dictlist_file(path, "list");
 1575|      0|		compile_dictlist_file(path, "listx");
 1576|      0|	} else {
 1577|      0|		compile_dictlist_file(path, "listx");
 1578|      0|		compile_dictlist_file(path, "list");
 1579|      0|	}
 1580|      0|	compile_dictlist_file(path, "emoji");
 1581|      0|	compile_dictlist_file(path, "extra");
 1582|      0|
 1583|      0|	compile_dictlist_end(f_out);
 1584|      0|	offset_rules = ftell(f_out);
 1585|      0|
 1586|      0|	fprintf(f_log, "Compiling: '%s'\n", fname_in);
 1587|      0|
 1588|      0|	espeak_ng_STATUS status = compile_dictrules(f_in, f_out, fname_temp, context);
 1589|      0|	fclose(f_in);
 1590|      0|
 1591|      0|	fseek(f_out, 4, SEEK_SET);
 1592|      0|	Write4Bytes(f_out, offset_rules);
 1593|      0|	fclose(f_out);
 1594|      0|	fflush(f_log);
 1595|      0|
 1596|      0|	if (status != ENS_OK)
 1597|      0|		return status;
 1598|      0|
 1599|      0|	LoadDictionary(translator, dict_name, 0);
 1600|      0|
 1601|      0|	return error_count > 0 ? ENS_COMPILE_ERROR : ENS_OK;
 1602|      0|}
 1603|       |#pragma GCC visibility pop

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/dictionary.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2014 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2013-2017 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <ctype.h>
   23|       |#include <stdint.h>
   24|       |#include <stdio.h>
   25|       |#include <stdlib.h>
   26|       |#include <string.h>
   27|       |#include <wctype.h>
   28|       |#include <wchar.h>
   29|       |
   30|       |#include <espeak-ng/espeak_ng.h>
   31|       |#include <espeak-ng/speak_lib.h>
   32|       |#include <espeak-ng/encoding.h>
   33|       |
   34|       |#include "dictionary.h"
   35|       |#include "numbers.h"                       // for LookupAccentedLetter, Look...
   36|       |#include "phoneme.h"                       // for PHONEME_TAB, phVOWEL, phon...
   37|       |#include "readclause.h"                    // for WordToString2, is_str_tota...
   38|       |#include "speech.h"                        // for GetFileLength, path_home
   39|       |#include "compiledict.h"                   // for DecodeRule
   40|       |#include "synthdata.h"                     // for PhonemeCode, InterpretPhoneme
   41|       |#include "synthesize.h"                    // for STRESS_IS_PRIMARY, phoneme...
   42|       |#include "translate.h"                     // for Translator, utf8_in, LANGU...
   43|       |
   44|       |typedef struct {
   45|       |	int points;
   46|       |	const char *phonemes;
   47|       |	int end_type;
   48|       |	char *del_fwd;
   49|       |} MatchRecord;
   50|       |
   51|       |
   52|       |int dictionary_skipwords;
   53|       |char dictionary_name[40];
   54|       |
   55|       |// accented characters which indicate (in some languages) the start of a separate syllable
   56|       |static const unsigned short diereses_list[7] = { 0xe4, 0xeb, 0xef, 0xf6, 0xfc, 0xff, 0 };
   57|       |
   58|       |// convert characters to an approximate 7 bit ascii equivalent
   59|       |// used for checking for vowels (up to 0x259=schwa)
   60|      0|#define N_REMOVE_ACCENT  0x25e
   61|       |static unsigned char remove_accent[N_REMOVE_ACCENT] = {
   62|       |	'a', 'a', 'a', 'a', 'a', 'a', 'a', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i',  // 0c0
   63|       |	'd', 'n', 'o', 'o', 'o', 'o', 'o',   0, 'o', 'u', 'u', 'u', 'u', 'y', 't', 's',  // 0d0
   64|       |	'a', 'a', 'a', 'a', 'a', 'a', 'a', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i',  // 0e0
   65|       |	'd', 'n', 'o', 'o', 'o', 'o', 'o',   0, 'o', 'u', 'u', 'u', 'u', 'y', 't', 'y',  // 0f0
   66|       |
   67|       |	'a', 'a', 'a', 'a', 'a', 'a', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'd', 'd',  // 100
   68|       |	'd', 'd', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'g', 'g', 'g', 'g',  // 110
   69|       |	'g', 'g', 'g', 'g', 'h', 'h', 'h', 'h', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i',  // 120
   70|       |	'i', 'i', 'i', 'i', 'j', 'j', 'k', 'k', 'k', 'l', 'l', 'l', 'l', 'l', 'l', 'l',  // 130
   71|       |	'l', 'l', 'l', 'n', 'n', 'n', 'n', 'n', 'n', 'n', 'n', 'n', 'o', 'o', 'o', 'o',  // 140
   72|       |	'o', 'o', 'o', 'o', 'r', 'r', 'r', 'r', 'r', 'r', 's', 's', 's', 's', 's', 's',  // 150
   73|       |	's', 's', 't', 't', 't', 't', 't', 't', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u',  // 160
   74|       |	'u', 'u', 'u', 'u', 'w', 'w', 'y', 'y', 'y', 'z', 'z', 'z', 'z', 'z', 'z', 's',  // 170
   75|       |	'b', 'b', 'b', 'b',   0,   0, 'o', 'c', 'c', 'd', 'd', 'd', 'd', 'd', 'e', 'e',  // 180
   76|       |	'e', 'f', 'f', 'g', 'g', 'h', 'i', 'i', 'k', 'k', 'l', 'l', 'm', 'n', 'n', 'o',  // 190
   77|       |	'o', 'o', 'o', 'o', 'p', 'p', 'y',   0,   0, 's', 's', 't', 't', 't', 't', 'u',  // 1a0
   78|       |	'u', 'u', 'v', 'y', 'y', 'z', 'z', 'z', 'z', 'z', 'z', 'z',   0,   0,   0, 'w',  // 1b0
   79|       |	't', 't', 't', 'k', 'd', 'd', 'd', 'l', 'l', 'l', 'n', 'n', 'n', 'a', 'a', 'i',  // 1c0
   80|       |	'i', 'o', 'o', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'e', 'a', 'a',  // 1d0
   81|       |	'a', 'a', 'a', 'a', 'g', 'g', 'g', 'g', 'k', 'k', 'o', 'o', 'o', 'o', 'z', 'z',  // 1e0
   82|       |	'j', 'd', 'd', 'd', 'g', 'g', 'w', 'w', 'n', 'n', 'a', 'a', 'a', 'a', 'o', 'o',  // 1f0
   83|       |
   84|       |	'a', 'a', 'a', 'a', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i', 'o', 'o', 'o', 'o',  // 200
   85|       |	'r', 'r', 'r', 'r', 'u', 'u', 'u', 'u', 's', 's', 't', 't', 'y', 'y', 'h', 'h',  // 210
   86|       |	'n', 'd', 'o', 'o', 'z', 'z', 'a', 'a', 'e', 'e', 'o', 'o', 'o', 'o', 'o', 'o',  // 220
   87|       |	'o', 'o', 'y', 'y', 'l', 'n', 't', 'j', 'd', 'q', 'a', 'c', 'c', 'l', 't', 's',  // 230
   88|       |	'z',   0,   0, 'b', 'u', 'v', 'e', 'e', 'j', 'j', 'q', 'q', 'r', 'r', 'y', 'y',  // 240
   89|       |	'a', 'a', 'a', 'b', 'o', 'c', 'd', 'd', 'e', 'e', 'e', 'e', 'e', 'e'
   90|       |};
   91|       |
   92|       |#pragma GCC visibility push(default)
   93|       |void strncpy0(char *to, const char *from, int size)
   94|      0|{
   95|      0|	// strcpy with limit, ensures a zero terminator
   96|      0|	strncpy(to, from, size);
   97|      0|	to[size-1] = 0;
   98|      0|}
   99|       |#pragma GCC visibility pop
  100|       |
  101|       |static int Reverse4Bytes(int word)
  102|      0|{
  103|      0|	// reverse the order of bytes from little-endian to big-endian
  104|       |#ifdef ARCH_BIG
  105|       |	int ix;
  106|       |	int word2 = 0;
  107|       |
  108|       |	for (ix = 0; ix <= 24; ix += 8) {
  109|       |		word2 = word2 << 8;
  110|       |		word2 |= (word >> ix) & 0xff;
  111|       |	}
  112|       |	return word2;
  113|       |#else
  114|       |	return word;
  115|      0|#endif
  116|      0|}
  117|       |
  118|       |static void InitGroups(Translator *tr)
  119|      0|{
  120|      0|	// Called after dictionary 1 is loaded, to set up table of entry points for translation rule chains
  121|      0|	// for single-letters and two-letter combinations
  122|      0|
  123|      0|	int ix;
  124|      0|	char *p;
  125|      0|	char *p_name;
  126|      0|	unsigned char c, c2;
  127|      0|	int len;
  128|      0|
  129|      0|	tr->n_groups2 = 0;
  130|      0|	for (ix = 0; ix < 256; ix++) {
  131|      0|		tr->groups1[ix] = NULL;
  132|      0|		tr->groups2_count[ix] = 0;
  133|      0|		tr->groups2_start[ix] = 255; // indicates "not set"
  134|      0|	}
  135|      0|	memset(tr->letterGroups, 0, sizeof(tr->letterGroups));
  136|      0|	memset(tr->groups3, 0, sizeof(tr->groups3));
  137|      0|
  138|      0|	p = tr->data_dictrules;
  139|      0|	// If there are no rules in the dictionary, compile_dictrules will not
  140|      0|	// write a RULE_GROUP_START (written in the for loop), but will write
  141|      0|	// a RULE_GROUP_END.
  142|      0|	if (*p != RULE_GROUP_END) while (*p != 0) {
  143|      0|		if (*p != RULE_GROUP_START) {
  144|      0|			fprintf(stderr, "Bad rules data in '%s_dict' at 0x%x (%c)\n", dictionary_name, (unsigned int)(p - tr->data_dictrules), *p);
  145|      0|			break;
  146|      0|		}
  147|      0|		p++;
  148|      0|
  149|      0|		if (p[0] == RULE_REPLACEMENTS) {
  150|      0|			p = (char *)(((intptr_t)p+4) & ~3); // advance to next word boundary
  151|      0|			tr->langopts.replace_chars = (unsigned char *)p;
  152|      0|
  153|      0|			while ( !is_str_totally_null(p, 4) ) {
  154|      0|				p++;
  155|      0|			}
  156|      0|
  157|      0|			while (*p != RULE_GROUP_END) p++;
  158|      0|			p++;
  159|      0|			continue;
  160|      0|		}
  161|      0|
  162|      0|		if (p[0] == RULE_LETTERGP2) {
  163|      0|			ix = p[1] - 'A';
  164|      0|			if (ix < 0)
  165|      0|				ix += 256;
  166|      0|			p += 2;
  167|      0|			if ((ix >= 0) && (ix < N_LETTER_GROUPS))
  168|      0|				tr->letterGroups[ix] = p;
  169|      0|		} else {
  170|      0|			len = strlen(p);
  171|      0|			p_name = p;
  172|      0|			c = p_name[0];
  173|      0|			c2 = p_name[1];
  174|      0|
  175|      0|			p += (len+1);
  176|      0|			if (len == 1)
  177|      0|				tr->groups1[c] = p;
  178|      0|			else if (len == 0)
  179|      0|				tr->groups1[0] = p;
  180|      0|			else if (c == 1) {
  181|      0|				// index by offset from letter base
  182|      0|				tr->groups3[c2 - 1] = p;
  183|      0|			} else {
  184|      0|				if (tr->groups2_start[c] == 255)
  185|      0|					tr->groups2_start[c] = tr->n_groups2;
  186|      0|
  187|      0|				tr->groups2_count[c]++;
  188|      0|				tr->groups2[tr->n_groups2] = p;
  189|      0|				tr->groups2_name[tr->n_groups2++] = (c + (c2 << 8));
  190|      0|			}
  191|      0|		}
  192|      0|
  193|      0|		// skip over all the rules in this group
  194|      0|		while (*p != RULE_GROUP_END)
  195|      0|			p += (strlen(p) + 1);
  196|      0|		p++;
  197|      0|	}
  198|      0|}
  199|       |
  200|       |int LoadDictionary(Translator *tr, const char *name, int no_error)
  201|      0|{
  202|      0|	int hash;
  203|      0|	char *p;
  204|      0|	int *pw;
  205|      0|	int length;
  206|      0|	FILE *f;
  207|      0|	int size;
  208|      0|	char fname[sizeof(path_home)+20];
  209|      0|
  210|      0|	if (dictionary_name != name)
  211|      0|		strncpy(dictionary_name, name, 40); // currently loaded dictionary name
  212|      0|	if (tr->dictionary_name != name)
  213|      0|		strncpy(tr->dictionary_name, name, 40);
  214|      0|
  215|      0|	// Load a pronunciation data file into memory
  216|      0|	// bytes 0-3:  offset to rules data
  217|      0|	// bytes 4-7:  number of hash table entries
  218|      0|	sprintf(fname, "%s%c%s_dict", path_home, PATHSEP, name);
  219|      0|	size = GetFileLength(fname);
  220|      0|
  221|      0|	if (tr->data_dictlist != NULL) {
  222|      0|		free(tr->data_dictlist);
  223|      0|		tr->data_dictlist = NULL;
  224|      0|	}
  225|      0|
  226|      0|	f = fopen(fname, "rb");
  227|      0|	if ((f == NULL) || (size <= 0)) {
  228|      0|		if (no_error == 0)
  229|      0|			fprintf(stderr, "Can't read dictionary file: '%s'\n", fname);
  230|      0|		if (f != NULL)
  231|      0|			fclose(f);
  232|      0|		return 1;
  233|      0|	}
  234|      0|
  235|      0|	if ((tr->data_dictlist = malloc(size)) == NULL) {
  236|      0|		fclose(f);
  237|      0|		return 3;
  238|      0|	}
  239|      0|	size = fread(tr->data_dictlist, 1, size, f);
  240|      0|	fclose(f);
  241|      0|
  242|      0|	pw = (int *)(tr->data_dictlist);
  243|      0|	length = Reverse4Bytes(pw[1]);
  244|      0|
  245|      0|	if (size <= (N_HASH_DICT + sizeof(int)*2)) {
  246|      0|		fprintf(stderr, "Empty _dict file: '%s\n", fname);
  247|      0|		return 2;
  248|      0|	}
  249|      0|
  250|      0|	if ((Reverse4Bytes(pw[0]) != N_HASH_DICT) ||
  251|      0|	    (length <= 0) || (length > 0x8000000)) {
  252|      0|		fprintf(stderr, "Bad data: '%s' (%x length=%x)\n", fname, Reverse4Bytes(pw[0]), length);
  253|      0|		return 2;
  254|      0|	}
  255|      0|	tr->data_dictrules = &(tr->data_dictlist[length]);
  256|      0|
  257|      0|	// set up indices into data_dictrules
  258|      0|	InitGroups(tr);
  259|      0|
  260|      0|	// set up hash table for data_dictlist
  261|      0|	p = &(tr->data_dictlist[8]);
  262|      0|
  263|      0|	for (hash = 0; hash < N_HASH_DICT; hash++) {
  264|      0|		tr->dict_hashtab[hash] = p;
  265|      0|		while ((length = *(uint8_t *)p) != 0)
  266|      0|			p += length;
  267|      0|		p++; // skip over the zero which terminates the list for this hash value
  268|      0|	}
  269|      0|
  270|      0|	if ((tr->dict_min_size > 0) && (size < (unsigned int)tr->dict_min_size))
  271|      0|		fprintf(stderr, "Full dictionary is not installed for '%s'\n", name);
  272|      0|
  273|      0|	return 0;
  274|      0|}
  275|       |
  276|       |/* Generate a hash code from the specified string
  277|       |    This is used to access the dictionary_2 word-lookup dictionary
  278|       | */
  279|       |int HashDictionary(const char *string)
  280|      0|{
  281|      0|	int c;
  282|      0|	int chars = 0;
  283|      0|	int hash = 0;
  284|      0|
  285|      0|	while ((c = (*string++ & 0xff)) != 0) {
  286|      0|		hash = hash * 8 + c;
  287|      0|		hash = (hash & 0x3ff) ^ (hash >> 8); // exclusive or
  288|      0|		chars++;
  289|      0|	}
  290|      0|
  291|      0|	return (hash+chars) & 0x3ff; // a 10 bit hash code
  292|      0|}
  293|       |
  294|       |/* Translate a phoneme string from ascii mnemonics to internal phoneme numbers,
  295|       |   from 'p' up to next blank .
  296|       |   Returns advanced 'p'
  297|       |   outptr contains encoded phonemes, unrecognized phoneme stops the encoding
  298|       |   bad_phoneme must point to char array of length 2 of more
  299|       | */
  300|       |const char *EncodePhonemes(const char *p, char *outptr, int *bad_phoneme)
  301|      0|{
  302|      0|	int ix;
  303|      0|	unsigned char c;
  304|      0|	int count;     // num. of matching characters
  305|      0|	int max;       // highest num. of matching found so far
  306|      0|	int max_ph;    // corresponding phoneme with highest matching
  307|      0|	int consumed;
  308|      0|	unsigned int mnemonic_word;
  309|      0|
  310|      0|	if (bad_phoneme != NULL)
  311|      0|		*bad_phoneme = 0;
  312|      0|
  313|      0|	// skip initial blanks
  314|      0|	while ((uint8_t)*p < 0x80 && isspace(*p))
  315|      0|		p++;
  316|      0|
  317|      0|	while (((c = *p) != 0) && !isspace(c)) {
  318|      0|		consumed = 0;
  319|      0|
  320|      0|		switch (c)
  321|      0|		{
  322|      0|		case '|':
  323|      0|			// used to separate phoneme mnemonics if needed, to prevent characters being treated
  324|      0|			// as a multi-letter mnemonic
  325|      0|
  326|      0|			if ((c = p[1]) == '|') {
  327|      0|				// treat double || as a word-break symbol, drop through
  328|      0|				// to the default case with c = '|'
  329|      0|			} else {
  330|      0|				p++;
  331|      0|				break;
  332|      0|			}
  333|      0|		default:
  334|      0|			// lookup the phoneme mnemonic, find the phoneme with the highest number of
  335|      0|			// matching characters
  336|      0|			max = -1;
  337|      0|			max_ph = 0;
  338|      0|
  339|      0|			for (ix = 1; ix < n_phoneme_tab; ix++) {
  340|      0|				if (phoneme_tab[ix] == NULL)
  341|      0|					continue;
  342|      0|				if (phoneme_tab[ix]->type == phINVALID)
  343|      0|					continue; // this phoneme is not defined for this language
  344|      0|
  345|      0|				count = 0;
  346|      0|				mnemonic_word = phoneme_tab[ix]->mnemonic;
  347|      0|
  348|      0|				while (((c = p[count]) > ' ') && (count < 4) &&
  349|      0|				       (c == ((mnemonic_word >> (count*8)) & 0xff)))
  350|      0|					count++;
  351|      0|
  352|      0|				if ((count > max) &&
  353|      0|				    ((count == 4) || (((mnemonic_word >> (count*8)) & 0xff) == 0))) {
  354|      0|					max = count;
  355|      0|					max_ph = phoneme_tab[ix]->code;
  356|      0|				}
  357|      0|			}
  358|      0|
  359|      0|			if (max_ph == 0) {
  360|      0|				// not recognised, report and ignore
  361|      0|				if (bad_phoneme != NULL)
  362|      0|					utf8_in(bad_phoneme, p);
  363|      0|				*outptr++ = 0;
  364|      0|				return p+1;
  365|      0|			}
  366|      0|
  367|      0|			if (max <= 0)
  368|      0|				max = 1;
  369|      0|			p += (consumed + max);
  370|      0|			*outptr++ = (char)(max_ph);
  371|      0|
  372|      0|			if (max_ph == phonSWITCH) {
  373|      0|				// Switch Language: this phoneme is followed by a text string
  374|      0|				char *p_lang = outptr;
  375|      0|				while (!isspace(c = *p) && (c != 0)) {
  376|      0|					p++;
  377|      0|					*outptr++ = tolower(c);
  378|      0|				}
  379|      0|				*outptr = 0;
  380|      0|				if (c == 0) {
  381|      0|					if (strcmp(p_lang, ESPEAKNG_DEFAULT_VOICE) == 0) {
  382|      0|						*p_lang = 0; // don't need ESPEAKNG_DEFAULT_VOICE, it's assumed by default
  383|      0|						return p;
  384|      0|					}
  385|      0|				} else
  386|      0|					*outptr++ = '|'; // more phonemes follow, terminate language string with separator
  387|      0|			}
  388|      0|			break;
  389|      0|		}
  390|      0|	}
  391|      0|	// terminate the encoded string
  392|      0|	*outptr = 0;
  393|      0|	return p;
  394|      0|}
  395|       |
  396|       |void DecodePhonemes(const char *inptr, char *outptr)
  397|      0|{
  398|      0|	// Translate from internal phoneme codes into phoneme mnemonics
  399|      0|	unsigned char phcode;
  400|      0|	unsigned char c;
  401|      0|	unsigned int mnem;
  402|      0|	PHONEME_TAB *ph;
  403|      0|	static const char *stress_chars = "==,,'*  ";
  404|      0|
  405|      0|	sprintf(outptr, "* ");
  406|      0|	while ((phcode = *inptr++) > 0) {
  407|      0|		if (phcode == 255)
  408|      0|			continue; // indicates unrecognised phoneme
  409|      0|		if ((ph = phoneme_tab[phcode]) == NULL)
  410|      0|			continue;
  411|      0|
  412|      0|		if ((ph->type == phSTRESS) && (ph->std_length <= 4) && (ph->program == 0)) {
  413|      0|			if (ph->std_length > 1)
  414|      0|				*outptr++ = stress_chars[ph->std_length];
  415|      0|		} else {
  416|      0|			mnem = ph->mnemonic;
  417|      0|
  418|      0|			while ((c = (mnem & 0xff)) != 0) {
  419|      0|				*outptr++ = c;
  420|      0|				mnem = mnem >> 8;
  421|      0|			}
  422|      0|			if (phcode == phonSWITCH) {
  423|      0|				while (isalpha(*inptr))
  424|      0|					*outptr++ = *inptr++;
  425|      0|			}
  426|      0|		}
  427|      0|	}
  428|      0|	*outptr = 0; // string terminator
  429|      0|}
  430|       |
  431|       |// using Kirschenbaum to IPA translation, ascii 0x20 to 0x7f
  432|       |unsigned short ipa1[96] = {
  433|       |	0x20,  0x21,  0x22,  0x2b0, 0x24,  0x25,  0x0e6, 0x2c8, 0x28,  0x29,  0x27e, 0x2b,  0x2cc, 0x2d,  0x2e,  0x2f,
  434|       |	0x252, 0x31,  0x32,  0x25c, 0x34,  0x35,  0x36,  0x37,  0x275, 0x39,  0x2d0, 0x2b2, 0x3c,  0x3d,  0x3e,  0x294,
  435|       |	0x259, 0x251, 0x3b2, 0xe7,  0xf0,  0x25b, 0x46,  0x262, 0x127, 0x26a, 0x25f, 0x4b,  0x26b, 0x271, 0x14b, 0x254,
  436|       |	0x3a6, 0x263, 0x280, 0x283, 0x3b8, 0x28a, 0x28c, 0x153, 0x3c7, 0xf8,  0x292, 0x32a, 0x5c,  0x5d,  0x5e,  0x5f,
  437|       |	0x60,  0x61,  0x62,  0x63,  0x64,  0x65,  0x66,  0x261, 0x68,  0x69,  0x6a,  0x6b,  0x6c,  0x6d,  0x6e,  0x6f,
  438|       |	0x70,  0x71,  0x72,  0x73,  0x74,  0x75,  0x76,  0x77,  0x78,  0x79,  0x7a,  0x7b,  0x7c,  0x7d,  0x303, 0x7f
  439|       |};
  440|       |
  441|      0|#define N_PHON_OUT  500  // realloc increment
  442|       |static char *phon_out_buf = NULL;   // passes the result of GetTranslatedPhonemeString()
  443|       |static unsigned int phon_out_size = 0;
  444|       |
  445|       |char *WritePhMnemonic(char *phon_out, PHONEME_TAB *ph, PHONEME_LIST *plist, int use_ipa, int *flags)
  446|      0|{
  447|      0|	int c;
  448|      0|	int mnem;
  449|      0|	int len;
  450|      0|	bool first;
  451|      0|	int ix = 0;
  452|      0|	char *p;
  453|      0|	PHONEME_DATA phdata;
  454|      0|
  455|      0|	if (ph->code == phonEND_WORD) {
  456|      0|		// ignore
  457|      0|		phon_out[0] = 0;
  458|      0|		return phon_out;
  459|      0|	}
  460|      0|
  461|      0|	if (ph->code == phonSWITCH) {
  462|      0|		// the tone_ph field contains a phoneme table number
  463|      0|		p = phoneme_tab_list[plist->tone_ph].name;
  464|      0|		sprintf(phon_out, "(%s)", p);
  465|      0|		return phon_out + strlen(phon_out);
  466|      0|	}
  467|      0|
  468|      0|	if (use_ipa) {
  469|      0|		// has an ipa name been defined for this phoneme ?
  470|      0|		phdata.ipa_string[0] = 0;
  471|      0|
  472|      0|		if (plist == NULL)
  473|      0|			InterpretPhoneme2(ph->code, &phdata);
  474|      0|		else
  475|      0|			InterpretPhoneme(NULL, 0, plist, &phdata, NULL);
  476|      0|
  477|      0|		p = phdata.ipa_string;
  478|      0|		if (*p == 0x20) {
  479|      0|			// indicates no name for this phoneme
  480|      0|			*phon_out = 0;
  481|      0|			return phon_out;
  482|      0|		}
  483|      0|		if ((*p != 0) && ((*p & 0xff) < 0x20)) {
  484|      0|			// name starts with a flags byte
  485|      0|			if (flags != NULL)
  486|      0|				*flags = *p;
  487|      0|			p++;
  488|      0|		}
  489|      0|
  490|      0|		len = strlen(p);
  491|      0|		if (len > 0) {
  492|      0|			strcpy(phon_out, p);
  493|      0|			phon_out += len;
  494|      0|			*phon_out = 0;
  495|      0|			return phon_out;
  496|      0|		}
  497|      0|	}
  498|      0|
  499|      0|	first = true;
  500|      0|	for (mnem = ph->mnemonic; (c = mnem & 0xff) != 0; mnem = mnem >> 8) {
  501|      0|		if (c == '/')
  502|      0|			break; // discard phoneme variant indicator
  503|      0|
  504|      0|		if (use_ipa) {
  505|      0|			// convert from ascii to ipa
  506|      0|			if (first && (c == '_'))
  507|      0|				break; // don't show pause phonemes
  508|      0|
  509|      0|			if ((c == '#') && (ph->type == phVOWEL))
  510|      0|				break; // # is subscript-h, but only for consonants
  511|      0|
  512|      0|			// ignore digits after the first character
  513|      0|			if (!first && IsDigit09(c))
  514|      0|				continue;
  515|      0|
  516|      0|			if ((c >= 0x20) && (c < 128))
  517|      0|				c = ipa1[c-0x20];
  518|      0|
  519|      0|			ix += utf8_out(c, &phon_out[ix]);
  520|      0|		} else
  521|      0|			phon_out[ix++] = c;
  522|      0|		first = false;
  523|      0|	}
  524|      0|
  525|      0|	phon_out = &phon_out[ix];
  526|      0|	*phon_out = 0;
  527|      0|	return phon_out;
  528|      0|}
  529|       |
  530|       |const char *GetTranslatedPhonemeString(int phoneme_mode)
  531|      0|{
  532|      0|	/* Called after a clause has been translated into phonemes, in order
  533|      0|	   to display the clause in phoneme mnemonic form.
  534|      0|
  535|      0|	   phoneme_mode
  536|      0|	                 bit  1:   use IPA phoneme names
  537|      0|	                 bit  7:   use tie between letters in multi-character phoneme names
  538|      0|	                 bits 8-23 tie or separator character
  539|      0|
  540|      0|	 */
  541|      0|
  542|      0|	int ix;
  543|      0|	unsigned int len;
  544|      0|	int phon_out_ix = 0;
  545|      0|	int stress;
  546|      0|	int c;
  547|      0|	char *p;
  548|      0|	char *buf;
  549|      0|	int count;
  550|      0|	int flags;
  551|      0|	int use_ipa;
  552|      0|	int use_tie;
  553|      0|	int separate_phonemes;
  554|      0|	char phon_buf[30];
  555|      0|	char phon_buf2[30];
  556|      0|	PHONEME_LIST *plist;
  557|      0|
  558|      0|	static const char *stress_chars = "==,,''";
  559|      0|
  560|      0|	if (phon_out_buf == NULL) {
  561|      0|		phon_out_size = N_PHON_OUT;
  562|      0|		if ((phon_out_buf = (char *)malloc(phon_out_size)) == NULL) {
  563|      0|			phon_out_size = 0;
  564|      0|			return "";
  565|      0|		}
  566|      0|	}
  567|      0|
  568|      0|	use_ipa = phoneme_mode & espeakPHONEMES_IPA;
  569|      0|	if (phoneme_mode & espeakPHONEMES_TIE) {
  570|      0|		use_tie = phoneme_mode >> 8;
  571|      0|		separate_phonemes = 0;
  572|      0|	} else {
  573|      0|		separate_phonemes = phoneme_mode >> 8;
  574|      0|		use_tie = 0;
  575|      0|	}
  576|      0|
  577|      0|	for (ix = 1; ix < (n_phoneme_list-2); ix++) {
  578|      0|		buf = phon_buf;
  579|      0|
  580|      0|		plist = &phoneme_list[ix];
  581|      0|
  582|      0|		WritePhMnemonic(phon_buf2, plist->ph, plist, use_ipa, &flags);
  583|      0|		if (plist->newword & PHLIST_START_OF_WORD && !(plist->newword & (PHLIST_START_OF_SENTENCE | PHLIST_START_OF_CLAUSE)))
  584|      0|			*buf++ = ' ';
  585|      0|
  586|      0|		if ((!plist->newword) || (separate_phonemes == ' ')) {
  587|      0|			if ((separate_phonemes != 0) && (ix > 1)) {
  588|      0|				utf8_in(&c, phon_buf2);
  589|      0|				if ((c < 0x2b0) || (c > 0x36f)) // not if the phoneme starts with a superscript letter
  590|      0|					buf += utf8_out(separate_phonemes, buf);
  591|      0|			}
  592|      0|		}
  593|      0|
  594|      0|		if (plist->synthflags & SFLAG_SYLLABLE) {
  595|      0|			if ((stress = plist->stresslevel) > 1) {
  596|      0|				c = 0;
  597|      0|				if (stress > STRESS_IS_PRIORITY) stress = STRESS_IS_PRIORITY;
  598|      0|
  599|      0|				if (use_ipa) {
  600|      0|					c = 0x2cc; // ipa, secondary stress
  601|      0|					if (stress > STRESS_IS_SECONDARY)
  602|      0|						c = 0x02c8; // ipa, primary stress
  603|      0|				} else
  604|      0|					c = stress_chars[stress];
  605|      0|
  606|      0|				if (c != 0)
  607|      0|					buf += utf8_out(c, buf);
  608|      0|			}
  609|      0|		}
  610|      0|
  611|      0|		flags = 0;
  612|      0|		count = 0;
  613|      0|		for (p = phon_buf2; *p != 0;) {
  614|      0|			p += utf8_in(&c, p);
  615|      0|			if (use_tie != 0) {
  616|      0|				// look for non-initial alphabetic character, but not diacritic, superscript etc.
  617|      0|				if ((count > 0) && !(flags & (1 << (count-1))) && ((c < 0x2b0) || (c > 0x36f)) && iswalpha(c))
  618|      0|					buf += utf8_out(use_tie, buf);
  619|      0|			}
  620|      0|			buf += utf8_out(c, buf);
  621|      0|			count++;
  622|      0|		}
  623|      0|
  624|      0|		if (plist->ph->code != phonSWITCH) {
  625|      0|			if (plist->synthflags & SFLAG_LENGTHEN)
  626|      0|				buf = WritePhMnemonic(buf, phoneme_tab[phonLENGTHEN], plist, use_ipa, NULL);
  627|      0|			if ((plist->synthflags & SFLAG_SYLLABLE) && (plist->type != phVOWEL)) {
  628|      0|				// syllablic consonant
  629|      0|				buf = WritePhMnemonic(buf, phoneme_tab[phonSYLLABIC], plist, use_ipa, NULL);
  630|      0|			}
  631|      0|			if (plist->tone_ph > 0)
  632|      0|				buf = WritePhMnemonic(buf, phoneme_tab[plist->tone_ph], plist, use_ipa, NULL);
  633|      0|		}
  634|      0|
  635|      0|		len = buf - phon_buf;
  636|      0|		if ((phon_out_ix + len) >= phon_out_size) {
  637|      0|			// enlarge the phoneme buffer
  638|      0|			phon_out_size = phon_out_ix + len + N_PHON_OUT;
  639|      0|			char *new_phon_out_buf = (char *)realloc(phon_out_buf, phon_out_size);
  640|      0|			if (new_phon_out_buf == NULL) {
  641|      0|				phon_out_size = 0;
  642|      0|				return "";
  643|      0|			} else
  644|      0|				phon_out_buf = new_phon_out_buf;
  645|      0|		}
  646|      0|
  647|      0|		phon_buf[len] = 0;
  648|      0|		strcpy(&phon_out_buf[phon_out_ix], phon_buf);
  649|      0|		phon_out_ix += len;
  650|      0|	}
  651|      0|
  652|      0|	if (!phon_out_buf)
  653|      0|		return "";
  654|      0|
  655|      0|	phon_out_buf[phon_out_ix] = 0;
  656|      0|
  657|      0|	return phon_out_buf;
  658|      0|}
  659|       |
  660|       |static int LetterGroupNo(char *rule)
  661|      0|{
  662|      0|	/*
  663|      0|	 * Returns number of letter group
  664|      0|	 */
  665|      0|	int groupNo = *rule;
  666|      0|	groupNo = groupNo - 'A'; // subtracting 'A' makes letter_group equal to number in .Lxx definition
  667|      0|	if (groupNo < 0)         // fix sign if necessary
  668|      0|		groupNo += 256;
  669|      0|	return groupNo;
  670|      0|}
  671|       |
  672|       |static int IsLetterGroup(Translator *tr, char *word, int group, int pre)
  673|      0|{
  674|      0|	/* Match the word against a list of utf-8 strings.
  675|      0|	 * returns length of matching letter group or -1
  676|      0|	 *
  677|      0|	 * How this works:
  678|      0|	 *
  679|      0|	 *       +-+
  680|      0|	 *       |c|<-(tr->letterGroups[group])
  681|      0|	 *       |0|
  682|      0|	 *   *p->|c|<-len+              +-+
  683|      0|	 *       |s|<----+              |a|<-(Actual word to be tested)
  684|      0|	 *       |0|            *word-> |t|<-*w=word-len+1 (for pre-rule)
  685|      0|	 *       |~|                    |a|<-*w=word       (for post-rule)
  686|      0|	 *       |7|                    |s|
  687|      0|	 *       +-+                    +-+
  688|      0|	 *
  689|      0|	 *     7=RULE_GROUP_END
  690|      0|	 *     0=null terminator
  691|      0|	 *     pre==1 — pre-rule
  692|      0|	 *     pre==0 — post-rule
  693|      0|	 */
  694|      0|	char *p; // group counter
  695|      0|	char *w; // word counter
  696|      0|	int len = 0;
  697|      0|
  698|      0|	p = tr->letterGroups[group];
  699|      0|	if (p == NULL)
  700|      0|		return -1;
  701|      0|
  702|      0|	while (*p != RULE_GROUP_END) {
  703|      0|		if (pre) {
  704|      0|			len = strlen(p);
  705|      0|			w = word - len + 1;
  706|      0|		} else
  707|      0|			w = word;
  708|      0|
  709|      0|		// If '~' (no character) is allowed in group, return 0.
  710|      0|		if (*p == '~')
  711|      0|			return 0;
  712|      0|
  713|      0|		//  Check current group
  714|      0|		while ((*p == *w) && (*w != 0)) {
  715|      0|			w++;
  716|      0|			p++;
  717|      0|		}
  718|      0|		if (*p == 0) { // Matched the current group.
  719|      0|			if (pre)
  720|      0|				return len;
  721|      0|			return w - word;
  722|      0|		}
  723|      0|
  724|      0|		// No match, so skip the rest of this group.
  725|      0|		while (*p++ != 0)
  726|      0|			;
  727|      0|	}
  728|      0|	// Not found
  729|      0|	return -1;
  730|      0|}
  731|       |
  732|       |static int IsLetter(Translator *tr, int letter, int group)
  733|      0|{
  734|      0|	int letter2;
  735|      0|
  736|      0|	if (tr->letter_groups[group] != NULL) {
  737|      0|		if (wcschr(tr->letter_groups[group], letter))
  738|      0|			return 1;
  739|      0|		return 0;
  740|      0|	}
  741|      0|
  742|      0|	if (group > 7)
  743|      0|		return 0;
  744|      0|
  745|      0|	if (tr->letter_bits_offset > 0) {
  746|      0|		if (((letter2 = (letter - tr->letter_bits_offset)) > 0) && (letter2 < 0x100))
  747|      0|			letter = letter2;
  748|      0|		else
  749|      0|			return 0;
  750|      0|	} else if ((letter >= 0xc0) && (letter < N_REMOVE_ACCENT))
  751|      0|		return tr->letter_bits[remove_accent[letter-0xc0]] & (1L << group);
  752|      0|
  753|      0|	if ((letter >= 0) && (letter < 0x100))
  754|      0|		return tr->letter_bits[letter] & (1L << group);
  755|      0|
  756|      0|	return 0;
  757|      0|}
  758|       |
  759|       |int IsVowel(Translator *tr, int letter)
  760|      0|{
  761|      0|	return IsLetter(tr, letter, LETTERGP_VOWEL2);
  762|      0|}
  763|       |
  764|       |static int Unpronouncable2(Translator *tr, char *word)
  765|      0|{
  766|      0|	int c;
  767|      0|	int end_flags;
  768|      0|	char ph_buf[N_WORD_PHONEMES];
  769|      0|
  770|      0|	ph_buf[0] = 0;
  771|      0|	c = word[-1];
  772|      0|	word[-1] = ' '; // ensure there is a space before the "word"
  773|      0|	end_flags = TranslateRules(tr, word, ph_buf, sizeof(ph_buf), NULL, FLAG_UNPRON_TEST, NULL);
  774|      0|	word[-1] = c;
  775|      0|	if ((end_flags == 0) || (end_flags & SUFX_UNPRON))
  776|      0|		return 1;
  777|      0|	return 0;
  778|      0|}
  779|       |
  780|       |int Unpronouncable(Translator *tr, char *word, int posn)
  781|      0|{
  782|      0|	/* Determines whether a word in 'unpronouncable', i.e. whether it should
  783|      0|	    be spoken as individual letters.
  784|      0|
  785|      0|	    This function may be language specific. This is a generic version.
  786|      0|	 */
  787|      0|
  788|      0|	int c;
  789|      0|	int c1 = 0;
  790|      0|	int vowel_posn = 9;
  791|      0|	int index;
  792|      0|	int count;
  793|      0|	ALPHABET *alphabet;
  794|      0|
  795|      0|	utf8_in(&c, word);
  796|      0|	if ((tr->letter_bits_offset > 0) && (c < 0x241)) {
  797|      0|		// Latin characters for a language with a non-latin alphabet
  798|      0|		return 0;  // so we can re-translate the word as English
  799|      0|	}
  800|      0|
  801|      0|	if (((alphabet = AlphabetFromChar(c)) != NULL)  && (alphabet->offset != tr->letter_bits_offset)) {
  802|      0|		// Character is not in our alphabet
  803|      0|		return 0;
  804|      0|	}
  805|      0|
  806|      0|	if (tr->langopts.param[LOPT_UNPRONOUNCABLE] == 1)
  807|      0|		return 0;
  808|      0|
  809|      0|	if (((c = *word) == ' ') || (c == 0) || (c == '\''))
  810|      0|		return 0;
  811|      0|
  812|      0|	index = 0;
  813|      0|	count = 0;
  814|      0|	for (;;) {
  815|      0|		index += utf8_in(&c, &word[index]);
  816|      0|		if ((c == 0) || (c == ' '))
  817|      0|			break;
  818|      0|
  819|      0|		if ((c == '\'') && ((count > 1) || (posn > 0)))
  820|      0|			break; // "tv'" but not "l'"
  821|      0|
  822|      0|		if (count == 0)
  823|      0|			c1 = c;
  824|      0|
  825|      0|		if ((c == '\'') && (tr->langopts.param[LOPT_UNPRONOUNCABLE] == 3)) {
  826|      0|			// don't count apostrophe
  827|      0|		} else
  828|      0|			count++;
  829|      0|
  830|      0|		if (IsVowel(tr, c)) {
  831|      0|			vowel_posn = count; // position of the first vowel
  832|      0|			break;
  833|      0|		}
  834|      0|
  835|      0|		if ((c != '\'') && !iswalpha(c))
  836|      0|			return 0;
  837|      0|	}
  838|      0|
  839|      0|	if ((vowel_posn > 2) && (tr->langopts.param[LOPT_UNPRONOUNCABLE] == 2)) {
  840|      0|		// Lookup unpronounable rules in *_rules
  841|      0|		return Unpronouncable2(tr, word);
  842|      0|	}
  843|      0|
  844|      0|	if (c1 == tr->langopts.param[LOPT_UNPRONOUNCABLE])
  845|      0|		vowel_posn--; // disregard this as the initial letter when counting
  846|      0|
  847|      0|	if (vowel_posn > (tr->langopts.max_initial_consonants+1))
  848|      0|		return 1; // no vowel, or no vowel in first few letters
  849|      0|
  850|      0|	return 0;
  851|      0|}
  852|       |
  853|       |static int GetVowelStress(Translator *tr, unsigned char *phonemes, signed char *vowel_stress, int *vowel_count, int *stressed_syllable, int control)
  854|      0|{
  855|      0|	// control = 1, set stress to 1 for forced unstressed vowels
  856|      0|	unsigned char phcode;
  857|      0|	PHONEME_TAB *ph;
  858|      0|	unsigned char *ph_out = phonemes;
  859|      0|	int count = 1;
  860|      0|	int max_stress = -1;
  861|      0|	int ix;
  862|      0|	int j;
  863|      0|	int stress = -1;
  864|      0|	int primary_posn = 0;
  865|      0|
  866|      0|	vowel_stress[0] = STRESS_IS_UNSTRESSED;
  867|      0|	while (((phcode = *phonemes++) != 0) && (count < (N_WORD_PHONEMES/2)-1)) {
  868|      0|		if ((ph = phoneme_tab[phcode]) == NULL)
  869|      0|			continue;
  870|      0|
  871|      0|		if ((ph->type == phSTRESS) && (ph->program == 0)) {
  872|      0|			// stress marker, use this for the following vowel
  873|      0|
  874|      0|			if (phcode == phonSTRESS_PREV) {
  875|      0|				// primary stress on preceeding vowel
  876|      0|				j = count - 1;
  877|      0|				while ((j > 0) && (*stressed_syllable == 0) && (vowel_stress[j] < STRESS_IS_PRIMARY)) {
  878|      0|					if ((vowel_stress[j] != STRESS_IS_DIMINISHED) && (vowel_stress[j] != STRESS_IS_UNSTRESSED)) {
  879|      0|						// don't promote a phoneme which must be unstressed
  880|      0|						vowel_stress[j] = STRESS_IS_PRIMARY;
  881|      0|
  882|      0|						if (max_stress < STRESS_IS_PRIMARY) {
  883|      0|							max_stress = STRESS_IS_PRIMARY;
  884|      0|							primary_posn = j;
  885|      0|						}
  886|      0|
  887|      0|						/* reduce any preceding primary stress markers */
  888|      0|						for (ix = 1; ix < j; ix++) {
  889|      0|							if (vowel_stress[ix] == STRESS_IS_PRIMARY)
  890|      0|								vowel_stress[ix] = STRESS_IS_SECONDARY;
  891|      0|						}
  892|      0|						break;
  893|      0|					}
  894|      0|					j--;
  895|      0|				}
  896|      0|			} else {
  897|      0|				if ((ph->std_length < 4) || (*stressed_syllable == 0)) {
  898|      0|					stress = ph->std_length;
  899|      0|
  900|      0|					if (stress > max_stress)
  901|      0|						max_stress = stress;
  902|      0|				}
  903|      0|			}
  904|      0|			continue;
  905|      0|		}
  906|      0|
  907|      0|		if ((ph->type == phVOWEL) && !(ph->phflags & phNONSYLLABIC)) {
  908|      0|			vowel_stress[count] = (char)stress;
  909|      0|			if ((stress >= STRESS_IS_PRIMARY) && (stress >= max_stress)) {
  910|      0|				primary_posn = count;
  911|      0|				max_stress = stress;
  912|      0|			}
  913|      0|
  914|      0|			if ((stress < 0) && (control & 1) && (ph->phflags & phUNSTRESSED))
  915|      0|				vowel_stress[count] = STRESS_IS_UNSTRESSED; // weak vowel, must be unstressed
  916|      0|
  917|      0|			count++;
  918|      0|			stress = -1;
  919|      0|		} else if (phcode == phonSYLLABIC) {
  920|      0|			// previous consonant phoneme is syllablic
  921|      0|			vowel_stress[count] = (char)stress;
  922|      0|			if ((stress == 0) && (control & 1))
  923|      0|				vowel_stress[count++] = STRESS_IS_UNSTRESSED; // syllabic consonant, usually unstressed
  924|      0|		}
  925|      0|
  926|      0|		*ph_out++ = phcode;
  927|      0|	}
  928|      0|	vowel_stress[count] = STRESS_IS_UNSTRESSED;
  929|      0|	*ph_out = 0;
  930|      0|
  931|      0|	// has the position of the primary stress been specified by $1, $2, etc?
  932|      0|	if (*stressed_syllable > 0) {
  933|      0|		if (*stressed_syllable >= count)
  934|      0|			*stressed_syllable = count-1; // the final syllable
  935|      0|
  936|      0|		vowel_stress[*stressed_syllable] = STRESS_IS_PRIMARY;
  937|      0|		max_stress = STRESS_IS_PRIMARY;
  938|      0|		primary_posn = *stressed_syllable;
  939|      0|	}
  940|      0|
  941|      0|	if (max_stress == STRESS_IS_PRIORITY) {
  942|      0|		// priority stress, replaces any other primary stress marker
  943|      0|		for (ix = 1; ix < count; ix++) {
  944|      0|			if (vowel_stress[ix] == STRESS_IS_PRIMARY) {
  945|      0|				if (tr->langopts.stress_flags & S_PRIORITY_STRESS)
  946|      0|					vowel_stress[ix] = STRESS_IS_UNSTRESSED;
  947|      0|				else
  948|      0|					vowel_stress[ix] = STRESS_IS_SECONDARY;
  949|      0|			}
  950|      0|
  951|      0|			if (vowel_stress[ix] == STRESS_IS_PRIORITY) {
  952|      0|				vowel_stress[ix] = STRESS_IS_PRIMARY;
  953|      0|				primary_posn = ix;
  954|      0|			}
  955|      0|		}
  956|      0|		max_stress = STRESS_IS_PRIMARY;
  957|      0|	}
  958|      0|
  959|      0|	*stressed_syllable = primary_posn;
  960|      0|	*vowel_count = count;
  961|      0|	return max_stress;
  962|      0|}
  963|       |
  964|       |static char stress_phonemes[] = {
  965|       |	phonSTRESS_D, phonSTRESS_U, phonSTRESS_2, phonSTRESS_3,
  966|       |	phonSTRESS_P, phonSTRESS_P2, phonSTRESS_TONIC
  967|       |};
  968|       |
  969|       |void ChangeWordStress(Translator *tr, char *word, int new_stress)
  970|      0|{
  971|      0|	int ix;
  972|      0|	unsigned char *p;
  973|      0|	int max_stress;
  974|      0|	int vowel_count; // num of vowels + 1
  975|      0|	int stressed_syllable = 0; // position of stressed syllable
  976|      0|	unsigned char phonetic[N_WORD_PHONEMES];
  977|      0|	signed char vowel_stress[N_WORD_PHONEMES/2];
  978|      0|
  979|      0|	strcpy((char *)phonetic, word);
  980|      0|	max_stress = GetVowelStress(tr, phonetic, vowel_stress, &vowel_count, &stressed_syllable, 0);
  981|      0|
  982|      0|	if (new_stress >= STRESS_IS_PRIMARY) {
  983|      0|		// promote to primary stress
  984|      0|		for (ix = 1; ix < vowel_count; ix++) {
  985|      0|			if (vowel_stress[ix] >= max_stress) {
  986|      0|				vowel_stress[ix] = new_stress;
  987|      0|				break;
  988|      0|			}
  989|      0|		}
  990|      0|	} else {
  991|      0|		// remove primary stress
  992|      0|		for (ix = 1; ix < vowel_count; ix++) {
  993|      0|			if (vowel_stress[ix] > new_stress) // >= allows for diminished stress (=1)
  994|      0|				vowel_stress[ix] = new_stress;
  995|      0|		}
  996|      0|	}
  997|      0|
  998|      0|	// write out phonemes
  999|      0|	ix = 1;
 1000|      0|	p = phonetic;
 1001|      0|	while (*p != 0) {
 1002|      0|		if ((phoneme_tab[*p]->type == phVOWEL) && !(phoneme_tab[*p]->phflags & phNONSYLLABIC)) {
 1003|      0|			if ((vowel_stress[ix] == STRESS_IS_DIMINISHED) || (vowel_stress[ix] > STRESS_IS_UNSTRESSED))
 1004|      0|				*word++ = stress_phonemes[(unsigned char)vowel_stress[ix]];
 1005|      0|
 1006|      0|			ix++;
 1007|      0|		}
 1008|      0|		*word++ = *p++;
 1009|      0|	}
 1010|      0|	*word = 0;
 1011|      0|}
 1012|       |
 1013|       |void SetWordStress(Translator *tr, char *output, unsigned int *dictionary_flags, int tonic, int control)
 1014|      0|{
 1015|      0|	/* Guess stress pattern of word.  This is language specific
 1016|      0|
 1017|      0|	   'output' is used for input and output
 1018|      0|
 1019|      0|	   'dictionary_flags' has bits 0-3   position of stressed vowel (if > 0)
 1020|      0|	                                     or unstressed (if == 7) or syllables 1 and 2 (if == 6)
 1021|      0|	                          bits 8...  dictionary flags
 1022|      0|
 1023|      0|	   If 'tonic' is set (>= 0), replace highest stress by this value.
 1024|      0|
 1025|      0|	   control:  bit 0   This is an individual symbol, not a word
 1026|      0|	            bit 1   Suffix phonemes are still to be added
 1027|      0|	 */
 1028|      0|
 1029|      0|	unsigned char phcode;
 1030|      0|	unsigned char *p;
 1031|      0|	PHONEME_TAB *ph;
 1032|      0|	int stress;
 1033|      0|	int max_stress;
 1034|      0|	int max_stress_input; // any stress specified in the input?
 1035|      0|	int vowel_count; // num of vowels + 1
 1036|      0|	int ix;
 1037|      0|	int v;
 1038|      0|	int v_stress;
 1039|      0|	int stressed_syllable; // position of stressed syllable
 1040|      0|	int max_stress_posn;
 1041|      0|	char *max_output;
 1042|      0|	int final_ph;
 1043|      0|	int final_ph2;
 1044|      0|	int mnem;
 1045|      0|	int opt_length;
 1046|      0|	int stressflags;
 1047|      0|	int dflags = 0;
 1048|      0|	int first_primary;
 1049|      0|	int long_vowel;
 1050|      0|
 1051|      0|	signed char vowel_stress[N_WORD_PHONEMES/2];
 1052|      0|	char syllable_weight[N_WORD_PHONEMES/2];
 1053|      0|	char vowel_length[N_WORD_PHONEMES/2];
 1054|      0|	unsigned char phonetic[N_WORD_PHONEMES];
 1055|      0|
 1056|      0|	static char consonant_types[16] = { 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0 };
 1057|      0|
 1058|      0|	stressflags = tr->langopts.stress_flags;
 1059|      0|
 1060|      0|	if (dictionary_flags != NULL)
 1061|      0|		dflags = dictionary_flags[0];
 1062|      0|
 1063|      0|	// copy input string into internal buffer
 1064|      0|	for (ix = 0; ix < N_WORD_PHONEMES; ix++) {
 1065|      0|		phonetic[ix] = output[ix];
 1066|      0|		// check for unknown phoneme codes
 1067|      0|		if (phonetic[ix] >= n_phoneme_tab)
 1068|      0|			phonetic[ix] = phonSCHWA;
 1069|      0|		if (phonetic[ix] == 0)
 1070|      0|			break;
 1071|      0|	}
 1072|      0|	if (ix == 0) return;
 1073|      0|	final_ph = phonetic[ix-1];
 1074|      0|	final_ph2 = phonetic[(ix > 1) ? ix-2 : ix-1];
 1075|      0|
 1076|      0|	max_output = output + (N_WORD_PHONEMES-3); // check for overrun
 1077|      0|
 1078|      0|
 1079|      0|	// any stress position marked in the xx_list dictionary ?
 1080|      0|	bool unstressed_word = false;
 1081|      0|	stressed_syllable = dflags & 0x7;
 1082|      0|	if (dflags & 0x8) {
 1083|      0|		// this indicates a word without a primary stress
 1084|      0|		stressed_syllable = dflags & 0x3;
 1085|      0|		unstressed_word = true;
 1086|      0|	}
 1087|      0|
 1088|      0|	max_stress = max_stress_input = GetVowelStress(tr, phonetic, vowel_stress, &vowel_count, &stressed_syllable, 1);
 1089|      0|	if ((max_stress < 0) && dictionary_flags)
 1090|      0|		max_stress = STRESS_IS_DIMINISHED;
 1091|      0|
 1092|      0|	// heavy or light syllables
 1093|      0|	ix = 1;
 1094|      0|	for (p = phonetic; *p != 0; p++) {
 1095|      0|		if ((phoneme_tab[p[0]]->type == phVOWEL) && !(phoneme_tab[p[0]]->phflags & phNONSYLLABIC)) {
 1096|      0|			int weight = 0;
 1097|      0|			bool lengthened = false;
 1098|      0|
 1099|      0|			if (phoneme_tab[p[1]]->code == phonLENGTHEN)
 1100|      0|				lengthened = true;
 1101|      0|
 1102|      0|			if (lengthened || (phoneme_tab[p[0]]->phflags & phLONG)) {
 1103|      0|				// long vowel, increase syllable weight
 1104|      0|				weight++;
 1105|      0|			}
 1106|      0|			vowel_length[ix] = weight;
 1107|      0|
 1108|      0|			if (lengthened) p++; // advance over phonLENGTHEN
 1109|      0|
 1110|      0|			if (consonant_types[phoneme_tab[p[1]]->type] && ((phoneme_tab[p[2]]->type != phVOWEL) || (phoneme_tab[p[1]]->phflags & phLONG))) {
 1111|      0|				// followed by two consonants, a long consonant, or consonant and end-of-word
 1112|      0|				weight++;
 1113|      0|			}
 1114|      0|			syllable_weight[ix] = weight;
 1115|      0|			ix++;
 1116|      0|		}
 1117|      0|	}
 1118|      0|
 1119|      0|	switch (tr->langopts.stress_rule)
 1120|      0|	{
 1121|      0|	case STRESSPOSN_2LLH:
 1122|      0|		// stress on first syllable, unless it is a light syllable followed by a heavy syllable
 1123|      0|		if ((syllable_weight[1] > 0) || (syllable_weight[2] == 0))
 1124|      0|			break;
 1125|      0|		// fallthrough:
 1126|      0|	case STRESSPOSN_2L:
 1127|      0|		// stress on second syllable
 1128|      0|		if ((stressed_syllable == 0) && (vowel_count > 2)) {
 1129|      0|			stressed_syllable = 2;
 1130|      0|			if (max_stress == STRESS_IS_DIMINISHED)
 1131|      0|				vowel_stress[stressed_syllable] = STRESS_IS_PRIMARY;
 1132|      0|			max_stress = STRESS_IS_PRIMARY;
 1133|      0|		}
 1134|      0|		break;
 1135|      0|
 1136|      0|	case STRESSPOSN_2R:
 1137|      0|		// a language with stress on penultimate vowel
 1138|      0|
 1139|      0|		if (stressed_syllable == 0) {
 1140|      0|			// no explicit stress - stress the penultimate vowel
 1141|      0|			max_stress = STRESS_IS_PRIMARY;
 1142|      0|
 1143|      0|			if (vowel_count > 2) {
 1144|      0|				stressed_syllable = vowel_count - 2;
 1145|      0|
 1146|      0|				if (stressflags & S_FINAL_SPANISH) {
 1147|      0|					// LANG=Spanish, stress on last vowel if the word ends in a consonant other than 'n' or 's'
 1148|      0|					if (phoneme_tab[final_ph]->type != phVOWEL) {
 1149|      0|						mnem = phoneme_tab[final_ph]->mnemonic;
 1150|      0|
 1151|      0|						if (tr->translator_name == L('a', 'n')) {
 1152|      0|							if (((mnem != 's') && (mnem != 'n')) || phoneme_tab[final_ph2]->type != phVOWEL)
 1153|      0|								stressed_syllable = vowel_count - 1; // stress on last syllable
 1154|      0|						} else if (tr->translator_name == L('i', 'a')) {
 1155|      0|							if ((mnem != 's') || phoneme_tab[final_ph2]->type != phVOWEL)
 1156|      0|								stressed_syllable = vowel_count - 1; // stress on last syllable
 1157|      0|						} else {
 1158|      0|							if ((mnem == 's') && (phoneme_tab[final_ph2]->type == phNASAL)) {
 1159|      0|								// -ns  stress remains on penultimate syllable
 1160|      0|							} else if (((phoneme_tab[final_ph]->type != phNASAL) && (mnem != 's')) || (phoneme_tab[final_ph2]->type != phVOWEL))
 1161|      0|								stressed_syllable = vowel_count - 1;
 1162|      0|						}
 1163|      0|					}
 1164|      0|				}
 1165|      0|
 1166|      0|				if (stressflags & S_FINAL_LONG) {
 1167|      0|					// stress on last syllable if it has a long vowel, but previous syllable has a short vowel
 1168|      0|					if (vowel_length[vowel_count - 1] > vowel_length[vowel_count - 2])
 1169|      0|						stressed_syllable = vowel_count - 1;
 1170|      0|				}
 1171|      0|
 1172|      0|				if ((vowel_stress[stressed_syllable] == STRESS_IS_DIMINISHED) || (vowel_stress[stressed_syllable] == STRESS_IS_UNSTRESSED)) {
 1173|      0|					// but this vowel is explicitly marked as unstressed
 1174|      0|					if (stressed_syllable > 1)
 1175|      0|						stressed_syllable--;
 1176|      0|					else
 1177|      0|						stressed_syllable++;
 1178|      0|				}
 1179|      0|			} else
 1180|      0|				stressed_syllable = 1;
 1181|      0|
 1182|      0|			// only set the stress if it's not already marked explicitly
 1183|      0|			if (vowel_stress[stressed_syllable] < 0) {
 1184|      0|				// don't stress if next and prev syllables are stressed
 1185|      0|				if ((vowel_stress[stressed_syllable-1] < STRESS_IS_PRIMARY) || (vowel_stress[stressed_syllable+1] < STRESS_IS_PRIMARY))
 1186|      0|					vowel_stress[stressed_syllable] = max_stress;
 1187|      0|			}
 1188|      0|		}
 1189|      0|		break;
 1190|      0|	case STRESSPOSN_1R:
 1191|      0|		// stress on last vowel
 1192|      0|		if (stressed_syllable == 0) {
 1193|      0|			// no explicit stress - stress the final vowel
 1194|      0|			stressed_syllable = vowel_count - 1;
 1195|      0|
 1196|      0|			while (stressed_syllable > 0) {
 1197|      0|				// find the last vowel which is not unstressed
 1198|      0|				if (vowel_stress[stressed_syllable] < STRESS_IS_DIMINISHED) {
 1199|      0|					vowel_stress[stressed_syllable] = STRESS_IS_PRIMARY;
 1200|      0|					break;
 1201|      0|				} else
 1202|      0|					stressed_syllable--;
 1203|      0|			}
 1204|      0|			max_stress = STRESS_IS_PRIMARY;
 1205|      0|		}
 1206|      0|		break;
 1207|      0|	case  STRESSPOSN_3R: // stress on antipenultimate vowel
 1208|      0|		if (stressed_syllable == 0) {
 1209|      0|			stressed_syllable = vowel_count - 3;
 1210|      0|			if (stressed_syllable < 1)
 1211|      0|				stressed_syllable = 1;
 1212|      0|
 1213|      0|			if (max_stress == STRESS_IS_DIMINISHED)
 1214|      0|				vowel_stress[stressed_syllable] = STRESS_IS_PRIMARY;
 1215|      0|			max_stress = STRESS_IS_PRIMARY;
 1216|      0|		}
 1217|      0|		break;
 1218|      0|	case STRESSPOSN_SYLCOUNT:
 1219|      0|		// LANG=Russian
 1220|      0|		if (stressed_syllable == 0) {
 1221|      0|			// no explicit stress - guess the stress from the number of syllables
 1222|      0|			static char guess_ru[16] =   { 0, 0, 1, 1, 2, 3, 3, 4, 5, 6, 7, 7, 8, 9, 10, 11 };
 1223|      0|			static char guess_ru_v[16] = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 7, 8, 9, 10 }; // for final phoneme is a vowel
 1224|      0|			static char guess_ru_t[16] = { 0, 0, 1, 2, 3, 3, 3, 4, 5, 6, 7, 7, 7, 8, 9, 10 }; // for final phoneme is an unvoiced stop
 1225|      0|
 1226|      0|			stressed_syllable = vowel_count - 3;
 1227|      0|			if (vowel_count < 16) {
 1228|      0|				if (phoneme_tab[final_ph]->type == phVOWEL)
 1229|      0|					stressed_syllable = guess_ru_v[vowel_count];
 1230|      0|				else if (phoneme_tab[final_ph]->type == phSTOP)
 1231|      0|					stressed_syllable = guess_ru_t[vowel_count];
 1232|      0|				else
 1233|      0|					stressed_syllable = guess_ru[vowel_count];
 1234|      0|			}
 1235|      0|			vowel_stress[stressed_syllable] = STRESS_IS_PRIMARY;
 1236|      0|			max_stress = STRESS_IS_PRIMARY;
 1237|      0|		}
 1238|      0|		break;
 1239|      0|	case STRESSPOSN_1RH: // LANG=hi stress on the last heaviest syllable
 1240|      0|		if (stressed_syllable == 0) {
 1241|      0|			int wt;
 1242|      0|			int max_weight = -1;
 1243|      0|
 1244|      0|			// find the heaviest syllable, excluding the final syllable
 1245|      0|			for (ix = 1; ix < (vowel_count-1); ix++) {
 1246|      0|				if (vowel_stress[ix] < STRESS_IS_DIMINISHED) {
 1247|      0|					if ((wt = syllable_weight[ix]) >= max_weight) {
 1248|      0|						max_weight = wt;
 1249|      0|						stressed_syllable = ix;
 1250|      0|					}
 1251|      0|				}
 1252|      0|			}
 1253|      0|
 1254|      0|			if ((syllable_weight[vowel_count-1] == 2) &&  (max_weight < 2)) {
 1255|      0|				// the only double=heavy syllable is the final syllable, so stress this
 1256|      0|				stressed_syllable = vowel_count-1;
 1257|      0|			} else if (max_weight <= 0) {
 1258|      0|				// all syllables, exclusing the last, are light. Stress the first syllable
 1259|      0|				stressed_syllable = 1;
 1260|      0|			}
 1261|      0|
 1262|      0|			vowel_stress[stressed_syllable] = STRESS_IS_PRIMARY;
 1263|      0|			max_stress = STRESS_IS_PRIMARY;
 1264|      0|		}
 1265|      0|		break;
 1266|      0|	case STRESSPOSN_1RU : // LANG=tr, the last syllable for any vowel marked explicitly as unstressed
 1267|      0|		if (stressed_syllable == 0) {
 1268|      0|			stressed_syllable = vowel_count - 1;
 1269|      0|			for (ix = 1; ix < vowel_count; ix++) {
 1270|      0|				if (vowel_stress[ix] == STRESS_IS_UNSTRESSED) {
 1271|      0|					stressed_syllable = ix-1;
 1272|      0|					break;
 1273|      0|				}
 1274|      0|			}
 1275|      0|			vowel_stress[stressed_syllable] = STRESS_IS_PRIMARY;
 1276|      0|			max_stress = STRESS_IS_PRIMARY;
 1277|      0|		}
 1278|      0|		break;
 1279|      0|	case STRESSPOSN_ALL: // mark all as stressed
 1280|      0|		for (ix = 1; ix < vowel_count; ix++) {
 1281|      0|			if (vowel_stress[ix] < STRESS_IS_DIMINISHED)
 1282|      0|				vowel_stress[ix] = STRESS_IS_PRIMARY;
 1283|      0|		}
 1284|      0|		break;
 1285|      0|	case STRESSPOSN_GREENLANDIC: // LANG=kl (Greenlandic)
 1286|      0|		long_vowel = 0;
 1287|      0|		for (ix = 1; ix < vowel_count; ix++) {
 1288|      0|			if (vowel_stress[ix] == STRESS_IS_PRIMARY)
 1289|      0|				vowel_stress[ix] = STRESS_IS_SECONDARY; // change marked stress (consonant clusters) to secondary (except the last)
 1290|      0|
 1291|      0|			if (vowel_length[ix] > 0) {
 1292|      0|				long_vowel = ix;
 1293|      0|				vowel_stress[ix] = STRESS_IS_SECONDARY; // give secondary stress to all long vowels
 1294|      0|			}
 1295|      0|		}
 1296|      0|
 1297|      0|		// 'stressed_syllable' gives the last marked stress
 1298|      0|		if (stressed_syllable == 0) {
 1299|      0|			// no marked stress, choose the last long vowel
 1300|      0|			if (long_vowel > 0)
 1301|      0|				stressed_syllable = long_vowel;
 1302|      0|			else {
 1303|      0|				// no long vowels or consonant clusters
 1304|      0|				if (vowel_count > 5)
 1305|      0|					stressed_syllable = vowel_count - 3; // more than 4 syllables
 1306|      0|				else
 1307|      0|					stressed_syllable = vowel_count - 1;
 1308|      0|			}
 1309|      0|		}
 1310|      0|		vowel_stress[stressed_syllable] = STRESS_IS_PRIMARY;
 1311|      0|		max_stress = STRESS_IS_PRIMARY;
 1312|      0|		break;
 1313|      0|	case STRESSPOSN_1SL:  // LANG=ml, 1st unless 1st vowel is short and 2nd is long
 1314|      0|		if (stressed_syllable == 0) {
 1315|      0|			stressed_syllable = 1;
 1316|      0|			if ((vowel_length[1] == 0) && (vowel_count > 2) && (vowel_length[2] > 0))
 1317|      0|				stressed_syllable = 2;
 1318|      0|			vowel_stress[stressed_syllable] = STRESS_IS_PRIMARY;
 1319|      0|			max_stress = STRESS_IS_PRIMARY;
 1320|      0|		}
 1321|      0|		break;
 1322|      0|
 1323|      0|	case STRESSPOSN_EU: // LANG=eu. If more than 2 syllables: primary stress in second syllable and secondary on last. 
 1324|      0|		if ((stressed_syllable == 0) && (vowel_count > 2)) {
 1325|      0|			for (ix = 1; ix < vowel_count; ix++) {
 1326|      0|				vowel_stress[ix] = STRESS_IS_DIMINISHED;
 1327|      0|			}
 1328|      0|			stressed_syllable = 2;
 1329|      0|			if (max_stress == STRESS_IS_DIMINISHED)
 1330|      0|				vowel_stress[stressed_syllable] = STRESS_IS_PRIMARY;
 1331|      0|			max_stress = STRESS_IS_PRIMARY;
 1332|      0|			if (vowel_count > 3) {
 1333|      0|				vowel_stress[vowel_count - 1] = STRESS_IS_SECONDARY;
 1334|      0|			}
 1335|      0|		}
 1336|      0|		break;
 1337|      0|	}
 1338|      0|
 1339|      0|	if ((stressflags & S_FINAL_VOWEL_UNSTRESSED) && ((control & 2) == 0) && (vowel_count > 2) && (max_stress_input < STRESS_IS_SECONDARY) && (vowel_stress[vowel_count - 1] == STRESS_IS_PRIMARY)) {
 1340|      0|		// Don't allow stress on a word-final vowel
 1341|      0|		// Only do this if there is no suffix phonemes to be added, and if a stress position was not given explicitly
 1342|      0|		if (phoneme_tab[final_ph]->type == phVOWEL) {
 1343|      0|			vowel_stress[vowel_count - 1] = STRESS_IS_UNSTRESSED;
 1344|      0|			vowel_stress[vowel_count - 2] = STRESS_IS_PRIMARY;
 1345|      0|		}
 1346|      0|	}
 1347|      0|
 1348|      0|	// now guess the complete stress pattern
 1349|      0|	if (max_stress < STRESS_IS_PRIMARY)
 1350|      0|		stress = STRESS_IS_PRIMARY; // no primary stress marked, use for 1st syllable
 1351|      0|	else
 1352|      0|		stress = STRESS_IS_SECONDARY;
 1353|      0|
 1354|      0|	if (unstressed_word == false) {
 1355|      0|		if ((stressflags & S_2_SYL_2) && (vowel_count == 3)) {
 1356|      0|			// Two syllable word, if one syllable has primary stress, then give the other secondary stress
 1357|      0|			if (vowel_stress[1] == STRESS_IS_PRIMARY)
 1358|      0|				vowel_stress[2] = STRESS_IS_SECONDARY;
 1359|      0|			if (vowel_stress[2] == STRESS_IS_PRIMARY)
 1360|      0|				vowel_stress[1] = STRESS_IS_SECONDARY;
 1361|      0|		}
 1362|      0|
 1363|      0|		if ((stressflags & S_INITIAL_2) && (vowel_stress[1] < STRESS_IS_DIMINISHED)) {
 1364|      0|			// If there is only one syllable before the primary stress, give it a secondary stress
 1365|      0|			if ((vowel_count > 3) && (vowel_stress[2] >= STRESS_IS_PRIMARY))
 1366|      0|				vowel_stress[1] = STRESS_IS_SECONDARY;
 1367|      0|		}
 1368|      0|	}
 1369|      0|
 1370|      0|	bool done = false;
 1371|      0|	first_primary = 0;
 1372|      0|	for (v = 1; v < vowel_count; v++) {
 1373|      0|		if (vowel_stress[v] < STRESS_IS_DIMINISHED) {
 1374|      0|			if ((stressflags & S_FINAL_NO_2) && (stress < STRESS_IS_PRIMARY) && (v == vowel_count-1)) {
 1375|      0|				// flag: don't give secondary stress to final vowel
 1376|      0|			} else if ((stressflags & 0x8000) && (done == false)) {
 1377|      0|				vowel_stress[v] = (char)stress;
 1378|      0|				done = true;
 1379|      0|				stress = STRESS_IS_SECONDARY; // use secondary stress for remaining syllables
 1380|      0|			} else if ((vowel_stress[v-1] <= STRESS_IS_UNSTRESSED) && ((vowel_stress[v+1] <= STRESS_IS_UNSTRESSED) || ((stress == STRESS_IS_PRIMARY) && (vowel_stress[v+1] <= STRESS_IS_NOT_STRESSED)))) {
 1381|      0|				// trochaic: give stress to vowel surrounded by unstressed vowels
 1382|      0|
 1383|      0|				if ((stress == STRESS_IS_SECONDARY) && (stressflags & S_NO_AUTO_2))
 1384|      0|					continue; // don't use secondary stress
 1385|      0|
 1386|      0|				// don't put secondary stress on a light syllable if the rest of the word (excluding last syllable) contains a heavy syllable
 1387|      0|				if ((v > 1) && (stressflags & S_2_TO_HEAVY) && (syllable_weight[v] == 0)) {
 1388|      0|					bool skip = false;
 1389|      0|					for (int i = v; i < vowel_count - 1; i++) {
 1390|      0|						if (syllable_weight[i] > 0) {
 1391|      0|							skip = true;
 1392|      0|							break;
 1393|      0|						}
 1394|      0|					}
 1395|      0|					if (skip == true)
 1396|      0|						continue;
 1397|      0|				}
 1398|      0|
 1399|      0|				if ((v > 1) && (stressflags & S_2_TO_HEAVY) && (syllable_weight[v] == 0) && (syllable_weight[v+1] > 0)) {
 1400|      0|					// don't put secondary stress on a light syllable which is followed by a heavy syllable
 1401|      0|					continue;
 1402|      0|				}
 1403|      0|
 1404|      0|				// should start with secondary stress on the first syllable, or should it count back from
 1405|      0|				// the primary stress and put secondary stress on alternate syllables?
 1406|      0|				vowel_stress[v] = (char)stress;
 1407|      0|				done = true;
 1408|      0|				stress = STRESS_IS_SECONDARY; // use secondary stress for remaining syllables
 1409|      0|			}
 1410|      0|		}
 1411|      0|
 1412|      0|		if (vowel_stress[v] >= STRESS_IS_PRIMARY) {
 1413|      0|			if (first_primary == 0)
 1414|      0|				first_primary = v;
 1415|      0|			else if (stressflags & S_FIRST_PRIMARY) {
 1416|      0|				// reduce primary stresses after the first to secondary
 1417|      0|				vowel_stress[v] = STRESS_IS_SECONDARY;
 1418|      0|			}
 1419|      0|		}
 1420|      0|	}
 1421|      0|
 1422|      0|	if ((unstressed_word) && (tonic < 0)) {
 1423|      0|		if (vowel_count <= 2)
 1424|      0|			tonic = tr->langopts.unstressed_wd1; // monosyllable - unstressed
 1425|      0|		else
 1426|      0|			tonic = tr->langopts.unstressed_wd2; // more than one syllable, used secondary stress as the main stress
 1427|      0|	}
 1428|      0|
 1429|      0|	max_stress = STRESS_IS_DIMINISHED;
 1430|      0|	max_stress_posn = 0;
 1431|      0|	for (v = 1; v < vowel_count; v++) {
 1432|      0|		if (vowel_stress[v] >= max_stress) {
 1433|      0|			max_stress = vowel_stress[v];
 1434|      0|			max_stress_posn = v;
 1435|      0|		}
 1436|      0|	}
 1437|      0|
 1438|      0|	if (tonic >= 0) {
 1439|      0|		// find position of highest stress, and replace it by 'tonic'
 1440|      0|
 1441|      0|		// don't disturb an explicitly set stress by 'unstress-at-end' flag
 1442|      0|		if ((tonic > max_stress) || (max_stress <= STRESS_IS_PRIMARY))
 1443|      0|			vowel_stress[max_stress_posn] = (char)tonic;
 1444|      0|		max_stress = tonic;
 1445|      0|	}
 1446|      0|
 1447|      0|	// produce output phoneme string
 1448|      0|	p = phonetic;
 1449|      0|	v = 1;
 1450|      0|
 1451|      0|	if (!(control & 1) && ((ph = phoneme_tab[*p]) != NULL)) {
 1452|      0|		while ((ph->type == phSTRESS) || (*p == phonEND_WORD)) {
 1453|      0|			p++;
 1454|      0|			ph = phoneme_tab[p[0]];
 1455|      0|		}
 1456|      0|
 1457|      0|		if ((tr->langopts.vowel_pause & 0x30) && (ph->type == phVOWEL)) {
 1458|      0|			// word starts with a vowel
 1459|      0|
 1460|      0|			if ((tr->langopts.vowel_pause & 0x20) && (vowel_stress[1] >= STRESS_IS_PRIMARY))
 1461|      0|				*output++ = phonPAUSE_NOLINK; // not to be replaced by link
 1462|      0|			else
 1463|      0|				*output++ = phonPAUSE_VSHORT; // break, but no pause
 1464|      0|		}
 1465|      0|	}
 1466|      0|
 1467|      0|	p = phonetic;
 1468|      0|	while (((phcode = *p++) != 0) && (output < max_output)) {
 1469|      0|		if ((ph = phoneme_tab[phcode]) == NULL)
 1470|      0|			continue;
 1471|      0|
 1472|      0|		if (ph->type == phPAUSE)
 1473|      0|			tr->prev_last_stress = 0;
 1474|      0|		else if (((ph->type == phVOWEL) && !(ph->phflags & phNONSYLLABIC)) || (*p == phonSYLLABIC)) {
 1475|      0|			// a vowel, or a consonant followed by a syllabic consonant marker
 1476|      0|
 1477|      0|			v_stress = vowel_stress[v];
 1478|      0|			tr->prev_last_stress = v_stress;
 1479|      0|
 1480|      0|			if (v_stress <= STRESS_IS_UNSTRESSED) {
 1481|      0|				if ((v > 1) && (max_stress >= 2) && (stressflags & S_FINAL_DIM) && (v == (vowel_count-1))) {
 1482|      0|					// option: mark unstressed final syllable as diminished
 1483|      0|					v_stress = STRESS_IS_DIMINISHED;
 1484|      0|				} else if ((stressflags & S_NO_DIM) || (v == 1) || (v == (vowel_count-1))) {
 1485|      0|					// first or last syllable, or option 'don't set diminished stress'
 1486|      0|					v_stress = STRESS_IS_UNSTRESSED;
 1487|      0|				} else if ((v == (vowel_count-2)) && (vowel_stress[vowel_count-1] <= STRESS_IS_UNSTRESSED)) {
 1488|      0|					// penultimate syllable, followed by an unstressed final syllable
 1489|      0|					v_stress = STRESS_IS_UNSTRESSED;
 1490|      0|				} else {
 1491|      0|					// unstressed syllable within a word
 1492|      0|					if ((vowel_stress[v-1] < STRESS_IS_DIMINISHED) || ((stressflags & S_MID_DIM) == 0)) {
 1493|      0|						v_stress = STRESS_IS_DIMINISHED;
 1494|      0|						vowel_stress[v] = v_stress;
 1495|      0|					}
 1496|      0|				}
 1497|      0|			}
 1498|      0|
 1499|      0|			if ((v_stress == STRESS_IS_DIMINISHED) || (v_stress > STRESS_IS_UNSTRESSED))
 1500|      0|				*output++ = stress_phonemes[v_stress]; // mark stress of all vowels except 1 (unstressed)
 1501|      0|
 1502|      0|			if (vowel_stress[v] > max_stress)
 1503|      0|				max_stress = vowel_stress[v];
 1504|      0|
 1505|      0|			if ((*p == phonLENGTHEN) && ((opt_length = tr->langopts.param[LOPT_IT_LENGTHEN]) & 1)) {
 1506|      0|				// remove lengthen indicator from non-stressed syllables
 1507|      0|				bool shorten = false;
 1508|      0|
 1509|      0|				if (opt_length & 0x10) {
 1510|      0|					// only allow lengthen indicator on the highest stress syllable in the word
 1511|      0|					if (v != max_stress_posn)
 1512|      0|						shorten = true;
 1513|      0|				} else if (v_stress < STRESS_IS_PRIMARY) {
 1514|      0|					// only allow lengthen indicator if stress >= STRESS_IS_PRIMARY.
 1515|      0|					shorten = true;
 1516|      0|				}
 1517|      0|
 1518|      0|				if (shorten)
 1519|      0|					p++;
 1520|      0|			}
 1521|      0|			v++;
 1522|      0|		}
 1523|      0|
 1524|      0|		if (phcode != 1)
 1525|      0|			*output++ = phcode;
 1526|      0|	}
 1527|      0|	*output++ = 0;
 1528|      0|
 1529|      0|	return;
 1530|      0|}
 1531|       |
 1532|       |void AppendPhonemes(Translator *tr, char *string, int size, const char *ph)
 1533|      0|{
 1534|      0|	/* Add new phoneme string "ph" to "string"
 1535|      0|	    Keeps count of the number of vowel phonemes in the word, and whether these
 1536|      0|	   can be stressed syllables.  These values can be used in translation rules
 1537|      0|	 */
 1538|      0|
 1539|      0|	const char *p;
 1540|      0|	unsigned char c;
 1541|      0|	int length;
 1542|      0|
 1543|      0|	length = strlen(ph) + strlen(string);
 1544|      0|	if (length >= size)
 1545|      0|		return;
 1546|      0|
 1547|      0|	// any stressable vowel ?
 1548|      0|	bool unstress_mark = false;
 1549|      0|	p = ph;
 1550|      0|	while ((c = *p++) != 0) {
 1551|      0|		if (c >= n_phoneme_tab) continue;
 1552|      0|
 1553|      0|		if (phoneme_tab[c]->type == phSTRESS) {
 1554|      0|			if (phoneme_tab[c]->std_length < 4)
 1555|      0|				unstress_mark = true;
 1556|      0|		} else {
 1557|      0|			if (phoneme_tab[c]->type == phVOWEL) {
 1558|      0|				if (((phoneme_tab[c]->phflags & phUNSTRESSED) == 0) &&
 1559|      0|				    (unstress_mark == false)) {
 1560|      0|					tr->word_stressed_count++;
 1561|      0|				}
 1562|      0|				unstress_mark = false;
 1563|      0|				tr->word_vowel_count++;
 1564|      0|			}
 1565|      0|		}
 1566|      0|	}
 1567|      0|
 1568|      0|	if (string != NULL)
 1569|      0|		strcat(string, ph);
 1570|      0|}
 1571|       |
 1572|       |static void MatchRule(Translator *tr, char *word[], char *word_start, int group_length, char *rule, MatchRecord *match_out, int word_flags, int dict_flags)
 1573|      0|{
 1574|      0|	/* Checks a specified word against dictionary rules.
 1575|      0|	    Returns with phoneme code string, or NULL if no match found.
 1576|      0|
 1577|      0|	    word (indirect) points to current character group within the input word
 1578|      0|	            This is advanced by this procedure as characters are consumed
 1579|      0|
 1580|      0|	    group:  the initial characters used to choose the rules group
 1581|      0|
 1582|      0|	    rule:  address of dictionary rule data for this character group
 1583|      0|
 1584|      0|	    match_out:  returns best points score
 1585|      0|
 1586|      0|	    word_flags:  indicates whether this is a retranslation after a suffix has been removed
 1587|      0|	 */
 1588|      0|
 1589|      0|	unsigned char rb;     // current instuction from rule
 1590|      0|	unsigned char letter; // current letter from input word, single byte
 1591|      0|	int letter_w;         // current letter, wide character
 1592|      0|	int last_letter_w;    // last letter, wide character
 1593|      0|	int letter_xbytes;    // number of extra bytes of multibyte character (num bytes - 1)
 1594|      0|
 1595|      0|	char *pre_ptr;
 1596|      0|	char *post_ptr;       // pointer to first character after group
 1597|      0|
 1598|      0|	char *rule_start;     // start of current match template
 1599|      0|	char *p;
 1600|      0|	int ix;
 1601|      0|
 1602|      0|	int match_type;       // left, right, or consume
 1603|      0|	int failed;
 1604|      0|	int unpron_ignore;
 1605|      0|	int consumed;         // number of letters consumed from input
 1606|      0|	int syllable_count;
 1607|      0|	int vowel;
 1608|      0|	int letter_group;
 1609|      0|	int distance_right;
 1610|      0|	int distance_left;
 1611|      0|	int lg_pts;
 1612|      0|	int n_bytes;
 1613|      0|	int add_points;
 1614|      0|	int command;
 1615|      0|	bool check_atstart;
 1616|      0|	unsigned int *flags;
 1617|      0|
 1618|      0|	MatchRecord match;
 1619|      0|	static MatchRecord best;
 1620|      0|
 1621|      0|	int total_consumed; // letters consumed for best match
 1622|      0|
 1623|      0|	unsigned char condition_num;
 1624|      0|	char *common_phonemes; // common to a group of entries
 1625|      0|	char *group_chars;
 1626|      0|	char word_buf[N_WORD_BYTES];
 1627|      0|
 1628|      0|	group_chars = *word;
 1629|      0|
 1630|      0|	if (rule == NULL) {
 1631|      0|		match_out->points = 0;
 1632|      0|		(*word)++;
 1633|      0|		return;
 1634|      0|	}
 1635|      0|
 1636|      0|	total_consumed = 0;
 1637|      0|	common_phonemes = NULL;
 1638|      0|
 1639|      0|	best.points = 0;
 1640|      0|	best.phonemes = "";
 1641|      0|	best.end_type = 0;
 1642|      0|	best.del_fwd = NULL;
 1643|      0|
 1644|      0|	// search through dictionary rules
 1645|      0|	while (rule[0] != RULE_GROUP_END) {
 1646|      0|		unpron_ignore = word_flags & FLAG_UNPRON_TEST;
 1647|      0|		match_type = 0;
 1648|      0|		consumed = 0;
 1649|      0|		letter_w = 0;
 1650|      0|		distance_right = -6; // used to reduce points for matches further away the current letter
 1651|      0|		distance_left = -2;
 1652|      0|		check_atstart = false;
 1653|      0|
 1654|      0|		match.points = 1;
 1655|      0|		match.end_type = 0;
 1656|      0|		match.del_fwd = NULL;
 1657|      0|
 1658|      0|		pre_ptr = *word;
 1659|      0|		post_ptr = *word + group_length;
 1660|      0|
 1661|      0|		// work through next rule until end, or until no-match proved
 1662|      0|		rule_start = rule;
 1663|      0|
 1664|      0|		failed = 0;
 1665|      0|		while (!failed) {
 1666|      0|			rb = *rule++;
 1667|      0|
 1668|      0|			if (rb <= RULE_LINENUM) {
 1669|      0|				switch (rb)
 1670|      0|				{
 1671|      0|				case 0: // no phoneme string for this rule, use previous common rule
 1672|      0|					if (common_phonemes != NULL) {
 1673|      0|						match.phonemes = common_phonemes;
 1674|      0|						while (((rb = *match.phonemes++) != 0) && (rb != RULE_PHONEMES)) {
 1675|      0|							if (rb == RULE_CONDITION)
 1676|      0|								match.phonemes++; // skip over condition number
 1677|      0|							if (rb == RULE_LINENUM)
 1678|      0|								match.phonemes += 2; // skip over line number
 1679|      0|						}
 1680|      0|					} else
 1681|      0|						match.phonemes = "";
 1682|      0|					rule--; // so we are still pointing at the 0
 1683|      0|					failed = 2; // matched OK
 1684|      0|					break;
 1685|      0|				case RULE_PRE_ATSTART: // pre rule with implied 'start of word'
 1686|      0|					check_atstart = true;
 1687|      0|					unpron_ignore = 0;
 1688|      0|					match_type = RULE_PRE;
 1689|      0|					break;
 1690|      0|				case RULE_PRE:
 1691|      0|					match_type = RULE_PRE;
 1692|      0|					if (word_flags & FLAG_UNPRON_TEST) {
 1693|      0|						// checking the start of the word for unpronouncable character sequences, only
 1694|      0|						// consider rules which explicitly match the start of a word
 1695|      0|						// Note: Those rules now use RULE_PRE_ATSTART
 1696|      0|						failed = 1;
 1697|      0|					}
 1698|      0|					break;
 1699|      0|				case RULE_POST:
 1700|      0|					match_type = RULE_POST;
 1701|      0|					break;
 1702|      0|				case RULE_PHONEMES:
 1703|      0|					match.phonemes = rule;
 1704|      0|					failed = 2; // matched OK
 1705|      0|					break;
 1706|      0|				case RULE_PH_COMMON:
 1707|      0|					common_phonemes = rule;
 1708|      0|					break;
 1709|      0|				case RULE_CONDITION:
 1710|      0|					// conditional rule, next byte gives condition number
 1711|      0|					condition_num = *rule++;
 1712|      0|
 1713|      0|					if (condition_num >= 32) {
 1714|      0|						// allow the rule only if the condition number is NOT set
 1715|      0|						if ((tr->dict_condition & (1L << (condition_num-32))) != 0)
 1716|      0|							failed = 1;
 1717|      0|					} else {
 1718|      0|						// allow the rule only if the condition number is set
 1719|      0|						if ((tr->dict_condition & (1L << condition_num)) == 0)
 1720|      0|							failed = 1;
 1721|      0|					}
 1722|      0|
 1723|      0|					if (!failed)
 1724|      0|						match.points++; // add one point for a matched conditional rule
 1725|      0|					break;
 1726|      0|				case RULE_LINENUM:
 1727|      0|					rule += 2;
 1728|      0|					break;
 1729|      0|				}
 1730|      0|				continue;
 1731|      0|			}
 1732|      0|
 1733|      0|			add_points = 0;
 1734|      0|
 1735|      0|			switch (match_type)
 1736|      0|			{
 1737|      0|			case 0:
 1738|      0|				// match and consume this letter
 1739|      0|				letter = *post_ptr++;
 1740|      0|
 1741|      0|				if ((letter == rb) || ((letter == (unsigned char)REPLACED_E) && (rb == 'e'))) {
 1742|      0|					if ((letter & 0xc0) != 0x80)
 1743|      0|						add_points = 21; // don't add point for non-initial UTF-8 bytes
 1744|      0|					consumed++;
 1745|      0|				} else
 1746|      0|					failed = 1;
 1747|      0|				break;
 1748|      0|			case RULE_POST:
 1749|      0|				// continue moving forwards
 1750|      0|				distance_right += 6;
 1751|      0|				if (distance_right > 18)
 1752|      0|					distance_right = 19;
 1753|      0|				last_letter_w = letter_w;
 1754|      0|				letter_xbytes = utf8_in(&letter_w, post_ptr)-1;
 1755|      0|				letter = *post_ptr++;
 1756|      0|
 1757|      0|				switch (rb)
 1758|      0|				{
 1759|      0|				case RULE_LETTERGP:
 1760|      0|					letter_group = LetterGroupNo(rule++);
 1761|      0|					if (IsLetter(tr, letter_w, letter_group)) {
 1762|      0|						lg_pts = 20;
 1763|      0|						if (letter_group == 2)
 1764|      0|							lg_pts = 19; // fewer points for C, general consonant
 1765|      0|						add_points = (lg_pts-distance_right);
 1766|      0|						post_ptr += letter_xbytes;
 1767|      0|					} else
 1768|      0|						failed = 1;
 1769|      0|					break;
 1770|      0|				case RULE_LETTERGP2: // match against a list of utf-8 strings
 1771|      0|					letter_group = LetterGroupNo(rule++);
 1772|      0|					if ((n_bytes = IsLetterGroup(tr, post_ptr-1, letter_group, 0)) >= 0) {
 1773|      0|						add_points = (20-distance_right);
 1774|      0|						if (n_bytes >= 0) // move pointer, if group was found
 1775|      0|							post_ptr += (n_bytes-1);
 1776|      0|					} else
 1777|      0|						failed = 1;
 1778|      0|					break;
 1779|      0|				case RULE_NOTVOWEL:
 1780|      0|					if (IsLetter(tr, letter_w, 0) || ((letter_w == ' ') && (word_flags & FLAG_SUFFIX_VOWEL)))
 1781|      0|						failed = 1;
 1782|      0|					else {
 1783|      0|						add_points = (20-distance_right);
 1784|      0|						post_ptr += letter_xbytes;
 1785|      0|					}
 1786|      0|					break;
 1787|      0|				case RULE_DIGIT:
 1788|      0|					if (IsDigit(letter_w)) {
 1789|      0|						add_points = (20-distance_right);
 1790|      0|						post_ptr += letter_xbytes;
 1791|      0|					} else if (tr->langopts.tone_numbers) {
 1792|      0|						// also match if there is no digit
 1793|      0|						add_points = (20-distance_right);
 1794|      0|						post_ptr--;
 1795|      0|					} else
 1796|      0|						failed = 1;
 1797|      0|					break;
 1798|      0|				case RULE_NONALPHA:
 1799|      0|					if (!iswalpha(letter_w)) {
 1800|      0|						add_points = (21-distance_right);
 1801|      0|						post_ptr += letter_xbytes;
 1802|      0|					} else
 1803|      0|						failed = 1;
 1804|      0|					break;
 1805|      0|				case RULE_DOUBLE:
 1806|      0|					if (letter_w == last_letter_w)
 1807|      0|						add_points = (21-distance_right);
 1808|      0|					else
 1809|      0|						failed = 1;
 1810|      0|					break;
 1811|      0|				case RULE_DOLLAR:
 1812|      0|					command = *rule++;
 1813|      0|					if (command == DOLLAR_UNPR)
 1814|      0|						match.end_type = SUFX_UNPRON; // $unpron
 1815|      0|					else if (command == DOLLAR_NOPREFIX) { // $noprefix
 1816|      0|						if (word_flags & FLAG_PREFIX_REMOVED)
 1817|      0|							failed = 1; // a prefix has been removed
 1818|      0|						else
 1819|      0|							add_points = 1;
 1820|      0|					} else if ((command & 0xf0) == 0x10) {
 1821|      0|						// $w_alt
 1822|      0|						if (dict_flags & (1 << (BITNUM_FLAG_ALT + (command & 0xf))))
 1823|      0|							add_points = 23;
 1824|      0|						else
 1825|      0|							failed = 1;
 1826|      0|					} else if (((command & 0xf0) == 0x20) || (command == DOLLAR_LIST)) {
 1827|      0|						// $list or $p_alt
 1828|      0|						// make a copy of the word up to the post-match characters
 1829|      0|						ix = *word - word_start + consumed + group_length + 1;
 1830|      0|						memcpy(word_buf, word_start-1, ix);
 1831|      0|						word_buf[ix] = ' ';
 1832|      0|						word_buf[ix+1] = 0;
 1833|      0|						LookupFlags(tr, &word_buf[1], &flags);
 1834|      0|
 1835|      0|						if ((command == DOLLAR_LIST) && (flags[0] & FLAG_FOUND) && !(flags[1] & FLAG_ONLY))
 1836|      0|							add_points = 23;
 1837|      0|						else if (flags[0] & (1 << (BITNUM_FLAG_ALT + (command & 0xf))))
 1838|      0|							add_points = 23;
 1839|      0|						else
 1840|      0|							failed = 1;
 1841|      0|					}
 1842|      0|					break;
 1843|      0|				case '-':
 1844|      0|					if ((letter == '-') || ((letter == ' ') && (word_flags & FLAG_HYPHEN_AFTER)))
 1845|      0|						add_points = (22-distance_right); // one point more than match against space
 1846|      0|					else
 1847|      0|						failed = 1;
 1848|      0|					break;
 1849|      0|				case RULE_SYLLABLE:
 1850|      0|				{
 1851|      0|					// more than specified number of vowel letters to the right
 1852|      0|					char *p = post_ptr + letter_xbytes;
 1853|      0|					int vowel_count = 0;
 1854|      0|
 1855|      0|					syllable_count = 1;
 1856|      0|					while (*rule == RULE_SYLLABLE) {
 1857|      0|						rule++;
 1858|      0|						syllable_count += 1; // number of syllables to match
 1859|      0|					}
 1860|      0|					vowel = 0;
 1861|      0|					while (letter_w != RULE_SPACE) {
 1862|      0|						if ((vowel == 0) && IsLetter(tr, letter_w, LETTERGP_VOWEL2)) {
 1863|      0|							// this is counting vowels which are separated by non-vowel letters
 1864|      0|							vowel_count++;
 1865|      0|						}
 1866|      0|						vowel = IsLetter(tr, letter_w, LETTERGP_VOWEL2);
 1867|      0|						p += utf8_in(&letter_w, p);
 1868|      0|					}
 1869|      0|					if (syllable_count <= vowel_count)
 1870|      0|						add_points = (18+syllable_count-distance_right);
 1871|      0|					else
 1872|      0|						failed = 1;
 1873|      0|				}
 1874|      0|					break;
 1875|      0|				case RULE_NOVOWELS:
 1876|      0|				{
 1877|      0|					char *p = post_ptr + letter_xbytes;
 1878|      0|					while (letter_w != RULE_SPACE) {
 1879|      0|						if (IsLetter(tr, letter_w, LETTERGP_VOWEL2)) {
 1880|      0|							failed = 1;
 1881|      0|							break;
 1882|      0|						}
 1883|      0|						p += utf8_in(&letter_w, p);
 1884|      0|					}
 1885|      0|					if (!failed)
 1886|      0|						add_points = (19-distance_right);
 1887|      0|				}
 1888|      0|					break;
 1889|      0|				case RULE_SKIPCHARS:
 1890|      0|				{
 1891|      0|					// '(Jxy'  means 'skip characters until xy'
 1892|      0|					char *p = post_ptr - 1; // to allow empty jump (without letter between), go one back
 1893|      0|					char *p2 = p;		// pointer to the previous character in the word
 1894|      0|					int rule_w;		// first wide character of skip rule
 1895|      0|					utf8_in(&rule_w, rule);
 1896|      0|					int g_bytes = -1;	// bytes of successfully found character group
 1897|      0|					while ((letter_w != rule_w) && (letter_w != RULE_SPACE) && (letter_w != 0) && (g_bytes == -1)) {
 1898|      0|						if (rule_w == RULE_LETTERGP2)
 1899|      0|							g_bytes = IsLetterGroup(tr, p, LetterGroupNo(rule + 1), 0);
 1900|      0|						p2 = p;
 1901|      0|						p += utf8_in(&letter_w, p);
 1902|      0|					}
 1903|      0|					if ((letter_w == rule_w) || (g_bytes >= 0))
 1904|      0|						post_ptr = p2;
 1905|      0|				}
 1906|      0|					break;
 1907|      0|				case RULE_INC_SCORE:
 1908|      0|					add_points = 20; // force an increase in points
 1909|      0|					break;
 1910|      0|				case RULE_DEC_SCORE:
 1911|      0|					add_points = -20; // force an decrease in points
 1912|      0|					break;
 1913|      0|				case RULE_DEL_FWD:
 1914|      0|					// find the next 'e' in the word and replace by 'E'
 1915|      0|					for (p = *word + group_length; p < post_ptr; p++) {
 1916|      0|						if (*p == 'e') {
 1917|      0|							match.del_fwd = p;
 1918|      0|							break;
 1919|      0|						}
 1920|      0|					}
 1921|      0|					break;
 1922|      0|				case RULE_ENDING:
 1923|      0|				{
 1924|      0|					int end_type;
 1925|      0|					// next 3 bytes are a (non-zero) ending type. 2 bytes of flags + suffix length
 1926|      0|					end_type = (rule[0] << 16) + ((rule[1] & 0x7f) << 8) + (rule[2] & 0x7f);
 1927|      0|
 1928|      0|					if ((tr->word_vowel_count == 0) && !(end_type & SUFX_P) && (tr->langopts.param[LOPT_SUFFIX] & 1))
 1929|      0|						failed = 1; // don't match a suffix rule if there are no previous syllables (needed for lang=tr).
 1930|      0|					else {
 1931|      0|						match.end_type = end_type;
 1932|      0|						rule += 3;
 1933|      0|					}
 1934|      0|				}
 1935|      0|					break;
 1936|      0|				case RULE_NO_SUFFIX:
 1937|      0|					if (word_flags & FLAG_SUFFIX_REMOVED)
 1938|      0|						failed = 1; // a suffix has been removed
 1939|      0|					else
 1940|      0|						add_points = 1;
 1941|      0|					break;
 1942|      0|				default:
 1943|      0|					if (letter == rb) {
 1944|      0|						if ((letter & 0xc0) != 0x80) {
 1945|      0|							// not for non-initial UTF-8 bytes
 1946|      0|							add_points = (21-distance_right);
 1947|      0|						}
 1948|      0|					} else
 1949|      0|						failed = 1;
 1950|      0|					break;
 1951|      0|				}
 1952|      0|				break;
 1953|      0|			case RULE_PRE:
 1954|      0|				// match backwards from start of current group
 1955|      0|				distance_left += 2;
 1956|      0|				if (distance_left > 18)
 1957|      0|					distance_left = 19;
 1958|      0|
 1959|      0|				utf8_in(&last_letter_w, pre_ptr);
 1960|      0|				pre_ptr--;
 1961|      0|				letter_xbytes = utf8_in2(&letter_w, pre_ptr, 1)-1;
 1962|      0|				letter = *pre_ptr;
 1963|      0|
 1964|      0|				switch (rb)
 1965|      0|				{
 1966|      0|				case RULE_LETTERGP:
 1967|      0|					letter_group = LetterGroupNo(rule++);
 1968|      0|					if (IsLetter(tr, letter_w, letter_group)) {
 1969|      0|						lg_pts = 20;
 1970|      0|						if (letter_group == 2)
 1971|      0|							lg_pts = 19; // fewer points for C, general consonant
 1972|      0|						add_points = (lg_pts-distance_left);
 1973|      0|						pre_ptr -= letter_xbytes;
 1974|      0|					} else
 1975|      0|						failed = 1;
 1976|      0|					break;
 1977|      0|				case RULE_LETTERGP2: // match against a list of utf-8 strings
 1978|      0|					letter_group = LetterGroupNo(rule++);
 1979|      0|					if ((n_bytes = IsLetterGroup(tr, pre_ptr, letter_group, 1)) >= 0) {
 1980|      0|						add_points = (20-distance_right);
 1981|      0|						if (n_bytes >= 0)  // move pointer, if group was found
 1982|      0|							pre_ptr -= (n_bytes-1);
 1983|      0|					} else
 1984|      0|						failed = 1;
 1985|      0|					break;
 1986|      0|				case RULE_NOTVOWEL:
 1987|      0|					if (!IsLetter(tr, letter_w, 0)) {
 1988|      0|						add_points = (20-distance_left);
 1989|      0|						pre_ptr -= letter_xbytes;
 1990|      0|					} else
 1991|      0|						failed = 1;
 1992|      0|					break;
 1993|      0|				case RULE_DOUBLE:
 1994|      0|					if (letter_w == last_letter_w)
 1995|      0|						add_points = (21-distance_left);
 1996|      0|					else
 1997|      0|						failed = 1;
 1998|      0|					break;
 1999|      0|				case RULE_DIGIT:
 2000|      0|					if (IsDigit(letter_w)) {
 2001|      0|						add_points = (21-distance_left);
 2002|      0|						pre_ptr -= letter_xbytes;
 2003|      0|					} else
 2004|      0|						failed = 1;
 2005|      0|					break;
 2006|      0|				case RULE_NONALPHA:
 2007|      0|					if (!iswalpha(letter_w)) {
 2008|      0|						add_points = (21-distance_right);
 2009|      0|						pre_ptr -= letter_xbytes;
 2010|      0|					} else
 2011|      0|						failed = 1;
 2012|      0|					break;
 2013|      0|				case RULE_DOLLAR:
 2014|      0|					command = *rule++;
 2015|      0|					if ((command == DOLLAR_LIST) || ((command & 0xf0) == 0x20)) {
 2016|      0|						// $list or $p_alt
 2017|      0|						// make a copy of the word up to the current character
 2018|      0|						ix = *word - word_start + 1;
 2019|      0|						memcpy(word_buf, word_start-1, ix);
 2020|      0|						word_buf[ix] = ' ';
 2021|      0|						word_buf[ix+1] = 0;
 2022|      0|						LookupFlags(tr, &word_buf[1], &flags);
 2023|      0|
 2024|      0|						if ((command == DOLLAR_LIST) && (flags[0] & FLAG_FOUND) && !(flags[1] & FLAG_ONLY))
 2025|      0|							add_points = 23;
 2026|      0|						else if (flags[0] & (1 << (BITNUM_FLAG_ALT + (command & 0xf))))
 2027|      0|							add_points = 23;
 2028|      0|						else
 2029|      0|							failed = 1;
 2030|      0|					}
 2031|      0|					break;
 2032|      0|				case RULE_SYLLABLE:
 2033|      0|					// more than specified number of vowels to the left
 2034|      0|					syllable_count = 1;
 2035|      0|					while (*rule == RULE_SYLLABLE) {
 2036|      0|						rule++;
 2037|      0|						syllable_count++; // number of syllables to match
 2038|      0|					}
 2039|      0|					if (syllable_count <= tr->word_vowel_count)
 2040|      0|						add_points = (18+syllable_count-distance_left);
 2041|      0|					else
 2042|      0|						failed = 1;
 2043|      0|					break;
 2044|      0|				case RULE_STRESSED:
 2045|      0|					if (tr->word_stressed_count > 0)
 2046|      0|						add_points = 19;
 2047|      0|					else
 2048|      0|						failed = 1;
 2049|      0|					break;
 2050|      0|				case RULE_NOVOWELS:
 2051|      0|				{
 2052|      0|					char *p = pre_ptr - letter_xbytes - 1;
 2053|      0|					while (letter_w != RULE_SPACE) {
 2054|      0|						if (IsLetter(tr, letter_w, LETTERGP_VOWEL2)) {
 2055|      0|							failed = 1;
 2056|      0|							break;
 2057|      0|						}
 2058|      0|						p -= utf8_in2(&letter_w, p, 1);
 2059|      0|					}
 2060|      0|					if (!failed)
 2061|      0|						add_points = 3;
 2062|      0|				}
 2063|      0|					break;
 2064|      0|				case RULE_IFVERB:
 2065|      0|					if (tr->expect_verb)
 2066|      0|						add_points = 1;
 2067|      0|					else
 2068|      0|						failed = 1;
 2069|      0|					break;
 2070|      0|				case RULE_CAPITAL:
 2071|      0|					if (word_flags & FLAG_FIRST_UPPER)
 2072|      0|						add_points = 1;
 2073|      0|					else
 2074|      0|						failed = 1;
 2075|      0|					break;
 2076|      0|				case '.':
 2077|      0|					// dot in pre- section, match on any dot before this point in the word
 2078|      0|					for (p = pre_ptr; *p != ' '; p--) {
 2079|      0|						if (*p == '.') {
 2080|      0|							add_points = 50;
 2081|      0|							break;
 2082|      0|						}
 2083|      0|					}
 2084|      0|					if (*p == ' ')
 2085|      0|						failed = 1;
 2086|      0|					break;
 2087|      0|				case '-':
 2088|      0|					if ((letter == '-') || ((letter == ' ') && (word_flags & FLAG_HYPHEN)))
 2089|      0|						add_points = (22-distance_right); // one point more than match against space
 2090|      0|					else
 2091|      0|						failed = 1;
 2092|      0|					break;
 2093|      0|
 2094|      0|				case RULE_SKIPCHARS: {
 2095|      0|					// 'xyJ)'  means 'skip characters backwards until xy'
 2096|      0|					char *p = pre_ptr + 1;	// to allow empty jump (without letter between), go one forward
 2097|      0|					char *p2 = p;		// pointer to previous character in word
 2098|      0|					int g_bytes = -1;	// bytes of successfully found character group
 2099|      0|
 2100|      0|					while ((*p != *rule) && (*p != RULE_SPACE) && (*p != 0) && (g_bytes == -1)) {
 2101|      0|						p2 = p;
 2102|      0|						p--;
 2103|      0|						if (*rule == RULE_LETTERGP2)
 2104|      0|							g_bytes = IsLetterGroup(tr, p2, LetterGroupNo(rule + 1), 1);
 2105|      0|					}
 2106|      0|
 2107|      0|					// if succeed, set pre_ptr to next character after 'xy' and remaining
 2108|      0|					// 'xy' part is checked as usual in following cycles of PRE rule characters
 2109|      0|					if (*p == *rule)
 2110|      0|						pre_ptr = p2;
 2111|      0|					if (g_bytes >= 0)
 2112|      0|						pre_ptr = p2 + 1;
 2113|      0|
 2114|      0|				}
 2115|      0|					break;
 2116|      0|
 2117|      0|				default:
 2118|      0|					if (letter == rb) {
 2119|      0|						if (letter == RULE_SPACE)
 2120|      0|							add_points = 4;
 2121|      0|						else if ((letter & 0xc0) != 0x80) {
 2122|      0|							// not for non-initial UTF-8 bytes
 2123|      0|							add_points = (21-distance_left);
 2124|      0|						}
 2125|      0|					} else
 2126|      0|						failed = 1;
 2127|      0|					break;
 2128|      0|				}
 2129|      0|				break;
 2130|      0|			}
 2131|      0|
 2132|      0|			if (failed == 0)
 2133|      0|				match.points += add_points;
 2134|      0|		}
 2135|      0|
 2136|      0|		if ((failed == 2) && (unpron_ignore == 0)) {
 2137|      0|			// do we also need to check for 'start of word' ?
 2138|      0|			if ((check_atstart == false) || (pre_ptr[-1] == ' ')) {
 2139|      0|				if (check_atstart)
 2140|      0|					match.points += 4;
 2141|      0|
 2142|      0|				// matched OK, is this better than the last best match ?
 2143|      0|				if (match.points >= best.points) {
 2144|      0|					memcpy(&best, &match, sizeof(match));
 2145|      0|					total_consumed = consumed;
 2146|      0|				}
 2147|      0|
 2148|      0|				if ((option_phonemes & espeakPHONEMES_TRACE) && (match.points > 0) && ((word_flags & FLAG_NO_TRACE) == 0)) {
 2149|      0|					// show each rule that matches, and it's points score
 2150|      0|					int pts;
 2151|      0|					char decoded_phonemes[80];
 2152|      0|
 2153|      0|					pts = match.points;
 2154|      0|					if (group_length > 1)
 2155|      0|						pts += 35; // to account for an extra letter matching
 2156|      0|					DecodePhonemes(match.phonemes, decoded_phonemes);
 2157|      0|					fprintf(f_trans, "%3d\t%s [%s]\n", pts, DecodeRule(group_chars, group_length, rule_start, word_flags), decoded_phonemes);
 2158|      0|				}
 2159|      0|			}
 2160|      0|		}
 2161|      0|
 2162|      0|		// skip phoneme string to reach start of next template
 2163|      0|		while (*rule++ != 0) ;
 2164|      0|	}
 2165|      0|
 2166|      0|	// advance input data pointer
 2167|      0|	total_consumed += group_length;
 2168|      0|	if (total_consumed == 0)
 2169|      0|		total_consumed = 1; // always advance over 1st letter
 2170|      0|
 2171|      0|	*word += total_consumed;
 2172|      0|
 2173|      0|	if (best.points == 0)
 2174|      0|		best.phonemes = "";
 2175|      0|	memcpy(match_out, &best, sizeof(MatchRecord));
 2176|      0|}
 2177|       |
 2178|       |int TranslateRules(Translator *tr, char *p_start, char *phonemes, int ph_size, char *end_phonemes, int word_flags, unsigned int *dict_flags)
 2179|      0|{
 2180|      0|	/* Translate a word bounded by space characters
 2181|      0|	   Append the result to 'phonemes' and any standard prefix/suffix in 'end_phonemes' */
 2182|      0|
 2183|      0|	unsigned char c, c2;
 2184|      0|	unsigned int c12;
 2185|      0|	int wc = 0;
 2186|      0|	int wc_bytes;
 2187|      0|	char *p2;           // copy of p for use in double letter chain match
 2188|      0|	int found;
 2189|      0|	int g;              // group chain number
 2190|      0|	int g1;             // first group for this letter
 2191|      0|	int n;
 2192|      0|	int letter;
 2193|      0|	int any_alpha = 0;
 2194|      0|	int ix;
 2195|      0|	unsigned int digit_count = 0;
 2196|      0|	char *p;
 2197|      0|	ALPHABET *alphabet;
 2198|      0|	int dict_flags0 = 0;
 2199|      0|	MatchRecord match1;
 2200|      0|	MatchRecord match2;
 2201|      0|	char ph_buf[40];
 2202|      0|	char word_copy[N_WORD_BYTES];
 2203|      0|	static const char str_pause[2] = { phonPAUSE_NOLINK, 0 };
 2204|      0|
 2205|      0|	if (tr->data_dictrules == NULL)
 2206|      0|		return 0;
 2207|      0|
 2208|      0|	if (dict_flags != NULL)
 2209|      0|		dict_flags0 = dict_flags[0];
 2210|      0|
 2211|      0|	for (ix = 0; ix < (N_WORD_BYTES-1);) {
 2212|      0|		c = p_start[ix];
 2213|      0|		word_copy[ix++] = c;
 2214|      0|		if (c == 0)
 2215|      0|			break;
 2216|      0|	}
 2217|      0|	word_copy[ix] = 0;
 2218|      0|
 2219|      0|	if ((option_phonemes & espeakPHONEMES_TRACE) && ((word_flags & FLAG_NO_TRACE) == 0)) {
 2220|      0|		char wordbuf[120];
 2221|      0|		unsigned int ix;
 2222|      0|
 2223|      0|		for (ix = 0; ((c = p_start[ix]) != ' ') && (c != 0) && (ix < (sizeof(wordbuf)-1)); ix++)
 2224|      0|			wordbuf[ix] = c;
 2225|      0|		wordbuf[ix] = 0;
 2226|      0|		if (word_flags & FLAG_UNPRON_TEST)
 2227|      0|			fprintf(f_trans, "Unpronouncable? '%s'\n", wordbuf);
 2228|      0|		else
 2229|      0|			fprintf(f_trans, "Translate '%s'\n", wordbuf);
 2230|      0|	}
 2231|      0|
 2232|      0|	p = p_start;
 2233|      0|	tr->word_vowel_count = 0;
 2234|      0|	tr->word_stressed_count = 0;
 2235|      0|
 2236|      0|	if (end_phonemes != NULL)
 2237|      0|		end_phonemes[0] = 0;
 2238|      0|
 2239|      0|	while (((c = *p) != ' ') && (c != 0)) {
 2240|      0|		wc_bytes = utf8_in(&wc, p);
 2241|      0|		if (IsAlpha(wc))
 2242|      0|			any_alpha++;
 2243|      0|
 2244|      0|		n = tr->groups2_count[c];
 2245|      0|		if (IsDigit(wc) && ((tr->langopts.tone_numbers == 0) || !any_alpha)) {
 2246|      0|			// lookup the number in *_list not *_rules
 2247|      0|			char string[8];
 2248|      0|			char buf[40];
 2249|      0|			string[0] = '_';
 2250|      0|			memcpy(&string[1], p, wc_bytes);
 2251|      0|			string[1+wc_bytes] = 0;
 2252|      0|			Lookup(tr, string, buf);
 2253|      0|			if (++digit_count >= 2) {
 2254|      0|				strcat(buf, str_pause);
 2255|      0|				digit_count = 0;
 2256|      0|			}
 2257|      0|			AppendPhonemes(tr, phonemes, ph_size, buf);
 2258|      0|			p += wc_bytes;
 2259|      0|			continue;
 2260|      0|		} else {
 2261|      0|			digit_count = 0;
 2262|      0|			found = 0;
 2263|      0|
 2264|      0|			if (((ix = wc - tr->letter_bits_offset) >= 0) && (ix < 128)) {
 2265|      0|				if (tr->groups3[ix] != NULL) {
 2266|      0|					MatchRule(tr, &p, p_start, wc_bytes, tr->groups3[ix], &match1, word_flags, dict_flags0);
 2267|      0|					found = 1;
 2268|      0|				}
 2269|      0|			}
 2270|      0|
 2271|      0|			if (!found && (n > 0)) {
 2272|      0|				// there are some 2 byte chains for this initial letter
 2273|      0|				c2 = p[1];
 2274|      0|				c12 = c + (c2 << 8); // 2 characters
 2275|      0|
 2276|      0|				g1 = tr->groups2_start[c];
 2277|      0|				for (g = g1; g < (g1+n); g++) {
 2278|      0|					if (tr->groups2_name[g] == c12) {
 2279|      0|						found = 1;
 2280|      0|
 2281|      0|						p2 = p;
 2282|      0|						MatchRule(tr, &p2, p_start, 2, tr->groups2[g], &match2, word_flags, dict_flags0);
 2283|      0|						if (match2.points > 0)
 2284|      0|							match2.points += 35; // to acount for 2 letters matching
 2285|      0|
 2286|      0|						// now see whether single letter chain gives a better match ?
 2287|      0|						MatchRule(tr, &p, p_start, 1, tr->groups1[c], &match1, word_flags, dict_flags0);
 2288|      0|
 2289|      0|						if (match2.points >= match1.points) {
 2290|      0|							// use match from the 2-letter group
 2291|      0|							memcpy(&match1, &match2, sizeof(MatchRecord));
 2292|      0|							p = p2;
 2293|      0|						}
 2294|      0|					}
 2295|      0|				}
 2296|      0|			}
 2297|      0|
 2298|      0|			if (!found) {
 2299|      0|				// alphabetic, single letter chain
 2300|      0|				if (tr->groups1[c] != NULL)
 2301|      0|					MatchRule(tr, &p, p_start, 1, tr->groups1[c], &match1, word_flags, dict_flags0);
 2302|      0|				else {
 2303|      0|					// no group for this letter, use default group
 2304|      0|					MatchRule(tr, &p, p_start, 0, tr->groups1[0], &match1, word_flags, dict_flags0);
 2305|      0|
 2306|      0|					if ((match1.points == 0) && ((option_sayas & 0x10) == 0)) {
 2307|      0|						n = utf8_in(&letter, p-1)-1;
 2308|      0|
 2309|      0|						if (tr->letter_bits_offset > 0) {
 2310|      0|							// not a Latin alphabet, switch to the default Latin alphabet language
 2311|      0|							if ((letter <= 0x241) && iswalpha(letter)) {
 2312|      0|								sprintf(phonemes, "%cen", phonSWITCH);
 2313|      0|								return 0;
 2314|      0|							}
 2315|      0|						}
 2316|      0|
 2317|      0|						// is it a bracket ?
 2318|      0|						if (letter == 0xe000+'(') {
 2319|      0|							if (pre_pause < tr->langopts.param[LOPT_BRACKET_PAUSE_ANNOUNCED])
 2320|      0|								pre_pause = tr->langopts.param[LOPT_BRACKET_PAUSE_ANNOUNCED]; // a bracket, already spoken by AnnouncePunctuation()
 2321|      0|						} 
 2322|      0|						if (IsBracket(letter)) {
 2323|      0|							if (pre_pause < tr->langopts.param[LOPT_BRACKET_PAUSE])
 2324|      0|								pre_pause = tr->langopts.param[LOPT_BRACKET_PAUSE];
 2325|      0|						}
 2326|      0|
 2327|      0|						// no match, try removing the accent and re-translating the word
 2328|      0|						if ((letter >= 0xc0) && (letter < N_REMOVE_ACCENT) && ((ix = remove_accent[letter-0xc0]) != 0)) {
 2329|      0|							// within range of the remove_accent table
 2330|      0|							if ((p[-2] != ' ') || (p[n] != ' ')) {
 2331|      0|								// not the only letter in the word
 2332|      0|								p2 = p-1;
 2333|      0|								p[-1] = ix;
 2334|      0|								while ((p[0] = p[n]) != ' ')  p++;
 2335|      0|								while (n-- > 0) *p++ = ' '; // replacement character must be no longer than original
 2336|      0|
 2337|      0|								if (tr->langopts.param[LOPT_DIERESES] && (lookupwchar(diereses_list, letter) > 0)) {
 2338|      0|									// vowel with dieresis, replace and continue from this point
 2339|      0|									p = p2;
 2340|      0|									continue;
 2341|      0|								}
 2342|      0|
 2343|      0|								phonemes[0] = 0; // delete any phonemes which have been produced so far
 2344|      0|								p = p_start;
 2345|      0|								tr->word_vowel_count = 0;
 2346|      0|								tr->word_stressed_count = 0;
 2347|      0|								continue; // start again at the beginning of the word
 2348|      0|							}
 2349|      0|						}
 2350|      0|
 2351|      0|						if (((alphabet = AlphabetFromChar(letter)) != NULL)  && (alphabet->offset != tr->letter_bits_offset)) {
 2352|      0|							if (tr->langopts.alt_alphabet == alphabet->offset) {
 2353|      0|								sprintf(phonemes, "%c%s", phonSWITCH, WordToString2(tr->langopts.alt_alphabet_lang));
 2354|      0|								return 0;
 2355|      0|							}
 2356|      0|							if (alphabet->flags & AL_WORDS) {
 2357|      0|								// switch to the nominated language for this alphabet
 2358|      0|								sprintf(phonemes, "%c%s", phonSWITCH, WordToString2(alphabet->language));
 2359|      0|								return 0;
 2360|      0|							}
 2361|      0|						}
 2362|      0|					}
 2363|      0|				}
 2364|      0|
 2365|      0|				if (match1.points == 0) {
 2366|      0|					if ((wc >= 0x300) && (wc <= 0x36f)) {
 2367|      0|						// combining accent inside a word, ignore
 2368|      0|					} else if (IsAlpha(wc)) {
 2369|      0|						if ((any_alpha > 1) || (p[wc_bytes-1] > ' ')) {
 2370|      0|							// an unrecognised character in a word, abort and then spell the word
 2371|      0|							phonemes[0] = 0;
 2372|      0|							if (dict_flags != NULL)
 2373|      0|								dict_flags[0] |= FLAG_SPELLWORD;
 2374|      0|							break;
 2375|      0|						}
 2376|      0|					} else {
 2377|      0|						LookupLetter(tr, wc, -1, ph_buf, 0);
 2378|      0|						if (ph_buf[0]) {
 2379|      0|							match1.phonemes = ph_buf;
 2380|      0|							match1.points = 1;
 2381|      0|						}
 2382|      0|					}
 2383|      0|					p += (wc_bytes-1);
 2384|      0|				} else
 2385|      0|					tr->phonemes_repeat_count = 0;
 2386|      0|			}
 2387|      0|		}
 2388|      0|
 2389|      0|		if (match1.phonemes == NULL)
 2390|      0|			match1.phonemes = "";
 2391|      0|
 2392|      0|		if (match1.points > 0) {
 2393|      0|			if (word_flags & FLAG_UNPRON_TEST)
 2394|      0|				return match1.end_type | 1;
 2395|      0|
 2396|      0|			if ((match1.phonemes[0] == phonSWITCH) && ((word_flags & FLAG_DONT_SWITCH_TRANSLATOR) == 0)) {
 2397|      0|				// an instruction to switch language, return immediately so we can re-translate
 2398|      0|				strcpy(phonemes, match1.phonemes);
 2399|      0|				return 0;
 2400|      0|			}
 2401|      0|
 2402|      0|			if ((option_phonemes & espeakPHONEMES_TRACE) && ((word_flags & FLAG_NO_TRACE) == 0))
 2403|      0|				fprintf(f_trans, "\n");
 2404|      0|
 2405|      0|			match1.end_type &= ~SUFX_UNPRON;
 2406|      0|
 2407|      0|			if ((match1.end_type != 0) && (end_phonemes != NULL)) {
 2408|      0|				// a standard ending has been found, re-translate the word without it
 2409|      0|				if ((match1.end_type & SUFX_P) && (word_flags & FLAG_NO_PREFIX)) {
 2410|      0|					// ignore the match on a prefix
 2411|      0|				} else {
 2412|      0|					if ((match1.end_type & SUFX_P) && ((match1.end_type & 0x7f) == 0)) {
 2413|      0|						// no prefix length specified
 2414|      0|						match1.end_type |= p - p_start;
 2415|      0|					}
 2416|      0|					strcpy(end_phonemes, match1.phonemes);
 2417|      0|					memcpy(p_start, word_copy, strlen(word_copy));
 2418|      0|					return match1.end_type;
 2419|      0|				}
 2420|      0|			}
 2421|      0|			if (match1.del_fwd != NULL)
 2422|      0|				*match1.del_fwd = REPLACED_E;
 2423|      0|			AppendPhonemes(tr, phonemes, ph_size, match1.phonemes);
 2424|      0|		}
 2425|      0|	}
 2426|      0|
 2427|      0|	memcpy(p_start, word_copy, strlen(word_copy));
 2428|      0|
 2429|      0|	return 0;
 2430|      0|}
 2431|       |
 2432|       |void ApplySpecialAttribute2(Translator *tr, char *phonemes, int dict_flags)
 2433|      0|{
 2434|      0|	// apply after the translation is complete
 2435|      0|
 2436|      0|	int ix;
 2437|      0|	int len;
 2438|      0|	char *p;
 2439|      0|
 2440|      0|	len = strlen(phonemes);
 2441|      0|
 2442|      0|	if (tr->langopts.param[LOPT_ALT] & 2) {
 2443|      0|		for (ix = 0; ix < (len-1); ix++) {
 2444|      0|			if (phonemes[ix] == phonSTRESS_P) {
 2445|      0|				p = &phonemes[ix+1];
 2446|      0|				if ((dict_flags & FLAG_ALT2_TRANS) != 0) {
 2447|      0|					if (*p == PhonemeCode('E'))
 2448|      0|						*p = PhonemeCode('e');
 2449|      0|					if (*p == PhonemeCode('O'))
 2450|      0|						*p = PhonemeCode('o');
 2451|      0|				} else {
 2452|      0|					if (*p == PhonemeCode('e'))
 2453|      0|						*p = PhonemeCode('E');
 2454|      0|					if (*p == PhonemeCode('o'))
 2455|      0|						*p = PhonemeCode('O');
 2456|      0|				}
 2457|      0|				break;
 2458|      0|			}
 2459|      0|		}
 2460|      0|	}
 2461|      0|}
 2462|       |
 2463|       |int TransposeAlphabet(Translator *tr, char *text)
 2464|      0|{
 2465|      0|	// transpose cyrillic alphabet (for example) into ascii (single byte) character codes
 2466|      0|	// return: number of bytes, bit 6: 1=used compression
 2467|      0|
 2468|      0|	int c;
 2469|      0|	int c2;
 2470|      0|	int ix;
 2471|      0|	int offset;
 2472|      0|	int min;
 2473|      0|	int max;
 2474|      0|	const char *map;
 2475|      0|	char *p = text;
 2476|      0|	char *p2;
 2477|      0|	bool all_alpha = true;
 2478|      0|	int bits;
 2479|      0|	int acc;
 2480|      0|	int pairs_start;
 2481|      0|	const short *pairs_list;
 2482|      0|	int bufix;
 2483|      0|	char buf[N_WORD_BYTES+1];
 2484|      0|
 2485|      0|	offset = tr->transpose_min - 1;
 2486|      0|	min = tr->transpose_min;
 2487|      0|	max = tr->transpose_max;
 2488|      0|	map = tr->transpose_map;
 2489|      0|
 2490|      0|	pairs_start = max - min + 2;
 2491|      0|
 2492|      0|	bufix = 0;
 2493|      0|	do {
 2494|      0|		p += utf8_in(&c, p);
 2495|      0|		if (c != 0) {
 2496|      0|			if ((c >= min) && (c <= max)) {
 2497|      0|				if (map == NULL)
 2498|      0|					buf[bufix++] = c - offset;
 2499|      0|				else {
 2500|      0|					// get the code from the transpose map
 2501|      0|					if (map[c - min] > 0)
 2502|      0|						buf[bufix++] = map[c - min];
 2503|      0|					else {
 2504|      0|						all_alpha = false;
 2505|      0|						break;
 2506|      0|					}
 2507|      0|				}
 2508|      0|			} else {
 2509|      0|				all_alpha = false;
 2510|      0|				break;
 2511|      0|			}
 2512|      0|		}
 2513|      0|	} while ((c != 0) && (bufix < N_WORD_BYTES));
 2514|      0|	buf[bufix] = 0;
 2515|      0|
 2516|      0|	if (all_alpha) {
 2517|      0|		// compress to 6 bits per character
 2518|      0|		acc = 0;
 2519|      0|		bits = 0;
 2520|      0|
 2521|      0|		p = buf;
 2522|      0|		p2 = buf;
 2523|      0|		while ((c = *p++) != 0) {
 2524|      0|			if ((pairs_list = tr->frequent_pairs) != NULL) {
 2525|      0|				c2 = c + (*p << 8);
 2526|      0|				for (ix = 0; c2 >= pairs_list[ix]; ix++) {
 2527|      0|					if (c2 == pairs_list[ix]) {
 2528|      0|						// found an encoding for a 2-character pair
 2529|      0|						c = ix + pairs_start; // 2-character codes start after the single letter codes
 2530|      0|						p++;
 2531|      0|						break;
 2532|      0|					}
 2533|      0|				}
 2534|      0|			}
 2535|      0|			acc = (acc << 6) + (c & 0x3f);
 2536|      0|			bits += 6;
 2537|      0|
 2538|      0|			if (bits >= 8) {
 2539|      0|				bits -= 8;
 2540|      0|				*p2++ = (acc >> bits);
 2541|      0|			}
 2542|      0|		}
 2543|      0|		if (bits > 0)
 2544|      0|			*p2++ = (acc << (8-bits));
 2545|      0|		*p2 = 0;
 2546|      0|		ix = p2 - buf;
 2547|      0|		memcpy(text, buf, ix);
 2548|      0|		return ix | 0x40; // bit 6 indicates compressed characters
 2549|      0|	}
 2550|      0|	return strlen(text);
 2551|      0|}
 2552|       |
 2553|       |/* Find an entry in the word_dict file for a specified word.
 2554|       |   Returns NULL if no match, else returns 'word_end'
 2555|       |
 2556|       |    word   zero terminated word to match
 2557|       |    word2  pointer to next word(s) in the input text (terminated by space)
 2558|       |
 2559|       |    flags:  returns dictionary flags which are associated with a matched word
 2560|       |
 2561|       |    end_flags:  indicates whether this is a retranslation after removing a suffix
 2562|       | */
 2563|       |static const char *LookupDict2(Translator *tr, const char *word, const char *word2,
 2564|       |                               char *phonetic, unsigned int *flags, int end_flags, WORD_TAB *wtab)
 2565|      0|{
 2566|      0|	char *p;
 2567|      0|	char *next;
 2568|      0|	int hash;
 2569|      0|	int phoneme_len;
 2570|      0|	int wlen;
 2571|      0|	unsigned char flag;
 2572|      0|	unsigned int dictionary_flags;
 2573|      0|	unsigned int dictionary_flags2;
 2574|      0|	int condition_failed = 0;
 2575|      0|	int n_chars;
 2576|      0|	int no_phonemes;
 2577|      0|	int skipwords;
 2578|      0|	int ix;
 2579|      0|	int c;
 2580|      0|	const char *word_end;
 2581|      0|	const char *word1;
 2582|      0|	int wflags = 0;
 2583|      0|	int lookup_symbol;
 2584|      0|	char word_buf[N_WORD_BYTES+1];
 2585|      0|	char dict_flags_buf[80];
 2586|      0|
 2587|      0|	if (wtab != NULL)
 2588|      0|		wflags = wtab->flags;
 2589|      0|
 2590|      0|	lookup_symbol = flags[1] & FLAG_LOOKUP_SYMBOL;
 2591|      0|	word1 = word;
 2592|      0|	if (tr->transpose_min > 0) {
 2593|      0|		strncpy0(word_buf, word, N_WORD_BYTES);
 2594|      0|		wlen = TransposeAlphabet(tr, word_buf); // bit 6 indicates compressed characters
 2595|      0|		word = word_buf;
 2596|      0|	} else
 2597|      0|		wlen = strlen(word);
 2598|      0|
 2599|      0|	hash = HashDictionary(word);
 2600|      0|	p = tr->dict_hashtab[hash];
 2601|      0|
 2602|      0|	if (p == NULL) {
 2603|      0|		if (flags != NULL)
 2604|      0|			*flags = 0;
 2605|      0|		return 0;
 2606|      0|	}
 2607|      0|
 2608|      0|	// Find the first entry in the list for this hash value which matches.
 2609|      0|	// This corresponds to the last matching entry in the *_list file.
 2610|      0|
 2611|      0|	while (*p != 0) {
 2612|      0|		next = p + (p[0] & 0xff);
 2613|      0|
 2614|      0|		if (((p[1] & 0x7f) != wlen) || (memcmp(word, &p[2], wlen & 0x3f) != 0)) {
 2615|      0|			// bit 6 of wlen indicates whether the word has been compressed; so we need to match on this also.
 2616|      0|			p = next;
 2617|      0|			continue;
 2618|      0|		}
 2619|      0|
 2620|      0|		// found matching entry. Decode the phonetic string
 2621|      0|		word_end = word2;
 2622|      0|
 2623|      0|		dictionary_flags = 0;
 2624|      0|		dictionary_flags2 = 0;
 2625|      0|		no_phonemes = p[1] & 0x80;
 2626|      0|
 2627|      0|		p += ((p[1] & 0x3f) + 2);
 2628|      0|
 2629|      0|		if (no_phonemes) {
 2630|      0|			phonetic[0] = 0;
 2631|      0|			phoneme_len = 0;
 2632|      0|		} else {
 2633|      0|			strcpy(phonetic, p);
 2634|      0|			phoneme_len = strlen(p);
 2635|      0|			p += (phoneme_len + 1);
 2636|      0|		}
 2637|      0|
 2638|      0|		while (p < next) {
 2639|      0|			// examine the flags which follow the phoneme string
 2640|      0|
 2641|      0|			flag = *p++;
 2642|      0|			if (flag >= 100) {
 2643|      0|				// conditional rule
 2644|      0|				if (flag >= 132) {
 2645|      0|					// fail if this condition is set
 2646|      0|					if ((tr->dict_condition & (1 << (flag-132))) != 0)
 2647|      0|						condition_failed = 1;
 2648|      0|				} else {
 2649|      0|					// allow only if this condition is set
 2650|      0|					if ((tr->dict_condition & (1 << (flag-100))) == 0)
 2651|      0|						condition_failed = 1;
 2652|      0|				}
 2653|      0|			} else if (flag > 80) {
 2654|      0|				// flags 81 to 90  match more than one word
 2655|      0|				// This comes after the other flags
 2656|      0|				n_chars = next - p;
 2657|      0|				skipwords = flag - 80;
 2658|      0|
 2659|      0|				// don't use the contraction if any of the words are emphasized
 2660|      0|				//  or has an embedded command, such as MARK
 2661|      0|				if (wtab != NULL) {
 2662|      0|					for (ix = 0; ix <= skipwords; ix++) {
 2663|      0|						if (wtab[ix].flags & FLAG_EMPHASIZED2)
 2664|      0|							condition_failed = 1;
 2665|      0|					}
 2666|      0|				}
 2667|      0|
 2668|      0|				if (memcmp(word2, p, n_chars) != 0)
 2669|      0|					condition_failed = 1;
 2670|      0|
 2671|      0|				if (condition_failed) {
 2672|      0|					p = next;
 2673|      0|					break;
 2674|      0|				}
 2675|      0|
 2676|      0|				dictionary_flags |= FLAG_SKIPWORDS;
 2677|      0|				dictionary_skipwords = skipwords;
 2678|      0|				p = next;
 2679|      0|				word_end = word2 + n_chars;
 2680|      0|			} else if (flag > 64) {
 2681|      0|				// stressed syllable information, put in bits 0-3
 2682|      0|				dictionary_flags = (dictionary_flags & ~0xf) | (flag & 0xf);
 2683|      0|				if ((flag & 0xc) == 0xc)
 2684|      0|					dictionary_flags |= FLAG_STRESS_END;
 2685|      0|			} else if (flag >= 32)
 2686|      0|				dictionary_flags2 |= (1L << (flag-32));
 2687|      0|			else
 2688|      0|				dictionary_flags |= (1L << flag);
 2689|      0|		}
 2690|      0|
 2691|      0|		if (condition_failed) {
 2692|      0|			condition_failed = 0;
 2693|      0|			continue;
 2694|      0|		}
 2695|      0|
 2696|      0|		if ((end_flags & FLAG_SUFX) == 0) {
 2697|      0|			// no suffix has been removed
 2698|      0|			if (dictionary_flags2 & FLAG_STEM)
 2699|      0|				continue; // this word must have a suffix
 2700|      0|		}
 2701|      0|
 2702|      0|		if ((end_flags & SUFX_P) && (dictionary_flags2 & (FLAG_ONLY | FLAG_ONLY_S)))
 2703|      0|			continue; // $only or $onlys, don't match if a prefix has been removed
 2704|      0|
 2705|      0|		if (end_flags & FLAG_SUFX) {
 2706|      0|			// a suffix was removed from the word
 2707|      0|			if (dictionary_flags2 & FLAG_ONLY)
 2708|      0|				continue; // no match if any suffix
 2709|      0|
 2710|      0|			if ((dictionary_flags2 & FLAG_ONLY_S) && ((end_flags & FLAG_SUFX_S) == 0)) {
 2711|      0|				// only a 's' suffix allowed, but the suffix wasn't 's'
 2712|      0|				continue;
 2713|      0|			}
 2714|      0|		}
 2715|      0|
 2716|      0|		if (dictionary_flags2 & FLAG_CAPITAL) {
 2717|      0|			if (!(wflags & FLAG_FIRST_UPPER))
 2718|      0|				continue;
 2719|      0|		}
 2720|      0|		if (dictionary_flags2 & FLAG_ALLCAPS) {
 2721|      0|			if (!(wflags & FLAG_ALL_UPPER))
 2722|      0|				continue;
 2723|      0|		}
 2724|      0|		if (dictionary_flags & FLAG_NEEDS_DOT) {
 2725|      0|			if (!(wflags & FLAG_HAS_DOT))
 2726|      0|				continue;
 2727|      0|		}
 2728|      0|
 2729|      0|		if ((dictionary_flags2 & FLAG_ATEND) && (word_end < translator->clause_end) && (lookup_symbol == 0)) {
 2730|      0|			// only use this pronunciation if it's the last word of the clause, or called from Lookup()
 2731|      0|			continue;
 2732|      0|		}
 2733|      0|
 2734|      0|		if ((dictionary_flags2 & FLAG_ATSTART) && !(wflags & FLAG_FIRST_WORD)) {
 2735|      0|			// only use this pronunciation if it's the first word of a clause
 2736|      0|			continue;
 2737|      0|		}
 2738|      0|
 2739|      0|		if ((dictionary_flags2 & FLAG_SENTENCE) && !(translator->clause_terminator & CLAUSE_TYPE_SENTENCE)) {
 2740|      0|			// only if this clause is a sentence , i.e. terminator is {. ? !} not {, : :}
 2741|      0|			continue;
 2742|      0|		}
 2743|      0|
 2744|      0|		if (dictionary_flags2 & FLAG_VERB) {
 2745|      0|			// this is a verb-form pronunciation
 2746|      0|
 2747|      0|			if (tr->expect_verb || (tr->expect_verb_s && (end_flags & FLAG_SUFX_S))) {
 2748|      0|				// OK, we are expecting a verb
 2749|      0|				if ((tr->translator_name == L('e', 'n')) && (tr->prev_dict_flags[0] & FLAG_ALT7_TRANS) && (end_flags & FLAG_SUFX_S)) {
 2750|      0|					// lang=en, don't use verb form after 'to' if the word has 's' suffix
 2751|      0|					continue;
 2752|      0|				}
 2753|      0|			} else {
 2754|      0|				// don't use the 'verb' pronunciation unless we are expecting a verb
 2755|      0|				continue;
 2756|      0|			}
 2757|      0|		}
 2758|      0|		if (dictionary_flags2 & FLAG_PAST) {
 2759|      0|			if (!tr->expect_past) {
 2760|      0|				// don't use the 'past' pronunciation unless we are expecting past tense
 2761|      0|				continue;
 2762|      0|			}
 2763|      0|		}
 2764|      0|		if (dictionary_flags2 & FLAG_NOUN) {
 2765|      0|			if ((!tr->expect_noun) || (end_flags & SUFX_V)) {
 2766|      0|				// don't use the 'noun' pronunciation unless we are expecting a noun
 2767|      0|				continue;
 2768|      0|			}
 2769|      0|		}
 2770|      0|		if (dictionary_flags2 & FLAG_NATIVE) {
 2771|      0|			if (tr != translator)
 2772|      0|				continue; // don't use if we've switched translators
 2773|      0|		}
 2774|      0|		if (dictionary_flags & FLAG_ALT2_TRANS) {
 2775|      0|			// language specific
 2776|      0|			if ((tr->translator_name == L('h', 'u')) && !(tr->prev_dict_flags[0] & FLAG_ALT_TRANS))
 2777|      0|				continue;
 2778|      0|		}
 2779|      0|
 2780|      0|		if (flags != NULL) {
 2781|      0|			flags[0] = dictionary_flags | FLAG_FOUND_ATTRIBUTES;
 2782|      0|			flags[1] = dictionary_flags2;
 2783|      0|		}
 2784|      0|
 2785|      0|		if (phoneme_len == 0) {
 2786|      0|			if (option_phonemes & espeakPHONEMES_TRACE) {
 2787|      0|				print_dictionary_flags(flags, dict_flags_buf, sizeof(dict_flags_buf));
 2788|      0|				fprintf(f_trans, "Flags:  %s  %s\n", word1, dict_flags_buf);
 2789|      0|			}
 2790|      0|			return 0; // no phoneme translation found here, only flags. So use rules
 2791|      0|		}
 2792|      0|
 2793|      0|		if (flags != NULL)
 2794|      0|			flags[0] |= FLAG_FOUND; // this flag indicates word was found in dictionary
 2795|      0|
 2796|      0|		if (option_phonemes & espeakPHONEMES_TRACE) {
 2797|      0|			char ph_decoded[N_WORD_PHONEMES];
 2798|      0|			bool textmode;
 2799|      0|
 2800|      0|			DecodePhonemes(phonetic, ph_decoded);
 2801|      0|
 2802|      0|			if ((dictionary_flags & FLAG_TEXTMODE) == 0)
 2803|      0|				textmode = false;
 2804|      0|			else
 2805|      0|				textmode = true;
 2806|      0|
 2807|      0|			if (textmode == translator->langopts.textmode) {
 2808|      0|				// only show this line if the word translates to phonemes, not replacement text
 2809|      0|				if ((dictionary_flags & FLAG_SKIPWORDS) && (wtab != NULL)) {
 2810|      0|					// matched more than one word
 2811|      0|					// (check for wtab prevents showing RULE_SPELLING byte when speaking individual letters)
 2812|      0|					memcpy(word_buf, word2, word_end-word2);
 2813|      0|					word_buf[word_end-word2-1] = 0;
 2814|      0|					fprintf(f_trans, "Found: '%s %s\n", word1, word_buf);
 2815|      0|				} else
 2816|      0|					fprintf(f_trans, "Found: '%s", word1);
 2817|      0|				print_dictionary_flags(flags, dict_flags_buf, sizeof(dict_flags_buf));
 2818|      0|				fprintf(f_trans, "' [%s]  %s\n", ph_decoded, dict_flags_buf);
 2819|      0|			}
 2820|      0|		}
 2821|      0|
 2822|      0|		ix = utf8_in(&c, word);
 2823|      0|		if (flags != NULL && (word[ix] == 0) && !IsAlpha(c))
 2824|      0|			flags[0] |= FLAG_MAX3;
 2825|      0|		return word_end;
 2826|      0|
 2827|      0|	}
 2828|      0|	return 0;
 2829|      0|}
 2830|       |
 2831|       |/* Lookup a specified word in the word dictionary.
 2832|       |   Returns phonetic data in 'phonetic' and bits in 'flags'
 2833|       |
 2834|       |   end_flags:  indicates if a suffix has been removed
 2835|       | */
 2836|       |int LookupDictList(Translator *tr, char **wordptr, char *ph_out, unsigned int *flags, int end_flags, WORD_TAB *wtab)
 2837|      0|{
 2838|      0|	int length;
 2839|      0|	const char *found;
 2840|      0|	const char *word1;
 2841|      0|	const char *word2;
 2842|      0|	unsigned char c;
 2843|      0|	int nbytes;
 2844|      0|	int len;
 2845|      0|	char word[N_WORD_BYTES];
 2846|      0|	static char word_replacement[N_WORD_BYTES];
 2847|      0|
 2848|      0|	length = 0;
 2849|      0|	word2 = word1 = *wordptr;
 2850|      0|
 2851|      0|	while ((word2[nbytes = utf8_nbytes(word2)] == ' ') && (word2[nbytes+1] == '.')) {
 2852|      0|		// look for an abbreviation of the form a.b.c
 2853|      0|		// try removing the spaces between the dots and looking for a match
 2854|      0|		memcpy(&word[length], word2, nbytes);
 2855|      0|		length += nbytes;
 2856|      0|		word[length++] = '.';
 2857|      0|		word2 += nbytes+3;
 2858|      0|	}
 2859|      0|	if (length > 0) {
 2860|      0|		// found an abbreviation containing dots
 2861|      0|		nbytes = 0;
 2862|      0|		while (((c = word2[nbytes]) != 0) && (c != ' '))
 2863|      0|			nbytes++;
 2864|      0|		memcpy(&word[length], word2, nbytes);
 2865|      0|		word[length+nbytes] = 0;
 2866|      0|		found =  LookupDict2(tr, word, word2, ph_out, flags, end_flags, wtab);
 2867|      0|		if (found) {
 2868|      0|			// set the skip words flag
 2869|      0|			flags[0] |= FLAG_SKIPWORDS;
 2870|      0|			dictionary_skipwords = length;
 2871|      0|			return 1;
 2872|      0|		}
 2873|      0|	}
 2874|      0|
 2875|      0|	for (length = 0; length < (N_WORD_BYTES-1); length++) {
 2876|      0|		if (((c = *word1++) == 0) || (c == ' '))
 2877|      0|			break;
 2878|      0|
 2879|      0|		if ((c == '.') && (length > 0) && (IsDigit09(word[length-1])))
 2880|      0|			break; // needed for lang=hu, eg. "december 2.-ig"
 2881|      0|
 2882|      0|		word[length] = c;
 2883|      0|	}
 2884|      0|	word[length] = 0;
 2885|      0|
 2886|      0|	found = LookupDict2(tr, word, word1, ph_out, flags, end_flags, wtab);
 2887|      0|
 2888|      0|	if (flags[0] & FLAG_MAX3) {
 2889|      0|		if (strcmp(ph_out, tr->phonemes_repeat) == 0) {
 2890|      0|			tr->phonemes_repeat_count++;
 2891|      0|			if (tr->phonemes_repeat_count > 3)
 2892|      0|				ph_out[0] = 0;
 2893|      0|		} else {
 2894|      0|			strncpy0(tr->phonemes_repeat, ph_out, sizeof(tr->phonemes_repeat));
 2895|      0|			tr->phonemes_repeat_count = 1;
 2896|      0|		}
 2897|      0|	} else
 2898|      0|		tr->phonemes_repeat_count = 0;
 2899|      0|
 2900|      0|	if ((found == 0) && (flags[1] & FLAG_ACCENT)) {
 2901|      0|		int letter;
 2902|      0|		word2 = word;
 2903|      0|		if (*word2 == '_') word2++;
 2904|      0|		len = utf8_in(&letter, word2);
 2905|      0|		LookupAccentedLetter(tr, letter, ph_out);
 2906|      0|		found = word2 + len;
 2907|      0|	}
 2908|      0|
 2909|      0|	if (found == 0 && length >= 2) {
 2910|      0|		ph_out[0] = 0;
 2911|      0|
 2912|      0|		// try modifications to find a recognised word
 2913|      0|
 2914|      0|		if ((end_flags & FLAG_SUFX_E_ADDED) && (word[length-1] == 'e')) {
 2915|      0|			// try removing an 'e' which has been added by RemoveEnding
 2916|      0|			word[length-1] = 0;
 2917|      0|			found = LookupDict2(tr, word, word1, ph_out, flags, end_flags, wtab);
 2918|      0|		} else if ((end_flags & SUFX_D) && (word[length-1] == word[length-2])) {
 2919|      0|			// try removing a double letter
 2920|      0|			word[length-1] = 0;
 2921|      0|			found = LookupDict2(tr, word, word1, ph_out, flags, end_flags, wtab);
 2922|      0|		}
 2923|      0|	}
 2924|      0|
 2925|      0|	if (found) {
 2926|      0|		// if textmode is the default, then words which have phonemes are marked.
 2927|      0|		if (tr->langopts.textmode)
 2928|      0|			*flags ^= FLAG_TEXTMODE;
 2929|      0|
 2930|      0|		if (*flags & FLAG_TEXTMODE) {
 2931|      0|			// the word translates to replacement text, not to phonemes
 2932|      0|
 2933|      0|			if (end_flags & FLAG_ALLOW_TEXTMODE) {
 2934|      0|				// only use replacement text if this is the original word, not if a prefix or suffix has been removed
 2935|      0|				word_replacement[0] = 0;
 2936|      0|				word_replacement[1] = ' ';
 2937|      0|				sprintf(&word_replacement[2], "%s ", ph_out); // replacement word, preceded by zerochar and space
 2938|      0|
 2939|      0|				word1 = *wordptr;
 2940|      0|				*wordptr = &word_replacement[2];
 2941|      0|
 2942|      0|				if (option_phonemes & espeakPHONEMES_TRACE) {
 2943|      0|					len = found - word1;
 2944|      0|					memcpy(word, word1, len); // include multiple matching words
 2945|      0|					word[len] = 0;
 2946|      0|					fprintf(f_trans, "Replace: %s  %s\n", word, *wordptr);
 2947|      0|				}
 2948|      0|			}
 2949|      0|
 2950|      0|			ph_out[0] = 0;
 2951|      0|			return 0;
 2952|      0|		}
 2953|      0|
 2954|      0|		return 1;
 2955|      0|	}
 2956|      0|
 2957|      0|	ph_out[0] = 0;
 2958|      0|	return 0;
 2959|      0|}
 2960|       |
 2961|       |extern char word_phonemes[N_WORD_PHONEMES]; // a word translated into phoneme codes
 2962|       |
 2963|       |int Lookup(Translator *tr, const char *word, char *ph_out)
 2964|      0|{
 2965|      0|	// Look up in *_list, returns dictionary flags[0] and phonemes
 2966|      0|
 2967|      0|	int flags0;
 2968|      0|	unsigned int flags[2];
 2969|      0|	int say_as;
 2970|      0|	char *word1 = (char *)word;
 2971|      0|	char text[80];
 2972|      0|
 2973|      0|	flags[0] = 0;
 2974|      0|	flags[1] = FLAG_LOOKUP_SYMBOL;
 2975|      0|	if ((flags0 = LookupDictList(tr, &word1, ph_out, flags, FLAG_ALLOW_TEXTMODE, NULL)) != 0)
 2976|      0|		flags0 = flags[0];
 2977|      0|
 2978|      0|	if (flags[0] & FLAG_TEXTMODE) {
 2979|      0|		say_as = option_sayas;
 2980|      0|		option_sayas = 0; // don't speak replacement word as letter names
 2981|      0|		// NOTE: TranslateRoman checks text[-2], so pad the start of text to prevent
 2982|      0|		// it reading data on the stack.
 2983|      0|		text[0] = ' ';
 2984|      0|		text[1] = ' ';
 2985|      0|		strncpy0(text+2, word1, sizeof(text)-2);
 2986|      0|		flags0 = TranslateWord(tr, text+2, NULL, NULL);
 2987|      0|		strcpy(ph_out, word_phonemes);
 2988|      0|		option_sayas = say_as;
 2989|      0|	}
 2990|      0|	return flags0;
 2991|      0|}
 2992|       |
 2993|       |int LookupFlags(Translator *tr, const char *word, unsigned int **flags_out)
 2994|      0|{
 2995|      0|	char buf[100];
 2996|      0|	static unsigned int flags[2];
 2997|      0|	char *word1 = (char *)word;
 2998|      0|
 2999|      0|	flags[0] = flags[1] = 0;
 3000|      0|	LookupDictList(tr, &word1, buf, flags, 0, NULL);
 3001|      0|	*flags_out = flags;
 3002|      0|	return flags[0];
 3003|      0|}
 3004|       |
 3005|       |int RemoveEnding(Translator *tr, char *word, int end_type, char *word_copy)
 3006|      0|{
 3007|      0|	/* Removes a standard suffix from a word, once it has been indicated by the dictionary rules.
 3008|      0|	   end_type: bits 0-6  number of letters
 3009|      0|	             bits 8-14  suffix flags
 3010|      0|
 3011|      0|	    word_copy: make a copy of the original word
 3012|      0|	    This routine is language specific.  In English it deals with reversing y->i and e-dropping
 3013|      0|	    that were done when the suffix was added to the original word.
 3014|      0|	 */
 3015|      0|
 3016|      0|	int i;
 3017|      0|	char *word_end;
 3018|      0|	int len_ending;
 3019|      0|	int end_flags;
 3020|      0|	const char *p;
 3021|      0|	int len;
 3022|      0|	char ending[50] = {0};
 3023|      0|
 3024|      0|	// these lists are language specific, but are only relevant if the 'e' suffix flag is used
 3025|      0|	static const char *add_e_exceptions[] = {
 3026|      0|		"ion", NULL
 3027|      0|	};
 3028|      0|
 3029|      0|	static const char *add_e_additions[] = {
 3030|      0|		"c", "rs", "ir", "ur", "ath", "ns", "u",
 3031|      0|		"spong", // sponge
 3032|      0|		"rang", // strange
 3033|      0|		"larg", // large
 3034|      0|		NULL
 3035|      0|	};
 3036|      0|
 3037|      0|	for (word_end = word; *word_end != ' '; word_end++) {
 3038|      0|		// replace discarded 'e's
 3039|      0|		if (*word_end == REPLACED_E)
 3040|      0|			*word_end = 'e';
 3041|      0|	}
 3042|      0|	i = word_end - word;
 3043|      0|
 3044|      0|	if (word_copy != NULL) {
 3045|      0|		memcpy(word_copy, word, i);
 3046|      0|		word_copy[i] = 0;
 3047|      0|	}
 3048|      0|
 3049|      0|	// look for multibyte characters to increase the number of bytes to remove
 3050|      0|	for (len_ending = i = (end_type & 0x3f); i > 0; i--) { // num.of characters of the suffix
 3051|      0|		word_end--;
 3052|      0|		while ((*word_end & 0xc0) == 0x80) {
 3053|      0|			word_end--; // for multibyte characters
 3054|      0|			len_ending++;
 3055|      0|		}
 3056|      0|	}
 3057|      0|
 3058|      0|	// remove bytes from the end of the word and replace them by spaces
 3059|      0|	for (i = 0; (i < len_ending) && (i < (int)sizeof(ending)-1); i++) {
 3060|      0|		ending[i] = word_end[i];
 3061|      0|		word_end[i] = ' ';
 3062|      0|	}
 3063|      0|	ending[i] = 0;
 3064|      0|	word_end--; // now pointing at last character of stem
 3065|      0|
 3066|      0|	end_flags = (end_type & 0xfff0) | FLAG_SUFX;
 3067|      0|
 3068|      0|	/* add an 'e' to the stem if appropriate,
 3069|      0|	    if  stem ends in vowel+consonant
 3070|      0|	    or  stem ends in 'c'  (add 'e' to soften it) */
 3071|      0|
 3072|      0|	if (end_type & SUFX_I) {
 3073|      0|		if (word_end[0] == 'i')
 3074|      0|			word_end[0] = 'y';
 3075|      0|	}
 3076|      0|
 3077|      0|	if (end_type & SUFX_E) {
 3078|      0|		if (tr->translator_name == L('n', 'l')) {
 3079|      0|			if (((word_end[0] & 0x80) == 0) && ((word_end[-1] & 0x80) == 0) && IsVowel(tr, word_end[-1]) && IsLetter(tr, word_end[0], LETTERGP_C) && !IsVowel(tr, word_end[-2])) {
 3080|      0|				// double the vowel before the (ascii) final consonant
 3081|      0|				word_end[1] = word_end[0];
 3082|      0|				word_end[0] = word_end[-1];
 3083|      0|				word_end[2] = ' ';
 3084|      0|			}
 3085|      0|		} else if (tr->translator_name == L('e', 'n')) {
 3086|      0|			// add 'e' to end of stem
 3087|      0|			if (IsLetter(tr, word_end[-1], LETTERGP_VOWEL2) && IsLetter(tr, word_end[0], 1)) {
 3088|      0|				// vowel(incl.'y') + hard.consonant
 3089|      0|
 3090|      0|				for (i = 0; (p = add_e_exceptions[i]) != NULL; i++) {
 3091|      0|					len = strlen(p);
 3092|      0|					if (memcmp(p, &word_end[1-len], len) == 0)
 3093|      0|						break;
 3094|      0|				}
 3095|      0|				if (p == NULL)
 3096|      0|					end_flags |= FLAG_SUFX_E_ADDED; // no exception found
 3097|      0|			} else {
 3098|      0|				for (i = 0; (p = add_e_additions[i]) != NULL; i++) {
 3099|      0|					len = strlen(p);
 3100|      0|					if (memcmp(p, &word_end[1-len], len) == 0) {
 3101|      0|						end_flags |= FLAG_SUFX_E_ADDED;
 3102|      0|						break;
 3103|      0|					}
 3104|      0|				}
 3105|      0|			}
 3106|      0|		} else if (tr->langopts.suffix_add_e != 0)
 3107|      0|			end_flags |= FLAG_SUFX_E_ADDED;
 3108|      0|
 3109|      0|		if (end_flags & FLAG_SUFX_E_ADDED) {
 3110|      0|			utf8_out(tr->langopts.suffix_add_e, &word_end[1]);
 3111|      0|
 3112|      0|			if (option_phonemes & espeakPHONEMES_TRACE)
 3113|      0|				fprintf(f_trans, "add e\n");
 3114|      0|		}
 3115|      0|	}
 3116|      0|
 3117|      0|	if ((end_type & SUFX_V) && (tr->expect_verb == 0))
 3118|      0|		tr->expect_verb = 1; // this suffix indicates the verb pronunciation
 3119|      0|
 3120|      0|
 3121|      0|	if ((strcmp(ending, "s") == 0) || (strcmp(ending, "es") == 0))
 3122|      0|		end_flags |= FLAG_SUFX_S;
 3123|      0|
 3124|      0|	if (ending[0] == '\'')
 3125|      0|		end_flags &= ~FLAG_SUFX; // don't consider 's as an added suffix
 3126|      0|
 3127|      0|	return end_flags;
 3128|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/encoding.c:
    1|       |/*
    2|       | * Copyright (C) 2017 Reece H. Dunn
    3|       | *
    4|       | * This program is free software; you can redistribute it and/or modify
    5|       | * it under the terms of the GNU General Public License as published by
    6|       | * the Free Software Foundation; either version 3 of the License, or
    7|       | * (at your option) any later version.
    8|       | *
    9|       | * This program is distributed in the hope that it will be useful,
   10|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   11|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   12|       | * GNU General Public License for more details.
   13|       | *
   14|       | * You should have received a copy of the GNU General Public License
   15|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   16|       | */
   17|       |
   18|       |#include "config.h"
   19|       |
   20|       |#include <string.h>
   21|       |#include <stdint.h>
   22|       |#include <stdlib.h>
   23|       |#include <wchar.h>
   24|       |
   25|       |#include <espeak-ng/espeak_ng.h>
   26|       |#include <espeak-ng/encoding.h>
   27|       |
   28|       |#include <espeak-ng/encoding.h>   // for espeak_ng_TEXT_DECODER, ESPEAKNG_EN...
   29|       |#include "espeak-ng/speak_lib.h"  // for espeakCHARS_16BIT, espeakCHARS_8BIT
   30|       |#include "mnemonics.h"               // for LookupMnem, MNEM_TAB
   31|       |#include "translate.h"            // for LEADING_2_BITS, UTF8_TAIL_BITS
   32|       |
   33|       |// http://www.iana.org/assignments/character-sets/character-sets.xhtml
   34|       |MNEM_TAB mnem_encoding[] = {
   35|       |	{ "ANSI_X3.4-1968",   ESPEAKNG_ENCODING_US_ASCII },
   36|       |	{ "ANSI_X3.4-1986",   ESPEAKNG_ENCODING_US_ASCII },
   37|       |	{ "ASMO-708",         ESPEAKNG_ENCODING_ISO_8859_6 },
   38|       |	{ "ECMA-114",         ESPEAKNG_ENCODING_ISO_8859_6 },
   39|       |	{ "ECMA-118",         ESPEAKNG_ENCODING_ISO_8859_7 },
   40|       |	{ "ELOT_928",         ESPEAKNG_ENCODING_ISO_8859_7 },
   41|       |	{ "IBM367",           ESPEAKNG_ENCODING_US_ASCII },
   42|       |	{ "IBM819",           ESPEAKNG_ENCODING_ISO_8859_1 },
   43|       |	{ "ISCII",            ESPEAKNG_ENCODING_ISCII },
   44|       |	{ "ISO_646.irv:1991", ESPEAKNG_ENCODING_US_ASCII },
   45|       |	{ "ISO_8859-1",       ESPEAKNG_ENCODING_ISO_8859_1 },
   46|       |	{ "ISO_8859-1:1987",  ESPEAKNG_ENCODING_ISO_8859_1 },
   47|       |	{ "ISO_8859-2",       ESPEAKNG_ENCODING_ISO_8859_2 },
   48|       |	{ "ISO_8859-2:1987",  ESPEAKNG_ENCODING_ISO_8859_2 },
   49|       |	{ "ISO_8859-3",       ESPEAKNG_ENCODING_ISO_8859_3 },
   50|       |	{ "ISO_8859-3:1988",  ESPEAKNG_ENCODING_ISO_8859_3 },
   51|       |	{ "ISO_8859-4",       ESPEAKNG_ENCODING_ISO_8859_4 },
   52|       |	{ "ISO_8859-4:1988",  ESPEAKNG_ENCODING_ISO_8859_4 },
   53|       |	{ "ISO_8859-5",       ESPEAKNG_ENCODING_ISO_8859_5 },
   54|       |	{ "ISO_8859-5:1988",  ESPEAKNG_ENCODING_ISO_8859_5 },
   55|       |	{ "ISO_8859-6",       ESPEAKNG_ENCODING_ISO_8859_6 },
   56|       |	{ "ISO_8859-6:1987",  ESPEAKNG_ENCODING_ISO_8859_6 },
   57|       |	{ "ISO_8859-7",       ESPEAKNG_ENCODING_ISO_8859_7 },
   58|       |	{ "ISO_8859-7:1987",  ESPEAKNG_ENCODING_ISO_8859_7 },
   59|       |	{ "ISO_8859-8",       ESPEAKNG_ENCODING_ISO_8859_8 },
   60|       |	{ "ISO_8859-8:1988",  ESPEAKNG_ENCODING_ISO_8859_8 },
   61|       |	{ "ISO_8859-9",       ESPEAKNG_ENCODING_ISO_8859_9 },
   62|       |	{ "ISO_8859-9:1989",  ESPEAKNG_ENCODING_ISO_8859_9 },
   63|       |	{ "ISO_8859-10",      ESPEAKNG_ENCODING_ISO_8859_10 },
   64|       |	{ "ISO_8859-10:1992", ESPEAKNG_ENCODING_ISO_8859_10 },
   65|       |	{ "ISO_8859-14",      ESPEAKNG_ENCODING_ISO_8859_14 },
   66|       |	{ "ISO_8859-14:1998", ESPEAKNG_ENCODING_ISO_8859_14 },
   67|       |	{ "ISO_8859-15",      ESPEAKNG_ENCODING_ISO_8859_15 },
   68|       |	{ "ISO_8859-16",      ESPEAKNG_ENCODING_ISO_8859_16 },
   69|       |	{ "ISO_8859-16:2001", ESPEAKNG_ENCODING_ISO_8859_16 },
   70|       |	{ "ISO646-US",        ESPEAKNG_ENCODING_US_ASCII },
   71|       |	{ "ISO-10646-UCS-2",  ESPEAKNG_ENCODING_ISO_10646_UCS_2 },
   72|       |	{ "ISO-8859-1",       ESPEAKNG_ENCODING_ISO_8859_1 },
   73|       |	{ "ISO-8859-2",       ESPEAKNG_ENCODING_ISO_8859_2 },
   74|       |	{ "ISO-8859-3",       ESPEAKNG_ENCODING_ISO_8859_3 },
   75|       |	{ "ISO-8859-4",       ESPEAKNG_ENCODING_ISO_8859_4 },
   76|       |	{ "ISO-8859-5",       ESPEAKNG_ENCODING_ISO_8859_5 },
   77|       |	{ "ISO-8859-6",       ESPEAKNG_ENCODING_ISO_8859_6 },
   78|       |	{ "ISO-8859-7",       ESPEAKNG_ENCODING_ISO_8859_7 },
   79|       |	{ "ISO-8859-8",       ESPEAKNG_ENCODING_ISO_8859_8 },
   80|       |	{ "ISO-8859-9",       ESPEAKNG_ENCODING_ISO_8859_9 },
   81|       |	{ "ISO-8859-10",      ESPEAKNG_ENCODING_ISO_8859_10 },
   82|       |	{ "ISO-8859-11",      ESPEAKNG_ENCODING_ISO_8859_11 },
   83|       |	{ "ISO-8859-13",      ESPEAKNG_ENCODING_ISO_8859_13 },
   84|       |	{ "ISO-8859-14",      ESPEAKNG_ENCODING_ISO_8859_14 },
   85|       |	{ "ISO-8859-15",      ESPEAKNG_ENCODING_ISO_8859_15 },
   86|       |	{ "ISO-8859-16",      ESPEAKNG_ENCODING_ISO_8859_16 },
   87|       |	{ "KOI8-R",           ESPEAKNG_ENCODING_KOI8_R },
   88|       |	{ "Latin-9",          ESPEAKNG_ENCODING_ISO_8859_15 },
   89|       |	{ "TIS-620",          ESPEAKNG_ENCODING_ISO_8859_11 },
   90|       |	{ "US-ASCII",         ESPEAKNG_ENCODING_US_ASCII },
   91|       |	{ "UTF-8",            ESPEAKNG_ENCODING_UTF_8 },
   92|       |	{ "cp367",            ESPEAKNG_ENCODING_US_ASCII },
   93|       |	{ "cp819",            ESPEAKNG_ENCODING_ISO_8859_1 },
   94|       |	{ "csASCII",          ESPEAKNG_ENCODING_US_ASCII },
   95|       |	{ "csISO885913",      ESPEAKNG_ENCODING_ISO_8859_13 },
   96|       |	{ "csISO885914",      ESPEAKNG_ENCODING_ISO_8859_14 },
   97|       |	{ "csISO885915",      ESPEAKNG_ENCODING_ISO_8859_15 },
   98|       |	{ "csISO885916",      ESPEAKNG_ENCODING_ISO_8859_16 },
   99|       |	{ "csISOLatin1",      ESPEAKNG_ENCODING_ISO_8859_1 },
  100|       |	{ "csISOLatin2",      ESPEAKNG_ENCODING_ISO_8859_2 },
  101|       |	{ "csISOLatin3",      ESPEAKNG_ENCODING_ISO_8859_3 },
  102|       |	{ "csISOLatin4",      ESPEAKNG_ENCODING_ISO_8859_4 },
  103|       |	{ "csISOLatin5",      ESPEAKNG_ENCODING_ISO_8859_9 },
  104|       |	{ "csISOLatin6",      ESPEAKNG_ENCODING_ISO_8859_10 },
  105|       |	{ "csISOLatinArabic", ESPEAKNG_ENCODING_ISO_8859_6 },
  106|       |	{ "csISOLatinCyrillic",ESPEAKNG_ENCODING_ISO_8859_5 },
  107|       |	{ "csISOLatinGreek",  ESPEAKNG_ENCODING_ISO_8859_7 },
  108|       |	{ "csISOLatinHebrew", ESPEAKNG_ENCODING_ISO_8859_8 },
  109|       |	{ "csKOI8R",          ESPEAKNG_ENCODING_KOI8_R },
  110|       |	{ "csTIS620",         ESPEAKNG_ENCODING_ISO_8859_11 },
  111|       |	{ "csUTF8",           ESPEAKNG_ENCODING_UTF_8 },
  112|       |	{ "csUnicode",        ESPEAKNG_ENCODING_ISO_10646_UCS_2 },
  113|       |	{ "arabic",           ESPEAKNG_ENCODING_ISO_8859_6 },
  114|       |	{ "cyrillic",         ESPEAKNG_ENCODING_ISO_8859_5 },
  115|       |	{ "greek",            ESPEAKNG_ENCODING_ISO_8859_7 },
  116|       |	{ "greek8",           ESPEAKNG_ENCODING_ISO_8859_7 },
  117|       |	{ "hebrew",           ESPEAKNG_ENCODING_ISO_8859_8 },
  118|       |	{ "iso-celtic",       ESPEAKNG_ENCODING_ISO_8859_14 },
  119|       |	{ "iso-ir-6",         ESPEAKNG_ENCODING_US_ASCII },
  120|       |	{ "iso-ir-100",       ESPEAKNG_ENCODING_ISO_8859_1 },
  121|       |	{ "iso-ir-101",       ESPEAKNG_ENCODING_ISO_8859_2 },
  122|       |	{ "iso-ir-109",       ESPEAKNG_ENCODING_ISO_8859_3 },
  123|       |	{ "iso-ir-110",       ESPEAKNG_ENCODING_ISO_8859_4 },
  124|       |	{ "iso-ir-126",       ESPEAKNG_ENCODING_ISO_8859_7 },
  125|       |	{ "iso-ir-127",       ESPEAKNG_ENCODING_ISO_8859_6 },
  126|       |	{ "iso-ir-138",       ESPEAKNG_ENCODING_ISO_8859_8 },
  127|       |	{ "iso-ir-144",       ESPEAKNG_ENCODING_ISO_8859_5 },
  128|       |	{ "iso-ir-148",       ESPEAKNG_ENCODING_ISO_8859_9 },
  129|       |	{ "iso-ir-157",       ESPEAKNG_ENCODING_ISO_8859_10 },
  130|       |	{ "iso-ir-199",       ESPEAKNG_ENCODING_ISO_8859_14 },
  131|       |	{ "iso-ir-226",       ESPEAKNG_ENCODING_ISO_8859_16 },
  132|       |	{ "latin1",           ESPEAKNG_ENCODING_ISO_8859_1 },
  133|       |	{ "latin2",           ESPEAKNG_ENCODING_ISO_8859_2 },
  134|       |	{ "latin3",           ESPEAKNG_ENCODING_ISO_8859_3 },
  135|       |	{ "latin4",           ESPEAKNG_ENCODING_ISO_8859_4 },
  136|       |	{ "latin5",           ESPEAKNG_ENCODING_ISO_8859_9 },
  137|       |	{ "latin6",           ESPEAKNG_ENCODING_ISO_8859_10 },
  138|       |	{ "latin8",           ESPEAKNG_ENCODING_ISO_8859_14 },
  139|       |	{ "latin10",          ESPEAKNG_ENCODING_ISO_8859_16 },
  140|       |	{ "l1",               ESPEAKNG_ENCODING_ISO_8859_1 },
  141|       |	{ "l2",               ESPEAKNG_ENCODING_ISO_8859_2 },
  142|       |	{ "l3",               ESPEAKNG_ENCODING_ISO_8859_3 },
  143|       |	{ "l4",               ESPEAKNG_ENCODING_ISO_8859_4 },
  144|       |	{ "l5",               ESPEAKNG_ENCODING_ISO_8859_9 },
  145|       |	{ "l6",               ESPEAKNG_ENCODING_ISO_8859_10 },
  146|       |	{ "l8",               ESPEAKNG_ENCODING_ISO_8859_14 },
  147|       |	{ "l10",              ESPEAKNG_ENCODING_ISO_8859_16 },
  148|       |	{ "us",               ESPEAKNG_ENCODING_US_ASCII },
  149|       |	{ NULL,               ESPEAKNG_ENCODING_UNKNOWN }
  150|       |};
  151|       |
  152|       |#pragma GCC visibility push(default)
  153|       |
  154|       |espeak_ng_ENCODING
  155|       |espeak_ng_EncodingFromName(const char *encoding)
  156|      0|{
  157|      0|	return LookupMnem(mnem_encoding, encoding);
  158|      0|}
  159|       |
  160|       |#pragma GCC visibility pop
  161|       |
  162|       |struct espeak_ng_TEXT_DECODER_
  163|       |{
  164|       |	const uint8_t *current;
  165|       |	const uint8_t *end;
  166|       |
  167|       |	uint32_t (*get)(espeak_ng_TEXT_DECODER *decoder);
  168|       |	const uint16_t *codepage;
  169|       |};
  170|       |
  171|       |// Reference: http://www.iana.org/go/rfc1345
  172|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-1.TXT
  173|       |static const uint16_t ISO_8859_1[0x80] = {
  174|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  175|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  176|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  177|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  178|       |	0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, // a0
  179|       |	0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af, // a8
  180|       |	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7, // b0
  181|       |	0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf, // b8
  182|       |	0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7, // c0
  183|       |	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, // c8
  184|       |	0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7, // d0
  185|       |	0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df, // d8
  186|       |	0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, // e0
  187|       |	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, // e8
  188|       |	0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7, // f0
  189|       |	0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff, // f8
  190|       |};
  191|       |
  192|       |// Reference: http://www.iana.org/go/rfc1345
  193|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-2.TXT
  194|       |static const uint16_t ISO_8859_2[0x80] = {
  195|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  196|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  197|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  198|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  199|       |	0x00a0, 0x0104, 0x02d8, 0x0141, 0x00a4, 0x013d, 0x015a, 0x00a7, // a0
  200|       |	0x00a8, 0x0160, 0x015e, 0x0164, 0x0179, 0x00ad, 0x017d, 0x017b, // a8
  201|       |	0x00b0, 0x0105, 0x02db, 0x0142, 0x00b4, 0x013e, 0x015b, 0x02c7, // b0
  202|       |	0x00b8, 0x0161, 0x015f, 0x0165, 0x017a, 0x02dd, 0x017e, 0x017c, // b8
  203|       |	0x0154, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0139, 0x0106, 0x00c7, // c0
  204|       |	0x010c, 0x00c9, 0x0118, 0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e, // c8
  205|       |	0x0110, 0x0143, 0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7, // d0
  206|       |	0x0158, 0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df, // d8
  207|       |	0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 0x00e7, // e0
  208|       |	0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 0x00ee, 0x010f, // e8
  209|       |	0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x00f7, // f0
  210|       |	0x0159, 0x016f, 0x00fa, 0x0171, 0x00fc, 0x00fd, 0x0163, 0x02d9, // f8
  211|       |};
  212|       |
  213|       |// Reference: http://www.iana.org/go/rfc1345
  214|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-3.TXT
  215|       |static const uint16_t ISO_8859_3[0x80] = {
  216|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  217|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  218|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  219|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  220|       |	0x00a0, 0x0126, 0x02d8, 0x00a3, 0x00a4, 0xfffd, 0x0124, 0x00a7, // a0
  221|       |	0x00a8, 0x0130, 0x015e, 0x011e, 0x0134, 0x00ad, 0xfffd, 0x017b, // a8
  222|       |	0x00b0, 0x0127, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x0125, 0x00b7, // b0
  223|       |	0x00b8, 0x0131, 0x015f, 0x011f, 0x0135, 0x00bd, 0xfffd, 0x017c, // b8
  224|       |	0x00c0, 0x00c1, 0x00c2, 0xfffd, 0x00c4, 0x010a, 0x0108, 0x00c7, // c0
  225|       |	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, // c8
  226|       |	0xfffd, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x0120, 0x00d6, 0x00d7, // d0
  227|       |	0x011c, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x016c, 0x015c, 0x00df, // d8
  228|       |	0x00e0, 0x00e1, 0x00e2, 0xfffd, 0x00e4, 0x010b, 0x0109, 0x00e7, // e0
  229|       |	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, // e8
  230|       |	0xfffd, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x0121, 0x00f6, 0x00f7, // f0
  231|       |	0x011d, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x016d, 0x015d, 0x02d9, // f8
  232|       |};
  233|       |
  234|       |// Reference: http://www.iana.org/go/rfc1345
  235|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-4.TXT
  236|       |static const uint16_t ISO_8859_4[0x80] = {
  237|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  238|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  239|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  240|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  241|       |	0x00a0, 0x0104, 0x0138, 0x0156, 0x00a4, 0x0128, 0x013b, 0x00a7, // a0
  242|       |	0x00a8, 0x0160, 0x0112, 0x0122, 0x0166, 0x00ad, 0x017d, 0x00af, // a8
  243|       |	0x00b0, 0x0105, 0x02db, 0x0157, 0x00b4, 0x0129, 0x013c, 0x02c7, // b0
  244|       |	0x00b8, 0x0161, 0x0113, 0x0123, 0x0167, 0x014a, 0x017e, 0x014b, // b8
  245|       |	0x0100, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x012e, // c0
  246|       |	0x010c, 0x00c9, 0x0118, 0x00cb, 0x0116, 0x00cd, 0x00ce, 0x012a, // c8
  247|       |	0x0110, 0x0145, 0x014c, 0x0136, 0x00d4, 0x00d5, 0x00d6, 0x00d7, // d0
  248|       |	0x00d8, 0x0172, 0x00da, 0x00db, 0x00dc, 0x0168, 0x016a, 0x00df, // d8
  249|       |	0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x012f, // e0
  250|       |	0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 0x00ee, 0x012b, // e8
  251|       |	0x0111, 0x0146, 0x014d, 0x0137, 0x00f4, 0x00f5, 0x00f6, 0x00f7, // f0
  252|       |	0x00f8, 0x0173, 0x00fa, 0x00fb, 0x00fc, 0x0169, 0x016b, 0x02d9, // f8
  253|       |};
  254|       |
  255|       |// Reference: http://www.iana.org/go/rfc1345
  256|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-5.TXT
  257|       |static const uint16_t ISO_8859_5[0x80] = {
  258|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  259|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  260|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  261|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  262|       |	0x00a0, 0x0401, 0x0402, 0x0403, 0x0404, 0x0405, 0x0406, 0x0407, // a0
  263|       |	0x0408, 0x0409, 0x040a, 0x040b, 0x040c, 0x00ad, 0x040e, 0x040f, // a8
  264|       |	0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, // b0
  265|       |	0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 0x041d, 0x041e, 0x041f, // b8
  266|       |	0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, // c0
  267|       |	0x0428, 0x0429, 0x042a, 0x042b, 0x042c, 0x042d, 0x042e, 0x042f, // c8
  268|       |	0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, // d0
  269|       |	0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e, 0x043f, // d8
  270|       |	0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, // e0
  271|       |	0x0448, 0x0449, 0x044a, 0x044b, 0x044c, 0x044d, 0x044e, 0x044f, // e8
  272|       |	0x2116, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457, // f0
  273|       |	0x0458, 0x0459, 0x045a, 0x045b, 0x045c, 0x00a7, 0x045e, 0x045f, // f8
  274|       |};
  275|       |
  276|       |// Reference: http://www.iana.org/go/rfc1345
  277|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-6.TXT
  278|       |static const uint16_t ISO_8859_6[0x80] = {
  279|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  280|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  281|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  282|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  283|       |	0x00a0, 0xfffd, 0xfffd, 0xfffd, 0x00a4, 0xfffd, 0xfffd, 0xfffd, // a0
  284|       |	0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x060c, 0x00ad, 0xfffd, 0xfffd, // a8
  285|       |	0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // b0
  286|       |	0xfffd, 0xfffd, 0xfffd, 0x061b, 0xfffd, 0xfffd, 0xfffd, 0x061f, // b8
  287|       |	0xfffd, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627, // c0
  288|       |	0x0628, 0x0629, 0x062a, 0x062b, 0x062c, 0x062d, 0x062e, 0x062f, // c8
  289|       |	0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x0637, // d0
  290|       |	0x0638, 0x0639, 0x063a, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // d8
  291|       |	0x0640, 0x0641, 0x0642, 0x0643, 0x0644, 0x0645, 0x0646, 0x0647, // e0
  292|       |	0x0648, 0x0649, 0x064a, 0x064b, 0x064c, 0x064d, 0x064e, 0x064f, // e8
  293|       |	0x0650, 0x0651, 0x0652, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // f0
  294|       |	0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // f8
  295|       |};
  296|       |
  297|       |// Reference: http://www.iana.org/go/rfc1345
  298|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-7.TXT
  299|       |static const uint16_t ISO_8859_7[0x80] = {
  300|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  301|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  302|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  303|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  304|       |	0x00a0, 0x2018, 0x2019, 0x00a3, 0x20ac, 0x20af, 0x00a6, 0x00a7, // a0
  305|       |	0x00a8, 0x00a9, 0x037a, 0x00ab, 0x00ac, 0x00ad, 0xfffd, 0x2015, // a8
  306|       |	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x0384, 0x0385, 0x0386, 0x00b7, // b0
  307|       |	0x0388, 0x0389, 0x038a, 0x00bb, 0x038c, 0x00bd, 0x038e, 0x038f, // b8
  308|       |	0x0390, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, // c0
  309|       |	0x0398, 0x0399, 0x039a, 0x039b, 0x039c, 0x039d, 0x039e, 0x039f, // c8
  310|       |	0x03a0, 0x03a1, 0xfffd, 0x03a3, 0x03a4, 0x03a5, 0x03a6, 0x03a7, // d0
  311|       |	0x03a8, 0x03a9, 0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03ae, 0x03af, // d8
  312|       |	0x03b0, 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 0x03b7, // e0
  313|       |	0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be, 0x03bf, // e8
  314|       |	0x03c0, 0x03c1, 0x03c2, 0x03c3, 0x03c4, 0x03c5, 0x03c6, 0x03c7, // f0
  315|       |	0x03c8, 0x03c9, 0x03ca, 0x03cb, 0x03cc, 0x03cd, 0x03ce, 0xfffd, // f8
  316|       |};
  317|       |
  318|       |// Reference: http://www.iana.org/go/rfc1345
  319|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-8.TXT
  320|       |static const uint16_t ISO_8859_8[0x80] = {
  321|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  322|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  323|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  324|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  325|       |	0x00a0, 0xfffd, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, // a0
  326|       |	0x00a8, 0x00a9, 0x00d7, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af, // a8
  327|       |	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7, // b0
  328|       |	0x00b8, 0x00b9, 0x00f7, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0xfffd, // b8
  329|       |	0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // c0
  330|       |	0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // c8
  331|       |	0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // d0
  332|       |	0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2017, // d8
  333|       |	0x05d0, 0x05d1, 0x05d2, 0x05d3, 0x05d4, 0x05d5, 0x05d6, 0x05d7, // e0
  334|       |	0x05d8, 0x05d9, 0x05da, 0x05db, 0x05dc, 0x05dd, 0x05de, 0x05df, // e8
  335|       |	0x05e0, 0x05e1, 0x05e2, 0x05e3, 0x05e4, 0x05e5, 0x05e6, 0x05e7, // f0
  336|       |	0x05e8, 0x05e9, 0x05ea, 0xfffd, 0xfffd, 0x200e, 0x200f, 0xfffd, // f8
  337|       |};
  338|       |
  339|       |// Reference: http://www.iana.org/go/rfc1345
  340|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-9.TXT
  341|       |static const uint16_t ISO_8859_9[0x80] = {
  342|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  343|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  344|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  345|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  346|       |	0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, // a0
  347|       |	0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af, // a8
  348|       |	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7, // b0
  349|       |	0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf, // b8
  350|       |	0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7, // c0
  351|       |	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, // c8
  352|       |	0x011e, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7, // d0
  353|       |	0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x0130, 0x015e, 0x00df, // d8
  354|       |	0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, // e0
  355|       |	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, // e8
  356|       |	0x011f, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7, // f0
  357|       |	0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x0131, 0x015f, 0x00ff, // f8
  358|       |};
  359|       |
  360|       |// Reference: http://www.iana.org/go/rfc1345
  361|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-10.TXT
  362|       |static const uint16_t ISO_8859_10[0x80] = {
  363|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  364|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  365|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  366|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  367|       |	0x00a0, 0x0104, 0x0112, 0x0122, 0x012a, 0x0128, 0x0136, 0x00a7, // a0
  368|       |	0x013b, 0x0110, 0x0160, 0x0166, 0x017d, 0x00ad, 0x016a, 0x014a, // a8
  369|       |	0x00b0, 0x0105, 0x0113, 0x0123, 0x012b, 0x0129, 0x0137, 0x00b7, // b0
  370|       |	0x013c, 0x0111, 0x0161, 0x0167, 0x017e, 0x2015, 0x016b, 0x014b, // b8
  371|       |	0x0100, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x012e, // c0
  372|       |	0x010c, 0x00c9, 0x0118, 0x00cb, 0x0116, 0x00cd, 0x00ce, 0x00cf, // c8
  373|       |	0x00d0, 0x0145, 0x014c, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x0168, // d0
  374|       |	0x00d8, 0x0172, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df, // d8
  375|       |	0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x012f, // e0
  376|       |	0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 0x00ee, 0x00ef, // e8
  377|       |	0x00f0, 0x0146, 0x014d, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x0169, // f0
  378|       |	0x00f8, 0x0173, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x0138, // f8
  379|       |};
  380|       |
  381|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-11.TXT
  382|       |static const uint16_t ISO_8859_11[0x80] = {
  383|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  384|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  385|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  386|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  387|       |	0x00a0, 0x0e01, 0x0e02, 0x0e03, 0x0e04, 0x0e05, 0x0e06, 0x0e07, // a0
  388|       |	0x0e08, 0x0e09, 0x0e0a, 0x0e0b, 0x0e0c, 0x0e0d, 0x0e0e, 0x0e0f, // a8
  389|       |	0x0e10, 0x0e11, 0x0e12, 0x0e13, 0x0e14, 0x0e15, 0x0e16, 0x0e17, // b0
  390|       |	0x0e18, 0x0e19, 0x0e1a, 0x0e1b, 0x0e1c, 0x0e1d, 0x0e1e, 0x0e1f, // b8
  391|       |	0x0e20, 0x0e21, 0x0e22, 0x0e23, 0x0e24, 0x0e25, 0x0e26, 0x0e27, // c0
  392|       |	0x0e28, 0x0e29, 0x0e2a, 0x0e2b, 0x0e2c, 0x0e2d, 0x0e2e, 0x0e2f, // c8
  393|       |	0x0e30, 0x0e31, 0x0e32, 0x0e33, 0x0e34, 0x0e35, 0x0e36, 0x0e37, // d0
  394|       |	0x0e38, 0x0e39, 0x0e3a, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x0e3f, // d8
  395|       |	0x0e40, 0x0e41, 0x0e42, 0x0e43, 0x0e44, 0x0e45, 0x0e46, 0x0e47, // e0
  396|       |	0x0e48, 0x0e49, 0x0e4a, 0x0e4b, 0x0e4c, 0x0e4d, 0x0e4e, 0x0e4f, // e8
  397|       |	0x0e50, 0x0e51, 0x0e52, 0x0e53, 0x0e54, 0x0e55, 0x0e56, 0x0e57, // f0
  398|       |	0x0e58, 0x0e59, 0x0e5a, 0x0e5b, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // f8
  399|       |};
  400|       |
  401|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-13.TXT
  402|       |static const uint16_t ISO_8859_13[0x80] = {
  403|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  404|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  405|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  406|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  407|       |	0x00a0, 0x201d, 0x00a2, 0x00a3, 0x00a4, 0x201e, 0x00a6, 0x00a7, // a0
  408|       |	0x00d8, 0x00a9, 0x0156, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00c6, // a8
  409|       |	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x201c, 0x00b5, 0x00b6, 0x00b7, // b0
  410|       |	0x00f8, 0x00b9, 0x0157, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00e6, // b8
  411|       |	0x0104, 0x012e, 0x0100, 0x0106, 0x00c4, 0x00c5, 0x0118, 0x0112, // c0
  412|       |	0x010c, 0x00c9, 0x0179, 0x0116, 0x0122, 0x0136, 0x012a, 0x013b, // c8
  413|       |	0x0160, 0x0143, 0x0145, 0x00d3, 0x014c, 0x00d5, 0x00d6, 0x00d7, // d0
  414|       |	0x0172, 0x0141, 0x015a, 0x016a, 0x00dc, 0x017b, 0x017d, 0x00df, // d8
  415|       |	0x0105, 0x012f, 0x0101, 0x0107, 0x00e4, 0x00e5, 0x0119, 0x0113, // e0
  416|       |	0x010d, 0x00e9, 0x017a, 0x0117, 0x0123, 0x0137, 0x012b, 0x013c, // e8
  417|       |	0x0161, 0x0144, 0x0146, 0x00f3, 0x014d, 0x00f5, 0x00f6, 0x00f7, // f0
  418|       |	0x0173, 0x0142, 0x015b, 0x016b, 0x00fc, 0x017c, 0x017e, 0x2019, // f8
  419|       |};
  420|       |
  421|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-14.TXT
  422|       |static const uint16_t ISO_8859_14[0x80] = {
  423|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  424|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  425|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  426|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  427|       |	0x00a0, 0x1e02, 0x1e03, 0x00a3, 0x010a, 0x010b, 0x1e0a, 0x00a7, // a0
  428|       |	0x1e80, 0x00a9, 0x1e82, 0x1e0b, 0x1ef2, 0x00ad, 0x00ae, 0x0178, // a8
  429|       |	0x1e1e, 0x1e1f, 0x0120, 0x0121, 0x1e40, 0x1e41, 0x00b6, 0x1e56, // b0
  430|       |	0x1e81, 0x1e57, 0x1e83, 0x1e60, 0x1ef3, 0x1e84, 0x1e85, 0x1e61, // b8
  431|       |	0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7, // c0
  432|       |	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, // c8
  433|       |	0x0174, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x1e6a, // d0
  434|       |	0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x0176, 0x00df, // d8
  435|       |	0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, // e0
  436|       |	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, // e8
  437|       |	0x0175, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x1e6b, // f0
  438|       |	0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x0177, 0x00ff, // f8
  439|       |};
  440|       |
  441|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-15.TXT
  442|       |static const uint16_t ISO_8859_15[0x80] = {
  443|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  444|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  445|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  446|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  447|       |	0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x20ac, 0x00a5, 0x0160, 0x00a7, // a0
  448|       |	0x0161, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af, // a8
  449|       |	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x017d, 0x00b5, 0x00b6, 0x00b7, // b0
  450|       |	0x017e, 0x00b9, 0x00ba, 0x00bb, 0x0152, 0x0153, 0x0178, 0x00bf, // b8
  451|       |	0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7, // c0
  452|       |	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, // c8
  453|       |	0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7, // d0
  454|       |	0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df, // d8
  455|       |	0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, // e0
  456|       |	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, // e8
  457|       |	0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7, // f0
  458|       |	0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff, // f8
  459|       |};
  460|       |
  461|       |// Reference: http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-16.TXT
  462|       |static const uint16_t ISO_8859_16[0x80] = {
  463|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  464|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  465|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  466|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  467|       |	0x00a0, 0x0104, 0x0105, 0x0141, 0x20ac, 0x201e, 0x0160, 0x00a7, // a0
  468|       |	0x0161, 0x00a9, 0x0218, 0x00ab, 0x0179, 0x00ad, 0x017a, 0x017b, // a8
  469|       |	0x00b0, 0x00b1, 0x010c, 0x0142, 0x017d, 0x201d, 0x00b6, 0x00b7, // b0
  470|       |	0x017e, 0x010d, 0x0219, 0x00bb, 0x0152, 0x0153, 0x0178, 0x017c, // b8
  471|       |	0x00c0, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0106, 0x00c6, 0x00c7, // c0
  472|       |	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, // c8
  473|       |	0x0110, 0x0143, 0x00d2, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x015a, // d0
  474|       |	0x0170, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x0118, 0x021a, 0x00df, // d8
  475|       |	0x00e0, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x0107, 0x00e6, 0x00e7, // e0
  476|       |	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, // e8
  477|       |	0x0111, 0x0144, 0x00f2, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x015b, // f0
  478|       |	0x0171, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x0119, 0x021b, 0x00ff, // f8
  479|       |};
  480|       |
  481|       |// Reference: http://www.iana.org/go/rfc1489
  482|       |// Reference: http://www.unicode.org/Public/MAPPINGS/VENDORS/MISC/KOI8-R.TXT
  483|       |static const uint16_t KOI8_R[0x80] = {
  484|       |	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, // 80
  485|       |	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, // 88
  486|       |	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, // 90
  487|       |	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f, // 98
  488|       |	0x00a0, 0x0104, 0x0105, 0x0141, 0x20ac, 0x201e, 0x0160, 0x00a7, // a0
  489|       |	0x0161, 0x00a9, 0x0218, 0x00ab, 0x0179, 0x00ad, 0x017a, 0x017b, // a8
  490|       |	0x00b0, 0x00b1, 0x010c, 0x0142, 0x017d, 0x201d, 0x00b6, 0x00b7, // b0
  491|       |	0x017e, 0x010d, 0x0219, 0x00bb, 0x0152, 0x0153, 0x0178, 0x017c, // b8
  492|       |	0x00c0, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0106, 0x00c6, 0x00c7, // c0
  493|       |	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, // c8
  494|       |	0x0110, 0x0143, 0x00d2, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x015a, // d0
  495|       |	0x0170, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x0118, 0x021a, 0x00df, // d8
  496|       |	0x00e0, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x0107, 0x00e6, 0x00e7, // e0
  497|       |	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, // e8
  498|       |	0x0111, 0x0144, 0x00f2, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x015b, // f0
  499|       |	0x0171, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x0119, 0x021b, 0x00ff, // f8
  500|       |};
  501|       |
  502|       |// Reference: http://varamozhi.sourceforge.net/iscii91.pdf
  503|       |static const uint16_t ISCII[0x80] = {
  504|       |	0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // 80
  505|       |	0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // 88
  506|       |	0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // 90
  507|       |	0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // 98
  508|       |	0xfffd, 0x0901, 0x0902, 0x0903, 0x0905, 0x0906, 0x0907, 0x0908, // a0
  509|       |	0x0909, 0x090a, 0x090b, 0x090e, 0x090f, 0x0910, 0x090d, 0x0912, // a8
  510|       |	0x0913, 0x0914, 0x0911, 0x0915, 0x0916, 0x0917, 0x0918, 0x0919, // b0
  511|       |	0x091a, 0x091b, 0x091c, 0x091d, 0x091e, 0x091f, 0x0920, 0x0921, // b8
  512|       |	0x0922, 0x0923, 0x0924, 0x0925, 0x0926, 0x0927, 0x0928, 0x0929, // c0
  513|       |	0x092a, 0x092b, 0x092c, 0x092d, 0x092e, 0x092f, 0x095f, 0x0930, // c8
  514|       |	0x0931, 0x0932, 0x0933, 0x0934, 0x0935, 0x0936, 0x0937, 0x0938, // d0
  515|       |	0x0939, 0x0020, 0x093e, 0x093f, 0x0940, 0x0941, 0x0942, 0x0943, // d8
  516|       |	0x0946, 0x0947, 0x0948, 0x0945, 0x094a, 0x094b, 0x094c, 0x0949, // e0
  517|       |	0x094d, 0x093c, 0x0964, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // e8
  518|       |	0x0020, 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, // f0
  519|       |	0x0037, 0x0038, 0x0039, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, // f8
  520|       |};
  521|       |
  522|       |static uint32_t
  523|       |string_decoder_getc_us_ascii(espeak_ng_TEXT_DECODER *decoder)
  524|      0|{
  525|      0|	uint8_t c = *decoder->current++;
  526|      0|	return (c >= 0x80) ? 0xFFFD : c;
  527|      0|}
  528|       |
  529|       |static uint32_t
  530|       |string_decoder_getc_codepage(espeak_ng_TEXT_DECODER *decoder)
  531|      0|{
  532|      0|	uint8_t c = *decoder->current++;
  533|      0|	return (c >= 0x80) ? decoder->codepage[c - 0x80] : c;
  534|      0|}
  535|       |
  536|       |static uint32_t
  537|       |string_decoder_getc_utf_8(espeak_ng_TEXT_DECODER *decoder)
  538|      0|{
  539|      0|	uint8_t  c = *decoder->current++;
  540|      0|	uint32_t ret;
  541|      0|	switch (c & 0xF0)
  542|      0|	{
  543|      0|	// 1-byte UTF-8 sequence
  544|      0|	case 0x00: case 0x10: case 0x20: case 0x30:
  545|      0|	case 0x40: case 0x50: case 0x60: case 0x70:
  546|      0|		return c;
  547|      0|	// UTF-8 tail byte -- invalid in isolation
  548|      0|	case 0x80: case 0x90: case 0xA0: case 0xB0:
  549|      0|		return 0xFFFD;
  550|      0|	// 2-byte UTF-8 sequence
  551|      0|	case 0xC0: case 0xD0:
  552|      0|		if (decoder->current + 1 >= decoder->end) goto eof;
  553|      0|		ret = c & 0x1F;
  554|      0|		if (((c = *decoder->current++) & LEADING_2_BITS) != UTF8_TAIL_BITS) goto error;
  555|      0|		ret = (ret << 6) + (c & 0x3F);
  556|      0|		return ret;
  557|      0|	// 3-byte UTF-8 sequence
  558|      0|	case 0xE0:
  559|      0|		if (decoder->current + 2 >= decoder->end) goto eof;
  560|      0|		ret = c & 0x0F;
  561|      0|		if (((c = *decoder->current++) & LEADING_2_BITS) != UTF8_TAIL_BITS) goto error;
  562|      0|		ret = (ret << 6) + (c & 0x3F);
  563|      0|		if (((c = *decoder->current++) & LEADING_2_BITS) != UTF8_TAIL_BITS) goto error;
  564|      0|		ret = (ret << 6) + (c & 0x3F);
  565|      0|		return ret;
  566|      0|	// 4-byte UTF-8 sequence
  567|      0|	case 0xF0:
  568|      0|		if (decoder->current + 3 >= decoder->end) goto eof;
  569|      0|		ret = c & 0x0F;
  570|      0|		if (((c = *decoder->current++) & LEADING_2_BITS) != UTF8_TAIL_BITS) goto error;
  571|      0|		ret = (ret << 6) + (c & 0x3F);
  572|      0|		if (((c = *decoder->current++) & LEADING_2_BITS) != UTF8_TAIL_BITS) goto error;
  573|      0|		ret = (ret << 6) + (c & 0x3F);
  574|      0|		if (((c = *decoder->current++) & LEADING_2_BITS) != UTF8_TAIL_BITS) goto error;
  575|      0|		ret = (ret << 6) + (c & 0x3F);
  576|      0|		return (ret <= 0x10FFFF) ? ret : 0xFFFD;
  577|      0|	}
  578|      0|error:
  579|      0|	--decoder->current;
  580|      0|	return 0xFFFD;
  581|      0|eof:
  582|      0|	decoder->current = decoder->end;
  583|      0|	return 0xFFFD;
  584|      0|}
  585|       |
  586|       |static uint32_t
  587|       |string_decoder_getc_iso_10646_ucs_2(espeak_ng_TEXT_DECODER *decoder)
  588|      0|{
  589|      0|	if (decoder->current + 1 >= decoder->end) {
  590|      0|		decoder->current = decoder->end;
  591|      0|		return 0xFFFD;
  592|      0|	}
  593|      0|
  594|      0|	uint8_t c1 = *decoder->current++;
  595|      0|	uint8_t c2 = *decoder->current++;
  596|      0|	return c1 + (c2 << 8);
  597|      0|}
  598|       |
  599|       |static uint32_t
  600|       |string_decoder_getc_wchar(espeak_ng_TEXT_DECODER *decoder)
  601|      0|{
  602|      0|	wchar_t c = *(const wchar_t *)decoder->current;
  603|      0|	decoder->current += sizeof(wchar_t);
  604|      0|	return c;
  605|      0|}
  606|       |
  607|       |static uint32_t
  608|       |string_decoder_getc_auto(espeak_ng_TEXT_DECODER *decoder)
  609|      0|{
  610|      0|	const uint8_t *ptr = decoder->current;
  611|      0|	uint32_t c = string_decoder_getc_utf_8(decoder);
  612|      0|	if (c == 0xFFFD) {
  613|      0|		decoder->get = string_decoder_getc_codepage;
  614|      0|		decoder->current = ptr;
  615|      0|		c = decoder->get(decoder);
  616|      0|	}
  617|      0|	return c;
  618|      0|}
  619|       |
  620|       |static uint32_t
  621|       |null_decoder_getc(espeak_ng_TEXT_DECODER *decoder)
  622|      0|{
  623|      0|	(void)decoder; // unused parameter
  624|      0|	return 0;
  625|      0|}
  626|       |
  627|       |typedef struct
  628|       |{
  629|       |	uint32_t (*get)(espeak_ng_TEXT_DECODER *decoder);
  630|       |	const uint16_t *codepage;
  631|       |} encoding_t;
  632|       |
  633|       |static const encoding_t string_decoders[] = {
  634|       |	{ NULL, NULL },
  635|       |	{ string_decoder_getc_us_ascii, NULL },
  636|       |	{ string_decoder_getc_codepage, ISO_8859_1 },
  637|       |	{ string_decoder_getc_codepage, ISO_8859_2 },
  638|       |	{ string_decoder_getc_codepage, ISO_8859_3 },
  639|       |	{ string_decoder_getc_codepage, ISO_8859_4 },
  640|       |	{ string_decoder_getc_codepage, ISO_8859_5 },
  641|       |	{ string_decoder_getc_codepage, ISO_8859_6 },
  642|       |	{ string_decoder_getc_codepage, ISO_8859_7 },
  643|       |	{ string_decoder_getc_codepage, ISO_8859_8 },
  644|       |	{ string_decoder_getc_codepage, ISO_8859_9 },
  645|       |	{ string_decoder_getc_codepage, ISO_8859_10 },
  646|       |	{ string_decoder_getc_codepage, ISO_8859_11 },
  647|       |	// ISO-8859-12 is not a valid encoding.
  648|       |	{ string_decoder_getc_codepage, ISO_8859_13 },
  649|       |	{ string_decoder_getc_codepage, ISO_8859_14 },
  650|       |	{ string_decoder_getc_codepage, ISO_8859_15 },
  651|       |	{ string_decoder_getc_codepage, ISO_8859_16 },
  652|       |	{ string_decoder_getc_codepage, KOI8_R },
  653|       |	{ string_decoder_getc_codepage, ISCII },
  654|       |	{ string_decoder_getc_utf_8, NULL },
  655|       |	{ string_decoder_getc_iso_10646_ucs_2, NULL },
  656|       |};
  657|       |
  658|       |#pragma GCC visibility push(default)
  659|       |
  660|       |espeak_ng_TEXT_DECODER *
  661|       |create_text_decoder(void)
  662|      0|{
  663|      0|	espeak_ng_TEXT_DECODER *decoder = malloc(sizeof(espeak_ng_TEXT_DECODER));
  664|      0|	if (!decoder) return NULL;
  665|      0|
  666|      0|	decoder->current = NULL;
  667|      0|	decoder->end = NULL;
  668|      0|	decoder->get = NULL;
  669|      0|	decoder->codepage = NULL;
  670|      0|	return decoder;
  671|      0|}
  672|       |
  673|       |void
  674|       |destroy_text_decoder(espeak_ng_TEXT_DECODER *decoder)
  675|      0|{
  676|      0|	if (decoder) free(decoder);
  677|      0|}
  678|       |
  679|       |espeak_ng_STATUS
  680|       |text_decoder_decode_string(espeak_ng_TEXT_DECODER *decoder,
  681|       |                           const char *string,
  682|       |                           int length,
  683|       |                           espeak_ng_ENCODING encoding)
  684|      0|{
  685|      0|	if (encoding > ESPEAKNG_ENCODING_ISO_10646_UCS_2)
  686|      0|		return ENS_UNKNOWN_TEXT_ENCODING;
  687|      0|
  688|      0|	const encoding_t *enc = string_decoders + encoding;
  689|      0|	if (enc->get == NULL)
  690|      0|		return ENS_UNKNOWN_TEXT_ENCODING;
  691|      0|
  692|      0|	if (length < 0) length = string ? strlen(string) + 1 : 0;
  693|      0|
  694|      0|	decoder->get = string ? enc->get : null_decoder_getc;
  695|      0|	decoder->codepage = enc->codepage;
  696|      0|	decoder->current = (const uint8_t *)string;
  697|      0|	decoder->end = (const uint8_t *)(string ? string + length : string);
  698|      0|	return ENS_OK;
  699|      0|}
  700|       |
  701|       |espeak_ng_STATUS
  702|       |text_decoder_decode_string_auto(espeak_ng_TEXT_DECODER *decoder,
  703|       |                                const char *string,
  704|       |                                int length,
  705|       |                                espeak_ng_ENCODING encoding)
  706|      0|{
  707|      0|	if (encoding > ESPEAKNG_ENCODING_ISO_10646_UCS_2)
  708|      0|		return ENS_UNKNOWN_TEXT_ENCODING;
  709|      0|
  710|      0|	const encoding_t *enc = string_decoders + encoding;
  711|      0|	if (enc->get == NULL)
  712|      0|		return ENS_UNKNOWN_TEXT_ENCODING;
  713|      0|
  714|      0|	if (length < 0) length = string ? strlen(string) + 1 : 0;
  715|      0|
  716|      0|	decoder->get = string ? string_decoder_getc_auto : null_decoder_getc;
  717|      0|	decoder->codepage = enc->codepage;
  718|      0|	decoder->current = (const uint8_t *)string;
  719|      0|	decoder->end = (const uint8_t *)(string ? string + length : string);
  720|      0|	return ENS_OK;
  721|      0|}
  722|       |
  723|       |espeak_ng_STATUS
  724|       |text_decoder_decode_wstring(espeak_ng_TEXT_DECODER *decoder,
  725|       |                            const wchar_t *string,
  726|       |                            int length)
  727|      0|{
  728|      0|	if (length < 0) length = string ? wcslen(string) + 1 : 0;
  729|      0|
  730|      0|	decoder->get = string ? string_decoder_getc_wchar : null_decoder_getc;
  731|      0|	decoder->codepage = NULL;
  732|      0|	decoder->current = (const uint8_t *)string;
  733|      0|	decoder->end = (const uint8_t *)(string ? string + length : string);
  734|      0|	return ENS_OK;
  735|      0|}
  736|       |
  737|       |espeak_ng_STATUS
  738|       |text_decoder_decode_string_multibyte(espeak_ng_TEXT_DECODER *decoder,
  739|       |                                     const void *input,
  740|       |                                     espeak_ng_ENCODING encoding,
  741|       |                                     int flags)
  742|      0|{
  743|      0|	switch (flags & 7)
  744|      0|	{
  745|      0|	case espeakCHARS_WCHAR:
  746|      0|		return text_decoder_decode_wstring(decoder, (const wchar_t *)input, -1);
  747|      0|	case espeakCHARS_AUTO:
  748|      0|		return text_decoder_decode_string_auto(decoder, (const char *)input, -1, encoding);
  749|      0|	case espeakCHARS_UTF8:
  750|      0|		return text_decoder_decode_string(decoder, (const char *)input, -1, ESPEAKNG_ENCODING_UTF_8);
  751|      0|	case espeakCHARS_8BIT:
  752|      0|		return text_decoder_decode_string(decoder, (const char *)input, -1, encoding);
  753|      0|	case espeakCHARS_16BIT:
  754|      0|		return text_decoder_decode_string(decoder, (const char *)input, -1, ESPEAKNG_ENCODING_ISO_10646_UCS_2);
  755|      0|	default:
  756|      0|		return ENS_UNKNOWN_TEXT_ENCODING;
  757|      0|	}
  758|      0|}
  759|       |
  760|       |int
  761|       |text_decoder_eof(espeak_ng_TEXT_DECODER *decoder)
  762|      0|{
  763|      0|	return decoder->current == decoder->end;
  764|      0|}
  765|       |
  766|       |uint32_t
  767|       |text_decoder_getc(espeak_ng_TEXT_DECODER *decoder)
  768|      0|{
  769|      0|	return decoder->get(decoder);
  770|      0|}
  771|       |
  772|       |uint32_t
  773|       |text_decoder_peekc(espeak_ng_TEXT_DECODER *decoder)
  774|      0|{
  775|      0|	if (decoder->current == decoder->end) return 0;
  776|      0|
  777|      0|	const uint8_t *current = decoder->current;
  778|      0|	uint32_t c = decoder->get(decoder);
  779|      0|	decoder->current = current;
  780|      0|	return c;
  781|      0|}
  782|       |
  783|       |const void *
  784|       |text_decoder_get_buffer(espeak_ng_TEXT_DECODER *decoder)
  785|      0|{
  786|      0|	if (text_decoder_eof(decoder))
  787|      0|		return NULL;
  788|      0|	return decoder->current;
  789|      0|}
  790|       |
  791|       |#pragma GCC visibility pop

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/error.c:
    1|       |/* Error handling APIs.
    2|       | *
    3|       | * Copyright (C) 2016 Reece H. Dunn
    4|       | *
    5|       | * This program is free software; you can redistribute it and/or modify
    6|       | * it under the terms of the GNU General Public License as published by
    7|       | * the Free Software Foundation; either version 3 of the License, or
    8|       | * (at your option) any later version.
    9|       | *
   10|       | * This program is distributed in the hope that it will be useful,
   11|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   12|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   13|       | * GNU General Public License for more details.
   14|       | *
   15|       | * You should have received a copy of the GNU General Public License
   16|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   17|       | */
   18|       |
   19|       |#include "config.h"
   20|       |
   21|       |#include <errno.h>
   22|       |#include <stdint.h>
   23|       |#include <stdio.h>
   24|       |#include <stdlib.h>
   25|       |#include <string.h>
   26|       |
   27|       |#include <espeak-ng/espeak_ng.h>
   28|       |
   29|       |#include "error.h"
   30|       |#include "dictionary.h"           // for strncpy0
   31|       |
   32|       |espeak_ng_STATUS
   33|       |create_file_error_context(espeak_ng_ERROR_CONTEXT *context,
   34|       |                          espeak_ng_STATUS status,
   35|       |                          const char *filename)
   36|      0|{
   37|      0|	if (context) {
   38|      0|		if (*context) {
   39|      0|			free((*context)->name);
   40|      0|		} else {
   41|      0|			*context = malloc(sizeof(espeak_ng_ERROR_CONTEXT_));
   42|      0|			if (!*context)
   43|      0|				return ENOMEM;
   44|      0|		}
   45|      0|		(*context)->type = ERROR_CONTEXT_FILE;
   46|      0|		(*context)->name = strdup(filename);
   47|      0|		(*context)->version = 0;
   48|      0|		(*context)->expected_version = 0;
   49|      0|	}
   50|      0|	return status;
   51|      0|}
   52|       |
   53|       |espeak_ng_STATUS
   54|       |create_version_mismatch_error_context(espeak_ng_ERROR_CONTEXT *context,
   55|       |                                      const char *path_home,
   56|       |                                      int version,
   57|       |                                      int expected_version)
   58|      0|{
   59|      0|	if (context) {
   60|      0|		if (*context) {
   61|      0|			free((*context)->name);
   62|      0|		} else {
   63|      0|			*context = malloc(sizeof(espeak_ng_ERROR_CONTEXT_));
   64|      0|			if (!*context)
   65|      0|				return ENOMEM;
   66|      0|		}
   67|      0|		(*context)->type = ERROR_CONTEXT_VERSION;
   68|      0|		(*context)->name = strdup(path_home);
   69|      0|		(*context)->version = version;
   70|      0|		(*context)->expected_version = expected_version;
   71|      0|	}
   72|      0|	return ENS_VERSION_MISMATCH;
   73|      0|}
   74|       |
   75|       |#pragma GCC visibility push(default)
   76|       |
   77|       |ESPEAK_NG_API void
   78|       |espeak_ng_ClearErrorContext(espeak_ng_ERROR_CONTEXT *context)
   79|      0|{
   80|      0|	if (context && *context) {
   81|      0|		free((*context)->name);
   82|      0|		free(*context);
   83|      0|		*context = NULL;
   84|      0|	}
   85|      0|}
   86|       |
   87|       |ESPEAK_NG_API void
   88|       |espeak_ng_GetStatusCodeMessage(espeak_ng_STATUS status,
   89|       |                               char *buffer,
   90|       |                               size_t length)
   91|      0|{
   92|      0|	switch (status)
   93|      0|	{
   94|      0|	case ENS_COMPILE_ERROR:
   95|      0|		strncpy0(buffer, "Compile error", length);
   96|      0|		break;
   97|      0|	case ENS_VERSION_MISMATCH:
   98|      0|		strncpy0(buffer, "Wrong version of espeak-ng-data", length);
   99|      0|		break;
  100|      0|	case ENS_FIFO_BUFFER_FULL:
  101|      0|		strncpy0(buffer, "The FIFO buffer is full", length);
  102|      0|		break;
  103|      0|	case ENS_NOT_INITIALIZED:
  104|      0|		strncpy0(buffer, "The espeak-ng library has not been initialized", length);
  105|      0|		break;
  106|      0|	case ENS_AUDIO_ERROR:
  107|      0|		strncpy0(buffer, "Cannot initialize the audio device", length);
  108|      0|		break;
  109|      0|	case ENS_VOICE_NOT_FOUND:
  110|      0|		strncpy0(buffer, "The specified espeak-ng voice does not exist", length);
  111|      0|		break;
  112|      0|	case ENS_MBROLA_NOT_FOUND:
  113|      0|		strncpy0(buffer, "Could not load the mbrola.dll file", length);
  114|      0|		break;
  115|      0|	case ENS_MBROLA_VOICE_NOT_FOUND:
  116|      0|		strncpy0(buffer, "Could not load the specified mbrola voice file", length);
  117|      0|		break;
  118|      0|	case ENS_EVENT_BUFFER_FULL:
  119|      0|		strncpy0(buffer, "The event buffer is full", length);
  120|      0|		break;
  121|      0|	case ENS_NOT_SUPPORTED:
  122|      0|		strncpy0(buffer, "The requested functionality has not been built into espeak-ng", length);
  123|      0|		break;
  124|      0|	case ENS_UNSUPPORTED_PHON_FORMAT:
  125|      0|		strncpy0(buffer, "The phoneme file is not in a supported format", length);
  126|      0|		break;
  127|      0|	case ENS_NO_SPECT_FRAMES:
  128|      0|		strncpy0(buffer, "The spectral file does not contain any frame data", length);
  129|      0|		break;
  130|      0|	case ENS_EMPTY_PHONEME_MANIFEST:
  131|      0|		strncpy0(buffer, "The phoneme manifest file does not contain any phonemes", length);
  132|      0|		break;
  133|      0|	case ENS_UNKNOWN_PHONEME_FEATURE:
  134|      0|		strncpy0(buffer, "The phoneme feature is not recognised", length);
  135|      0|		break;
  136|      0|	case ENS_UNKNOWN_TEXT_ENCODING:
  137|      0|		strncpy0(buffer, "The text encoding is not supported", length);
  138|      0|		break;
  139|      0|	default:
  140|      0|		if ((status & ENS_GROUP_MASK) == ENS_GROUP_ERRNO)
  141|      0|			strerror_r(status, buffer, length);
  142|      0|		else
  143|      0|			snprintf(buffer, length, "Unspecified error 0x%x", status);
  144|      0|		break;
  145|      0|	}
  146|      0|}
  147|       |
  148|       |ESPEAK_NG_API void
  149|       |espeak_ng_PrintStatusCodeMessage(espeak_ng_STATUS status,
  150|       |                                 FILE *out,
  151|       |                                 espeak_ng_ERROR_CONTEXT context)
  152|      0|{
  153|      0|	char error[512];
  154|      0|	espeak_ng_GetStatusCodeMessage(status, error, sizeof(error));
  155|      0|	if (context) {
  156|      0|		switch (context->type)
  157|      0|		{
  158|      0|		case ERROR_CONTEXT_FILE:
  159|      0|			fprintf(out, "Error processing file '%s': %s.\n", context->name, error);
  160|      0|			break;
  161|      0|		case ERROR_CONTEXT_VERSION:
  162|      0|			fprintf(out, "Error: %s at '%s' (expected 0x%x, got 0x%x).\n",
  163|      0|			        error, context->name, context->expected_version, context->version);
  164|      0|			break;
  165|      0|		}
  166|      0|	} else
  167|      0|		fprintf(out, "Error: %s.\n", error);
  168|      0|}
  169|       |
  170|       |#pragma GCC visibility pop

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/espeak_api.c:
    1|       |/* An implementation of the eSpeak API using the espeak-ng API.
    2|       | *
    3|       | * Copyright (C) 2005 to 2013 by Jonathan Duddington
    4|       | * email: jonsd@users.sourceforge.net
    5|       | * Copyright (C) 2016 Reece H. Dunn
    6|       | *
    7|       | * This program is free software; you can redistribute it and/or modify
    8|       | * it under the terms of the GNU General Public License as published by
    9|       | * the Free Software Foundation; either version 3 of the License, or
   10|       | * (at your option) any later version.
   11|       | *
   12|       | * This program is distributed in the hope that it will be useful,
   13|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   14|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   15|       | * GNU General Public License for more details.
   16|       | *
   17|       | * You should have received a copy of the GNU General Public License
   18|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   19|       | */
   20|       |
   21|       |#include "config.h"
   22|       |
   23|       |#include <stdint.h>
   24|       |#include <stdlib.h>
   25|       |
   26|       |#include <espeak-ng/espeak_ng.h>
   27|       |#include <espeak-ng/speak_lib.h>
   28|       |#include <espeak-ng/encoding.h>
   29|       |
   30|       |#include "compiledict.h"
   31|       |
   32|       |#include "synthesize.h"           // for espeakINITIALIZE_PHONEME_IPA
   33|       |#include "translate.h"            // for dictionary_name, option_phoneme_events
   34|       |
   35|       |static espeak_ERROR status_to_espeak_error(espeak_ng_STATUS status)
   36|       |{
   37|       |	switch (status)
   38|       |	{
   39|       |	case ENS_OK:                     return EE_OK;
   40|       |	case ENS_SPEECH_STOPPED:         return EE_OK;
   41|       |	case ENS_VOICE_NOT_FOUND:        return EE_NOT_FOUND;
   42|       |	case ENS_MBROLA_NOT_FOUND:       return EE_NOT_FOUND;
   43|       |	case ENS_MBROLA_VOICE_NOT_FOUND: return EE_NOT_FOUND;
   44|       |	case ENS_FIFO_BUFFER_FULL:       return EE_BUFFER_FULL;
   45|       |	default:                         return EE_INTERNAL_ERROR;
   46|       |	}
   47|       |}
   48|       |
   49|       |#pragma GCC visibility push(default)
   50|       |
   51|       |ESPEAK_API int espeak_Initialize(espeak_AUDIO_OUTPUT output_type, int buf_length, const char *path, int options)
   52|      0|{
   53|      0|	espeak_ng_InitializePath(path);
   54|      0|	espeak_ng_ERROR_CONTEXT context = NULL;
   55|      0|	espeak_ng_STATUS result = espeak_ng_Initialize(&context);
   56|      0|	if (result != ENS_OK) {
   57|      0|		espeak_ng_PrintStatusCodeMessage(result, stderr, context);
   58|      0|		espeak_ng_ClearErrorContext(&context);
   59|      0|		if ((options & espeakINITIALIZE_DONT_EXIT) == 0)
   60|      0|			exit(1);
   61|      0|	}
   62|      0|
   63|      0|	switch (output_type)
   64|      0|	{
   65|      0|	case AUDIO_OUTPUT_PLAYBACK:
   66|      0|		espeak_ng_InitializeOutput(ENOUTPUT_MODE_SPEAK_AUDIO, buf_length, NULL);
   67|      0|		break;
   68|      0|	case AUDIO_OUTPUT_RETRIEVAL:
   69|      0|		espeak_ng_InitializeOutput(0, buf_length, NULL);
   70|      0|		break;
   71|      0|	case AUDIO_OUTPUT_SYNCHRONOUS:
   72|      0|		espeak_ng_InitializeOutput(ENOUTPUT_MODE_SYNCHRONOUS, buf_length, NULL);
   73|      0|		break;
   74|      0|	case AUDIO_OUTPUT_SYNCH_PLAYBACK:
   75|      0|		espeak_ng_InitializeOutput(ENOUTPUT_MODE_SYNCHRONOUS | ENOUTPUT_MODE_SPEAK_AUDIO, buf_length, NULL);
   76|      0|		break;
   77|      0|	}
   78|      0|
   79|      0|	option_phoneme_events = (options & (espeakINITIALIZE_PHONEME_EVENTS | espeakINITIALIZE_PHONEME_IPA));
   80|      0|
   81|      0|	return espeak_ng_GetSampleRate();
   82|      0|}
   83|       |
   84|       |ESPEAK_API espeak_ERROR espeak_Synth(const void *text, size_t size,
   85|       |                                     unsigned int position,
   86|       |                                     espeak_POSITION_TYPE position_type,
   87|       |                                     unsigned int end_position, unsigned int flags,
   88|       |                                     unsigned int *unique_identifier, void *user_data)
   89|      0|{
   90|      0|	return status_to_espeak_error(espeak_ng_Synthesize(text, size, position, position_type, end_position, flags, unique_identifier, user_data));
   91|      0|}
   92|       |
   93|       |ESPEAK_API espeak_ERROR espeak_Synth_Mark(const void *text, size_t size,
   94|       |                                          const char *index_mark,
   95|       |                                          unsigned int end_position,
   96|       |                                          unsigned int flags,
   97|       |                                          unsigned int *unique_identifier,
   98|       |                                          void *user_data)
   99|      0|{
  100|      0|	return status_to_espeak_error(espeak_ng_SynthesizeMark(text, size, index_mark, end_position, flags, unique_identifier, user_data));
  101|      0|}
  102|       |
  103|       |ESPEAK_API espeak_ERROR espeak_Key(const char *key_name)
  104|      0|{
  105|      0|	return status_to_espeak_error(espeak_ng_SpeakKeyName(key_name));
  106|      0|}
  107|       |
  108|       |ESPEAK_API espeak_ERROR espeak_Char(wchar_t character)
  109|      0|{
  110|      0|	return status_to_espeak_error(espeak_ng_SpeakCharacter(character));
  111|      0|}
  112|       |
  113|       |ESPEAK_API espeak_ERROR espeak_SetParameter(espeak_PARAMETER parameter, int value, int relative)
  114|      0|{
  115|      0|	return status_to_espeak_error(espeak_ng_SetParameter(parameter, value, relative));
  116|      0|}
  117|       |
  118|       |ESPEAK_API espeak_ERROR espeak_SetPunctuationList(const wchar_t *punctlist)
  119|      0|{
  120|      0|	return status_to_espeak_error(espeak_ng_SetPunctuationList(punctlist));
  121|      0|}
  122|       |
  123|       |ESPEAK_API espeak_ERROR espeak_SetVoiceByName(const char *name)
  124|      0|{
  125|      0|	return status_to_espeak_error(espeak_ng_SetVoiceByName(name));
  126|      0|}
  127|       |
  128|       |ESPEAK_API espeak_ERROR espeak_SetVoiceByFile(const char *filename)
  129|      0|{
  130|      0|	return status_to_espeak_error(espeak_ng_SetVoiceByFile(filename));
  131|      0|}
  132|       |
  133|       |ESPEAK_API espeak_ERROR espeak_SetVoiceByProperties(espeak_VOICE *voice_selector)
  134|      0|{
  135|      0|	return status_to_espeak_error(espeak_ng_SetVoiceByProperties(voice_selector));
  136|      0|}
  137|       |
  138|       |ESPEAK_API espeak_ERROR espeak_Cancel(void)
  139|      0|{
  140|      0|	return status_to_espeak_error(espeak_ng_Cancel());
  141|      0|}
  142|       |
  143|       |ESPEAK_API espeak_ERROR espeak_Synchronize(void)
  144|      0|{
  145|      0|	return status_to_espeak_error(espeak_ng_Synchronize());
  146|      0|}
  147|       |
  148|       |ESPEAK_API espeak_ERROR espeak_Terminate(void)
  149|      0|{
  150|      0|	return status_to_espeak_error(espeak_ng_Terminate());
  151|      0|}
  152|       |
  153|       |ESPEAK_API void espeak_CompileDictionary(const char *path, FILE *log, int flags)
  154|      0|{
  155|      0|	espeak_ng_ERROR_CONTEXT context = NULL;
  156|      0|	espeak_ng_STATUS result = espeak_ng_CompileDictionary(path, dictionary_name, log, flags, &context);
  157|      0|	if (result != ENS_OK) {
  158|      0|		espeak_ng_PrintStatusCodeMessage(result, stderr, context);
  159|      0|		espeak_ng_ClearErrorContext(&context);
  160|      0|	}
  161|      0|}
  162|       |
  163|       |#pragma GCC visibility pop

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/espeak_command.c:
    1|       |/*
    2|       | * Copyright (C) 2007, Gilles Casse <gcasse@oralux.org>
    3|       | * Copyright (C) 2013-2016 Reece H. Dunn
    4|       | *
    5|       | * This program is free software; you can redistribute it and/or modify
    6|       | * it under the terms of the GNU General Public License as published by
    7|       | * the Free Software Foundation; either version 3 of the License, or
    8|       | * (at your option) any later version.
    9|       | *
   10|       | * This program is distributed in the hope that it will be useful,
   11|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   12|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   13|       | * GNU General Public License for more details.
   14|       | *
   15|       | * You should have received a copy of the GNU General Public License
   16|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   17|       | */
   18|       |
   19|       |#include "config.h"
   20|       |
   21|       |#include <assert.h>
   22|       |#include <stdlib.h>
   23|       |#include <string.h>
   24|       |#include <wchar.h>
   25|       |
   26|       |#include <espeak-ng/espeak_ng.h>
   27|       |
   28|       |#include "espeak_command.h"
   29|       |
   30|       |#ifdef USE_ASYNC
   31|       |
   32|       |static unsigned int my_current_text_id = 0;
   33|       |
   34|       |t_espeak_command *create_espeak_text(const void *text, size_t size, unsigned int position, espeak_POSITION_TYPE position_type, unsigned int end_position, unsigned int flags, void *user_data)
   35|      0|{
   36|      0|	if (!text || !size)
   37|      0|		return NULL;
   38|      0|
   39|      0|	void *a_text = NULL;
   40|      0|	t_espeak_text *data = NULL;
   41|      0|
   42|      0|	t_espeak_command *a_command = (t_espeak_command *)malloc(sizeof(t_espeak_command));
   43|      0|	if (!a_command)
   44|      0|		return NULL;
   45|      0|
   46|      0|	a_text = malloc(size+1);
   47|      0|	if (!a_text) {
   48|      0|		free(a_command);
   49|      0|		return NULL;
   50|      0|	}
   51|      0|	memcpy(a_text, text, size);
   52|      0|
   53|      0|	a_command->type = ET_TEXT;
   54|      0|	a_command->state = CS_UNDEFINED;
   55|      0|	data = &(a_command->u.my_text);
   56|      0|	data->unique_identifier = ++my_current_text_id;
   57|      0|	data->text = a_text;
   58|      0|	data->position = position;
   59|      0|	data->position_type = position_type;
   60|      0|	data->end_position = end_position;
   61|      0|	data->flags = flags;
   62|      0|	data->user_data = user_data;
   63|      0|
   64|      0|	return a_command;
   65|      0|}
   66|       |
   67|       |t_espeak_command *create_espeak_terminated_msg(unsigned int unique_identifier, void *user_data)
   68|      0|{
   69|      0|	t_espeak_terminated_msg *data = NULL;
   70|      0|	t_espeak_command *a_command = (t_espeak_command *)malloc(sizeof(t_espeak_command));
   71|      0|	if (!a_command)
   72|      0|		return NULL;
   73|      0|
   74|      0|	a_command->type = ET_TERMINATED_MSG;
   75|      0|	a_command->state = CS_UNDEFINED;
   76|      0|	data = &(a_command->u.my_terminated_msg);
   77|      0|	data->unique_identifier = unique_identifier;
   78|      0|	data->user_data = user_data;
   79|      0|
   80|      0|	return a_command;
   81|      0|}
   82|       |
   83|       |t_espeak_command *create_espeak_mark(const void *text, size_t size, const char *index_mark, unsigned int end_position, unsigned int flags, void *user_data)
   84|      0|{
   85|      0|	if (!text || !size || !index_mark)
   86|      0|		return NULL;
   87|      0|
   88|      0|	void *a_text = NULL;
   89|      0|	char *a_index_mark = NULL;
   90|      0|	t_espeak_mark *data = NULL;
   91|      0|
   92|      0|	t_espeak_command *a_command = (t_espeak_command *)malloc(sizeof(t_espeak_command));
   93|      0|	if (!a_command)
   94|      0|		return NULL;
   95|      0|
   96|      0|	a_text = malloc(size);
   97|      0|	if (!a_text) {
   98|      0|		free(a_command);
   99|      0|		return NULL;
  100|      0|	}
  101|      0|	memcpy(a_text, text, size);
  102|      0|
  103|      0|	a_index_mark = strdup(index_mark);
  104|      0|
  105|      0|	a_command->type = ET_MARK;
  106|      0|	a_command->state = CS_UNDEFINED;
  107|      0|	data = &(a_command->u.my_mark);
  108|      0|	data->unique_identifier = ++my_current_text_id;
  109|      0|	data->text = a_text;
  110|      0|	data->index_mark = a_index_mark;
  111|      0|	data->end_position = end_position;
  112|      0|	data->flags = flags;
  113|      0|	data->user_data = user_data;
  114|      0|
  115|      0|	return a_command;
  116|      0|}
  117|       |
  118|       |t_espeak_command *create_espeak_key(const char *key_name, void *user_data)
  119|      0|{
  120|      0|	if (!key_name)
  121|      0|		return NULL;
  122|      0|
  123|      0|	t_espeak_command *a_command = (t_espeak_command *)malloc(sizeof(t_espeak_command));
  124|      0|	if (!a_command)
  125|      0|		return NULL;
  126|      0|
  127|      0|	a_command->type = ET_KEY;
  128|      0|	a_command->state = CS_UNDEFINED;
  129|      0|	a_command->u.my_key.user_data = user_data;
  130|      0|	a_command->u.my_key.unique_identifier = ++my_current_text_id;
  131|      0|	a_command->u.my_key.key_name = strdup(key_name);
  132|      0|
  133|      0|	return a_command;
  134|      0|}
  135|       |
  136|       |t_espeak_command *create_espeak_char(wchar_t character, void *user_data)
  137|      0|{
  138|      0|	t_espeak_command *a_command = (t_espeak_command *)malloc(sizeof(t_espeak_command));
  139|      0|	if (!a_command)
  140|      0|		return NULL;
  141|      0|
  142|      0|	a_command->type = ET_CHAR;
  143|      0|	a_command->state = CS_UNDEFINED;
  144|      0|	a_command->u.my_char.user_data = user_data;
  145|      0|	a_command->u.my_char.unique_identifier = ++my_current_text_id;
  146|      0|	a_command->u.my_char.character = character;
  147|      0|
  148|      0|	return a_command;
  149|      0|}
  150|       |
  151|       |t_espeak_command *create_espeak_parameter(espeak_PARAMETER parameter, int value, int relative)
  152|      0|{
  153|      0|	t_espeak_parameter *data = NULL;
  154|      0|
  155|      0|	t_espeak_command *a_command = (t_espeak_command *)malloc(sizeof(t_espeak_command));
  156|      0|	if (!a_command)
  157|      0|		return NULL;
  158|      0|
  159|      0|	a_command->type = ET_PARAMETER;
  160|      0|	a_command->state = CS_UNDEFINED;
  161|      0|	data = &(a_command->u.my_param);
  162|      0|	data->parameter = parameter;
  163|      0|	data->value = value;
  164|      0|	data->relative = relative;
  165|      0|
  166|      0|	return a_command;
  167|      0|}
  168|       |
  169|       |t_espeak_command *create_espeak_punctuation_list(const wchar_t *punctlist)
  170|      0|{
  171|      0|	if (!punctlist)
  172|      0|		return NULL;
  173|      0|
  174|      0|	t_espeak_command *a_command = (t_espeak_command *)malloc(sizeof(t_espeak_command));
  175|      0|	if (!a_command)
  176|      0|		return NULL;
  177|      0|
  178|      0|	a_command->type = ET_PUNCTUATION_LIST;
  179|      0|	a_command->state = CS_UNDEFINED;
  180|      0|
  181|      0|	size_t len = (wcslen(punctlist) + 1)*sizeof(wchar_t);
  182|      0|	wchar_t *a_list = (wchar_t *)malloc(len);
  183|      0|	if (a_list == NULL) {
  184|      0|		free(a_command);
  185|      0|		return NULL;
  186|      0|	}
  187|      0|	memcpy(a_list, punctlist, len);
  188|      0|	a_command->u.my_punctuation_list = a_list;
  189|      0|
  190|      0|	return a_command;
  191|      0|}
  192|       |
  193|       |t_espeak_command *create_espeak_voice_name(const char *name)
  194|      0|{
  195|      0|	if (!name)
  196|      0|		return NULL;
  197|      0|
  198|      0|	t_espeak_command *a_command = (t_espeak_command *)malloc(sizeof(t_espeak_command));
  199|      0|	if (!a_command)
  200|      0|		return NULL;
  201|      0|
  202|      0|	a_command->type = ET_VOICE_NAME;
  203|      0|	a_command->state = CS_UNDEFINED;
  204|      0|	a_command->u.my_voice_name = strdup(name);
  205|      0|
  206|      0|	return a_command;
  207|      0|}
  208|       |
  209|       |t_espeak_command *create_espeak_voice_spec(espeak_VOICE *voice)
  210|      0|{
  211|      0|	if (!voice)
  212|      0|		return NULL;
  213|      0|
  214|      0|	t_espeak_command *a_command = (t_espeak_command *)malloc(sizeof(t_espeak_command));
  215|      0|	if (!a_command)
  216|      0|		return NULL;
  217|      0|
  218|      0|	a_command->type = ET_VOICE_SPEC;
  219|      0|	a_command->state = CS_UNDEFINED;
  220|      0|
  221|      0|	espeak_VOICE *data = &(a_command->u.my_voice_spec);
  222|      0|	memcpy(data, voice, sizeof(espeak_VOICE));
  223|      0|
  224|      0|	if (voice->name)
  225|      0|		data->name = strdup(voice->name);
  226|      0|
  227|      0|	if (voice->languages)
  228|      0|		data->languages = strdup(voice->languages);
  229|      0|
  230|      0|	if (voice->identifier)
  231|      0|		data->identifier = strdup(voice->identifier);
  232|      0|
  233|      0|	return a_command;
  234|      0|}
  235|       |
  236|       |int delete_espeak_command(t_espeak_command *the_command)
  237|      0|{
  238|      0|	int a_status = 0;
  239|      0|	if (the_command) {
  240|      0|		switch (the_command->type)
  241|      0|		{
  242|      0|		case ET_TEXT:
  243|      0|			if (the_command->u.my_text.text)
  244|      0|				free(the_command->u.my_text.text);
  245|      0|			break;
  246|      0|		case ET_MARK:
  247|      0|			if (the_command->u.my_mark.text)
  248|      0|				free(the_command->u.my_mark.text);
  249|      0|			if (the_command->u.my_mark.index_mark)
  250|      0|				free((void *)(the_command->u.my_mark.index_mark));
  251|      0|			break;
  252|      0|		case ET_TERMINATED_MSG:
  253|      0|		{
  254|      0|			// if the terminated msg is pending,
  255|      0|			// it must be processed here for informing the calling program
  256|      0|			// that its message is finished.
  257|      0|			// This can be important for cleaning the related user data.
  258|      0|			t_espeak_terminated_msg *data = &(the_command->u.my_terminated_msg);
  259|      0|			if (the_command->state == CS_PENDING) {
  260|      0|				the_command->state = CS_PROCESSED;
  261|      0|				sync_espeak_terminated_msg(data->unique_identifier, data->user_data);
  262|      0|			}
  263|      0|		}
  264|      0|			break;
  265|      0|		case ET_KEY:
  266|      0|			if (the_command->u.my_key.key_name)
  267|      0|				free((void *)(the_command->u.my_key.key_name));
  268|      0|			break;
  269|      0|		case ET_CHAR:
  270|      0|		case ET_PARAMETER:
  271|      0|			// No allocation
  272|      0|			break;
  273|      0|		case ET_PUNCTUATION_LIST:
  274|      0|			if (the_command->u.my_punctuation_list)
  275|      0|				free((void *)(the_command->u.my_punctuation_list));
  276|      0|			break;
  277|      0|		case ET_VOICE_NAME:
  278|      0|			if (the_command->u.my_voice_name)
  279|      0|				free((void *)(the_command->u.my_voice_name));
  280|      0|			break;
  281|      0|		case ET_VOICE_SPEC:
  282|      0|		{
  283|      0|			espeak_VOICE *data = &(the_command->u.my_voice_spec);
  284|      0|
  285|      0|			if (data->name)
  286|      0|				free((void *)data->name);
  287|      0|
  288|      0|			if (data->languages)
  289|      0|				free((void *)data->languages);
  290|      0|
  291|      0|			if (data->identifier)
  292|      0|				free((void *)data->identifier);
  293|      0|		}
  294|      0|			break;
  295|      0|		default:
  296|      0|			assert(0);
  297|      0|		}
  298|      0|		free(the_command);
  299|      0|		a_status = 1;
  300|      0|	}
  301|      0|	return a_status;
  302|      0|}
  303|       |
  304|       |void process_espeak_command(t_espeak_command *the_command)
  305|      0|{
  306|      0|	if (the_command == NULL)
  307|      0|		return;
  308|      0|
  309|      0|	the_command->state = CS_PROCESSED;
  310|      0|
  311|      0|	switch (the_command->type)
  312|      0|	{
  313|      0|	case ET_TEXT:
  314|      0|	{
  315|      0|		t_espeak_text *data = &(the_command->u.my_text);
  316|      0|		sync_espeak_Synth(data->unique_identifier, data->text,
  317|      0|		                  data->position, data->position_type,
  318|      0|		                  data->end_position, data->flags, data->user_data);
  319|      0|	}
  320|      0|		break;
  321|      0|	case ET_MARK:
  322|      0|	{
  323|      0|		t_espeak_mark *data = &(the_command->u.my_mark);
  324|      0|		sync_espeak_Synth_Mark(data->unique_identifier, data->text,
  325|      0|		                       data->index_mark, data->end_position, data->flags,
  326|      0|		                       data->user_data);
  327|      0|	}
  328|      0|		break;
  329|      0|	case ET_TERMINATED_MSG:
  330|      0|	{
  331|      0|		t_espeak_terminated_msg *data = &(the_command->u.my_terminated_msg);
  332|      0|		sync_espeak_terminated_msg(data->unique_identifier, data->user_data);
  333|      0|	}
  334|      0|		break;
  335|      0|	case ET_KEY:
  336|      0|	{
  337|      0|		const char *data = the_command->u.my_key.key_name;
  338|      0|		sync_espeak_Key(data);
  339|      0|	}
  340|      0|		break;
  341|      0|	case ET_CHAR:
  342|      0|	{
  343|      0|		const wchar_t data = the_command->u.my_char.character;
  344|      0|		sync_espeak_Char(data);
  345|      0|	}
  346|      0|		break;
  347|      0|	case ET_PARAMETER:
  348|      0|	{
  349|      0|		t_espeak_parameter *data = &(the_command->u.my_param);
  350|      0|		SetParameter(data->parameter, data->value, data->relative);
  351|      0|	}
  352|      0|		break;
  353|      0|	case ET_PUNCTUATION_LIST:
  354|      0|	{
  355|      0|		const wchar_t *data = the_command->u.my_punctuation_list;
  356|      0|		sync_espeak_SetPunctuationList(data);
  357|      0|	}
  358|      0|		break;
  359|      0|	case ET_VOICE_NAME:
  360|      0|	{
  361|      0|		const char *data = the_command->u.my_voice_name;
  362|      0|		espeak_SetVoiceByName(data);
  363|      0|	}
  364|      0|		break;
  365|      0|	case ET_VOICE_SPEC:
  366|      0|	{
  367|      0|		espeak_VOICE *data = &(the_command->u.my_voice_spec);
  368|      0|		espeak_SetVoiceByProperties(data);
  369|      0|	}
  370|      0|		break;
  371|      0|	default:
  372|      0|		assert(0);
  373|      0|		break;
  374|      0|	}
  375|      0|}
  376|       |
  377|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/event.c:
    1|       |/*
    2|       | * Copyright (C) 2007, Gilles Casse <gcasse@oralux.org>
    3|       | * Copyright (C) 2013-2016 Reece H. Dunn
    4|       | *
    5|       | * This program is free software; you can redistribute it and/or modify
    6|       | * it under the terms of the GNU General Public License as published by
    7|       | * the Free Software Foundation; either version 3 of the License, or
    8|       | * (at your option) any later version.
    9|       | *
   10|       | * This program is distributed in the hope that it will be useful,
   11|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   12|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   13|       | * GNU General Public License for more details.
   14|       | *
   15|       | * You should have received a copy of the GNU General Public License
   16|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   17|       | */
   18|       |
   19|       |// This source file is only used for asynchronous modes
   20|       |
   21|       |#include "config.h"
   22|       |
   23|       |#include <assert.h>
   24|       |#include <errno.h>
   25|       |#include <pthread.h>
   26|       |#include <stdbool.h>
   27|       |#include <stdint.h>
   28|       |#include <stdlib.h>
   29|       |#include <string.h>
   30|       |#include <sys/time.h>
   31|       |#include <unistd.h>
   32|       |
   33|       |#include <espeak-ng/espeak_ng.h>
   34|       |#include <espeak-ng/speak_lib.h>
   35|       |
   36|       |#include "event.h"
   37|       |
   38|       |// my_mutex: protects my_thread_is_talking,
   39|       |static pthread_mutex_t my_mutex;
   40|       |static pthread_cond_t my_cond_start_is_required;
   41|       |static bool my_start_is_required = false;
   42|       |static pthread_cond_t my_cond_stop_is_required;
   43|       |static bool my_stop_is_required = false;
   44|       |static pthread_cond_t my_cond_stop_is_acknowledged;
   45|       |static bool my_stop_is_acknowledged = false;
   46|       |static bool my_terminate_is_required = 0;
   47|       |// my_thread: polls the audio duration and compares it to the duration of the first event.
   48|       |static pthread_t my_thread;
   49|       |static bool thread_inited;
   50|       |
   51|       |static t_espeak_callback *my_callback = NULL;
   52|       |static bool my_event_is_running = false;
   53|       |
   54|       |enum {
   55|       |	MIN_TIMEOUT_IN_MS = 10,
   56|       |	ACTIVITY_TIMEOUT = 50, // in ms, check that the stream is active
   57|       |	MAX_ACTIVITY_CHECK = 6
   58|       |};
   59|       |
   60|       |typedef struct t_node {
   61|       |	void *data;
   62|       |	struct t_node *next;
   63|       |} node;
   64|       |
   65|       |static node *head = NULL;
   66|       |static node *tail = NULL;
   67|       |static int node_counter = 0;
   68|       |static espeak_ng_STATUS push(void *data);
   69|       |static void *pop(void);
   70|       |static void init(void);
   71|       |static void *polling_thread(void *);
   72|       |
   73|       |void event_set_callback(t_espeak_callback *SynthCallback)
   74|      0|{
   75|      0|	my_callback = SynthCallback;
   76|      0|}
   77|       |
   78|       |void event_init(void)
   79|      0|{
   80|      0|	my_event_is_running = false;
   81|      0|
   82|      0|	// security
   83|      0|	pthread_mutex_init(&my_mutex, (const pthread_mutexattr_t *)NULL);
   84|      0|	init();
   85|      0|
   86|      0|	assert(-1 != pthread_cond_init(&my_cond_start_is_required, NULL));
   87|      0|	assert(-1 != pthread_cond_init(&my_cond_stop_is_required, NULL));
   88|      0|	assert(-1 != pthread_cond_init(&my_cond_stop_is_acknowledged, NULL));
   89|      0|
   90|      0|	pthread_attr_t a_attrib;
   91|      0|
   92|      0|	if (pthread_attr_init(&a_attrib) == 0
   93|      0|	    && pthread_attr_setdetachstate(&a_attrib, PTHREAD_CREATE_JOINABLE) == 0) {
   94|      0|		thread_inited = (0 == pthread_create(&my_thread,
   95|      0|		                                     &a_attrib,
   96|      0|		                                     polling_thread,
   97|      0|		                                     (void *)NULL));
   98|      0|	}
   99|      0|	assert(thread_inited);
  100|      0|	pthread_attr_destroy(&a_attrib);
  101|      0|}
  102|       |
  103|       |static espeak_EVENT *event_copy(espeak_EVENT *event)
  104|      0|{
  105|      0|	if (event == NULL)
  106|      0|		return NULL;
  107|      0|
  108|      0|	espeak_EVENT *a_event = (espeak_EVENT *)malloc(sizeof(espeak_EVENT));
  109|      0|	if (a_event) {
  110|      0|		memcpy(a_event, event, sizeof(espeak_EVENT));
  111|      0|
  112|      0|		switch (event->type)
  113|      0|		{
  114|      0|		case espeakEVENT_MARK:
  115|      0|		case espeakEVENT_PLAY:
  116|      0|			if (event->id.name)
  117|      0|				a_event->id.name = strdup(event->id.name);
  118|      0|			break;
  119|      0|
  120|      0|		default:
  121|      0|			break;
  122|      0|		}
  123|      0|	}
  124|      0|
  125|      0|	return a_event;
  126|      0|}
  127|       |
  128|       |// Call the user supplied callback
  129|       |//
  130|       |// Note: the current sequence is:
  131|       |//
  132|       |// * First call with: event->type = espeakEVENT_SENTENCE
  133|       |// * 0, 1 or several calls: event->type = espeakEVENT_WORD
  134|       |// * Last call: event->type = espeakEVENT_MSG_TERMINATED
  135|       |//
  136|       |
  137|       |static void event_notify(espeak_EVENT *event)
  138|      0|{
  139|      0|	static unsigned int a_old_uid = 0;
  140|      0|
  141|      0|	espeak_EVENT events[2];
  142|      0|	memcpy(&events[0], event, sizeof(espeak_EVENT));     // the event parameter in the callback function should be an array of eventd
  143|      0|	memcpy(&events[1], event, sizeof(espeak_EVENT));
  144|      0|	events[1].type = espeakEVENT_LIST_TERMINATED;           // ... terminated by an event type=0
  145|      0|
  146|      0|	if (event && my_callback) {
  147|      0|		switch (event->type)
  148|      0|		{
  149|      0|		case espeakEVENT_SENTENCE:
  150|      0|			my_callback(NULL, 0, events);
  151|      0|			a_old_uid = event->unique_identifier;
  152|      0|			break;
  153|      0|		case espeakEVENT_MSG_TERMINATED:
  154|      0|		case espeakEVENT_MARK:
  155|      0|		case espeakEVENT_WORD:
  156|      0|		case espeakEVENT_END:
  157|      0|		case espeakEVENT_PHONEME:
  158|      0|		{
  159|      0|			if (a_old_uid != event->unique_identifier) {
  160|      0|				espeak_EVENT_TYPE a_new_type = events[0].type;
  161|      0|				events[0].type = espeakEVENT_SENTENCE;
  162|      0|				my_callback(NULL, 0, events);
  163|      0|				events[0].type = a_new_type;
  164|      0|			}
  165|      0|			my_callback(NULL, 0, events);
  166|      0|			a_old_uid = event->unique_identifier;
  167|      0|		}
  168|      0|			break;
  169|      0|		case espeakEVENT_LIST_TERMINATED:
  170|      0|		case espeakEVENT_PLAY:
  171|      0|		default:
  172|      0|			break;
  173|      0|		}
  174|      0|	}
  175|      0|}
  176|       |
  177|       |static int event_delete(espeak_EVENT *event)
  178|      0|{
  179|      0|	if (event == NULL)
  180|      0|		return 0;
  181|      0|
  182|      0|	switch (event->type)
  183|      0|	{
  184|      0|	case espeakEVENT_MSG_TERMINATED:
  185|      0|		event_notify(event);
  186|      0|		break;
  187|      0|	case espeakEVENT_MARK:
  188|      0|	case espeakEVENT_PLAY:
  189|      0|		if (event->id.name)
  190|      0|			free((void *)(event->id.name));
  191|      0|		break;
  192|      0|	default:
  193|      0|		break;
  194|      0|	}
  195|      0|
  196|      0|	free(event);
  197|      0|	return 1;
  198|      0|}
  199|       |
  200|       |espeak_ng_STATUS event_declare(espeak_EVENT *event)
  201|      0|{
  202|      0|	if (!event)
  203|      0|		return EINVAL;
  204|      0|
  205|      0|	espeak_ng_STATUS status;
  206|      0|	if ((status = pthread_mutex_lock(&my_mutex)) != ENS_OK) {
  207|      0|		my_start_is_required = true;
  208|      0|		return status;
  209|      0|	}
  210|      0|
  211|      0|	espeak_EVENT *a_event = event_copy(event);
  212|      0|	if ((status = push(a_event)) != ENS_OK) {
  213|      0|		event_delete(a_event);
  214|      0|		pthread_mutex_unlock(&my_mutex);
  215|      0|	} else {
  216|      0|		my_start_is_required = true;
  217|      0|		pthread_cond_signal(&my_cond_start_is_required);
  218|      0|		status = pthread_mutex_unlock(&my_mutex);
  219|      0|	}
  220|      0|
  221|      0|
  222|      0|	return status;
  223|      0|}
  224|       |
  225|       |espeak_ng_STATUS event_clear_all()
  226|      0|{
  227|      0|	espeak_ng_STATUS status;
  228|      0|	if ((status = pthread_mutex_lock(&my_mutex)) != ENS_OK)
  229|      0|		return status;
  230|      0|
  231|      0|	int a_event_is_running = 0;
  232|      0|	if (my_event_is_running) {
  233|      0|		my_stop_is_required = true;
  234|      0|		pthread_cond_signal(&my_cond_stop_is_required);
  235|      0|		a_event_is_running = 1;
  236|      0|	} else
  237|      0|		init(); // clear pending events
  238|      0|
  239|      0|	if (a_event_is_running) {
  240|      0|		while (my_stop_is_acknowledged == false) {
  241|      0|			while ((pthread_cond_wait(&my_cond_stop_is_acknowledged, &my_mutex) == -1) && errno == EINTR)
  242|      0|				continue; // Restart when interrupted by handler
  243|      0|		}
  244|      0|	}
  245|      0|
  246|      0|	if ((status = pthread_mutex_unlock(&my_mutex)) != ENS_OK)
  247|      0|		return status;
  248|      0|
  249|      0|	return ENS_OK;
  250|      0|}
  251|       |
  252|       |static void *polling_thread(void *p)
  253|      0|{
  254|      0|	(void)p; // unused
  255|      0|
  256|      0|	while (!my_terminate_is_required) {
  257|      0|		bool a_stop_is_required = false;
  258|      0|
  259|      0|		(void)pthread_mutex_lock(&my_mutex);
  260|      0|		my_event_is_running = false;
  261|      0|
  262|      0|		while (my_start_is_required == false && my_terminate_is_required == false) {
  263|      0|			while ((pthread_cond_wait(&my_cond_start_is_required, &my_mutex) == -1) && errno == EINTR)
  264|      0|				continue; // Restart when interrupted by handler
  265|      0|		}
  266|      0|
  267|      0|		my_event_is_running = true;
  268|      0|		a_stop_is_required = false;
  269|      0|		my_start_is_required = false;
  270|      0|
  271|      0|		pthread_mutex_unlock(&my_mutex);
  272|      0|
  273|      0|		// In this loop, my_event_is_running = true
  274|      0|		while (head && (a_stop_is_required == false) && (my_terminate_is_required == false)) {
  275|      0|			espeak_EVENT *event = (espeak_EVENT *)(head->data);
  276|      0|			assert(event);
  277|      0|
  278|      0|			if (my_callback) {
  279|      0|				event_notify(event);
  280|      0|				// the user_data (and the type) are cleaned to be sure
  281|      0|				// that MSG_TERMINATED is called twice (at delete time too).
  282|      0|				event->type = espeakEVENT_LIST_TERMINATED;
  283|      0|				event->user_data = NULL;
  284|      0|			}
  285|      0|
  286|      0|			(void)pthread_mutex_lock(&my_mutex);
  287|      0|			event_delete((espeak_EVENT *)pop());
  288|      0|			a_stop_is_required = my_stop_is_required;
  289|      0|			if (a_stop_is_required == true)
  290|      0|				my_stop_is_required = false;
  291|      0|
  292|      0|			(void)pthread_mutex_unlock(&my_mutex);
  293|      0|		}
  294|      0|
  295|      0|		(void)pthread_mutex_lock(&my_mutex);
  296|      0|
  297|      0|		my_event_is_running = false;
  298|      0|
  299|      0|		if (a_stop_is_required == false) {
  300|      0|			a_stop_is_required = my_stop_is_required;
  301|      0|			if (a_stop_is_required == true)
  302|      0|				my_stop_is_required = false;
  303|      0|		}
  304|      0|
  305|      0|		(void)pthread_mutex_unlock(&my_mutex);
  306|      0|
  307|      0|		if (a_stop_is_required == true || my_terminate_is_required == true) {
  308|      0|			// no mutex required since the stop command is synchronous
  309|      0|			// and waiting for my_cond_stop_is_acknowledged
  310|      0|			init();
  311|      0|
  312|      0|			// acknowledge the stop request
  313|      0|			(void)pthread_mutex_lock(&my_mutex);
  314|      0|			my_stop_is_acknowledged = true;
  315|      0|			(void)pthread_cond_signal(&my_cond_stop_is_acknowledged);
  316|      0|			(void)pthread_mutex_unlock(&my_mutex);
  317|      0|		}
  318|      0|	}
  319|      0|
  320|      0|	return NULL;
  321|      0|}
  322|       |
  323|       |enum { MAX_NODE_COUNTER = 1000 };
  324|       |
  325|       |static espeak_ng_STATUS push(void *the_data)
  326|      0|{
  327|      0|	assert((!head && !tail) || (head && tail));
  328|      0|
  329|      0|	if (the_data == NULL)
  330|      0|		return EINVAL;
  331|      0|
  332|      0|	if (node_counter >= MAX_NODE_COUNTER)
  333|      0|		return ENS_EVENT_BUFFER_FULL;
  334|      0|
  335|      0|	node *n = (node *)malloc(sizeof(node));
  336|      0|	if (n == NULL)
  337|      0|		return ENOMEM;
  338|      0|
  339|      0|	if (head == NULL) {
  340|      0|		head = n;
  341|      0|		tail = n;
  342|      0|	} else {
  343|      0|		tail->next = n;
  344|      0|		tail = n;
  345|      0|	}
  346|      0|
  347|      0|	tail->next = NULL;
  348|      0|	tail->data = the_data;
  349|      0|
  350|      0|	node_counter++;
  351|      0|
  352|      0|	return ENS_OK;
  353|      0|}
  354|       |
  355|       |static void *pop()
  356|       |{
  357|       |	void *the_data = NULL;
  358|       |
  359|       |	assert((!head && !tail) || (head && tail));
  360|       |
  361|       |	if (head != NULL) {
  362|       |		node *n = head;
  363|       |		the_data = n->data;
  364|       |		head = n->next;
  365|       |		free(n);
  366|       |		node_counter--;
  367|       |	}
  368|       |
  369|       |	if (head == NULL)
  370|       |		tail = NULL;
  371|       |
  372|       |	return the_data;
  373|       |}
  374|       |
  375|       |
  376|       |static void init()
  377|      0|{
  378|      0|	while (event_delete((espeak_EVENT *)pop()))
  379|      0|		;
  380|      0|
  381|      0|	node_counter = 0;
  382|      0|}
  383|       |
  384|       |void event_terminate()
  385|      0|{
  386|      0|	if (thread_inited) {
  387|      0|		my_terminate_is_required = true;
  388|      0|		pthread_cond_signal(&my_cond_start_is_required);
  389|      0|		pthread_cond_signal(&my_cond_stop_is_required);
  390|      0|		pthread_join(my_thread, NULL);
  391|      0|		my_terminate_is_required = false;
  392|      0|
  393|      0|		pthread_mutex_destroy(&my_mutex);
  394|      0|		pthread_cond_destroy(&my_cond_start_is_required);
  395|      0|		pthread_cond_destroy(&my_cond_stop_is_required);
  396|      0|		pthread_cond_destroy(&my_cond_stop_is_acknowledged);
  397|      0|		init(); // purge event
  398|      0|		thread_inited = 0;
  399|      0|	}
  400|      0|}
  401|       |
  402|       |enum { ONE_BILLION = 1000000000 };
  403|       |
  404|       |void clock_gettime2(struct timespec *ts)
  405|      0|{
  406|      0|	struct timeval tv;
  407|      0|
  408|      0|	if (!ts)
  409|      0|		return;
  410|      0|
  411|      0|	assert(gettimeofday(&tv, NULL) != -1);
  412|      0|	ts->tv_sec = tv.tv_sec;
  413|      0|	ts->tv_nsec = tv.tv_usec*1000;
  414|      0|}
  415|       |
  416|       |void add_time_in_ms(struct timespec *ts, int time_in_ms)
  417|      0|{
  418|      0|	if (!ts)
  419|      0|		return;
  420|      0|
  421|      0|	uint64_t t_ns = (uint64_t)ts->tv_nsec + 1000000 * (uint64_t)time_in_ms;
  422|      0|	while (t_ns >= ONE_BILLION) {
  423|      0|		ts->tv_sec += 1;
  424|      0|		t_ns -= ONE_BILLION;
  425|      0|	}
  426|      0|	ts->tv_nsec = (long int)t_ns;
  427|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/fifo.c:
    1|       |/*
    2|       | * Copyright (C) 2007, Gilles Casse <gcasse@oralux.org>
    3|       | * Copyright (C) 2013-2016 Reece H. Dunn
    4|       | *
    5|       | * This program is free software; you can redistribute it and/or modify
    6|       | * it under the terms of the GNU General Public License as published by
    7|       | * the Free Software Foundation; either version 3 of the License, or
    8|       | * (at your option) any later version.
    9|       | *
   10|       | * This program is distributed in the hope that it will be useful,
   11|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   12|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   13|       | * GNU General Public License for more details.
   14|       | *
   15|       | * You should have received a copy of the GNU General Public License
   16|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   17|       | */
   18|       |
   19|       |// This source file is only used for asynchronous modes
   20|       |
   21|       |#include "config.h"
   22|       |
   23|       |#include <assert.h>
   24|       |#include <errno.h>
   25|       |#include <pthread.h>
   26|       |#include <stdbool.h>
   27|       |#include <stdint.h>
   28|       |#include <stdlib.h>
   29|       |#include <string.h>
   30|       |#include <sys/time.h>
   31|       |#include <time.h>
   32|       |#include <unistd.h>
   33|       |
   34|       |#include <espeak-ng/espeak_ng.h>
   35|       |
   36|       |#include "speech.h"
   37|       |#include "espeak_command.h"
   38|       |#include "fifo.h"
   39|       |#include "event.h"
   40|       |
   41|       |#ifdef USE_ASYNC
   42|       |
   43|       |// my_mutex: protects my_thread_is_talking,
   44|       |// my_stop_is_required, and the command fifo
   45|       |static pthread_mutex_t my_mutex;
   46|       |static bool my_command_is_running = false;
   47|       |static pthread_cond_t my_cond_command_is_running;
   48|       |static bool my_stop_is_required = false;
   49|       |static bool my_terminate_is_required = 0;
   50|       |
   51|       |// my_thread: reads commands from the fifo, and runs them.
   52|       |static pthread_t my_thread;
   53|       |
   54|       |static pthread_cond_t my_cond_start_is_required;
   55|       |static bool my_start_is_required = false;
   56|       |
   57|       |static pthread_cond_t my_cond_stop_is_acknowledged;
   58|       |static bool my_stop_is_acknowledged = false;
   59|       |
   60|       |static void *say_thread(void *);
   61|       |
   62|       |static espeak_ng_STATUS push(t_espeak_command *the_command);
   63|       |static t_espeak_command *pop(void);
   64|       |static void init(int process_parameters);
   65|       |static int node_counter = 0;
   66|       |
   67|       |enum {
   68|       |	MAX_NODE_COUNTER = 400,
   69|       |	INACTIVITY_TIMEOUT = 50, // in ms, check that the stream is inactive
   70|       |	MAX_INACTIVITY_CHECK = 2
   71|       |};
   72|       |
   73|       |void fifo_init()
   74|      0|{
   75|      0|	// security
   76|      0|	pthread_mutex_init(&my_mutex, (const pthread_mutexattr_t *)NULL);
   77|      0|	init(0);
   78|      0|
   79|      0|	assert(-1 != pthread_cond_init(&my_cond_command_is_running, NULL));
   80|      0|	assert(-1 != pthread_cond_init(&my_cond_start_is_required, NULL));
   81|      0|	assert(-1 != pthread_cond_init(&my_cond_stop_is_acknowledged, NULL));
   82|      0|
   83|      0|	pthread_attr_t a_attrib;
   84|      0|	if (pthread_attr_init(&a_attrib)
   85|      0|	    || pthread_attr_setdetachstate(&a_attrib, PTHREAD_CREATE_JOINABLE)
   86|      0|	    || pthread_create(&my_thread,
   87|      0|	                      &a_attrib,
   88|      0|	                      say_thread,
   89|      0|	                      (void *)NULL)) {
   90|      0|		assert(0);
   91|      0|	}
   92|      0|
   93|      0|	pthread_attr_destroy(&a_attrib);
   94|      0|
   95|      0|	// leave once the thread is actually started
   96|      0|	assert(-1 != pthread_mutex_lock(&my_mutex));
   97|      0|	while (my_stop_is_acknowledged == false) {
   98|      0|		while ((pthread_cond_wait(&my_cond_stop_is_acknowledged, &my_mutex) == -1) && errno == EINTR)
   99|      0|			;
  100|      0|	}
  101|      0|	my_stop_is_acknowledged = false;
  102|      0|	pthread_mutex_unlock(&my_mutex);
  103|      0|}
  104|       |
  105|       |espeak_ng_STATUS fifo_add_command(t_espeak_command *the_command)
  106|      0|{
  107|      0|	espeak_ng_STATUS status;
  108|      0|	if ((status = pthread_mutex_lock(&my_mutex)) != ENS_OK)
  109|      0|		return status;
  110|      0|
  111|      0|	if ((status = push(the_command)) != ENS_OK) {
  112|      0|		pthread_mutex_unlock(&my_mutex);
  113|      0|		return status;
  114|      0|	}
  115|      0|	
  116|      0|	my_start_is_required = true;
  117|      0|	pthread_cond_signal(&my_cond_start_is_required);
  118|      0|
  119|      0|	while (my_start_is_required && !my_command_is_running) {
  120|      0|		if((status = pthread_cond_wait(&my_cond_command_is_running, &my_mutex)) != ENS_OK && errno != EINTR) {
  121|      0|			pthread_mutex_unlock(&my_mutex);
  122|      0|			return status;
  123|      0|		}
  124|      0|	}
  125|      0|	if ((status = pthread_mutex_unlock(&my_mutex)) != ENS_OK)
  126|      0|		return status;
  127|      0|
  128|      0|	return ENS_OK;
  129|      0|}
  130|       |
  131|       |espeak_ng_STATUS fifo_add_commands(t_espeak_command *command1, t_espeak_command *command2)
  132|      0|{
  133|      0|	espeak_ng_STATUS status;
  134|      0|	if ((status = pthread_mutex_lock(&my_mutex)) != ENS_OK)
  135|      0|		return status;
  136|      0|
  137|      0|	if (node_counter+1 >= MAX_NODE_COUNTER) {
  138|      0|		pthread_mutex_unlock(&my_mutex);
  139|      0|		return ENS_FIFO_BUFFER_FULL;
  140|      0|	}
  141|      0|
  142|      0|	if ((status = push(command1)) != ENS_OK) {
  143|      0|		pthread_mutex_unlock(&my_mutex);
  144|      0|		return status;
  145|      0|	}
  146|      0|
  147|      0|	if ((status = push(command2)) != ENS_OK) {
  148|      0|		pthread_mutex_unlock(&my_mutex);
  149|      0|		return status;
  150|      0|	}
  151|      0|
  152|      0|	my_start_is_required = true;
  153|      0|	pthread_cond_signal(&my_cond_start_is_required);
  154|      0|	
  155|      0|	while (my_start_is_required && !my_command_is_running) {
  156|      0|		if((status = pthread_cond_wait(&my_cond_command_is_running, &my_mutex)) != ENS_OK && errno != EINTR) {
  157|      0|			pthread_mutex_unlock(&my_mutex);
  158|      0|			return status;
  159|      0|		}
  160|      0|	}
  161|      0|	if ((status = pthread_mutex_unlock(&my_mutex)) != ENS_OK)
  162|      0|		return status;
  163|      0|
  164|      0|	return ENS_OK;
  165|      0|}
  166|       |
  167|       |espeak_ng_STATUS fifo_stop()
  168|      0|{
  169|      0|	espeak_ng_STATUS status;
  170|      0|	if ((status = pthread_mutex_lock(&my_mutex)) != ENS_OK)
  171|      0|		return status;
  172|      0|
  173|      0|	bool a_command_is_running = false;
  174|      0|	if (my_command_is_running) {
  175|      0|		a_command_is_running = true;
  176|      0|		my_stop_is_required = true;
  177|      0|		my_stop_is_acknowledged = false;
  178|      0|	}
  179|      0|
  180|      0|	if (a_command_is_running) {
  181|      0|		while (my_stop_is_acknowledged == false) {
  182|      0|			while ((pthread_cond_wait(&my_cond_stop_is_acknowledged, &my_mutex) == -1) && errno == EINTR)
  183|      0|				continue; // Restart when interrupted by handler
  184|      0|		}
  185|      0|	}
  186|      0|
  187|      0|	my_stop_is_required = false;
  188|      0|	if ((status = pthread_mutex_unlock(&my_mutex)) != ENS_OK)
  189|      0|		return status;
  190|      0|
  191|      0|	return ENS_OK;
  192|      0|}
  193|       |
  194|       |int fifo_is_busy()
  195|      0|{
  196|      0|	return my_command_is_running;
  197|      0|}
  198|       |
  199|       |static int sleep_until_start_request_or_inactivity()
  200|      0|{
  201|      0|	int a_start_is_required = false;
  202|      0|
  203|      0|	// Wait for the start request (my_cond_start_is_required).
  204|      0|	// Besides this, if the audio stream is still busy,
  205|      0|	// check from time to time its end.
  206|      0|	// The end of the stream is confirmed by several checks
  207|      0|	// for filtering underflow.
  208|      0|	//
  209|      0|	int i = 0;
  210|      0|	int err = pthread_mutex_lock(&my_mutex);
  211|      0|	assert(err != -1);
  212|      0|	while ((i <= MAX_INACTIVITY_CHECK) && !a_start_is_required) {
  213|      0|		i++;
  214|      0|
  215|      0|		struct timespec ts;
  216|      0|		struct timeval tv;
  217|      0|
  218|      0|		clock_gettime2(&ts);
  219|      0|
  220|      0|		add_time_in_ms(&ts, INACTIVITY_TIMEOUT);
  221|      0|
  222|      0|		while ((err = pthread_cond_timedwait(&my_cond_start_is_required, &my_mutex, &ts)) == -1
  223|      0|		       && errno == EINTR)
  224|      0|			continue;
  225|      0|
  226|      0|		assert(gettimeofday(&tv, NULL) != -1);
  227|      0|
  228|      0|		if (err == 0)
  229|      0|			a_start_is_required = true;
  230|      0|	}
  231|      0|	pthread_mutex_unlock(&my_mutex);
  232|      0|	return a_start_is_required;
  233|      0|}
  234|       |
  235|       |static espeak_ng_STATUS close_stream()
  236|      0|{
  237|      0|	espeak_ng_STATUS status = pthread_mutex_lock(&my_mutex);
  238|      0|	if (status != ENS_OK)
  239|      0|		return status;
  240|      0|
  241|      0|	bool a_stop_is_required = my_stop_is_required;
  242|      0|	if (!a_stop_is_required)
  243|      0|		my_command_is_running = true;
  244|      0|
  245|      0|	status = pthread_mutex_unlock(&my_mutex);
  246|      0|
  247|      0|	if (!a_stop_is_required) {
  248|      0|		int a_status = pthread_mutex_lock(&my_mutex);
  249|      0|		if (status == ENS_OK)
  250|      0|			status = a_status;
  251|      0|
  252|      0|		my_command_is_running = false;
  253|      0|		a_stop_is_required = my_stop_is_required;
  254|      0|
  255|      0|		a_status = pthread_mutex_unlock(&my_mutex);
  256|      0|		if (status == ENS_OK)
  257|      0|			status = a_status;
  258|      0|
  259|      0|		if (a_stop_is_required) {
  260|      0|			// cancel the audio early, to be more responsive when using eSpeak NG
  261|      0|			// for audio.
  262|      0|			cancel_audio();
  263|      0|
  264|      0|			// acknowledge the stop request
  265|      0|			if((a_status = pthread_mutex_lock(&my_mutex)) != ENS_OK)
  266|      0|				return a_status;
  267|      0|
  268|      0|			my_stop_is_acknowledged = true;
  269|      0|			a_status = pthread_cond_signal(&my_cond_stop_is_acknowledged);
  270|      0|			if(a_status != ENS_OK)
  271|      0|				return a_status;
  272|      0|			a_status = pthread_mutex_unlock(&my_mutex);
  273|      0|			if (status == ENS_OK)
  274|      0|				status = a_status;
  275|      0|			
  276|      0|		}
  277|      0|	}
  278|      0|
  279|      0|	return status;
  280|      0|}
  281|       |
  282|       |static void *say_thread(void *p)
  283|      0|{
  284|      0|	(void)p; // unused
  285|      0|
  286|      0|	// announce that thread is started
  287|      0|	assert(-1 != pthread_mutex_lock(&my_mutex));
  288|      0|	my_stop_is_acknowledged = true;
  289|      0|	assert(-1 != pthread_cond_signal(&my_cond_stop_is_acknowledged));
  290|      0|	assert(-1 != pthread_mutex_unlock(&my_mutex));
  291|      0|
  292|      0|	bool look_for_inactivity = false;
  293|      0|
  294|      0|	while (!my_terminate_is_required) {
  295|      0|		bool a_start_is_required = false;
  296|      0|		if (look_for_inactivity) {
  297|      0|			a_start_is_required = sleep_until_start_request_or_inactivity();
  298|      0|			if (!a_start_is_required)
  299|      0|				close_stream();
  300|      0|		}
  301|      0|		look_for_inactivity = true;
  302|      0|
  303|      0|		int a_status = pthread_mutex_lock(&my_mutex);
  304|      0|		assert(!a_status);
  305|      0|
  306|      0|		if (!a_start_is_required) {
  307|      0|			while (my_start_is_required == false && my_terminate_is_required == false) {
  308|      0|				while ((pthread_cond_wait(&my_cond_start_is_required, &my_mutex) == -1) && errno == EINTR)
  309|      0|					continue; // Restart when interrupted by handler
  310|      0|			}
  311|      0|		}
  312|      0|
  313|      0|
  314|      0|		my_command_is_running = true;
  315|      0|
  316|      0|		assert(-1 != pthread_cond_broadcast(&my_cond_command_is_running));
  317|      0|		assert(-1 != pthread_mutex_unlock(&my_mutex));
  318|      0|
  319|      0|		while (my_command_is_running && !my_terminate_is_required) {
  320|      0|			int a_status = pthread_mutex_lock(&my_mutex);
  321|      0|			assert(!a_status);
  322|      0|			t_espeak_command *a_command = (t_espeak_command *)pop();
  323|      0|
  324|      0|			if (a_command == NULL) {
  325|      0|				my_command_is_running = false;
  326|      0|				a_status = pthread_mutex_unlock(&my_mutex);
  327|      0|			} else {
  328|      0|				my_start_is_required = false;
  329|      0|
  330|      0|				if (my_stop_is_required)
  331|      0|					my_command_is_running = false;
  332|      0|				a_status = pthread_mutex_unlock(&my_mutex);
  333|      0|
  334|      0|				if (my_command_is_running)
  335|      0|					process_espeak_command(a_command);
  336|      0|				delete_espeak_command(a_command);
  337|      0|			}
  338|      0|		}
  339|      0|
  340|      0|		if (my_stop_is_required || my_terminate_is_required) {
  341|      0|			// no mutex required since the stop command is synchronous
  342|      0|			// and waiting for my_cond_stop_is_acknowledged
  343|      0|			init(1);
  344|      0|
  345|      0|			assert(-1 != pthread_mutex_lock(&my_mutex));
  346|      0|			my_start_is_required = false;
  347|      0|
  348|      0|			// acknowledge the stop request
  349|      0|			my_stop_is_acknowledged = true;
  350|      0|			int a_status = pthread_cond_signal(&my_cond_stop_is_acknowledged);
  351|      0|			assert(a_status != -1);
  352|      0|			pthread_mutex_unlock(&my_mutex);
  353|      0|
  354|      0|		}
  355|      0|		// and wait for the next start
  356|      0|	}
  357|      0|
  358|      0|	return NULL;
  359|      0|}
  360|       |
  361|       |int fifo_is_command_enabled()
  362|      0|{
  363|      0|	return 0 == my_stop_is_required;
  364|      0|}
  365|       |
  366|       |typedef struct t_node {
  367|       |	t_espeak_command *data;
  368|       |	struct t_node *next;
  369|       |} node;
  370|       |
  371|       |static node *head = NULL;
  372|       |static node *tail = NULL;
  373|       |
  374|       |static espeak_ng_STATUS push(t_espeak_command *the_command)
  375|      0|{
  376|      0|	assert((!head && !tail) || (head && tail));
  377|      0|
  378|      0|	if (the_command == NULL)
  379|      0|		return EINVAL;
  380|      0|
  381|      0|	if (node_counter >= MAX_NODE_COUNTER)
  382|      0|		return ENS_FIFO_BUFFER_FULL;
  383|      0|
  384|      0|	node *n = (node *)malloc(sizeof(node));
  385|      0|	if (n == NULL)
  386|      0|		return ENOMEM;
  387|      0|
  388|      0|	if (head == NULL) {
  389|      0|		head = n;
  390|      0|		tail = n;
  391|      0|	} else {
  392|      0|		tail->next = n;
  393|      0|		tail = n;
  394|      0|	}
  395|      0|
  396|      0|	tail->next = NULL;
  397|      0|	tail->data = the_command;
  398|      0|
  399|      0|	node_counter++;
  400|      0|
  401|      0|	the_command->state = CS_PENDING;
  402|      0|
  403|      0|	return ENS_OK;
  404|      0|}
  405|       |
  406|       |static t_espeak_command *pop()
  407|       |{
  408|       |	t_espeak_command *the_command = NULL;
  409|       |
  410|       |	assert((!head && !tail) || (head && tail));
  411|       |
  412|       |	if (head != NULL) {
  413|       |		node *n = head;
  414|       |		the_command = n->data;
  415|       |		head = n->next;
  416|       |		free(n);
  417|       |		node_counter--;
  418|       |	}
  419|       |
  420|       |	if (head == NULL)
  421|       |		tail = NULL;
  422|       |
  423|       |	return the_command;
  424|       |}
  425|       |
  426|       |static void init(int process_parameters)
  427|      0|{
  428|      0|	t_espeak_command *c = NULL;
  429|      0|	c = pop();
  430|      0|	while (c != NULL) {
  431|      0|		if (process_parameters && (c->type == ET_PARAMETER || c->type == ET_VOICE_NAME || c->type == ET_VOICE_SPEC))
  432|      0|			process_espeak_command(c);
  433|      0|		delete_espeak_command(c);
  434|      0|		c = pop();
  435|      0|	}
  436|      0|	node_counter = 0;
  437|      0|}
  438|       |
  439|       |void fifo_terminate()
  440|      0|{
  441|      0|	my_terminate_is_required = true;
  442|      0|	pthread_cond_signal(&my_cond_start_is_required);
  443|      0|	pthread_join(my_thread, NULL);
  444|      0|	my_terminate_is_required = false;
  445|      0|
  446|      0|	pthread_mutex_destroy(&my_mutex);
  447|      0|	pthread_cond_destroy(&my_cond_start_is_required);
  448|      0|	pthread_cond_destroy(&my_cond_stop_is_acknowledged);
  449|      0|
  450|      0|	init(0); // purge fifo
  451|      0|}
  452|       |
  453|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/intonation.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2007 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2016 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <stdint.h>
   23|       |#include <stdio.h>
   24|       |#include <stdlib.h>
   25|       |#include <string.h>
   26|       |
   27|       |#include <espeak-ng/espeak_ng.h>
   28|       |#include <espeak-ng/speak_lib.h>
   29|       |#include <espeak-ng/encoding.h>
   30|       |
   31|       |#include "intonation.h"
   32|       |#include "phoneme.h"     // for PHONEME_TAB, PhonemeCode2, phonPAUSE, phPAUSE
   33|       |#include "synthdata.h"   // for PhonemeCode
   34|       |#include "synthesize.h"  // for PHONEME_LIST, TUNE, phoneme_list, phoneme_tab
   35|       |#include "translate.h"   // for Translator, LANGUAGE_OPTIONS, L, OPTION_EMPH...
   36|       |
   37|       |/* Note this module is mostly old code that needs to be rewritten to
   38|       |   provide a more flexible intonation system.
   39|       | */
   40|       |
   41|       |// bits in SYLLABLE.flags
   42|      0|#define SYL_RISE        1
   43|      0|#define SYL_EMPHASIS    2
   44|      0|#define SYL_END_CLAUSE   4
   45|       |
   46|       |typedef struct {
   47|       |	char stress;
   48|       |	char env;
   49|       |	char flags; // bit 0=pitch rising, bit1=emnphasized, bit2=end of clause
   50|       |	char nextph_type;
   51|       |	unsigned char pitch1;
   52|       |	unsigned char pitch2;
   53|       |} SYLLABLE;
   54|       |
   55|       |static int tone_pitch_env; // used to return pitch envelope
   56|       |
   57|       |/* Pitch data for tone types */
   58|       |/*****************************/
   59|       |
   60|      0|#define PITCHfall     0
   61|      0|#define PITCHrise     2
   62|       |#define PITCHfrise    4 // and 3 must be for the variant preceded by 'r'
   63|       |#define PITCHfrise2   6 // and 5 must be the 'r' variant
   64|       |
   65|       |unsigned char env_fall[128] = {
   66|       |	0xff, 0xfd, 0xfa, 0xf8, 0xf6, 0xf4, 0xf2, 0xf0, 0xee, 0xec, 0xea, 0xe8, 0xe6, 0xe4, 0xe2, 0xe0,
   67|       |	0xde, 0xdc, 0xda, 0xd8, 0xd6, 0xd4, 0xd2, 0xd0, 0xce, 0xcc, 0xca, 0xc8, 0xc6, 0xc4, 0xc2, 0xc0,
   68|       |	0xbe, 0xbc, 0xba, 0xb8, 0xb6, 0xb4, 0xb2, 0xb0, 0xae, 0xac, 0xaa, 0xa8, 0xa6, 0xa4, 0xa2, 0xa0,
   69|       |	0x9e, 0x9c, 0x9a, 0x98, 0x96, 0x94, 0x92, 0x90, 0x8e, 0x8c, 0x8a, 0x88, 0x86, 0x84, 0x82, 0x80,
   70|       |	0x7e, 0x7c, 0x7a, 0x78, 0x76, 0x74, 0x72, 0x70, 0x6e, 0x6c, 0x6a, 0x68, 0x66, 0x64, 0x62, 0x60,
   71|       |	0x5e, 0x5c, 0x5a, 0x58, 0x56, 0x54, 0x52, 0x50, 0x4e, 0x4c, 0x4a, 0x48, 0x46, 0x44, 0x42, 0x40,
   72|       |	0x3e, 0x3c, 0x3a, 0x38, 0x36, 0x34, 0x32, 0x30, 0x2e, 0x2c, 0x2a, 0x28, 0x26, 0x24, 0x22, 0x20,
   73|       |	0x1e, 0x1c, 0x1a, 0x18, 0x16, 0x14, 0x12, 0x10, 0x0e, 0x0c, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x00
   74|       |};
   75|       |
   76|       |unsigned char env_rise[128] = {
   77|       |	0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
   78|       |	0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
   79|       |	0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
   80|       |	0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
   81|       |	0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
   82|       |	0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
   83|       |	0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
   84|       |	0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfd, 0xff
   85|       |};
   86|       |
   87|       |unsigned char env_frise[128] = {
   88|       |	0xff, 0xf4, 0xea, 0xe0, 0xd6, 0xcc, 0xc3, 0xba, 0xb1, 0xa8, 0x9f, 0x97, 0x8f, 0x87, 0x7f, 0x78,
   89|       |	0x71, 0x6a, 0x63, 0x5c, 0x56, 0x50, 0x4a, 0x44, 0x3f, 0x39, 0x34, 0x2f, 0x2b, 0x26, 0x22, 0x1e,
   90|       |	0x1a, 0x17, 0x13, 0x10, 0x0d, 0x0b, 0x08, 0x06, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
   91|       |	0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x07, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x13, 0x15, 0x17,
   92|       |	0x1a, 0x1d, 0x1f, 0x22, 0x25, 0x28, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x39, 0x3b, 0x3d, 0x40,
   93|       |	0x42, 0x45, 0x47, 0x4a, 0x4c, 0x4f, 0x51, 0x54, 0x57, 0x5a, 0x5d, 0x5f, 0x62, 0x65, 0x68, 0x6b,
   94|       |	0x6e, 0x71, 0x74, 0x78, 0x7b, 0x7e, 0x81, 0x85, 0x88, 0x8b, 0x8f, 0x92, 0x96, 0x99, 0x9d, 0xa0,
   95|       |	0xa4, 0xa8, 0xac, 0xaf, 0xb3, 0xb7, 0xbb, 0xbf, 0xc3, 0xc7, 0xcb, 0xcf, 0xd3, 0xd7, 0xdb, 0xe0
   96|       |};
   97|       |
   98|       |static unsigned char env_r_frise[128] = {
   99|       |	0xcf, 0xcc, 0xc9, 0xc6, 0xc3, 0xc0, 0xbd, 0xb9, 0xb4, 0xb0, 0xab, 0xa7, 0xa2, 0x9c, 0x97, 0x92,
  100|       |	0x8c, 0x86, 0x81, 0x7b, 0x75, 0x6f, 0x69, 0x63, 0x5d, 0x57, 0x50, 0x4a, 0x44, 0x3e, 0x38, 0x33,
  101|       |	0x2d, 0x27, 0x22, 0x1c, 0x17, 0x12, 0x0d, 0x08, 0x04, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,
  102|       |	0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x07, 0x08, 0x0a, 0x0c, 0x0d, 0x0f, 0x12, 0x14, 0x16,
  103|       |	0x19, 0x1b, 0x1e, 0x21, 0x24, 0x27, 0x2a, 0x2d, 0x30, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3f, 0x41,
  104|       |	0x43, 0x46, 0x48, 0x4b, 0x4d, 0x50, 0x52, 0x55, 0x58, 0x5a, 0x5d, 0x60, 0x63, 0x66, 0x69, 0x6c,
  105|       |	0x6f, 0x72, 0x75, 0x78, 0x7b, 0x7e, 0x81, 0x85, 0x88, 0x8b, 0x8f, 0x92, 0x96, 0x99, 0x9d, 0xa0,
  106|       |	0xa4, 0xa8, 0xac, 0xaf, 0xb3, 0xb7, 0xbb, 0xbf, 0xc3, 0xc7, 0xcb, 0xcf, 0xd3, 0xd7, 0xdb, 0xe0
  107|       |};
  108|       |
  109|       |static unsigned char env_frise2[128] = {
  110|       |	0xff, 0xf9, 0xf4, 0xee, 0xe9, 0xe4, 0xdf, 0xda, 0xd5, 0xd0, 0xcb, 0xc6, 0xc1, 0xbd, 0xb8, 0xb3,
  111|       |	0xaf, 0xaa, 0xa6, 0xa1, 0x9d, 0x99, 0x95, 0x90, 0x8c, 0x88, 0x84, 0x80, 0x7d, 0x79, 0x75, 0x71,
  112|       |	0x6e, 0x6a, 0x67, 0x63, 0x60, 0x5d, 0x59, 0x56, 0x53, 0x50, 0x4d, 0x4a, 0x47, 0x44, 0x41, 0x3e,
  113|       |	0x3c, 0x39, 0x37, 0x34, 0x32, 0x2f, 0x2d, 0x2b, 0x28, 0x26, 0x24, 0x22, 0x20, 0x1e, 0x1c, 0x1a,
  114|       |	0x19, 0x17, 0x15, 0x14, 0x12, 0x11, 0x0f, 0x0e, 0x0d, 0x0c, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05,
  115|       |	0x05, 0x04, 0x03, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  116|       |	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08,
  117|       |	0x09, 0x0a, 0x0b, 0x0c, 0x0e, 0x0f, 0x10, 0x12, 0x13, 0x15, 0x17, 0x18, 0x1a, 0x1c, 0x1e, 0x20
  118|       |};
  119|       |
  120|       |static unsigned char env_r_frise2[128] = {
  121|       |	0xd0, 0xce, 0xcd, 0xcc, 0xca, 0xc8, 0xc7, 0xc5, 0xc3, 0xc1, 0xc0, 0xbd, 0xbb, 0xb8, 0xb5, 0xb3,
  122|       |	0xb0, 0xad, 0xaa, 0xa7, 0xa3, 0xa0, 0x9d, 0x99, 0x96, 0x92, 0x8f, 0x8b, 0x87, 0x84, 0x80, 0x7c,
  123|       |	0x78, 0x74, 0x70, 0x6d, 0x69, 0x65, 0x61, 0x5d, 0x59, 0x55, 0x51, 0x4d, 0x4a, 0x46, 0x42, 0x3e,
  124|       |	0x3b, 0x37, 0x34, 0x31, 0x2f, 0x2d, 0x2a, 0x28, 0x26, 0x24, 0x22, 0x20, 0x1e, 0x1c, 0x1a, 0x19,
  125|       |	0x17, 0x15, 0x14, 0x12, 0x11, 0x0f, 0x0e, 0x0d, 0x0c, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x05,
  126|       |	0x04, 0x03, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  127|       |	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08,
  128|       |	0x09, 0x0a, 0x0b, 0x0c, 0x0e, 0x0f, 0x10, 0x12, 0x13, 0x15, 0x17, 0x18, 0x1a, 0x1c, 0x1e, 0x20
  129|       |};
  130|       |
  131|       |static unsigned char env_risefall[128] = {
  132|       |	0x98, 0x99, 0x99, 0x9a, 0x9c, 0x9d, 0x9f, 0xa1, 0xa4, 0xa7, 0xa9, 0xac, 0xb0, 0xb3, 0xb6, 0xba,
  133|       |	0xbe, 0xc1, 0xc5, 0xc9, 0xcd, 0xd1, 0xd4, 0xd8, 0xdc, 0xdf, 0xe3, 0xe6, 0xea, 0xed, 0xf0, 0xf2,
  134|       |	0xf5, 0xf7, 0xf9, 0xfb, 0xfc, 0xfd, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfd,
  135|       |	0xfb, 0xfa, 0xf8, 0xf6, 0xf3, 0xf1, 0xee, 0xec, 0xe9, 0xe6, 0xe4, 0xe0, 0xdd, 0xda, 0xd7, 0xd3,
  136|       |	0xd0, 0xcc, 0xc8, 0xc4, 0xc0, 0xbc, 0xb8, 0xb4, 0xb0, 0xac, 0xa7, 0xa3, 0x9f, 0x9a, 0x96, 0x91,
  137|       |	0x8d, 0x88, 0x84, 0x7f, 0x7b, 0x76, 0x72, 0x6d, 0x69, 0x65, 0x60, 0x5c, 0x58, 0x54, 0x50, 0x4c,
  138|       |	0x48, 0x44, 0x40, 0x3c, 0x39, 0x35, 0x32, 0x2f, 0x2b, 0x28, 0x26, 0x23, 0x20, 0x1d, 0x1a, 0x17,
  139|       |	0x15, 0x12, 0x0f, 0x0d, 0x0a, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00
  140|       |};
  141|       |
  142|       |static unsigned char env_rise2[128] = {
  143|       |	0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06,
  144|       |	0x07, 0x08, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
  145|       |	0x16, 0x17, 0x18, 0x19, 0x1b, 0x1c, 0x1d, 0x1f, 0x20, 0x22, 0x23, 0x25, 0x26, 0x28, 0x29, 0x2b,
  146|       |	0x2d, 0x2f, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x47, 0x49, 0x4b,
  147|       |	0x4e, 0x50, 0x52, 0x55, 0x57, 0x5a, 0x5d, 0x5f, 0x62, 0x65, 0x67, 0x6a, 0x6d, 0x70, 0x73, 0x76,
  148|       |	0x79, 0x7c, 0x7f, 0x82, 0x86, 0x89, 0x8c, 0x90, 0x93, 0x96, 0x9a, 0x9d, 0xa0, 0xa3, 0xa6, 0xa9,
  149|       |	0xac, 0xaf, 0xb2, 0xb5, 0xb8, 0xbb, 0xbe, 0xc1, 0xc4, 0xc7, 0xca, 0xcd, 0xd0, 0xd3, 0xd6, 0xd9,
  150|       |	0xdc, 0xdf, 0xe2, 0xe4, 0xe7, 0xe9, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfb, 0xfd
  151|       |};
  152|       |
  153|       |static unsigned char env_fall2[128] = {
  154|       |	0xfe, 0xfe, 0xfd, 0xfd, 0xfc, 0xfb, 0xfb, 0xfa, 0xfa, 0xf9, 0xf8, 0xf8, 0xf7, 0xf7, 0xf6, 0xf6,
  155|       |	0xf5, 0xf4, 0xf4, 0xf3, 0xf3, 0xf2, 0xf2, 0xf1, 0xf0, 0xf0, 0xef, 0xee, 0xee, 0xed, 0xec, 0xeb,
  156|       |	0xea, 0xea, 0xe9, 0xe8, 0xe7, 0xe6, 0xe5, 0xe4, 0xe3, 0xe2, 0xe1, 0xe0, 0xde, 0xdd, 0xdc, 0xdb,
  157|       |	0xd9, 0xd8, 0xd6, 0xd5, 0xd3, 0xd2, 0xd0, 0xce, 0xcc, 0xcb, 0xc9, 0xc7, 0xc5, 0xc3, 0xc0, 0xbe,
  158|       |	0xbc, 0xb9, 0xb7, 0xb5, 0xb2, 0xaf, 0xad, 0xaa, 0xa7, 0xa4, 0xa1, 0x9e, 0x9a, 0x97, 0x94, 0x90,
  159|       |	0x8d, 0x89, 0x85, 0x81, 0x7d, 0x79, 0x75, 0x71, 0x6d, 0x68, 0x64, 0x61, 0x5e, 0x5b, 0x57, 0x54,
  160|       |	0x51, 0x4d, 0x4a, 0x46, 0x43, 0x40, 0x3c, 0x39, 0x35, 0x32, 0x2e, 0x2a, 0x27, 0x23, 0x1f, 0x1c,
  161|       |	0x18, 0x14, 0x11, 0x0d, 0x0b, 0x09, 0x07, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00
  162|       |};
  163|       |
  164|       |static unsigned char env_fallrise3[128] = {
  165|       |	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfd, 0xfc, 0xfa, 0xf8, 0xf6, 0xf4, 0xf1, 0xee, 0xeb,
  166|       |	0xe8, 0xe5, 0xe1, 0xde, 0xda, 0xd6, 0xd2, 0xcd, 0xc9, 0xc4, 0xbf, 0xba, 0xb6, 0xb0, 0xab, 0xa6,
  167|       |	0xa1, 0x9c, 0x96, 0x91, 0x8b, 0x86, 0x80, 0x7b, 0x75, 0x6f, 0x6a, 0x64, 0x5f, 0x59, 0x54, 0x4f,
  168|       |	0x49, 0x44, 0x3f, 0x3a, 0x35, 0x30, 0x2b, 0x26, 0x22, 0x1d, 0x19, 0x15, 0x11, 0x0d, 0x0a, 0x07,
  169|       |	0x04, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x04, 0x05,
  170|       |	0x07, 0x09, 0x0b, 0x0d, 0x10, 0x12, 0x15, 0x18, 0x1b, 0x1e, 0x22, 0x25, 0x29, 0x2d, 0x31, 0x35,
  171|       |	0x3a, 0x3e, 0x43, 0x48, 0x4c, 0x51, 0x57, 0x5b, 0x5e, 0x62, 0x65, 0x68, 0x6b, 0x6e, 0x71, 0x74,
  172|       |	0x76, 0x78, 0x7b, 0x7c, 0x7e, 0x80, 0x81, 0x82, 0x83, 0x83, 0x84, 0x84, 0x83, 0x83, 0x82, 0x81
  173|       |};
  174|       |
  175|       |static unsigned char env_fallrise4[128] = {
  176|       |	0x72, 0x72, 0x71, 0x71, 0x70, 0x6f, 0x6d, 0x6c, 0x6a, 0x68, 0x66, 0x64, 0x61, 0x5f, 0x5c, 0x5a,
  177|       |	0x57, 0x54, 0x51, 0x4e, 0x4b, 0x48, 0x45, 0x42, 0x3f, 0x3b, 0x38, 0x35, 0x32, 0x2f, 0x2c, 0x29,
  178|       |	0x26, 0x23, 0x20, 0x1d, 0x1b, 0x18, 0x16, 0x14, 0x12, 0x10, 0x0e, 0x0c, 0x0b, 0x0a, 0x09, 0x08,
  179|       |	0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06,
  180|       |	0x07, 0x07, 0x08, 0x09, 0x0a, 0x0c, 0x0d, 0x0f, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1b, 0x1d, 0x20,
  181|       |	0x23, 0x26, 0x29, 0x2c, 0x2f, 0x33, 0x37, 0x3b, 0x3f, 0x43, 0x47, 0x4c, 0x51, 0x56, 0x5b, 0x60,
  182|       |	0x65, 0x6a, 0x6f, 0x74, 0x79, 0x7f, 0x84, 0x89, 0x8f, 0x95, 0x9b, 0xa1, 0xa7, 0xad, 0xb3, 0xba,
  183|       |	0xc0, 0xc7, 0xce, 0xd5, 0xdc, 0xe3, 0xea, 0xf1, 0xf5, 0xf7, 0xfa, 0xfc, 0xfd, 0xfe, 0xff, 0xff
  184|       |};
  185|       |
  186|       |static unsigned char env_risefallrise[128] = {
  187|       |	0x7f, 0x7f, 0x7f, 0x80, 0x81, 0x83, 0x84, 0x87, 0x89, 0x8c, 0x8f, 0x92, 0x96, 0x99, 0x9d, 0xa1,
  188|       |	0xa5, 0xaa, 0xae, 0xb2, 0xb7, 0xbb, 0xc0, 0xc5, 0xc9, 0xcd, 0xd2, 0xd6, 0xda, 0xde, 0xe2, 0xe6,
  189|       |	0xea, 0xed, 0xf0, 0xf3, 0xf5, 0xf8, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xfe, 0xfd, 0xfc, 0xfb, 0xf9,
  190|       |	0xf7, 0xf4, 0xf0, 0xec, 0xe7, 0xe2, 0xdc, 0xd5, 0xce, 0xc6, 0xbd, 0xb4, 0xa9, 0x9e, 0x92, 0x88,
  191|       |	0x82, 0x7d, 0x77, 0x72, 0x6c, 0x66, 0x60, 0x5a, 0x54, 0x4e, 0x49, 0x42, 0x3c, 0x37, 0x32, 0x2d,
  192|       |	0x28, 0x24, 0x1f, 0x1b, 0x18, 0x14, 0x11, 0x0e, 0x0c, 0x09, 0x07, 0x06, 0x05, 0x04, 0x04, 0x04,
  193|       |	0x04, 0x05, 0x06, 0x08, 0x0a, 0x0d, 0x10, 0x14, 0x18, 0x1d, 0x23, 0x29, 0x2f, 0x37, 0x3e, 0x47,
  194|       |	0x50, 0x5a, 0x64, 0x70, 0x7c, 0x83, 0x85, 0x88, 0x8a, 0x8c, 0x8e, 0x8f, 0x91, 0x92, 0x93, 0x93
  195|       |};
  196|       |
  197|       |unsigned char *envelope_data[N_ENVELOPE_DATA] = {
  198|       |	env_fall,  env_fall,
  199|       |	env_rise,  env_rise,
  200|       |	env_frise,  env_r_frise,
  201|       |	env_frise2, env_r_frise2,
  202|       |	env_risefall, env_risefall,
  203|       |
  204|       |	env_fallrise3, env_fallrise3,
  205|       |	env_fallrise4, env_fallrise4,
  206|       |	env_fall2, env_fall2,
  207|       |	env_rise2, env_rise2,
  208|       |	env_risefallrise, env_risefallrise
  209|       |};
  210|       |
  211|       |// indexed by stress
  212|       |static int min_drop[] =  { 6, 7, 9, 9, 20, 20, 20, 25 };
  213|       |
  214|       |// pitch change during the main part of the clause
  215|       |static int drops_0[8] = { 9, 9, 16, 16, 16, 23, 55, 32 };
  216|       |
  217|       |// overflow table values are 64ths of the body pitch range (between body_start and body_end)
  218|       |static signed char oflow[] = { 0, 40, 24, 8, 0 };
  219|       |static signed char oflow_emf[] = { 10, 52, 32, 20, 10 };
  220|       |static signed char oflow_less[] = { 6, 38, 24, 14, 4 };
  221|       |
  222|       |#define N_TONE_HEAD_TABLE    13
  223|       |#define N_TONE_NUCLEUS_TABLE 13
  224|       |
  225|       |typedef struct {
  226|       |	unsigned char pre_start;
  227|       |	unsigned char pre_end;
  228|       |
  229|       |	unsigned char body_start;
  230|       |	unsigned char body_end;
  231|       |
  232|       |	int  *body_drops;
  233|       |	unsigned char body_max_steps;
  234|       |	char body_lower_u;
  235|       |
  236|       |	unsigned char n_overflow;
  237|       |	signed char *overflow;
  238|       |} TONE_HEAD;
  239|       |
  240|       |typedef struct {
  241|       |	unsigned char pitch_env0; // pitch envelope, tonic syllable at end
  242|       |	unsigned char tonic_max0;
  243|       |	unsigned char tonic_min0;
  244|       |
  245|       |	unsigned char pitch_env1; // followed by unstressed
  246|       |	unsigned char tonic_max1;
  247|       |	unsigned char tonic_min1;
  248|       |
  249|       |	short *backwards;
  250|       |
  251|       |	unsigned char tail_start;
  252|       |	unsigned char tail_end;
  253|       |	unsigned char flags;
  254|       |} TONE_NUCLEUS;
  255|       |
  256|      0|#define T_EMPH  1
  257|       |
  258|       |static TONE_HEAD tone_head_table[N_TONE_HEAD_TABLE] = {
  259|       |	{ 46, 57,   78, 50,  drops_0, 3, 7,   5, oflow },      // 0 statement
  260|       |	{ 46, 57,   78, 46,  drops_0, 3, 7,   5, oflow },      // 1 comma
  261|       |	{ 46, 57,   78, 46,  drops_0, 3, 7,   5, oflow },      // 2 question
  262|       |	{ 46, 57,   90, 50,  drops_0, 3, 9,   5, oflow_emf },  // 3 exclamation
  263|       |	{ 46, 57,   78, 50,  drops_0, 3, 7,   5, oflow },      // 4 statement, emphatic
  264|       |	{ 46, 57,   74, 55,  drops_0, 4, 7,   5, oflow_less }, // 5 statement, less intonation
  265|       |	{ 46, 57,   74, 55,  drops_0, 4, 7,   5, oflow_less }, // 6 comma, less intonation
  266|       |	{ 46, 57,   74, 55,  drops_0, 4, 7,   5, oflow_less }, // 7 comma, less intonation, less rise
  267|       |	{ 46, 57,   78, 50,  drops_0, 3, 7,   5, oflow },      // 8 pitch raises at end of sentence
  268|       |	{ 46, 57,   78, 46,  drops_0, 3, 7,   5, oflow },      // 9 comma
  269|       |	{ 46, 57,   78, 50,  drops_0, 3, 7,   5, oflow },      // 10  question
  270|       |	{ 34, 41,   41, 32,  drops_0, 3, 7,   5, oflow_less }, // 11 test
  271|       |	{ 46, 57,   55, 50,  drops_0, 3, 7,   5, oflow_less }, // 12 test
  272|       |};
  273|       |
  274|       |static TONE_NUCLEUS tone_nucleus_table[N_TONE_NUCLEUS_TABLE] = {
  275|       |	{ PITCHfall,   64,  8, PITCHfall,   70, 18, NULL, 24, 12, 0 },      //  0 statement
  276|       |	{ PITCHfrise,  80, 18, PITCHfrise2, 78, 22, NULL, 34, 52, 0 },      //  1 comma
  277|       |	{ PITCHfrise,  88, 22, PITCHfrise2, 82, 22, NULL, 34, 64, 0 },      //  2 question
  278|       |	{ PITCHfall,   92,  8, PITCHfall,   92, 80, NULL, 76,  8, T_EMPH }, //  3 exclamation
  279|       |	{ PITCHfall,   86,  4, PITCHfall,   94, 66, NULL, 34, 10, 0 },      //  4 statement, emphatic
  280|       |	{ PITCHfall,   62, 10, PITCHfall,   62, 20, NULL, 28, 16, 0 },      //  5 statement, less intonation
  281|       |	{ PITCHfrise,  68, 18, PITCHfrise2, 68, 22, NULL, 30, 44, 0 },      //  6 comma, less intonation
  282|       |	{ PITCHfrise2, 64, 16, PITCHfall,   66, 32, NULL, 32, 18, 0 },      //  7 comma, less intonation, less rise
  283|       |	{ PITCHrise,   68, 46, PITCHfall,   42, 32, NULL, 46, 58, 0 },      //  8 pitch raises at end of sentence
  284|       |	{ PITCHfrise,  78, 24, PITCHfrise2, 72, 22, NULL, 42, 52, 0 },      //  9 comma
  285|       |	{ PITCHfrise,  88, 34, PITCHfall,   64, 32, NULL, 46, 82, 0 },      // 10 question
  286|       |	{ PITCHfall,   56, 12, PITCHfall,   56, 20, NULL, 24, 12, 0 },      // 11 test
  287|       |	{ PITCHfall,   70, 18, PITCHfall,   70, 24, NULL, 32, 20, 0 },      // 12 test
  288|       |};
  289|       |
  290|       |int n_tunes = 0;
  291|       |TUNE *tunes = NULL;
  292|       |
  293|      0|#define SECONDARY        3
  294|      0|#define PRIMARY          4
  295|      0|#define PRIMARY_STRESSED 6
  296|      0|#define PRIMARY_LAST     7
  297|       |
  298|       |static int number_pre;
  299|       |static int number_body;
  300|       |static int number_tail;
  301|       |static int last_primary;
  302|       |static int tone_posn;
  303|       |static int tone_posn2;
  304|       |static int no_tonic;
  305|       |
  306|       |static void count_pitch_vowels(SYLLABLE *syllable_tab, int start, int end, int clause_end)
  307|      0|{
  308|      0|	int ix;
  309|      0|	int stress;
  310|      0|	int max_stress = 0;
  311|      0|	int max_stress_posn = 0;  // last syllable ot the highest stress
  312|      0|	int max_stress_posn2 = 0; // penuntimate syllable of the highest stress
  313|      0|
  314|      0|	number_pre = -1; // number of vowels before 1st primary stress
  315|      0|	number_body = 0;
  316|      0|	number_tail = 0; // number between tonic syllable and next primary
  317|      0|	last_primary = -1;
  318|      0|
  319|      0|	for (ix = start; ix < end; ix++) {
  320|      0|		stress = syllable_tab[ix].stress; // marked stress level
  321|      0|
  322|      0|		if (stress >= max_stress) {
  323|      0|			if (stress > max_stress)
  324|      0|				max_stress_posn2 = ix;
  325|      0|			else
  326|      0|				max_stress_posn2 = max_stress_posn;
  327|      0|			max_stress_posn = ix;
  328|      0|			max_stress = stress;
  329|      0|		}
  330|      0|		if (stress >= PRIMARY) {
  331|      0|			if (number_pre < 0)
  332|      0|				number_pre = ix - start;
  333|      0|
  334|      0|			last_primary = ix;
  335|      0|		}
  336|      0|	}
  337|      0|
  338|      0|	if (number_pre < 0)
  339|      0|		number_pre = end;
  340|      0|
  341|      0|	number_tail = end - max_stress_posn - 1;
  342|      0|	tone_posn = max_stress_posn;
  343|      0|	tone_posn2 = max_stress_posn2;
  344|      0|
  345|      0|	if (no_tonic)
  346|      0|		tone_posn = tone_posn2 = end; // next position after the end of the truncated clause
  347|      0|	else if (last_primary >= 0) {
  348|      0|		if (end == clause_end)
  349|      0|			syllable_tab[last_primary].stress = PRIMARY_LAST;
  350|      0|	} else {
  351|      0|		// no primary stress. Use the highest stress
  352|      0|		syllable_tab[tone_posn].stress = PRIMARY_LAST;
  353|      0|	}
  354|      0|}
  355|       |
  356|       |// Count number of primary stresses up to tonic syllable or body_reset
  357|       |static int count_increments(SYLLABLE *syllable_tab, int ix, int end_ix, int min_stress)
  358|      0|{
  359|      0|	int count = 0;
  360|      0|	int stress;
  361|      0|
  362|      0|	while (ix < end_ix) {
  363|      0|		stress = syllable_tab[ix++].stress;
  364|      0|		if (stress >= PRIMARY_LAST)
  365|      0|			break;
  366|      0|
  367|      0|		if (stress >= min_stress)
  368|      0|			count++;
  369|      0|	}
  370|      0|	return count;
  371|      0|}
  372|       |
  373|       |// Set the pitch of a vowel in syllable_tab
  374|       |static void set_pitch(SYLLABLE *syl, int base, int drop)
  375|      0|{
  376|      0|	int pitch1, pitch2;
  377|      0|	int flags = 0;
  378|      0|
  379|      0|	if (base < 0)  base = 0;
  380|      0|
  381|      0|	pitch2 = base;
  382|      0|
  383|      0|	if (drop < 0) {
  384|      0|		flags = SYL_RISE;
  385|      0|		drop = -drop;
  386|      0|	}
  387|      0|
  388|      0|	pitch1 = pitch2 + drop;
  389|      0|	if (pitch1 < 0)
  390|      0|		pitch1 = 0;
  391|      0|
  392|      0|	if (pitch1 > 254) pitch1 = 254;
  393|      0|	if (pitch2 > 254) pitch2 = 254;
  394|      0|
  395|      0|	syl->pitch1 = pitch1;
  396|      0|	syl->pitch2 = pitch2;
  397|      0|	syl->flags |= flags;
  398|      0|}
  399|       |
  400|       |static int CountUnstressed(SYLLABLE *syllable_tab, int start, int end, int limit)
  401|      0|{
  402|      0|	int ix;
  403|      0|
  404|      0|	for (ix = start; ix <= end; ix++) {
  405|      0|		if (syllable_tab[ix].stress >= limit)
  406|      0|			break;
  407|      0|	}
  408|      0|	return ix - start;
  409|      0|}
  410|       |
  411|       |static int SetHeadIntonation(SYLLABLE *syllable_tab, TUNE *tune, int syl_ix, int end_ix)
  412|      0|{
  413|      0|	int stress;
  414|      0|	SYLLABLE *syl;
  415|      0|	int ix;
  416|      0|	int pitch = 0;
  417|      0|	int increment = 0;
  418|      0|	int n_steps = 0;
  419|      0|	int stage; // onset, head, last
  420|      0|	bool initial;
  421|      0|	int overflow_ix = 0;
  422|      0|	int pitch_range;
  423|      0|	int pitch_range_abs;
  424|      0|	int *drops;
  425|      0|	int n_unstressed = 0;
  426|      0|	int unstressed_ix = 0;
  427|      0|	int unstressed_inc;
  428|      0|	bool used_onset = false;
  429|      0|	int head_final = end_ix;
  430|      0|	int secondary = 2;
  431|      0|
  432|      0|	pitch_range = (tune->head_end - tune->head_start) << 8;
  433|      0|	pitch_range_abs = abs(pitch_range);
  434|      0|	drops = drops_0; // this should be controlled by tune->head_drops
  435|      0|	initial = true;
  436|      0|
  437|      0|	stage = 0;
  438|      0|	if (tune->onset == 255)
  439|      0|		stage = 1; // no onset specified
  440|      0|
  441|      0|	if (tune->head_last != 255) {
  442|      0|		// find the last primary stress in the body
  443|      0|		for (ix = end_ix-1; ix >= syl_ix; ix--) {
  444|      0|			if (syllable_tab[ix].stress >= 4) {
  445|      0|				head_final = ix;
  446|      0|				break;
  447|      0|			}
  448|      0|		}
  449|      0|	}
  450|      0|
  451|      0|	while (syl_ix < end_ix) {
  452|      0|		syl = &syllable_tab[syl_ix];
  453|      0|		stress = syl->stress;
  454|      0|
  455|      0|		if (initial || (stress >= 4)) {
  456|      0|			// a primary stress
  457|      0|
  458|      0|			if ((initial) || (stress == 5)) {
  459|      0|				initial = false;
  460|      0|				overflow_ix = 0;
  461|      0|
  462|      0|				if (tune->onset == 255) {
  463|      0|					n_steps = count_increments(syllable_tab, syl_ix, head_final, 4);
  464|      0|					pitch = tune->head_start << 8;
  465|      0|				} else {
  466|      0|					// a pitch has been specified for the onset syllable, don't include it in the pitch incrementing
  467|      0|					n_steps = count_increments(syllable_tab, syl_ix+1, head_final, 4);
  468|      0|					pitch = tune->onset << 8;
  469|      0|					used_onset = true;
  470|      0|				}
  471|      0|
  472|      0|				if (n_steps > tune->head_max_steps)
  473|      0|					n_steps = tune->head_max_steps;
  474|      0|
  475|      0|				if (n_steps > 1)
  476|      0|					increment = pitch_range / (n_steps -1);
  477|      0|				else
  478|      0|					increment = 0;
  479|      0|			} else if (syl_ix == head_final) {
  480|      0|				// a pitch has been specified for the last primary stress before the nucleus
  481|      0|				pitch = tune->head_last << 8;
  482|      0|				stage = 2;
  483|      0|			} else {
  484|      0|				if (used_onset) {
  485|      0|					stage = 1;
  486|      0|					used_onset = false;
  487|      0|					pitch = tune->head_start << 8;
  488|      0|					n_steps++;
  489|      0|				} else if (n_steps > 0)
  490|      0|					pitch += increment;
  491|      0|				else {
  492|      0|					pitch = (tune->head_end << 8) + (pitch_range_abs * tune->head_extend[overflow_ix++])/64;
  493|      0|					if (overflow_ix >= tune->n_head_extend)
  494|      0|						overflow_ix = 0;
  495|      0|				}
  496|      0|			}
  497|      0|
  498|      0|			n_steps--;
  499|      0|		}
  500|      0|
  501|      0|		if (stress >= PRIMARY) {
  502|      0|			n_unstressed = CountUnstressed(syllable_tab, syl_ix+1, end_ix, secondary);
  503|      0|			unstressed_ix = 0;
  504|      0|			syl->stress = PRIMARY_STRESSED;
  505|      0|			syl->env = tune->stressed_env;
  506|      0|			set_pitch(syl, (pitch >> 8), tune->stressed_drop);
  507|      0|		} else if (stress >= secondary) {
  508|      0|			n_unstressed = CountUnstressed(syllable_tab, syl_ix+1, end_ix, secondary);
  509|      0|			unstressed_ix = 0;
  510|      0|			set_pitch(syl, (pitch >> 8), drops[stress]);
  511|      0|		} else {
  512|      0|			if (n_unstressed > 1)
  513|      0|				unstressed_inc = (tune->unstr_end[stage] - tune->unstr_start[stage]) / (n_unstressed - 1);
  514|      0|			else
  515|      0|				unstressed_inc = 0;
  516|      0|
  517|      0|			set_pitch(syl, (pitch >> 8) + tune->unstr_start[stage] + (unstressed_inc * unstressed_ix), drops[stress]);
  518|      0|			unstressed_ix++;
  519|      0|		}
  520|      0|
  521|      0|		syl_ix++;
  522|      0|	}
  523|      0|	return syl_ix;
  524|      0|}
  525|       |
  526|       |/* Calculate pitches until next RESET or tonic syllable, or end.
  527|       |    Increment pitch if stress is >= min_stress.
  528|       |    Used for tonic segment */
  529|       |static int calc_pitch_segment(SYLLABLE *syllable_tab, int ix, int end_ix, TONE_HEAD *th, TONE_NUCLEUS *tn, int min_stress, bool continuing)
  530|      0|{
  531|      0|	int stress;
  532|      0|	int pitch = 0;
  533|      0|	int increment = 0;
  534|      0|	int n_primary = 0;
  535|      0|	int n_steps = 0;
  536|      0|	bool initial;
  537|      0|	int overflow = 0;
  538|      0|	int n_overflow;
  539|      0|	int pitch_range;
  540|      0|	int pitch_range_abs;
  541|      0|	int *drops;
  542|      0|	signed char *overflow_tab;
  543|      0|	SYLLABLE *syl;
  544|      0|
  545|      0|	static signed char continue_tab[5] = { -26, 32, 20, 8, 0 };
  546|      0|
  547|      0|	drops = th->body_drops;
  548|      0|	pitch_range = (th->body_end - th->body_start) << 8;
  549|      0|	pitch_range_abs = abs(pitch_range);
  550|      0|
  551|      0|	if (continuing) {
  552|      0|		initial = false;
  553|      0|		overflow = 0;
  554|      0|		n_overflow = 5;
  555|      0|		overflow_tab = continue_tab;
  556|      0|		increment = pitch_range / (th->body_max_steps -1);
  557|      0|	} else {
  558|      0|		n_overflow = th->n_overflow;
  559|      0|		overflow_tab = th->overflow;
  560|      0|		initial = true;
  561|      0|	}
  562|      0|
  563|      0|	while (ix < end_ix) {
  564|      0|		syl = &syllable_tab[ix];
  565|      0|		stress = syl->stress;
  566|      0|
  567|      0|		if (initial || (stress >= min_stress)) {
  568|      0|			// a primary stress
  569|      0|
  570|      0|			if ((initial) || (stress == 5)) {
  571|      0|				initial = false;
  572|      0|				overflow = 0;
  573|      0|				n_steps = n_primary = count_increments(syllable_tab, ix, end_ix, min_stress);
  574|      0|
  575|      0|				if (n_steps > th->body_max_steps)
  576|      0|					n_steps = th->body_max_steps;
  577|      0|
  578|      0|				if (n_steps > 1)
  579|      0|					increment = pitch_range / (n_steps -1);
  580|      0|				else
  581|      0|					increment = 0;
  582|      0|
  583|      0|				pitch = th->body_start << 8;
  584|      0|			} else {
  585|      0|				if (n_steps > 0)
  586|      0|					pitch += increment;
  587|      0|				else {
  588|      0|					pitch = (th->body_end << 8) + (pitch_range_abs * overflow_tab[overflow++])/64;
  589|      0|					if (overflow >= n_overflow) {
  590|      0|						overflow = 0;
  591|      0|						overflow_tab = th->overflow;
  592|      0|					}
  593|      0|				}
  594|      0|			}
  595|      0|
  596|      0|			n_steps--;
  597|      0|
  598|      0|			n_primary--;
  599|      0|			if ((tn->backwards) && (n_primary < 2))
  600|      0|				pitch = tn->backwards[n_primary] << 8;
  601|      0|		}
  602|      0|
  603|      0|		if (stress >= PRIMARY) {
  604|      0|			syl->stress = PRIMARY_STRESSED;
  605|      0|			set_pitch(syl, (pitch >> 8), drops[stress]);
  606|      0|		} else if (stress >= SECONDARY)
  607|      0|			set_pitch(syl, (pitch >> 8), drops[stress]);
  608|      0|		else {
  609|      0|			// unstressed, drop pitch if preceded by PRIMARY
  610|      0|			if ((syllable_tab[ix-1].stress & 0x3f) >= SECONDARY)
  611|      0|				set_pitch(syl, (pitch >> 8) - th->body_lower_u, drops[stress]);
  612|      0|			else
  613|      0|				set_pitch(syl, (pitch >> 8), drops[stress]);
  614|      0|		}
  615|      0|
  616|      0|		ix++;
  617|      0|	}
  618|      0|	return ix;
  619|      0|}
  620|       |
  621|       |static void SetPitchGradient(SYLLABLE *syllable_tab, int start_ix, int end_ix, int start_pitch, int end_pitch)
  622|      0|{
  623|      0|	// Set a linear pitch change over a number of syllables.
  624|      0|	// Used for pre-head, unstressed syllables in the body, and the tail
  625|      0|
  626|      0|	int ix;
  627|      0|	int stress;
  628|      0|	int pitch;
  629|      0|	int increment;
  630|      0|	int n_increments;
  631|      0|	int drop;
  632|      0|	SYLLABLE *syl;
  633|      0|
  634|      0|	increment = (end_pitch - start_pitch) << 8;
  635|      0|	n_increments = end_ix - start_ix;
  636|      0|
  637|      0|	if (n_increments <= 0)
  638|      0|		return;
  639|      0|
  640|      0|	if (n_increments > 1)
  641|      0|		increment = increment / n_increments;
  642|      0|
  643|      0|	pitch = start_pitch << 8;
  644|      0|
  645|      0|	for (ix = start_ix; ix < end_ix; ix++) {
  646|      0|		syl = &syllable_tab[ix];
  647|      0|		stress = syl->stress;
  648|      0|
  649|      0|		if (increment > 0) {
  650|      0|			set_pitch(syl, (pitch >> 8), -(increment >> 8));
  651|      0|			pitch += increment;
  652|      0|		} else {
  653|      0|			drop = -(increment >> 8);
  654|      0|			if (drop < min_drop[stress])
  655|      0|				drop = min_drop[stress];
  656|      0|
  657|      0|			pitch += increment;
  658|      0|
  659|      0|			if (drop > 18)
  660|      0|				drop = 18;
  661|      0|			set_pitch(syl, (pitch >> 8), drop);
  662|      0|		}
  663|      0|	}
  664|      0|}
  665|       |
  666|       |// Calculate pitch values for the vowels in this tone group
  667|       |static int calc_pitches2(SYLLABLE *syllable_tab, int start, int end,  int tune_number)
  668|      0|{
  669|      0|	int ix;
  670|      0|	TUNE *tune;
  671|      0|	int drop;
  672|      0|
  673|      0|	tune = &tunes[tune_number];
  674|      0|	ix = start;
  675|      0|
  676|      0|	// vowels before the first primary stress
  677|      0|
  678|      0|	SetPitchGradient(syllable_tab, ix, ix+number_pre, tune->prehead_start, tune->prehead_end);
  679|      0|	ix += number_pre;
  680|      0|
  681|      0|	// body of tonic segment
  682|      0|
  683|      0|	if (option_tone_flags & OPTION_EMPHASIZE_PENULTIMATE)
  684|      0|		tone_posn = tone_posn2; // put tone on the penultimate stressed word
  685|      0|	ix = SetHeadIntonation(syllable_tab, tune, ix, tone_posn);
  686|      0|
  687|      0|	if (no_tonic)
  688|      0|		return 0;
  689|      0|
  690|      0|	// tonic syllable
  691|      0|
  692|      0|	if (number_tail == 0) {
  693|      0|		tone_pitch_env = tune->nucleus0_env;
  694|      0|		drop = tune->nucleus0_max - tune->nucleus0_min;
  695|      0|		set_pitch(&syllable_tab[ix++], tune->nucleus0_min, drop);
  696|      0|	} else {
  697|      0|		tone_pitch_env = tune->nucleus1_env;
  698|      0|		drop = tune->nucleus1_max - tune->nucleus1_min;
  699|      0|		set_pitch(&syllable_tab[ix++], tune->nucleus1_min, drop);
  700|      0|	}
  701|      0|
  702|      0|	syllable_tab[tone_posn].env = tone_pitch_env;
  703|      0|	if (syllable_tab[tone_posn].stress == PRIMARY)
  704|      0|		syllable_tab[tone_posn].stress = PRIMARY_STRESSED;
  705|      0|
  706|      0|	// tail, after the tonic syllable
  707|      0|
  708|      0|	SetPitchGradient(syllable_tab, ix, end, tune->tail_start, tune->tail_end);
  709|      0|
  710|      0|	return tone_pitch_env;
  711|      0|}
  712|       |
  713|       |// Calculate pitch values for the vowels in this tone group
  714|       |static int calc_pitches(SYLLABLE *syllable_tab, int control, int start, int end,  int tune_number)
  715|      0|{
  716|      0|	int ix;
  717|      0|	TONE_HEAD *th;
  718|      0|	TONE_NUCLEUS *tn;
  719|      0|	int drop;
  720|      0|	bool continuing = false;
  721|      0|
  722|      0|	if (control == 0)
  723|      0|		return calc_pitches2(syllable_tab, start, end, tune_number);
  724|      0|
  725|      0|	if (start > 0)
  726|      0|		continuing = true;
  727|      0|
  728|      0|	th = &tone_head_table[tune_number];
  729|      0|	tn = &tone_nucleus_table[tune_number];
  730|      0|	ix = start;
  731|      0|
  732|      0|	// vowels before the first primary stress
  733|      0|
  734|      0|	SetPitchGradient(syllable_tab, ix, ix+number_pre, th->pre_start, th->pre_end);
  735|      0|	ix += number_pre;
  736|      0|
  737|      0|	// body of tonic segment
  738|      0|
  739|      0|	if (option_tone_flags & OPTION_EMPHASIZE_PENULTIMATE)
  740|      0|		tone_posn = tone_posn2; // put tone on the penultimate stressed word
  741|      0|	ix = calc_pitch_segment(syllable_tab, ix, tone_posn, th, tn, PRIMARY, continuing);
  742|      0|
  743|      0|	if (no_tonic)
  744|      0|		return 0;
  745|      0|
  746|      0|	// tonic syllable
  747|      0|
  748|      0|	if (tn->flags & T_EMPH)
  749|      0|		syllable_tab[ix].flags |= SYL_EMPHASIS;
  750|      0|
  751|      0|	if (number_tail == 0) {
  752|      0|		tone_pitch_env = tn->pitch_env0;
  753|      0|		drop = tn->tonic_max0 - tn->tonic_min0;
  754|      0|		set_pitch(&syllable_tab[ix++], tn->tonic_min0, drop);
  755|      0|	} else {
  756|      0|		tone_pitch_env = tn->pitch_env1;
  757|      0|		drop = tn->tonic_max1 - tn->tonic_min1;
  758|      0|		set_pitch(&syllable_tab[ix++], tn->tonic_min1, drop);
  759|      0|	}
  760|      0|
  761|      0|	syllable_tab[tone_posn].env = tone_pitch_env;
  762|      0|	if (syllable_tab[tone_posn].stress == PRIMARY)
  763|      0|		syllable_tab[tone_posn].stress = PRIMARY_STRESSED;
  764|      0|
  765|      0|	// tail, after the tonic syllable
  766|      0|
  767|      0|	SetPitchGradient(syllable_tab, ix, end, tn->tail_start, tn->tail_end);
  768|      0|
  769|      0|	return tone_pitch_env;
  770|      0|}
  771|       |
  772|       |static void CalcPitches_Tone(Translator *tr)
  773|      0|{
  774|      0|	PHONEME_LIST *p;
  775|      0|	int ix;
  776|      0|	int count_stressed = 0;
  777|      0|	int final_stressed = 0;
  778|      0|
  779|      0|	int tone_ph;
  780|      0|	bool pause;
  781|      0|	bool tone_promoted;
  782|      0|	PHONEME_TAB *tph;
  783|      0|	PHONEME_TAB *prev_tph; // forget across word boundary
  784|      0|	PHONEME_TAB *prevw_tph; // remember across word boundary
  785|      0|	PHONEME_LIST *prev_p;
  786|      0|
  787|      0|	int pitch_adjust = 0;    // pitch gradient through the clause - initial value
  788|      0|	int pitch_decrement = 0; // decrease by this for each stressed syllable
  789|      0|	int pitch_low = 0;       // until it drops to this
  790|      0|	int pitch_high = 0;      // then reset to this
  791|      0|
  792|      0|	// count number of stressed syllables
  793|      0|	p = &phoneme_list[0];
  794|      0|	for (ix = 0; ix < n_phoneme_list; ix++, p++) {
  795|      0|		if ((p->type == phVOWEL) && (p->stresslevel >= 4)) {
  796|      0|			if (count_stressed == 0)
  797|      0|				final_stressed = ix;
  798|      0|
  799|      0|			if (p->stresslevel >= 4) {
  800|      0|				final_stressed = ix;
  801|      0|				count_stressed++;
  802|      0|			}
  803|      0|		}
  804|      0|	}
  805|      0|
  806|      0|	phoneme_list[final_stressed].stresslevel = 7;
  807|      0|
  808|      0|	// language specific, changes to tones
  809|      0|	if (tr->translator_name == L('v', 'i')) {
  810|      0|		// LANG=vi
  811|      0|		p = &phoneme_list[final_stressed];
  812|      0|		if (p->tone_ph == 0)
  813|      0|			p->tone_ph = PhonemeCode('7'); // change default tone (tone 1) to falling tone at end of clause
  814|      0|	}
  815|      0|
  816|      0|	pause = true;
  817|      0|	tone_promoted = false;
  818|      0|
  819|      0|	prev_p = p = &phoneme_list[0];
  820|      0|	prev_tph = prevw_tph = phoneme_tab[phonPAUSE];
  821|      0|
  822|      0|	// perform tone sandhi
  823|      0|	for (ix = 0; ix < n_phoneme_list; ix++, p++) {
  824|      0|		if ((p->type == phPAUSE) && (p->ph->std_length > 50)) {
  825|      0|			pause = true; // there is a pause since the previous vowel
  826|      0|			prevw_tph = phoneme_tab[phonPAUSE]; // forget previous tone
  827|      0|		}
  828|      0|
  829|      0|		if (p->newword)
  830|      0|			prev_tph = phoneme_tab[phonPAUSE]; // forget across word boundaries
  831|      0|
  832|      0|		if (p->synthflags & SFLAG_SYLLABLE) {
  833|      0|			tone_ph = p->tone_ph;
  834|      0|			tph = phoneme_tab[tone_ph];
  835|      0|			
  836|      0|			/* Hakka
  837|      0|			ref.:https://en.wikipedia.org/wiki/Sixian_dialect#Tone_sandhi */
  838|      0|			if (tr->translator_name == L3('h','a','k')){
  839|      0|				if (prev_tph->mnemonic == 0x31){ // [previous one is 1st tone]
  840|      0|				  // [this one is 1st, 4th, or 6th tone]
  841|      0|				  if (tph->mnemonic == 0x31 || tph->mnemonic == 0x34 ||
  842|      0|					  tph->mnemonic == 0x36){
  843|      0|					/* trigger the tone sandhi of the prev. syllable
  844|      0|					   from 1st tone ->2nd tone */
  845|      0|					prev_p->tone_ph = PhonemeCode('2'); 
  846|      0|				  }
  847|      0|				}
  848|      0|			  }
  849|      0|			// Mandarin
  850|      0|			if (tr->translator_name == L('z', 'h') || tr->translator_name == L3('c', 'm', 'n')) {
  851|      0|				if (tone_ph == 0) {
  852|      0|					if (pause || tone_promoted) {
  853|      0|						tone_ph = PhonemeCode2('5', '5'); // no previous vowel, use tone 1
  854|      0|						tone_promoted = true;
  855|      0|					} else
  856|      0|						tone_ph = PhonemeCode2('1', '1'); // default tone 5
  857|      0|
  858|      0|					p->tone_ph = tone_ph;
  859|      0|					tph = phoneme_tab[tone_ph];
  860|      0|				} else
  861|      0|					tone_promoted = false;
  862|      0|
  863|      0|				if (ix == final_stressed) {
  864|      0|					if ((tph->mnemonic == 0x3535 ) || (tph->mnemonic == 0x3135)) {
  865|      0|						// change sentence final tone 1 or 4 to stress 6, not 7
  866|      0|						phoneme_list[final_stressed].stresslevel = 6;
  867|      0|					}
  868|      0|				}
  869|      0|
  870|      0|				if (prevw_tph->mnemonic == 0x343132) { // [214]
  871|      0|					if (tph->mnemonic == 0x343132) // [214]
  872|      0|						prev_p->tone_ph = PhonemeCode2('3', '5');
  873|      0|					else
  874|      0|						prev_p->tone_ph = PhonemeCode2('2', '1');
  875|      0|				}
  876|      0|				if ((prev_tph->mnemonic == 0x3135)  && (tph->mnemonic == 0x3135)) // [51] + [51]
  877|      0|					prev_p->tone_ph = PhonemeCode2('5', '3');
  878|      0|
  879|      0|				if (tph->mnemonic == 0x3131) { // [11] Tone 5
  880|      0|					// tone 5, change its level depending on the previous tone (across word boundaries)
  881|      0|					if (prevw_tph->mnemonic == 0x3535)
  882|      0|						p->tone_ph = PhonemeCode2('2', '2');
  883|      0|					if (prevw_tph->mnemonic == 0x3533)
  884|      0|						p->tone_ph = PhonemeCode2('3', '3');
  885|      0|					if (prevw_tph->mnemonic == 0x343132)
  886|      0|						p->tone_ph = PhonemeCode2('4', '4');
  887|      0|
  888|      0|					// tone 5 is unstressed (shorter)
  889|      0|					p->stresslevel = 0; // diminished stress
  890|      0|				}
  891|      0|			}
  892|      0|
  893|      0|			prev_p = p;
  894|      0|			prevw_tph = prev_tph = tph;
  895|      0|			pause = false;
  896|      0|		}
  897|      0|	}
  898|      0|
  899|      0|	// convert tone numbers to pitch
  900|      0|	p = &phoneme_list[0];
  901|      0|	for (ix = 0; ix < n_phoneme_list; ix++, p++) {
  902|      0|		if (p->synthflags & SFLAG_SYLLABLE) {
  903|      0|			tone_ph = p->tone_ph;
  904|      0|
  905|      0|			if (p->stresslevel != 0) { // TEST, consider all syllables as stressed
  906|      0|				if (ix == final_stressed) {
  907|      0|					// the last stressed syllable
  908|      0|					pitch_adjust = pitch_low;
  909|      0|				} else {
  910|      0|					pitch_adjust -= pitch_decrement;
  911|      0|					if (pitch_adjust <= pitch_low)
  912|      0|						pitch_adjust = pitch_high;
  913|      0|				}
  914|      0|			}
  915|      0|
  916|      0|			if (tone_ph == 0) {
  917|      0|				tone_ph = phonDEFAULTTONE; // no tone specified, use default tone 1
  918|      0|				p->tone_ph = tone_ph;
  919|      0|			}
  920|      0|			p->pitch1 = pitch_adjust + phoneme_tab[tone_ph]->start_type;
  921|      0|			p->pitch2 = pitch_adjust + phoneme_tab[tone_ph]->end_type;
  922|      0|		}
  923|      0|	}
  924|      0|}
  925|       |
  926|       |void CalcPitches(Translator *tr, int clause_type)
  927|      0|{
  928|      0|	// clause_type: 0=. 1=, 2=?, 3=! 4=none
  929|      0|
  930|      0|	PHONEME_LIST *p;
  931|      0|	SYLLABLE *syl;
  932|      0|	int ix;
  933|      0|	int x;
  934|      0|	int st_ix;
  935|      0|	int n_st;
  936|      0|	int option;
  937|      0|	int group_tone;
  938|      0|	int group_tone_comma;
  939|      0|	int ph_start = 0;
  940|      0|	int st_start;
  941|      0|	int st_clause_end;
  942|      0|	int count;
  943|      0|	int n_primary;
  944|      0|	int count_primary;
  945|      0|	PHONEME_TAB *ph;
  946|      0|	int ph_end = n_phoneme_list;
  947|      0|
  948|      0|	SYLLABLE syllable_tab[N_PHONEME_LIST];
  949|      0|	n_st = 0;
  950|      0|	n_primary = 0;
  951|      0|	for (ix = 0; ix < (n_phoneme_list-1); ix++) {
  952|      0|		p = &phoneme_list[ix];
  953|      0|		syllable_tab[ix].flags = 0;
  954|      0|		if (p->synthflags & SFLAG_SYLLABLE) {
  955|      0|			syllable_tab[n_st].env = PITCHfall;
  956|      0|			syllable_tab[n_st].nextph_type = phoneme_list[ix+1].type;
  957|      0|			syllable_tab[n_st++].stress = p->stresslevel;
  958|      0|
  959|      0|			if (p->stresslevel >= 4)
  960|      0|				n_primary++;
  961|      0|		} else if ((p->ph->code == phonPAUSE_CLAUSE) && (n_st > 0))
  962|      0|			syllable_tab[n_st-1].flags |= SYL_END_CLAUSE;
  963|      0|	}
  964|      0|	syllable_tab[n_st].stress = 0; // extra 0 entry at the end
  965|      0|
  966|      0|	if (n_st == 0)
  967|      0|		return; // nothing to do
  968|      0|
  969|      0|	if (tr->langopts.tone_language == 1) {
  970|      0|		CalcPitches_Tone(tr);
  971|      0|		return;
  972|      0|	}
  973|      0|
  974|      0|	option = tr->langopts.intonation_group;
  975|      0|	if (option >= INTONATION_TYPES)
  976|      0|		option = 1;
  977|      0|
  978|      0|	if (option == 0) {
  979|      0|		group_tone = tr->langopts.tunes[clause_type];
  980|      0|		group_tone_comma = tr->langopts.tunes[1];
  981|      0|	} else {
  982|      0|		group_tone = tr->punct_to_tone[option][clause_type];
  983|      0|		group_tone_comma = tr->punct_to_tone[option][1]; // emphatic form of statement
  984|      0|	}
  985|      0|
  986|      0|	if (clause_type == 4)
  987|      0|		no_tonic = 1; // incomplete clause, used for abbreviations such as Mr. Dr. Mrs.
  988|      0|	else
  989|      0|		no_tonic = 0;
  990|      0|
  991|      0|	st_start = 0;
  992|      0|	count_primary = 0;
  993|      0|	for (st_ix = 0; st_ix < n_st; st_ix++) {
  994|      0|		syl = &syllable_tab[st_ix];
  995|      0|
  996|      0|		if (syl->stress >= 4)
  997|      0|			count_primary++;
  998|      0|
  999|      0|		if (syl->stress == 6) {
 1000|      0|			// reduce the stress of the previous stressed syllable (review only the previous few syllables)
 1001|      0|			for (ix = st_ix-1; ix >= st_start && ix >= (st_ix-3); ix--) {
 1002|      0|				if (syllable_tab[ix].stress == 6)
 1003|      0|					break;
 1004|      0|				if (syllable_tab[ix].stress == 4) {
 1005|      0|					syllable_tab[ix].stress = 3;
 1006|      0|					break;
 1007|      0|				}
 1008|      0|			}
 1009|      0|
 1010|      0|			// are the next primary syllables also emphasized ?
 1011|      0|			for (ix = st_ix+1; ix < n_st; ix++) {
 1012|      0|				if (syllable_tab[ix].stress == 4)
 1013|      0|					break;
 1014|      0|				if (syllable_tab[ix].stress == 6) {
 1015|      0|					// emphasize this syllable, but don't end the current tone group
 1016|      0|					syllable_tab[st_ix].flags = SYL_EMPHASIS;
 1017|      0|					syl->stress = 5;
 1018|      0|					break;
 1019|      0|				}
 1020|      0|			}
 1021|      0|		}
 1022|      0|
 1023|      0|		if (syl->stress == 6) {
 1024|      0|			// an emphasized syllable, end the tone group after the next primary stress
 1025|      0|			syllable_tab[st_ix].flags = SYL_EMPHASIS;
 1026|      0|
 1027|      0|			count = 0;
 1028|      0|			if ((n_primary - count_primary) > 1)
 1029|      0|				count = 1;
 1030|      0|
 1031|      0|			for (ix = st_ix+1; ix < n_st; ix++) {
 1032|      0|				if (syllable_tab[ix].stress > 4)
 1033|      0|					break;
 1034|      0|				if (syllable_tab[ix].stress == 4) {
 1035|      0|					count++;
 1036|      0|					if (count > 1)
 1037|      0|						break;
 1038|      0|				}
 1039|      0|			}
 1040|      0|
 1041|      0|			count_pitch_vowels(syllable_tab, st_start, ix, n_st);
 1042|      0|			if ((ix < n_st) || (clause_type == 0)) {
 1043|      0|				calc_pitches(syllable_tab, option, st_start, ix, group_tone); // split into > 1 tone groups
 1044|      0|
 1045|      0|				if ((clause_type == 1) || (clause_type == 2))
 1046|      0|					group_tone = tr->langopts.tunes[1]; // , or ?  remainder has comma-tone
 1047|      0|				else
 1048|      0|					group_tone = tr->langopts.tunes[0]; // . or !  remainder has statement tone
 1049|      0|			} else
 1050|      0|				calc_pitches(syllable_tab, option, st_start, ix, group_tone);
 1051|      0|
 1052|      0|			st_start = ix;
 1053|      0|		}
 1054|      0|		if ((st_start < st_ix) && (syl->flags & SYL_END_CLAUSE)) {
 1055|      0|			// end of clause after this syllable, indicated by a phonPAUSE_CLAUSE phoneme
 1056|      0|			st_clause_end = st_ix+1;
 1057|      0|			count_pitch_vowels(syllable_tab, st_start, st_clause_end, st_clause_end);
 1058|      0|			calc_pitches(syllable_tab, option, st_start, st_clause_end, group_tone_comma);
 1059|      0|			st_start = st_clause_end;
 1060|      0|		}
 1061|      0|	}
 1062|      0|
 1063|      0|	if (st_start < st_ix) {
 1064|      0|		count_pitch_vowels(syllable_tab, st_start, st_ix, n_st);
 1065|      0|		calc_pitches(syllable_tab, option, st_start, st_ix, group_tone);
 1066|      0|	}
 1067|      0|
 1068|      0|	// unpack pitch data
 1069|      0|	st_ix = 0;
 1070|      0|	for (ix = ph_start; ix < ph_end; ix++) {
 1071|      0|		p = &phoneme_list[ix];
 1072|      0|		p->stresslevel = syllable_tab[st_ix].stress;
 1073|      0|
 1074|      0|		if (p->synthflags & SFLAG_SYLLABLE) {
 1075|      0|			syl = &syllable_tab[st_ix];
 1076|      0|
 1077|      0|			p->pitch1 = syl->pitch1;
 1078|      0|			p->pitch2 = syl->pitch2;
 1079|      0|
 1080|      0|			p->env = PITCHfall;
 1081|      0|			if (syl->flags & SYL_RISE)
 1082|      0|				p->env = PITCHrise;
 1083|      0|			else if (p->stresslevel > 5)
 1084|      0|				p->env = syl->env;
 1085|      0|
 1086|      0|			if (p->pitch1 > p->pitch2) {
 1087|      0|				// swap so that pitch2 is the higher
 1088|      0|				x = p->pitch1;
 1089|      0|				p->pitch1 = p->pitch2;
 1090|      0|				p->pitch2 = x;
 1091|      0|			}
 1092|      0|
 1093|      0|			if (p->tone_ph) {
 1094|      0|				ph = phoneme_tab[p->tone_ph];
 1095|      0|				x = (p->pitch1 + p->pitch2)/2;
 1096|      0|				p->pitch2 = x + ph->end_type;
 1097|      0|				p->pitch1 = x + ph->start_type;
 1098|      0|			}
 1099|      0|
 1100|      0|			if (syl->flags & SYL_EMPHASIS)
 1101|      0|				p->stresslevel |= 8; // emphasized
 1102|      0|
 1103|      0|			st_ix++;
 1104|      0|		}
 1105|      0|	}
 1106|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/klatt.c:
    1|       |/*
    2|       | * Copyright (C) 2008 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2013-2016 Reece H. Dunn
    5|       | *
    6|       | * Based on a re-implementation by:
    7|       | * (c) 1993,94 Jon Iles and Nick Ing-Simmons
    8|       | * of the Klatt cascade-parallel formant synthesizer
    9|       | *
   10|       | * This program is free software; you can redistribute it and/or modify
   11|       | * it under the terms of the GNU General Public License as published by
   12|       | * the Free Software Foundation; either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | *
   15|       | * This program is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU General Public License for more details.
   19|       | *
   20|       | * You should have received a copy of the GNU General Public License
   21|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   22|       | */
   23|       |
   24|       |// See URL: ftp://svr-ftp.eng.cam.ac.uk/pub/comp.speech/synthesis/klatt.3.04.tar.gz
   25|       |
   26|       |#include "config.h"
   27|       |
   28|       |#include <math.h>
   29|       |#include <stdint.h>
   30|       |#include <stdio.h>
   31|       |#include <stdlib.h>
   32|       |#include <string.h>
   33|       |
   34|       |#include <espeak-ng/espeak_ng.h>
   35|       |#include <espeak-ng/speak_lib.h>
   36|       |
   37|       |#include "klatt.h"
   38|       |#include "synthesize.h"  // for frame_t, WGEN_DATA, STEPSIZE, N_KLATTP, echo...
   39|       |#include "voice.h"       // for voice_t, N_PEAKS
   40|       |#ifdef INCLUDE_SPEECHPLAYER
   41|       |#include "sPlayer.h"
   42|       |#endif
   43|       |
   44|       |extern unsigned char *out_ptr;
   45|       |extern unsigned char *out_end;
   46|       |static int nsamples;
   47|       |static int sample_count;
   48|       |
   49|       |#ifdef _MSC_VER
   50|       |#define getrandom(min, max) ((rand()%(int)(((max)+1)-(min)))+(min))
   51|       |#else
   52|      0|#define getrandom(min, max) ((rand()%(long)(((max)+1)-(min)))+(min))
   53|       |#endif
   54|       |
   55|       |// function prototypes for functions private to this file
   56|       |
   57|       |static void flutter(klatt_frame_ptr);
   58|       |static double sampled_source(int);
   59|       |static double impulsive_source(void);
   60|       |static double natural_source(void);
   61|       |static void pitch_synch_par_reset(klatt_frame_ptr);
   62|       |static double gen_noise(double);
   63|       |static double DBtoLIN(long);
   64|       |static void frame_init(klatt_frame_ptr);
   65|       |static void setabc(long, long, resonator_ptr);
   66|       |static void SetSynth_Klatt(int length, frame_t *fr1, frame_t *fr2, voice_t *v, int control);
   67|       |static void setzeroabc(long, long, resonator_ptr);
   68|       |
   69|       |static klatt_frame_t kt_frame;
   70|       |static klatt_global_t kt_globals;
   71|       |
   72|      0|#define NUMBER_OF_SAMPLES 100
   73|       |
   74|       |static int scale_wav_tab[] = { 45, 38, 45, 45, 55, 45 }; // scale output from different voicing sources
   75|       |
   76|       |// For testing, this can be overwritten in KlattInit()
   77|       |static short natural_samples2[256] = {
   78|       |	 2583,  2516,  2450,  2384,  2319,  2254,  2191,  2127,
   79|       |	 2067,  2005,  1946,  1890,  1832,  1779,  1726,  1675,
   80|       |	 1626,  1579,  1533,  1491,  1449,  1409,  1372,  1336,
   81|       |	 1302,  1271,  1239,  1211,  1184,  1158,  1134,  1111,
   82|       |	 1089,  1069,  1049,  1031,  1013,   996,   980,   965,
   83|       |	  950,   936,   921,   909,   895,   881,   869,   855,
   84|       |	  843,   830,   818,   804,   792,   779,   766,   754,
   85|       |	  740,   728,   715,   702,   689,   676,   663,   651,
   86|       |	  637,   626,   612,   601,   588,   576,   564,   552,
   87|       |	  540,   530,   517,   507,   496,   485,   475,   464,
   88|       |	  454,   443,   434,   424,   414,   404,   394,   385,
   89|       |	  375,   366,   355,   347,   336,   328,   317,   308,
   90|       |	  299,   288,   280,   269,   260,   250,   240,   231,
   91|       |	  220,   212,   200,   192,   181,   172,   161,   152,
   92|       |	  142,   133,   123,   113,   105,    94,    86,    76,
   93|       |	   67,    57,    49,    39,    30,    22,    11,     4,
   94|       |	   -5,   -14,   -23,   -32,   -41,   -50,   -60,   -69,
   95|       |	  -78,   -87,   -96,  -107,  -115,  -126,  -134,  -144,
   96|       |	 -154,  -164,  -174,  -183,  -193,  -203,  -213,  -222,
   97|       |	 -233,  -242,  -252,  -262,  -271,  -281,  -291,  -301,
   98|       |	 -310,  -320,  -330,  -339,  -349,  -357,  -368,  -377,
   99|       |	 -387,  -397,  -406,  -417,  -426,  -436,  -446,  -456,
  100|       |	 -467,  -477,  -487,  -499,  -509,  -521,  -532,  -543,
  101|       |	 -555,  -567,  -579,  -591,  -603,  -616,  -628,  -641,
  102|       |	 -653,  -666,  -679,  -692,  -705,  -717,  -732,  -743,
  103|       |	 -758,  -769,  -783,  -795,  -808,  -820,  -834,  -845,
  104|       |	 -860,  -872,  -885,  -898,  -911,  -926,  -939,  -955,
  105|       |	 -968,  -986,  -999, -1018, -1034, -1054, -1072, -1094,
  106|       |	-1115, -1138, -1162, -1188, -1215, -1244, -1274, -1307,
  107|       |	-1340, -1377, -1415, -1453, -1496, -1538, -1584, -1631,
  108|       |	-1680, -1732, -1783, -1839, -1894, -1952, -2010, -2072,
  109|       |	-2133, -2196, -2260, -2325, -2390, -2456, -2522, -2589,
  110|       |};
  111|       |static short natural_samples[100] = {
  112|       |	 -310,  -400,   530,   356,   224,    89,   23,  -10, -58, -16, 461,  599,  536,   701,   770,
  113|       |	  605,   497,   461,   560,   404,   110,  224,  131, 104, -97, 155,  278, -154, -1165,
  114|       |	 -598,   737,   125,  -592,    41,    11, -247,  -10,  65,  92,  80, -304,   71,   167,    -1, 122,
  115|       |	  233,   161,   -43,   278,   479,   485,  407,  266, 650, 134,  80,  236,   68,   260,   269, 179,
  116|       |	   53,   140,   275,   293,   296,   104,  257,  152, 311, 182, 263,  245,  125,   314,   140, 44,
  117|       |	  203,   230,  -235,  -286,    23,   107,   92,  -91,  38, 464, 443,  176,   98,  -784, -2449,
  118|       |	-1891, -1045, -1600, -1462, -1384, -1261, -949, -730
  119|       |};
  120|       |
  121|       |/*
  122|       |   function RESONATOR
  123|       |
  124|       |   This is a generic resonator function. Internal memory for the resonator
  125|       |   is stored in the globals structure.
  126|       | */
  127|       |
  128|       |static double resonator(resonator_ptr r, double input)
  129|      0|{
  130|      0|	double x;
  131|      0|
  132|      0|	x = (double)((double)r->a * (double)input + (double)r->b * (double)r->p1 + (double)r->c * (double)r->p2);
  133|      0|	r->p2 = (double)r->p1;
  134|      0|	r->p1 = (double)x;
  135|      0|
  136|      0|	return (double)x;
  137|      0|}
  138|       |
  139|       |/*
  140|       |function ANTIRESONATOR
  141|       |
  142|       |This is a generic anti-resonator function. The code is the same as resonator
  143|       |except that a,b,c need to be set with setzeroabc() and we save inputs in
  144|       |p1/p2 rather than outputs. There is currently only one of these - "rnz"
  145|       |Output = (rnz.a * input) + (rnz.b * oldin1) + (rnz.c * oldin2)
  146|       |*/
  147|       |
  148|       |static double antiresonator(resonator_ptr r, double input)
  149|      0|{
  150|      0|	register double x = (double)r->a * (double)input + (double)r->b * (double)r->p1 + (double)r->c * (double)r->p2;
  151|      0|	r->p2 = (double)r->p1;
  152|      0|	r->p1 = (double)input;
  153|      0|	return (double)x;
  154|      0|}
  155|       |
  156|       |/*
  157|       |   function FLUTTER
  158|       |
  159|       |   This function adds F0 flutter, as specified in:
  160|       |
  161|       |   "Analysis, synthesis and perception of voice quality variations among
  162|       |   female and male talkers" D.H. Klatt and L.C. Klatt JASA 87(2) February 1990.
  163|       |
  164|       |   Flutter is added by applying a quasi-random element constructed from three
  165|       |   slowly varying sine waves.
  166|       | */
  167|       |
  168|       |static void flutter(klatt_frame_ptr frame)
  169|      0|{
  170|      0|	static int time_count;
  171|      0|	double delta_f0;
  172|      0|	double fla, flb, flc, fld, fle;
  173|      0|
  174|      0|	fla = (double)kt_globals.f0_flutter / 50;
  175|      0|	flb = (double)kt_globals.original_f0 / 100;
  176|      0|	flc = sin(M_PI*12.7*time_count); // because we are calling flutter() more frequently, every 2.9mS
  177|      0|	fld = sin(M_PI*7.1*time_count);
  178|      0|	fle = sin(M_PI*4.7*time_count);
  179|      0|	delta_f0 =  fla * flb * (flc + fld + fle) * 10;
  180|      0|	frame->F0hz10 = frame->F0hz10 + (long)delta_f0;
  181|      0|	time_count++;
  182|      0|}
  183|       |
  184|       |/*
  185|       |   function SAMPLED_SOURCE
  186|       |
  187|       |   Allows the use of a glottal excitation waveform sampled from a real
  188|       |   voice.
  189|       | */
  190|       |
  191|       |static double sampled_source(int source_num)
  192|      0|{
  193|      0|	int itemp;
  194|      0|	double ftemp;
  195|      0|	double result;
  196|      0|	double diff_value;
  197|      0|	int current_value;
  198|      0|	int next_value;
  199|      0|	double temp_diff;
  200|      0|	short *samples;
  201|      0|
  202|      0|	if (source_num == 0) {
  203|      0|		samples = natural_samples;
  204|      0|		kt_globals.num_samples = 100;
  205|      0|	} else {
  206|      0|		samples = natural_samples2;
  207|      0|		kt_globals.num_samples = 256;
  208|      0|	}
  209|      0|
  210|      0|	if (kt_globals.T0 != 0) {
  211|      0|		ftemp = (double)kt_globals.nper;
  212|      0|		ftemp = ftemp / kt_globals.T0;
  213|      0|		ftemp = ftemp * kt_globals.num_samples;
  214|      0|		itemp = (int)ftemp;
  215|      0|
  216|      0|		temp_diff = ftemp - (double)itemp;
  217|      0|
  218|      0|		current_value = samples[itemp];
  219|      0|		next_value = samples[itemp+1];
  220|      0|
  221|      0|		diff_value = (double)next_value - (double)current_value;
  222|      0|		diff_value = diff_value * temp_diff;
  223|      0|
  224|      0|		result = samples[itemp] + diff_value;
  225|      0|		result = result * kt_globals.sample_factor;
  226|      0|	} else
  227|      0|		result = 0;
  228|      0|	return result;
  229|      0|}
  230|       |
  231|       |/*
  232|       |   function PARWAVE
  233|       |
  234|       |   Converts synthesis parameters to a waveform.
  235|       | */
  236|       |
  237|       |static int parwave(klatt_frame_ptr frame, WGEN_DATA *wdata)
  238|      0|{
  239|      0|	double temp;
  240|      0|	int value;
  241|      0|	double outbypas;
  242|      0|	double out;
  243|      0|	long n4;
  244|      0|	double frics;
  245|      0|	double glotout;
  246|      0|	double aspiration;
  247|      0|	double casc_next_in;
  248|      0|	double par_glotout;
  249|      0|	static double noise;
  250|      0|	static double voice;
  251|      0|	static double vlast;
  252|      0|	static double glotlast;
  253|      0|	static double sourc;
  254|      0|	int ix;
  255|      0|
  256|      0|	flutter(frame); // add f0 flutter
  257|      0|
  258|      0|	// MAIN LOOP, for each output sample of current frame:
  259|      0|
  260|      0|	for (kt_globals.ns = 0; kt_globals.ns < kt_globals.nspfr; kt_globals.ns++) {
  261|      0|		// Get low-passed random number for aspiration and frication noise
  262|      0|		noise = gen_noise(noise);
  263|      0|
  264|      0|		// Amplitude modulate noise (reduce noise amplitude during
  265|      0|		// second half of glottal period) if voicing simultaneously present.
  266|      0|
  267|      0|		if (kt_globals.nper > kt_globals.nmod)
  268|      0|			noise *= (double)0.5;
  269|      0|
  270|      0|		// Compute frication noise
  271|      0|		frics = kt_globals.amp_frica * noise;
  272|      0|
  273|      0|		// Compute voicing waveform. Run glottal source simulation at 4
  274|      0|		// times normal sample rate to minimize quantization noise in
  275|      0|		// period of female voice.
  276|      0|
  277|      0|		for (n4 = 0; n4 < 4; n4++) {
  278|      0|			switch (kt_globals.glsource)
  279|      0|			{
  280|      0|			case IMPULSIVE:
  281|      0|				voice = impulsive_source();
  282|      0|				break;
  283|      0|			case NATURAL:
  284|      0|				voice = natural_source();
  285|      0|				break;
  286|      0|			case SAMPLED:
  287|      0|				voice = sampled_source(0);
  288|      0|				break;
  289|      0|			case SAMPLED2:
  290|      0|				voice = sampled_source(1);
  291|      0|				break;
  292|      0|			}
  293|      0|
  294|      0|			// Reset period when counter 'nper' reaches T0
  295|      0|			if (kt_globals.nper >= kt_globals.T0) {
  296|      0|				kt_globals.nper = 0;
  297|      0|				pitch_synch_par_reset(frame);
  298|      0|			}
  299|      0|
  300|      0|			// Low-pass filter voicing waveform before downsampling from 4*samrate
  301|      0|			// to samrate samples/sec.  Resonator f=.09*samrate, bw=.06*samrate
  302|      0|
  303|      0|			voice = resonator(&(kt_globals.rsn[RLP]), voice);
  304|      0|
  305|      0|			// Increment counter that keeps track of 4*samrate samples per sec
  306|      0|			kt_globals.nper++;
  307|      0|		}
  308|      0|
  309|      0|		if(kt_globals.glsource==5) {
  310|      0|			double v=(kt_globals.nper/(double)kt_globals.T0);
  311|      0|			v=(v*2)-1;
  312|      0|			voice=v*6000;
  313|      0|		}
  314|      0|
  315|      0|		// Tilt spectrum of voicing source down by soft low-pass filtering, amount
  316|      0|		// of tilt determined by TLTdb
  317|      0|
  318|      0|		voice = (voice * kt_globals.onemd) + (vlast * kt_globals.decay);
  319|      0|		vlast = voice;
  320|      0|
  321|      0|		// Add breathiness during glottal open phase. Amount of breathiness
  322|      0|		// determined by parameter Aturb Use nrand rather than noise because
  323|      0|		// noise is low-passed.
  324|      0|
  325|      0|		if (kt_globals.nper < kt_globals.nopen)
  326|      0|			voice += kt_globals.amp_breth * kt_globals.nrand;
  327|      0|
  328|      0|		// Set amplitude of voicing
  329|      0|		glotout = kt_globals.amp_voice * voice;
  330|      0|		par_glotout = kt_globals.par_amp_voice * voice;
  331|      0|
  332|      0|		// Compute aspiration amplitude and add to voicing source
  333|      0|		aspiration = kt_globals.amp_aspir * noise;
  334|      0|		glotout += aspiration;
  335|      0|
  336|      0|		par_glotout += aspiration;
  337|      0|
  338|      0|		// Cascade vocal tract, excited by laryngeal sources.
  339|      0|		// Nasal antiresonator, then formants FNP, F5, F4, F3, F2, F1
  340|      0|
  341|      0|		out = 0;
  342|      0|		if (kt_globals.synthesis_model != ALL_PARALLEL) {
  343|      0|			casc_next_in = antiresonator(&(kt_globals.rsn[Rnz]), glotout);
  344|      0|			casc_next_in = resonator(&(kt_globals.rsn[Rnpc]), casc_next_in);
  345|      0|			casc_next_in = resonator(&(kt_globals.rsn[R8c]), casc_next_in);
  346|      0|			casc_next_in = resonator(&(kt_globals.rsn[R7c]), casc_next_in);
  347|      0|			casc_next_in = resonator(&(kt_globals.rsn[R6c]), casc_next_in);
  348|      0|			casc_next_in = resonator(&(kt_globals.rsn[R5c]), casc_next_in);
  349|      0|			casc_next_in = resonator(&(kt_globals.rsn[R4c]), casc_next_in);
  350|      0|			casc_next_in = resonator(&(kt_globals.rsn[R3c]), casc_next_in);
  351|      0|			casc_next_in = resonator(&(kt_globals.rsn[R2c]), casc_next_in);
  352|      0|			out = resonator(&(kt_globals.rsn[R1c]), casc_next_in);
  353|      0|		}
  354|      0|
  355|      0|		// Excite parallel F1 and FNP by voicing waveform
  356|      0|		sourc = par_glotout; // Source is voicing plus aspiration
  357|      0|
  358|      0|		// Standard parallel vocal tract Formants F6,F5,F4,F3,F2,
  359|      0|		// outputs added with alternating sign. Sound source for other
  360|      0|		// parallel resonators is frication plus first difference of
  361|      0|		// voicing waveform.
  362|      0|
  363|      0|		out += resonator(&(kt_globals.rsn[R1p]), sourc);
  364|      0|		out += resonator(&(kt_globals.rsn[Rnpp]), sourc);
  365|      0|
  366|      0|		sourc = frics + par_glotout - glotlast;
  367|      0|		glotlast = par_glotout;
  368|      0|
  369|      0|		for (ix = R2p; ix <= R6p; ix++)
  370|      0|			out = resonator(&(kt_globals.rsn[ix]), sourc) - out;
  371|      0|
  372|      0|		outbypas = kt_globals.amp_bypas * sourc;
  373|      0|
  374|      0|		out = outbypas - out;
  375|      0|
  376|      0|		out = resonator(&(kt_globals.rsn[Rout]), out);
  377|      0|		temp = (int)(out * wdata->amplitude * kt_globals.amp_gain0); // Convert back to integer
  378|      0|
  379|      0|		// mix with a recorded WAV if required for this phoneme
  380|      0|		signed char c;
  381|      0|		int sample;
  382|      0|
  383|      0|		if (wdata->mix_wavefile_ix < wdata->n_mix_wavefile) {
  384|      0|			if (wdata->mix_wave_scale == 0) {
  385|      0|				// a 16 bit sample
  386|      0|				c = wdata->mix_wavefile[wdata->mix_wavefile_ix+1];
  387|      0|				sample = wdata->mix_wavefile[wdata->mix_wavefile_ix] + (c * 256);
  388|      0|				wdata->mix_wavefile_ix += 2;
  389|      0|			} else {
  390|      0|				// a 8 bit sample, scaled
  391|      0|				sample = (signed char)wdata->mix_wavefile[wdata->mix_wavefile_ix++] * wdata->mix_wave_scale;
  392|      0|			}
  393|      0|			int z2 = sample * wdata->amplitude_v / 1024;
  394|      0|			z2 = (z2 * wdata->mix_wave_amp)/40;
  395|      0|			temp += z2;
  396|      0|		}
  397|      0|
  398|      0|		if (kt_globals.fadein < 64) {
  399|      0|			temp = (temp * kt_globals.fadein) / 64;
  400|      0|			++kt_globals.fadein;
  401|      0|		}
  402|      0|
  403|      0|		// if fadeout is set, fade to zero over 64 samples, to avoid clicks at end of synthesis
  404|      0|		if (kt_globals.fadeout > 0) {
  405|      0|			kt_globals.fadeout--;
  406|      0|			temp = (temp * kt_globals.fadeout) / 64;
  407|      0|			if (kt_globals.fadeout == 0)
  408|      0|				kt_globals.fadein = 0;
  409|      0|		}
  410|      0|
  411|      0|		value = (int)temp + ((echo_buf[echo_tail++]*echo_amp) >> 8);
  412|      0|		if (echo_tail >= N_ECHO_BUF)
  413|      0|			echo_tail = 0;
  414|      0|
  415|      0|		if (value < -32768)
  416|      0|			value = -32768;
  417|      0|
  418|      0|		if (value > 32767)
  419|      0|			value =  32767;
  420|      0|
  421|      0|		*out_ptr++ = value;
  422|      0|		*out_ptr++ = value >> 8;
  423|      0|
  424|      0|		echo_buf[echo_head++] = value;
  425|      0|		if (echo_head >= N_ECHO_BUF)
  426|      0|			echo_head = 0;
  427|      0|
  428|      0|		sample_count++;
  429|      0|		if (out_ptr + 2 > out_end)
  430|      0|			return 1;
  431|      0|	}
  432|      0|	return 0;
  433|      0|}
  434|       |
  435|       |void KlattReset(int control)
  436|      0|{
  437|      0|	int r_ix;
  438|      0|
  439|      0|#ifdef INCLUDE_SPEECHPLAYER
  440|      0|	KlattResetSP();
  441|      0|#endif
  442|      0|
  443|      0|	if (control == 2) {
  444|      0|		// Full reset
  445|      0|		kt_globals.FLPhz = (950 * kt_globals.samrate) / 10000;
  446|      0|		kt_globals.BLPhz = (630 * kt_globals.samrate) / 10000;
  447|      0|		kt_globals.minus_pi_t = -M_PI / kt_globals.samrate;
  448|      0|		kt_globals.two_pi_t = -2.0 * kt_globals.minus_pi_t;
  449|      0|		setabc(kt_globals.FLPhz, kt_globals.BLPhz, &(kt_globals.rsn[RLP]));
  450|      0|	}
  451|      0|
  452|      0|	if (control > 0) {
  453|      0|		kt_globals.nper = 0;
  454|      0|		kt_globals.T0 = 0;
  455|      0|		kt_globals.nopen = 0;
  456|      0|		kt_globals.nmod = 0;
  457|      0|
  458|      0|		for (r_ix = RGL; r_ix < N_RSN; r_ix++) {
  459|      0|			kt_globals.rsn[r_ix].p1 = 0;
  460|      0|			kt_globals.rsn[r_ix].p2 = 0;
  461|      0|		}
  462|      0|	}
  463|      0|
  464|      0|	for (r_ix = 0; r_ix <= R6p; r_ix++) {
  465|      0|		kt_globals.rsn[r_ix].p1 = 0;
  466|      0|		kt_globals.rsn[r_ix].p2 = 0;
  467|      0|	}
  468|      0|}
  469|       |
  470|       |/*
  471|       |   function FRAME_INIT
  472|       |
  473|       |   Use parameters from the input frame to set up resonator coefficients.
  474|       | */
  475|       |
  476|       |static void frame_init(klatt_frame_ptr frame)
  477|      0|{
  478|      0|	double amp_par[7];
  479|      0|	static double amp_par_factor[7] = { 0.6, 0.4, 0.15, 0.06, 0.04, 0.022, 0.03 };
  480|      0|	long Gain0_tmp;
  481|      0|	int ix;
  482|      0|
  483|      0|	kt_globals.original_f0 = frame->F0hz10 / 10;
  484|      0|
  485|      0|	frame->AVdb_tmp  = frame->AVdb - 7;
  486|      0|	if (frame->AVdb_tmp < 0)
  487|      0|		frame->AVdb_tmp = 0;
  488|      0|
  489|      0|	kt_globals.amp_aspir = DBtoLIN(frame->ASP) * 0.05;
  490|      0|	kt_globals.amp_frica = DBtoLIN(frame->AF) * 0.25;
  491|      0|	kt_globals.par_amp_voice = DBtoLIN(frame->AVpdb);
  492|      0|	kt_globals.amp_bypas = DBtoLIN(frame->AB) * 0.05;
  493|      0|
  494|      0|	for (ix = 0; ix <= 6; ix++) {
  495|      0|		// parallel amplitudes F1 to F6, and parallel nasal pole
  496|      0|		amp_par[ix] = DBtoLIN(frame->Ap[ix]) * amp_par_factor[ix];
  497|      0|	}
  498|      0|
  499|      0|	Gain0_tmp = frame->Gain0 - 3;
  500|      0|	if (Gain0_tmp <= 0)
  501|      0|		Gain0_tmp = 57;
  502|      0|	kt_globals.amp_gain0 = DBtoLIN(Gain0_tmp) / kt_globals.scale_wav;
  503|      0|
  504|      0|	// Set coefficients of variable cascade resonators
  505|      0|	for (ix = 1; ix <= 9; ix++) {
  506|      0|		// formants 1 to 8, plus nasal pole
  507|      0|		setabc(frame->Fhz[ix], frame->Bhz[ix], &(kt_globals.rsn[ix]));
  508|      0|
  509|      0|		if (ix <= 5) {
  510|      0|			setabc(frame->Fhz_next[ix], frame->Bhz_next[ix], &(kt_globals.rsn_next[ix]));
  511|      0|
  512|      0|			kt_globals.rsn[ix].a_inc = (kt_globals.rsn_next[ix].a - kt_globals.rsn[ix].a) / 64.0;
  513|      0|			kt_globals.rsn[ix].b_inc = (kt_globals.rsn_next[ix].b - kt_globals.rsn[ix].b) / 64.0;
  514|      0|			kt_globals.rsn[ix].c_inc = (kt_globals.rsn_next[ix].c - kt_globals.rsn[ix].c) / 64.0;
  515|      0|		}
  516|      0|	}
  517|      0|
  518|      0|	// nasal zero anti-resonator
  519|      0|	setzeroabc(frame->Fhz[F_NZ], frame->Bhz[F_NZ], &(kt_globals.rsn[Rnz]));
  520|      0|	setzeroabc(frame->Fhz_next[F_NZ], frame->Bhz_next[F_NZ], &(kt_globals.rsn_next[Rnz]));
  521|      0|	kt_globals.rsn[F_NZ].a_inc = (kt_globals.rsn_next[F_NZ].a - kt_globals.rsn[F_NZ].a) / 64.0;
  522|      0|	kt_globals.rsn[F_NZ].b_inc = (kt_globals.rsn_next[F_NZ].b - kt_globals.rsn[F_NZ].b) / 64.0;
  523|      0|	kt_globals.rsn[F_NZ].c_inc = (kt_globals.rsn_next[F_NZ].c - kt_globals.rsn[F_NZ].c) / 64.0;
  524|      0|
  525|      0|	// Set coefficients of parallel resonators, and amplitude of outputs
  526|      0|
  527|      0|	for (ix = 0; ix <= 6; ix++) {
  528|      0|		setabc(frame->Fhz[ix], frame->Bphz[ix], &(kt_globals.rsn[Rparallel+ix]));
  529|      0|		kt_globals.rsn[Rparallel+ix].a *= amp_par[ix];
  530|      0|	}
  531|      0|
  532|      0|	// output low-pass filter
  533|      0|
  534|      0|	setabc((long)0.0, (long)(kt_globals.samrate/2), &(kt_globals.rsn[Rout]));
  535|      0|}
  536|       |
  537|       |/*
  538|       |   function IMPULSIVE_SOURCE
  539|       |
  540|       |   Generate a low pass filtered train of impulses as an approximation of
  541|       |   a natural excitation waveform. Low-pass filter the differentiated impulse
  542|       |   with a critically-damped second-order filter, time constant proportional
  543|       |   to Kopen.
  544|       | */
  545|       |
  546|       |static double impulsive_source()
  547|      0|{
  548|      0|	static double doublet[] = { 0.0, 13000000.0, -13000000.0 };
  549|      0|	static double vwave;
  550|      0|
  551|      0|	if (kt_globals.nper < 3)
  552|      0|		vwave = doublet[kt_globals.nper];
  553|      0|	else
  554|      0|		vwave = 0.0;
  555|      0|
  556|      0|	return resonator(&(kt_globals.rsn[RGL]), vwave);
  557|      0|}
  558|       |
  559|       |/*
  560|       |   function NATURAL_SOURCE
  561|       |
  562|       |   Vwave is the differentiated glottal flow waveform, there is a weak
  563|       |   spectral zero around 800 Hz, magic constants a,b reset pitch synchronously.
  564|       | */
  565|       |
  566|       |static double natural_source()
  567|      0|{
  568|      0|	double lgtemp;
  569|      0|	static double vwave;
  570|      0|
  571|      0|	if (kt_globals.nper < kt_globals.nopen) {
  572|      0|		kt_globals.pulse_shape_a -= kt_globals.pulse_shape_b;
  573|      0|		vwave += kt_globals.pulse_shape_a;
  574|      0|		lgtemp = vwave * 0.028;
  575|      0|
  576|      0|		return lgtemp;
  577|      0|	}
  578|      0|	vwave = 0.0;
  579|      0|	return 0.0;
  580|      0|}
  581|       |
  582|       |/*
  583|       |   function PITCH_SYNC_PAR_RESET
  584|       |
  585|       |   Reset selected parameters pitch-synchronously.
  586|       |
  587|       |
  588|       |   Constant B0 controls shape of glottal pulse as a function
  589|       |   of desired duration of open phase N0
  590|       |   (Note that N0 is specified in terms of 40,000 samples/sec of speech)
  591|       |
  592|       |   Assume voicing waveform V(t) has form: k1 t**2 - k2 t**3
  593|       |
  594|       |   If the radiation characterivative, a temporal derivative
  595|       |   is folded in, and we go from continuous time to discrete
  596|       |   integers n:  dV/dt = vwave[n]
  597|       |                        = sum over i=1,2,...,n of { a - (i * b) }
  598|       |                        = a n  -  b/2 n**2
  599|       |
  600|       |   where the  constants a and b control the detailed shape
  601|       |   and amplitude of the voicing waveform over the open
  602|       |   potion of the voicing cycle "nopen".
  603|       |
  604|       |   Let integral of dV/dt have no net dc flow --> a = (b * nopen) / 3
  605|       |
  606|       |   Let maximum of dUg(n)/dn be constant --> b = gain / (nopen * nopen)
  607|       |   meaning as nopen gets bigger, V has bigger peak proportional to n
  608|       |
  609|       |   Thus, to generate the table below for 40 <= nopen <= 263:
  610|       |
  611|       |   B0[nopen - 40] = 1920000 / (nopen * nopen)
  612|       | */
  613|       |
  614|       |static void pitch_synch_par_reset(klatt_frame_ptr frame)
  615|      0|{
  616|      0|	long temp;
  617|      0|	double temp1;
  618|      0|	static long skew;
  619|      0|	static short B0[224] = {
  620|      0|		1200, 1142, 1088, 1038, 991, 948, 907, 869, 833, 799, 768, 738, 710, 683, 658,
  621|      0|		 634,  612,  590,  570, 551, 533, 515, 499, 483, 468, 454, 440, 427, 415, 403,
  622|      0|		 391,  380,  370,  360, 350, 341, 332, 323, 315, 307, 300, 292, 285, 278, 272,
  623|      0|		 265,  259,  253,  247, 242, 237, 231, 226, 221, 217, 212, 208, 204, 199, 195,
  624|      0|		 192,  188,  184,  180, 177, 174, 170, 167, 164, 161, 158, 155, 153, 150, 147,
  625|      0|		 145,  142,  140,  137, 135, 133, 131, 128, 126, 124, 122, 120, 119, 117, 115,
  626|      0|		 113,  111,  110,  108, 106, 105, 103, 102, 100,  99,  97,  96,  95,  93,  92, 91, 90,
  627|      0|		  88,   87,   86,   85,  84,  83,  82,  80,  79,  78,  77,  76,  75,  75,  74, 73, 72, 71,
  628|      0|		  70,   69,   68,   68,  67,  66,  65,  64,  64,  63,  62,  61,  61,  60,  59, 59, 58, 57,
  629|      0|		  57,   56,   56,   55,  55,  54,  54,  53,  53,  52,  52,  51,  51,  50,  50, 49, 49, 48, 48,
  630|      0|		  47,   47,   46,   46,  45,  45,  44,  44,  43,  43,  42,  42,  41,  41,  41, 41, 40, 40,
  631|      0|		  39,   39,   38,   38,  38,  38,  37,  37,  36,  36,  36,  36,  35,  35,  35, 35, 34, 34, 33,
  632|      0|		  33,   33,   33,   32,  32,  32,  32,  31,  31,  31,  31,  30,  30,  30,  30, 29, 29, 29, 29,
  633|      0|		  28,   28,   28,   28,  27,  27
  634|      0|	};
  635|      0|
  636|      0|	if (frame->F0hz10 > 0) {
  637|      0|		// T0 is 4* the number of samples in one pitch period
  638|      0|
  639|      0|		kt_globals.T0 = (40 * kt_globals.samrate) / frame->F0hz10;
  640|      0|
  641|      0|		kt_globals.amp_voice = DBtoLIN(frame->AVdb_tmp);
  642|      0|
  643|      0|		// Duration of period before amplitude modulation
  644|      0|
  645|      0|		kt_globals.nmod = kt_globals.T0;
  646|      0|		if (frame->AVdb_tmp > 0)
  647|      0|			kt_globals.nmod >>= 1;
  648|      0|
  649|      0|		// Breathiness of voicing waveform
  650|      0|
  651|      0|		kt_globals.amp_breth = DBtoLIN(frame->Aturb) * 0.1;
  652|      0|
  653|      0|		// Set open phase of glottal period where  40 <= open phase <= 263
  654|      0|
  655|      0|		kt_globals.nopen = 4 * frame->Kopen;
  656|      0|
  657|      0|		if ((kt_globals.glsource == IMPULSIVE) && (kt_globals.nopen > 263))
  658|      0|			kt_globals.nopen = 263;
  659|      0|
  660|      0|		if (kt_globals.nopen >= (kt_globals.T0-1))
  661|      0|			kt_globals.nopen = kt_globals.T0 - 2;
  662|      0|
  663|      0|		if (kt_globals.nopen < 40) {
  664|      0|			// F0 max = 1000 Hz
  665|      0|			kt_globals.nopen = 40;
  666|      0|		}
  667|      0|
  668|      0|		// Reset a & b, which determine shape of "natural" glottal waveform
  669|      0|
  670|      0|		kt_globals.pulse_shape_b = B0[kt_globals.nopen-40];
  671|      0|		kt_globals.pulse_shape_a = (kt_globals.pulse_shape_b * kt_globals.nopen) * 0.333;
  672|      0|
  673|      0|		// Reset width of "impulsive" glottal pulse
  674|      0|
  675|      0|		temp = kt_globals.samrate / kt_globals.nopen;
  676|      0|
  677|      0|		setabc((long)0, temp, &(kt_globals.rsn[RGL]));
  678|      0|
  679|      0|		// Make gain at F1 about constant
  680|      0|
  681|      0|		temp1 = kt_globals.nopen *.00833;
  682|      0|		kt_globals.rsn[RGL].a *= temp1 * temp1;
  683|      0|
  684|      0|		// Truncate skewness so as not to exceed duration of closed phase
  685|      0|		// of glottal period.
  686|      0|
  687|      0|		temp = kt_globals.T0 - kt_globals.nopen;
  688|      0|		if (frame->Kskew > temp)
  689|      0|			frame->Kskew = temp;
  690|      0|		if (skew >= 0)
  691|      0|			skew = frame->Kskew;
  692|      0|		else
  693|      0|			skew = -frame->Kskew;
  694|      0|
  695|      0|		// Add skewness to closed portion of voicing period
  696|      0|		kt_globals.T0 = kt_globals.T0 + skew;
  697|      0|		skew = -skew;
  698|      0|	} else {
  699|      0|		kt_globals.T0 = 4; // Default for f0 undefined
  700|      0|		kt_globals.amp_voice = 0.0;
  701|      0|		kt_globals.nmod = kt_globals.T0;
  702|      0|		kt_globals.amp_breth = 0.0;
  703|      0|		kt_globals.pulse_shape_a = 0.0;
  704|      0|		kt_globals.pulse_shape_b = 0.0;
  705|      0|	}
  706|      0|
  707|      0|	// Reset these pars pitch synchronously or at update rate if f0=0
  708|      0|
  709|      0|	if ((kt_globals.T0 != 4) || (kt_globals.ns == 0)) {
  710|      0|		// Set one-pole low-pass filter that tilts glottal source
  711|      0|
  712|      0|		kt_globals.decay = (0.033 * frame->TLTdb);
  713|      0|
  714|      0|		if (kt_globals.decay > 0.0)
  715|      0|			kt_globals.onemd = 1.0 - kt_globals.decay;
  716|      0|		else
  717|      0|			kt_globals.onemd = 1.0;
  718|      0|	}
  719|      0|}
  720|       |
  721|       |/*
  722|       |   function SETABC
  723|       |
  724|       |   Convert formant frequencies and bandwidth into resonator difference
  725|       |   equation constants.
  726|       | */
  727|       |
  728|       |static void setabc(long int f, long int bw, resonator_ptr rp)
  729|      0|{
  730|      0|	double r;
  731|      0|	double arg;
  732|      0|
  733|      0|	// Let r  =  exp(-pi bw t)
  734|      0|	arg = kt_globals.minus_pi_t * bw;
  735|      0|	r = exp(arg);
  736|      0|
  737|      0|	// Let c  =  -r**2
  738|      0|	rp->c = -(r * r);
  739|      0|
  740|      0|	// Let b = r * 2*cos(2 pi f t)
  741|      0|	arg = kt_globals.two_pi_t * f;
  742|      0|	rp->b = r * cos(arg) * 2.0;
  743|      0|
  744|      0|	// Let a = 1.0 - b - c
  745|      0|	rp->a = 1.0 - rp->b - rp->c;
  746|      0|}
  747|       |
  748|       |/*
  749|       |   function SETZEROABC
  750|       |
  751|       |   Convert formant frequencies and bandwidth into anti-resonator difference
  752|       |   equation constants.
  753|       | */
  754|       |
  755|       |static void setzeroabc(long int f, long int bw, resonator_ptr rp)
  756|      0|{
  757|      0|	double r;
  758|      0|	double arg;
  759|      0|
  760|      0|	f = -f;
  761|      0|
  762|      0|	// First compute ordinary resonator coefficients
  763|      0|	// Let r  =  exp(-pi bw t)
  764|      0|	arg = kt_globals.minus_pi_t * bw;
  765|      0|	r = exp(arg);
  766|      0|
  767|      0|	// Let c  =  -r**2
  768|      0|	rp->c = -(r * r);
  769|      0|
  770|      0|	// Let b = r * 2*cos(2 pi f t)
  771|      0|	arg = kt_globals.two_pi_t * f;
  772|      0|	rp->b = r * cos(arg) * 2.;
  773|      0|
  774|      0|	// Let a = 1.0 - b - c
  775|      0|	rp->a = 1.0 - rp->b - rp->c;
  776|      0|
  777|      0|	// Now convert to antiresonator coefficients (a'=1/a, b'=b/a, c'=c/a)
  778|      0|
  779|      0|	// If f == 0 then rp->a gets set to 0 which makes a'=1/a set a', b' and c' to
  780|      0|	// INF, causing an audible sound spike when triggered (e.g. apiration with the
  781|      0|	// nasal register set to f=0, bw=0).
  782|      0|	if (rp->a != 0) {
  783|      0|		// Now convert to antiresonator coefficients (a'=1/a, b'=b/a, c'=c/a)
  784|      0|		rp->a = 1.0 / rp->a;
  785|      0|		rp->c *= -rp->a;
  786|      0|		rp->b *= -rp->a;
  787|      0|	}
  788|      0|}
  789|       |
  790|       |/*
  791|       |   function GEN_NOISE
  792|       |
  793|       |   Random number generator (return a number between -8191 and +8191)
  794|       |   Noise spectrum is tilted down by soft low-pass filter having a pole near
  795|       |   the origin in the z-plane, i.e. output = input + (0.75 * lastoutput)
  796|       | */
  797|       |
  798|       |static double gen_noise(double noise)
  799|      0|{
  800|      0|	long temp;
  801|      0|	static double nlast;
  802|      0|
  803|      0|	temp = (long)getrandom(-8191, 8191);
  804|      0|	kt_globals.nrand = (long)temp;
  805|      0|
  806|      0|	noise = kt_globals.nrand + (0.75 * nlast);
  807|      0|	nlast = noise;
  808|      0|
  809|      0|	return noise;
  810|      0|}
  811|       |
  812|       |/*
  813|       |   function DBTOLIN
  814|       |
  815|       |   Convert from decibels to a linear scale factor
  816|       |
  817|       |
  818|       |   Conversion table, db to linear, 87 dB --> 32767
  819|       |                                86 dB --> 29491 (1 dB down = 0.5**1/6)
  820|       |                                 ...
  821|       |                                81 dB --> 16384 (6 dB down = 0.5)
  822|       |                                 ...
  823|       |                                 0 dB -->     0
  824|       |
  825|       |   The just noticeable difference for a change in intensity of a vowel
  826|       |   is approximately 1 dB.  Thus all amplitudes are quantized to 1 dB
  827|       |   steps.
  828|       | */
  829|       |
  830|       |static double DBtoLIN(long dB)
  831|      0|{
  832|      0|	static short amptable[88] = {
  833|      0|		   0,      0,     0,     0,     0,     0,     0,    0,     0,    0,   0,   0,  0, 6, 7,
  834|      0|		   8,      9,    10,    11,    13,    14,    16,   18,    20,   22,  25,  28, 32,
  835|      0|		   35,    40,    45,    51,    57,    64,    71,   80,    90,  101, 114, 128,
  836|      0|		  142,   159,   179,   202,   227,   256,   284,  318,   359,  405,
  837|      0|		  455,   512,   568,   638,   719,   881,   911, 1024,  1137, 1276,
  838|      0|		 1438,  1622,  1823,  2048,  2273,  2552,  2875, 3244,  3645,
  839|      0|		 4096,  4547,  5104,  5751,  6488,  7291,  8192, 9093, 10207,
  840|      0|		11502, 12976, 14582, 16384, 18350, 20644, 23429,
  841|      0|		26214, 29491, 32767
  842|      0|	};
  843|      0|
  844|      0|	if ((dB < 0) || (dB > 87))
  845|      0|		return 0;
  846|      0|
  847|      0|	return (double)(amptable[dB]) * 0.001;
  848|      0|}
  849|       |
  850|       |static klatt_peaks_t peaks[N_PEAKS];
  851|       |static int end_wave;
  852|       |static int klattp[N_KLATTP];
  853|       |static double klattp1[N_KLATTP];
  854|       |static double klattp_inc[N_KLATTP];
  855|       |
  856|       |int Wavegen_Klatt(int length, int resume, frame_t *fr1, frame_t *fr2, WGEN_DATA *wdata, voice_t *wvoice)
  857|      0|{
  858|      0|#ifdef INCLUDE_SPEECHPLAYER
  859|      0|	if(wvoice->klattv[0] == 6)
  860|      0|	return Wavegen_KlattSP(wdata, wvoice, length, resume, fr1, fr2);
  861|      0|#endif
  862|      0|
  863|      0|	if (resume == 0)
  864|      0|		SetSynth_Klatt(length, fr1, fr2, wvoice, 1);
  865|      0|
  866|      0|	int pk;
  867|      0|	int x;
  868|      0|	int ix;
  869|      0|	int fade;
  870|      0|
  871|      0|	if (resume == 0)
  872|      0|		sample_count = 0;
  873|      0|
  874|      0|	while (sample_count < nsamples) {
  875|      0|		kt_frame.F0hz10 = (wdata->pitch * 10) / 4096;
  876|      0|
  877|      0|		// formants F6,F7,F8 are fixed values for cascade resonators, set in KlattInit()
  878|      0|		// but F6 is used for parallel resonator
  879|      0|		// F0 is used for the nasal zero
  880|      0|		for (ix = 0; ix < 6; ix++) {
  881|      0|			kt_frame.Fhz[ix] = peaks[ix].freq;
  882|      0|			if (ix < 4)
  883|      0|				kt_frame.Bhz[ix] = peaks[ix].bw;
  884|      0|		}
  885|      0|		for (ix = 1; ix < 7; ix++)
  886|      0|			kt_frame.Ap[ix] = peaks[ix].ap;
  887|      0|
  888|      0|		kt_frame.AVdb = klattp[KLATT_AV];
  889|      0|		kt_frame.AVpdb = klattp[KLATT_AVp];
  890|      0|		kt_frame.AF = klattp[KLATT_Fric];
  891|      0|		kt_frame.AB = klattp[KLATT_FricBP];
  892|      0|		kt_frame.ASP = klattp[KLATT_Aspr];
  893|      0|		kt_frame.Aturb = klattp[KLATT_Turb];
  894|      0|		kt_frame.Kskew = klattp[KLATT_Skew];
  895|      0|		kt_frame.TLTdb = klattp[KLATT_Tilt];
  896|      0|		kt_frame.Kopen = klattp[KLATT_Kopen];
  897|      0|
  898|      0|		// advance formants
  899|      0|		for (pk = 0; pk < N_PEAKS; pk++) {
  900|      0|			peaks[pk].freq1 += peaks[pk].freq_inc;
  901|      0|			peaks[pk].freq = (int)peaks[pk].freq1;
  902|      0|			peaks[pk].bw1 += peaks[pk].bw_inc;
  903|      0|			peaks[pk].bw = (int)peaks[pk].bw1;
  904|      0|			peaks[pk].bp1 += peaks[pk].bp_inc;
  905|      0|			peaks[pk].bp = (int)peaks[pk].bp1;
  906|      0|			peaks[pk].ap1 += peaks[pk].ap_inc;
  907|      0|			peaks[pk].ap = (int)peaks[pk].ap1;
  908|      0|		}
  909|      0|
  910|      0|		// advance other parameters
  911|      0|		for (ix = 0; ix < N_KLATTP; ix++) {
  912|      0|			klattp1[ix] += klattp_inc[ix];
  913|      0|			klattp[ix] = (int)klattp1[ix];
  914|      0|		}
  915|      0|
  916|      0|		for (ix = 0; ix <= 6; ix++) {
  917|      0|			kt_frame.Fhz_next[ix] = peaks[ix].freq;
  918|      0|			if (ix < 4)
  919|      0|				kt_frame.Bhz_next[ix] = peaks[ix].bw;
  920|      0|		}
  921|      0|
  922|      0|		// advance the pitch
  923|      0|		wdata->pitch_ix += wdata->pitch_inc;
  924|      0|		if ((ix = wdata->pitch_ix>>8) > 127) ix = 127;
  925|      0|		x = wdata->pitch_env[ix] * wdata->pitch_range;
  926|      0|		wdata->pitch = (x>>8) + wdata->pitch_base;
  927|      0|
  928|      0|		kt_globals.nspfr = (nsamples - sample_count);
  929|      0|		if (kt_globals.nspfr > STEPSIZE)
  930|      0|			kt_globals.nspfr = STEPSIZE;
  931|      0|
  932|      0|		frame_init(&kt_frame); // get parameters for next frame of speech
  933|      0|
  934|      0|		if (parwave(&kt_frame, wdata) == 1)
  935|      0|			return 1; // output buffer is full
  936|      0|	}
  937|      0|
  938|      0|	if (end_wave > 0) {
  939|      0|		fade = 64; // not followed by formant synthesis
  940|      0|
  941|      0|		// fade out to avoid a click
  942|      0|		kt_globals.fadeout = fade;
  943|      0|		end_wave = 0;
  944|      0|		sample_count -= fade;
  945|      0|		kt_globals.nspfr = fade;
  946|      0|		if (parwave(&kt_frame, wdata) == 1)
  947|      0|			return 1; // output buffer is full
  948|      0|	}
  949|      0|
  950|      0|	return 0;
  951|      0|}
  952|       |
  953|       |static void SetSynth_Klatt(int length, frame_t *fr1, frame_t *fr2, voice_t *wvoice, int control)
  954|      0|{
  955|      0|	int ix;
  956|      0|	double next;
  957|      0|	int qix;
  958|      0|	int cmd;
  959|      0|	frame_t *fr3;
  960|      0|	static frame_t prev_fr;
  961|      0|
  962|      0|	if (wvoice != NULL) {
  963|      0|		if ((wvoice->klattv[0] > 0) && (wvoice->klattv[0] <= 5 )) {
  964|      0|			kt_globals.glsource = wvoice->klattv[0];
  965|      0|			kt_globals.scale_wav = scale_wav_tab[kt_globals.glsource];
  966|      0|		}
  967|      0|		kt_globals.f0_flutter = wvoice->flutter/32;
  968|      0|	}
  969|      0|
  970|      0|	end_wave = 0;
  971|      0|	if (control & 2)
  972|      0|		end_wave = 1; // fadeout at the end
  973|      0|	if (control & 1) {
  974|      0|		end_wave = 1;
  975|      0|		for (qix = wcmdq_head+1;; qix++) {
  976|      0|			if (qix >= N_WCMDQ) qix = 0;
  977|      0|			if (qix == wcmdq_tail) break;
  978|      0|
  979|      0|			cmd = wcmdq[qix][0];
  980|      0|			if (cmd == WCMD_KLATT) {
  981|      0|				end_wave = 0; // next wave generation is from another spectrum
  982|      0|
  983|      0|				fr3 = (frame_t *)wcmdq[qix][2];
  984|      0|				for (ix = 1; ix < 6; ix++) {
  985|      0|					if (fr3->ffreq[ix] != fr2->ffreq[ix]) {
  986|      0|						// there is a discontinuity in formants
  987|      0|						end_wave = 2;
  988|      0|						break;
  989|      0|					}
  990|      0|				}
  991|      0|				break;
  992|      0|			}
  993|      0|			if ((cmd == WCMD_WAVE) || (cmd == WCMD_PAUSE))
  994|      0|				break; // next is not from spectrum, so continue until end of wave cycle
  995|      0|		}
  996|      0|	}
  997|      0|
  998|      0|	if (control & 1) {
  999|      0|		for (ix = 1; ix < 6; ix++) {
 1000|      0|			if (prev_fr.ffreq[ix] != fr1->ffreq[ix]) {
 1001|      0|				// Discontinuity in formants.
 1002|      0|				// end_wave was set in SetSynth_Klatt() to fade out the previous frame
 1003|      0|				KlattReset(0);
 1004|      0|				break;
 1005|      0|			}
 1006|      0|		}
 1007|      0|		memcpy(&prev_fr, fr2, sizeof(prev_fr));
 1008|      0|	}
 1009|      0|
 1010|      0|	for (ix = 0; ix < N_KLATTP; ix++) {
 1011|      0|		if ((ix >= 5) && ((fr1->frflags & FRFLAG_KLATT) == 0)) {
 1012|      0|			klattp1[ix] = klattp[ix] = 0;
 1013|      0|			klattp_inc[ix] = 0;
 1014|      0|		} else {
 1015|      0|			klattp1[ix] = klattp[ix] = fr1->klattp[ix];
 1016|      0|			klattp_inc[ix] = (double)((fr2->klattp[ix] - klattp[ix]) * STEPSIZE)/length;
 1017|      0|		}
 1018|      0|	}
 1019|      0|
 1020|      0|	nsamples = length;
 1021|      0|
 1022|      0|	for (ix = 1; ix < 6; ix++) {
 1023|      0|		peaks[ix].freq1 = (fr1->ffreq[ix] * wvoice->freq[ix] / 256.0) + wvoice->freqadd[ix];
 1024|      0|		peaks[ix].freq = (int)peaks[ix].freq1;
 1025|      0|		next = (fr2->ffreq[ix] * wvoice->freq[ix] / 256.0) + wvoice->freqadd[ix];
 1026|      0|		peaks[ix].freq_inc =  ((next - peaks[ix].freq1) * STEPSIZE) / length;
 1027|      0|
 1028|      0|		if (ix < 4) {
 1029|      0|			// klatt bandwidth for f1, f2, f3 (others are fixed)
 1030|      0|			peaks[ix].bw1 = fr1->bw[ix] * 2  * (wvoice->width[ix] / 256.0);
 1031|      0|			peaks[ix].bw = (int)peaks[ix].bw1;
 1032|      0|			next = fr2->bw[ix] * 2;
 1033|      0|			peaks[ix].bw_inc =  ((next - peaks[ix].bw1) * STEPSIZE) / length;
 1034|      0|		}
 1035|      0|	}
 1036|      0|
 1037|      0|	// nasal zero frequency
 1038|      0|	peaks[0].freq1 = fr1->klattp[KLATT_FNZ] * 2;
 1039|      0|	if (peaks[0].freq1 == 0)
 1040|      0|		peaks[0].freq1 = kt_frame.Fhz[F_NP]; // if no nasal zero, set it to same freq as nasal pole
 1041|      0|
 1042|      0|	peaks[0].freq = (int)peaks[0].freq1;
 1043|      0|	next = fr2->klattp[KLATT_FNZ] * 2;
 1044|      0|	if (next == 0)
 1045|      0|		next = kt_frame.Fhz[F_NP];
 1046|      0|
 1047|      0|	peaks[0].freq_inc = ((next - peaks[0].freq1) * STEPSIZE) / length;
 1048|      0|
 1049|      0|	peaks[0].bw1 = 89;
 1050|      0|	peaks[0].bw = 89;
 1051|      0|	peaks[0].bw_inc = 0;
 1052|      0|
 1053|      0|	if (fr1->frflags & FRFLAG_KLATT) {
 1054|      0|		// the frame contains additional parameters for parallel resonators
 1055|      0|		for (ix = 1; ix < 7; ix++) {
 1056|      0|			peaks[ix].bp1 = fr1->klatt_bp[ix] * 4; // parallel bandwidth
 1057|      0|			peaks[ix].bp = (int)peaks[ix].bp1;
 1058|      0|			next = fr2->klatt_bp[ix] * 4;
 1059|      0|			peaks[ix].bp_inc =  ((next - peaks[ix].bp1) * STEPSIZE) / length;
 1060|      0|
 1061|      0|			peaks[ix].ap1 = fr1->klatt_ap[ix]; // parallal amplitude
 1062|      0|			peaks[ix].ap = (int)peaks[ix].ap1;
 1063|      0|			next = fr2->klatt_ap[ix];
 1064|      0|			peaks[ix].ap_inc =  ((next - peaks[ix].ap1) * STEPSIZE) / length;
 1065|      0|		}
 1066|      0|	}
 1067|      0|}
 1068|       |
 1069|       |void KlattInit()
 1070|      0|{
 1071|      0|
 1072|      0|	static short formant_hz[10] = { 280, 688, 1064, 2806, 3260, 3700, 6500, 7000, 8000, 280 };
 1073|      0|	static short bandwidth[10] = { 89, 160, 70, 160, 200, 200, 500, 500, 500, 89 };
 1074|      0|	static short parallel_amp[10] = { 0, 59, 59, 59, 59, 59, 59, 0, 0, 0 };
 1075|      0|	static short parallel_bw[10] = { 59, 59, 89, 149, 200, 200, 500, 0, 0, 0 };
 1076|      0|
 1077|      0|	int ix;
 1078|      0|
 1079|      0|#ifdef INCLUDE_SPEECHPLAYER
 1080|      0|	KlattInitSP();
 1081|      0|#endif
 1082|      0|
 1083|      0|	sample_count = 0;
 1084|      0|
 1085|      0|	kt_globals.synthesis_model = CASCADE_PARALLEL;
 1086|      0|	kt_globals.samrate = 22050;
 1087|      0|
 1088|      0|	kt_globals.glsource = IMPULSIVE;
 1089|      0|	kt_globals.scale_wav = scale_wav_tab[kt_globals.glsource];
 1090|      0|	kt_globals.natural_samples = natural_samples;
 1091|      0|	kt_globals.num_samples = NUMBER_OF_SAMPLES;
 1092|      0|	kt_globals.sample_factor = 3.0;
 1093|      0|	kt_globals.nspfr = (kt_globals.samrate * 10) / 1000;
 1094|      0|	kt_globals.outsl = 0;
 1095|      0|	kt_globals.f0_flutter = 20;
 1096|      0|
 1097|      0|	KlattReset(2);
 1098|      0|
 1099|      0|	// set default values for frame parameters
 1100|      0|	for (ix = 0; ix <= 9; ix++) {
 1101|      0|		kt_frame.Fhz[ix] = formant_hz[ix];
 1102|      0|		kt_frame.Bhz[ix] = bandwidth[ix];
 1103|      0|		kt_frame.Ap[ix] = parallel_amp[ix];
 1104|      0|		kt_frame.Bphz[ix] = parallel_bw[ix];
 1105|      0|	}
 1106|      0|	kt_frame.Bhz_next[F_NZ] = bandwidth[F_NZ];
 1107|      0|
 1108|      0|	kt_frame.F0hz10 = 1000;
 1109|      0|	kt_frame.AVdb = 59;
 1110|      0|	kt_frame.ASP = 0;
 1111|      0|	kt_frame.Kopen = 40;
 1112|      0|	kt_frame.Aturb = 0;
 1113|      0|	kt_frame.TLTdb = 0;
 1114|      0|	kt_frame.AF = 50;
 1115|      0|	kt_frame.Kskew = 0;
 1116|      0|	kt_frame.AB = 0;
 1117|      0|	kt_frame.AVpdb = 0;
 1118|      0|	kt_frame.Gain0 = 62;
 1119|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/klatt.h:
    1|       |/*
    2|       | * Copyright (C) 2008 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2017 Reece H. Dunn
    5|       | *
    6|       | * Based on a re-implementation by:
    7|       | * (c) 1993,94 Jon Iles and Nick Ing-Simmons
    8|       | * of the Klatt cascade-parallel formant synthesizer
    9|       | *
   10|       | * This program is free software; you can redistribute it and/or modify
   11|       | * it under the terms of the GNU General Public License as published by
   12|       | * the Free Software Foundation; either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | *
   15|       | * This program is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU General Public License for more details.
   19|       | *
   20|       | * You should have received a copy of the GNU General Public License
   21|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   22|       | */
   23|       |
   24|       |#ifndef ESPEAK_NG_KLATT_H
   25|       |#define ESPEAK_NG_KLATT_H
   26|       |
   27|       |#include "voice.h"                    // for voice_t
   28|       |#include "synthesize.h"              // for frame_t, WGEN_DATA
   29|       |
   30|       |#ifdef __cplusplus
   31|       |extern "C"
   32|       |{
   33|       |#endif
   34|       |
   35|      0|#define CASCADE_PARALLEL 1         /* Type of synthesis model */
   36|      0|#define ALL_PARALLEL     2
   37|       |
   38|      0|#define IMPULSIVE        1         /* Type of voicing source */
   39|      0|#define NATURAL          2
   40|      0|#define SAMPLED          3
   41|      0|#define SAMPLED2         4
   42|       |
   43|       |/* typedef's that need to be exported */
   44|       |
   45|       |typedef long flag;
   46|       |
   47|       |/* Resonator Structure */
   48|       |
   49|       |typedef struct {
   50|       |	double a;
   51|       |	double b;
   52|       |	double c;
   53|       |	double p1;
   54|       |	double p2;
   55|       |	double a_inc;
   56|       |	double b_inc;
   57|       |	double c_inc;
   58|       |} resonator_t, *resonator_ptr;
   59|       |
   60|       |/* Structure for Klatt Globals */
   61|       |
   62|       |typedef struct {
   63|       |	flag synthesis_model; /* cascade-parallel or all-parallel */
   64|       |	flag outsl;     /* Output waveform selector                      */
   65|       |	long samrate;   /* Number of output samples per second           */
   66|       |	long FLPhz;     /* Frequeny of glottal downsample low-pass filter */
   67|       |	long BLPhz;     /* Bandwidth of glottal downsample low-pass filter */
   68|       |	flag glsource;  /* Type of glottal source */
   69|       |	int f0_flutter; /* Percentage of f0 flutter 0-100 */
   70|       |	long nspfr;     /* number of samples per frame */
   71|       |	long nper;      /* Counter for number of samples in a pitch period */
   72|       |	long ns;
   73|       |	long T0;        /* Fundamental period in output samples times 4 */
   74|       |	long nopen;     /* Number of samples in open phase of period    */
   75|       |	long nmod;      /* Position in period to begin noise amp. modul */
   76|       |	long nrand;     /* Variable used by random number generator      */
   77|       |	double pulse_shape_a; /* Makes waveshape of glottal pulse when open   */
   78|       |	double pulse_shape_b; /* Makes waveshape of glottal pulse when open   */
   79|       |	double minus_pi_t;
   80|       |	double two_pi_t;
   81|       |	double onemd;
   82|       |	double decay;
   83|       |	double amp_bypas; /* AB converted to linear gain              */
   84|       |	double amp_voice; /* AVdb converted to linear gain            */
   85|       |	double par_amp_voice; /* AVpdb converted to linear gain       */
   86|       |	double amp_aspir; /* AP converted to linear gain              */
   87|       |	double amp_frica; /* AF converted to linear gain              */
   88|       |	double amp_breth; /* ATURB converted to linear gain           */
   89|       |	double amp_gain0; /* G0 converted to linear gain              */
   90|       |	int num_samples; /* number of glottal samples */
   91|       |	double sample_factor; /* multiplication factor for glottal samples */
   92|       |	short *natural_samples; /* pointer to an array of glottal samples */
   93|       |	long original_f0; /* original value of f0 not modified by flutter */
   94|       |
   95|       |	int fadein;
   96|       |	int fadeout;       // set to 64 to cause fadeout over 64 samples
   97|       |	int scale_wav;     // depends on the voicing source
   98|       |
   99|      0|#define N_RSN 20
  100|      0|#define Rnz  0   // nasal zero, anti-resonator
  101|      0|#define R1c  1
  102|      0|#define R2c  2
  103|      0|#define R3c  3
  104|      0|#define R4c  4
  105|      0|#define R5c  5
  106|      0|#define R6c  6
  107|      0|#define R7c  7
  108|      0|#define R8c  8
  109|      0|#define Rnpc 9   // nasal pole
  110|       |
  111|      0|#define Rparallel 10
  112|      0|#define Rnpp 10
  113|      0|#define R1p  11
  114|      0|#define R2p  12
  115|       |#define R3p  13
  116|       |#define R4p  14
  117|       |#define R5p  15
  118|      0|#define R6p  16
  119|       |
  120|      0|#define RGL  17
  121|      0|#define RLP  18
  122|      0|#define Rout 19
  123|       |
  124|       |	resonator_t rsn[N_RSN];  // internal storage for resonators
  125|       |	resonator_t rsn_next[N_RSN];
  126|       |
  127|       |} klatt_global_t, *klatt_global_ptr;
  128|       |
  129|       |/* Structure for Klatt Parameters */
  130|       |
  131|      0|#define F_NZ   0  // nasal zero formant
  132|       |#define F1     1
  133|       |#define F2     2
  134|       |#define F3     3
  135|       |#define F4     4
  136|       |#define F5     5
  137|       |#define F6     6
  138|      0|#define F_NP   9  // nasal pole formant
  139|       |
  140|       |
  141|       |typedef struct {
  142|       |	int F0hz10; /* Voicing fund freq in Hz                          */
  143|       |	int AVdb;   /* Amp of voicing in dB,            0 to   70       */
  144|       |	int Fhz[10];  // formant Hz, F_NZ to F6 to F_NP
  145|       |	int Bhz[10];
  146|       |	int Ap[10];   /* Amp of parallel formants in dB,    0 to   80       */
  147|       |	int Bphz[10]; /* Parallel formants bw in Hz,       40 to 1000      */
  148|       |
  149|       |	int ASP;    /* Amp of aspiration in dB,         0 to   70       */
  150|       |	int Kopen;  /* # of samples in open period,     10 to   65      */
  151|       |	int Aturb;  /* Breathiness in voicing,          0 to   80       */
  152|       |	int TLTdb;  /* Voicing spectral tilt in dB,     0 to   24       */
  153|       |	int AF;     /* Amp of frication in dB,          0 to   80       */
  154|       |	int Kskew;  /* Skewness of alternate periods,   0 to   40 in sample#/2  */
  155|       |
  156|       |	int AB;     /* Amp of bypass fric. in dB,       0 to   80       */
  157|       |	int AVpdb;  /* Amp of voicing,  par in dB,      0 to   70       */
  158|       |	int Gain0;  /* Overall gain, 60 dB is unity,    0 to   60       */
  159|       |
  160|       |	int AVdb_tmp;      // copy of AVdb, which is changed within parwave()
  161|       |	int Fhz_next[10];    // Fhz for the next chunk, so we can do interpolation of resonator (a,b,c) parameters
  162|       |	int Bhz_next[10];
  163|       |} klatt_frame_t, *klatt_frame_ptr;
  164|       |
  165|       |
  166|       |typedef struct {
  167|       |	int freq;     // Hz
  168|       |	int bw;   // klatt bandwidth
  169|       |	int ap;   // parallel amplitude
  170|       |	int bp;   // parallel bandwidth
  171|       |	double freq1; // floating point versions of the above
  172|       |	double bw1;
  173|       |	double ap1;
  174|       |	double bp1;
  175|       |	double freq_inc;    // increment by this every 64 samples
  176|       |	double bw_inc;
  177|       |	double ap_inc;
  178|       |	double bp_inc;
  179|       |}  klatt_peaks_t;
  180|       |
  181|       |void KlattInit(void);
  182|       |void KlattReset(int control);
  183|       |int Wavegen_Klatt(int length, int resume, frame_t *fr1, frame_t *fr2, WGEN_DATA *wdata, voice_t *wvoice);
  184|       |
  185|       |#ifdef __cplusplus
  186|       |}
  187|       |#endif
  188|       |
  189|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/mbrowrap.c:
    1|       |/*
    2|       | * mbrowrap -- A wrapper library around the mbrola binary
    3|       | * providing a subset of the API from the Windows mbrola DLL.
    4|       | *
    5|       | * Copyright (C) 2005 to 2013 by Jonathan Duddington
    6|       | * Copyright (C) 2010 by Nicolas Pitre <nico@fluxnic.net>
    7|       | * Copyright (C) 2013-2016 Reece H. Dunn
    8|       | *
    9|       | * This program is free software; you can redistribute it and/or modify
   10|       | * it under the terms of the GNU General Public License as published by
   11|       | * the Free Software Foundation; either version 3 of the License, or
   12|       | * (at your option) any later version.
   13|       | *
   14|       | * This program is distributed in the hope that it will be useful,
   15|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   16|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   17|       | * GNU General Public License for more details.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#if defined(_WIN32) || defined(_WIN64)
   23|       |#include <windows.h>
   24|       |#endif
   25|       |
   26|       |#include "mbrowrap.h"
   27|       |
   28|       |int (WINAPI *init_MBR)(char *voice_path);
   29|       |void (WINAPI *close_MBR)(void);
   30|       |void (WINAPI *reset_MBR)(void);
   31|       |int (WINAPI *read_MBR)(short *buffer, int nb_samples);
   32|       |int (WINAPI *write_MBR)(char *data);
   33|       |int (WINAPI *flush_MBR)(void);
   34|       |int (WINAPI *getFreq_MBR)(void);
   35|       |void (WINAPI *setVolumeRatio_MBR)(float value);
   36|       |char * (WINAPI *lastErrorStr_MBR)(char *buffer, int bufsize);
   37|       |void (WINAPI *setNoError_MBR)(int no_error);
   38|       |
   39|       |#if defined(_WIN32) || defined(_WIN64)
   40|       |
   41|       |HINSTANCE hinstDllMBR = NULL;
   42|       |
   43|       |BOOL load_MBR()
   44|       |{
   45|       |	if (hinstDllMBR != NULL)
   46|       |		return TRUE;   // already loaded
   47|       |
   48|       |	if ((hinstDllMBR = LoadLibraryA("mbrola.dll")) == 0)
   49|       |		return FALSE;
   50|       |	init_MBR = (void *)GetProcAddress(hinstDllMBR, "init_MBR");
   51|       |	write_MBR = (void *)GetProcAddress(hinstDllMBR, "write_MBR");
   52|       |	flush_MBR = (void *)GetProcAddress(hinstDllMBR, "flush_MBR");
   53|       |	getFreq_MBR = (void *)GetProcAddress(hinstDllMBR, "getFreq_MBR");
   54|       |	read_MBR = (void *)GetProcAddress(hinstDllMBR, "read_MBR");
   55|       |	close_MBR = (void *)GetProcAddress(hinstDllMBR, "close_MBR");
   56|       |	reset_MBR = (void *)GetProcAddress(hinstDllMBR, "reset_MBR");
   57|       |	lastErrorStr_MBR = (void *)GetProcAddress(hinstDllMBR, "lastErrorStr_MBR");
   58|       |	setNoError_MBR = (void *)GetProcAddress(hinstDllMBR, "setNoError_MBR");
   59|       |	setVolumeRatio_MBR = (void *)GetProcAddress(hinstDllMBR, "setVolumeRatio_MBR");
   60|       |	return TRUE;
   61|       |}
   62|       |
   63|       |void unload_MBR()
   64|       |{
   65|       |	if (hinstDllMBR) {
   66|       |		FreeLibrary(hinstDllMBR);
   67|       |		hinstDllMBR = NULL;
   68|       |	}
   69|       |}
   70|       |
   71|       |#else
   72|       |
   73|       |#include <errno.h>
   74|       |#include <fcntl.h>
   75|       |#include <poll.h>
   76|       |#include <signal.h>
   77|       |#include <stdarg.h>
   78|       |#include <stdio.h>
   79|       |#include <stdlib.h>
   80|       |#include <string.h>
   81|       |#include <sys/types.h>
   82|       |#include <sys/wait.h>
   83|       |#include <unistd.h>
   84|       |
   85|       |#include <espeak-ng/espeak_ng.h>
   86|       |
   87|       |/*
   88|       | * mbrola instance parameters
   89|       | */
   90|       |
   91|       |enum mbr_state {
   92|       |	MBR_INACTIVE = 0,
   93|       |	MBR_IDLE,
   94|       |	MBR_NEWDATA,
   95|       |	MBR_AUDIO,
   96|       |	MBR_WEDGED
   97|       |};
   98|       |
   99|       |static enum mbr_state mbr_state;
  100|       |
  101|       |static char *mbr_voice_path;
  102|       |static int mbr_cmd_fd, mbr_audio_fd, mbr_error_fd, mbr_proc_stat;
  103|       |static pid_t mbr_pid;
  104|       |static int mbr_samplerate;
  105|       |static float mbr_volume = 1.0;
  106|       |static char mbr_errorbuf[160];
  107|       |
  108|       |struct datablock {
  109|       |	struct datablock *next;
  110|       |	int done;
  111|       |	int size;
  112|       |	char buffer[1]; // 1 or more, dynamically allocated
  113|       |};
  114|       |
  115|       |static struct datablock *mbr_pending_data_head, *mbr_pending_data_tail;
  116|       |
  117|       |/*
  118|       | * Private support code.
  119|       | */
  120|       |
  121|       |static void err(const char *errmsg, ...)
  122|      0|{
  123|      0|	va_list params;
  124|      0|
  125|      0|	va_start(params, errmsg);
  126|      0|	vsnprintf(mbr_errorbuf, sizeof(mbr_errorbuf), errmsg, params);
  127|      0|	va_end(params);
  128|      0|	fprintf(stderr, "mbrowrap error: %s\n", mbr_errorbuf);
  129|      0|}
  130|       |
  131|       |static int create_pipes(int p1[2], int p2[2], int p3[2])
  132|      0|{
  133|      0|	int error;
  134|      0|
  135|      0|	if (pipe(p1) != -1) {
  136|      0|		if (pipe(p2) != -1) {
  137|      0|			if (pipe(p3) != -1)
  138|      0|				return 0;
  139|      0|			else
  140|      0|				error = errno;
  141|      0|			close(p2[0]);
  142|      0|			close(p2[1]);
  143|      0|		} else
  144|      0|			error = errno;
  145|      0|		close(p1[0]);
  146|      0|		close(p1[1]);
  147|      0|	} else
  148|      0|		error = errno;
  149|      0|
  150|      0|	err("pipe(): %s", strerror(error));
  151|      0|	return -1;
  152|      0|}
  153|       |
  154|       |static void close_pipes(int p1[2], int p2[2], int p3[2])
  155|      0|{
  156|      0|	close(p1[0]);
  157|      0|	close(p1[1]);
  158|      0|	close(p2[0]);
  159|      0|	close(p2[1]);
  160|      0|	close(p3[0]);
  161|      0|	close(p3[1]);
  162|      0|}
  163|       |
  164|       |static int start_mbrola(const char *voice_path)
  165|      0|{
  166|      0|	int error, p_stdin[2], p_stdout[2], p_stderr[2];
  167|      0|	ssize_t written;
  168|      0|	char charbuf[20];
  169|      0|
  170|      0|	if (mbr_state != MBR_INACTIVE) {
  171|      0|		err("mbrola init request when already initialized");
  172|      0|		return -1;
  173|      0|	}
  174|      0|
  175|      0|	error = create_pipes(p_stdin, p_stdout, p_stderr);
  176|      0|	if (error)
  177|      0|		return -1;
  178|      0|
  179|      0|	mbr_pid = fork();
  180|      0|
  181|      0|	if (mbr_pid == -1) {
  182|      0|		error = errno;
  183|      0|		close_pipes(p_stdin, p_stdout, p_stderr);
  184|      0|		err("fork(): %s", strerror(error));
  185|      0|		return -1;
  186|      0|	}
  187|      0|
  188|      0|	if (mbr_pid == 0) {
  189|      0|		int i;
  190|      0|
  191|      0|		if (dup2(p_stdin[0], 0) == -1 ||
  192|      0|		    dup2(p_stdout[1], 1) == -1 ||
  193|      0|		    dup2(p_stderr[1], 2) == -1) {
  194|      0|			snprintf(mbr_errorbuf, sizeof(mbr_errorbuf),
  195|      0|			         "dup2(): %s\n", strerror(errno));
  196|      0|			written = write(p_stderr[1], mbr_errorbuf, strlen(mbr_errorbuf));
  197|      0|			(void)written;   // suppress 'variable not used' warning
  198|      0|			_exit(1);
  199|      0|		}
  200|      0|
  201|      0|		for (i = p_stderr[1]; i > 2; i--)
  202|      0|			close(i);
  203|      0|		signal(SIGHUP, SIG_IGN);
  204|      0|		signal(SIGINT, SIG_IGN);
  205|      0|		signal(SIGQUIT, SIG_IGN);
  206|      0|		signal(SIGTERM, SIG_IGN);
  207|      0|
  208|      0|		snprintf(charbuf, sizeof(charbuf), "%g", mbr_volume);
  209|      0|		execlp("mbrola", "mbrola", "-e", "-v", charbuf,
  210|      0|		       voice_path, "-", "-.wav", (char *)NULL);
  211|      0|		/* if execution reaches this point then the exec() failed */
  212|      0|		snprintf(mbr_errorbuf, sizeof(mbr_errorbuf),
  213|      0|		         "mbrola: %s\n", strerror(errno));
  214|      0|		written = write(2, mbr_errorbuf, strlen(mbr_errorbuf));
  215|      0|		(void)written;   // suppress 'variable not used' warning
  216|      0|		_exit(1);
  217|      0|	}
  218|      0|
  219|      0|	snprintf(charbuf, sizeof(charbuf), "/proc/%d/stat", mbr_pid);
  220|      0|	mbr_proc_stat = open(charbuf, O_RDONLY);
  221|      0|	if (mbr_proc_stat == -1) {
  222|      0|		error = errno;
  223|      0|		close_pipes(p_stdin, p_stdout, p_stderr);
  224|      0|		waitpid(mbr_pid, NULL, 0);
  225|      0|		mbr_pid = 0;
  226|      0|		err("/proc is unaccessible: %s", strerror(error));
  227|      0|		return -1;
  228|      0|	}
  229|      0|
  230|      0|	signal(SIGPIPE, SIG_IGN);
  231|      0|
  232|      0|	if (fcntl(p_stdin[1], F_SETFL, O_NONBLOCK) == -1 ||
  233|      0|	    fcntl(p_stdout[0], F_SETFL, O_NONBLOCK) == -1 ||
  234|      0|	    fcntl(p_stderr[0], F_SETFL, O_NONBLOCK) == -1) {
  235|      0|		error = errno;
  236|      0|		close_pipes(p_stdin, p_stdout, p_stderr);
  237|      0|		waitpid(mbr_pid, NULL, 0);
  238|      0|		mbr_pid = 0;
  239|      0|		err("fcntl(): %s", strerror(error));
  240|      0|		return -1;
  241|      0|	}
  242|      0|
  243|      0|	mbr_cmd_fd = p_stdin[1];
  244|      0|	mbr_audio_fd = p_stdout[0];
  245|      0|	mbr_error_fd = p_stderr[0];
  246|      0|	close(p_stdin[0]);
  247|      0|	close(p_stdout[1]);
  248|      0|	close(p_stderr[1]);
  249|      0|
  250|      0|	mbr_state = MBR_IDLE;
  251|      0|	return 0;
  252|      0|}
  253|       |
  254|       |static void stop_mbrola(void)
  255|      0|{
  256|      0|	if (mbr_state == MBR_INACTIVE)
  257|      0|		return;
  258|      0|	close(mbr_proc_stat);
  259|      0|	close(mbr_cmd_fd);
  260|      0|	close(mbr_audio_fd);
  261|      0|	close(mbr_error_fd);
  262|      0|	if (mbr_pid) {
  263|      0|		kill(mbr_pid, SIGTERM);
  264|      0|		waitpid(mbr_pid, NULL, 0);
  265|      0|		mbr_pid = 0;
  266|      0|	}
  267|      0|	mbr_state = MBR_INACTIVE;
  268|      0|}
  269|       |
  270|       |static void free_pending_data(void)
  271|      0|{
  272|      0|	struct datablock *p, *head = mbr_pending_data_head;
  273|      0|	while (head) {
  274|      0|		p = head;
  275|      0|		head = head->next;
  276|      0|		free(p);
  277|      0|	}
  278|      0|	mbr_pending_data_head = NULL;
  279|      0|	mbr_pending_data_tail = NULL;
  280|      0|}
  281|       |
  282|       |static int mbrola_died(void)
  283|      0|{
  284|      0|	pid_t pid;
  285|      0|	int status, len;
  286|      0|	const char *msg;
  287|      0|	char msgbuf[80];
  288|      0|
  289|      0|	pid = waitpid(mbr_pid, &status, WNOHANG);
  290|      0|	if (!pid)
  291|      0|		msg = "mbrola closed stderr and did not exit";
  292|      0|	else if (pid != mbr_pid)
  293|      0|		msg = "waitpid() is confused";
  294|      0|	else {
  295|      0|		mbr_pid = 0;
  296|      0|		if (WIFSIGNALED(status)) {
  297|      0|			int sig = WTERMSIG(status);
  298|      0|			snprintf(msgbuf, sizeof(msgbuf),
  299|      0|			         "mbrola died by signal %d", sig);
  300|      0|			msg = msgbuf;
  301|      0|		} else if (WIFEXITED(status)) {
  302|      0|			int exst = WEXITSTATUS(status);
  303|      0|			snprintf(msgbuf, sizeof(msgbuf),
  304|      0|			         "mbrola exited with status %d", exst);
  305|      0|			msg = msgbuf;
  306|      0|		} else
  307|      0|			msg = "mbrola died and wait status is weird";
  308|      0|	}
  309|      0|
  310|      0|	fprintf(stderr, "mbrowrap error: %s\n", msg);
  311|      0|
  312|      0|	len = strlen(mbr_errorbuf);
  313|      0|	if (!len)
  314|      0|		snprintf(mbr_errorbuf, sizeof(mbr_errorbuf), "%s", msg);
  315|      0|	else
  316|      0|		snprintf(mbr_errorbuf + len, sizeof(mbr_errorbuf) - len,
  317|      0|		         ", (%s)", msg);
  318|      0|	return -1;
  319|      0|}
  320|       |
  321|       |static int mbrola_has_errors(void)
  322|      0|{
  323|      0|	int result;
  324|      0|	char buffer[256];
  325|      0|	char *buf_ptr, *lf;
  326|      0|
  327|      0|	buf_ptr = buffer;
  328|      0|	for (;;) {
  329|      0|		result = read(mbr_error_fd, buf_ptr,
  330|      0|		              sizeof(buffer) - (buf_ptr - buffer) - 1);
  331|      0|		if (result == -1) {
  332|      0|			if (errno == EAGAIN)
  333|      0|				return 0;
  334|      0|			err("read(error): %s", strerror(errno));
  335|      0|			return -1;
  336|      0|		}
  337|      0|
  338|      0|		if (result == 0) {
  339|      0|			// EOF on stderr, assume mbrola died.
  340|      0|			return mbrola_died();
  341|      0|		}
  342|      0|
  343|      0|		buf_ptr[result] = 0;
  344|      0|
  345|      0|		for (; (lf = strchr(buf_ptr, '\n')); buf_ptr = lf + 1) {
  346|      0|			// inhibit the reset signal messages
  347|      0|			if (strncmp(buf_ptr, "Got a reset signal", 18) == 0 ||
  348|      0|			    strncmp(buf_ptr, "Input Flush Signal", 18) == 0)
  349|      0|				continue;
  350|      0|			*lf = 0;
  351|      0|			if (strstr(buf_ptr, "mbrola: No such file or directory") != NULL)
  352|      0|				fprintf(stderr,
  353|      0|						"mbrola executable was not found. Please install MBROLA!\n");
  354|      0|			else
  355|      0|				fprintf(stderr, "mbrola: %s\n", buf_ptr);
  356|      0|			// is this the last line?
  357|      0|			if (lf == &buf_ptr[result - 1]) {
  358|      0|				snprintf(mbr_errorbuf, sizeof(mbr_errorbuf),
  359|      0|				         "%s", buf_ptr);
  360|      0|				// don't consider this fatal at this point
  361|      0|				return 0;
  362|      0|			}
  363|      0|		}
  364|      0|
  365|      0|		memmove(buffer, buf_ptr, result);
  366|      0|		buf_ptr = buffer + result;
  367|      0|	}
  368|      0|}
  369|       |
  370|       |static int send_to_mbrola(const char *cmd)
  371|      0|{
  372|      0|	ssize_t result;
  373|      0|	int len;
  374|      0|
  375|      0|	if (!mbr_pid)
  376|      0|		return -1;
  377|      0|
  378|      0|	len = strlen(cmd);
  379|      0|	result = write(mbr_cmd_fd, cmd, len);
  380|      0|
  381|      0|	if (result == -1) {
  382|      0|		int error = errno;
  383|      0|		if (error == EPIPE && mbrola_has_errors())
  384|      0|			return -1;
  385|      0|		else if (error == EAGAIN)
  386|      0|			result = 0;
  387|      0|		else {
  388|      0|			err("write(): %s", strerror(error));
  389|      0|			return -1;
  390|      0|		}
  391|      0|	}
  392|      0|
  393|      0|	if (result != len) {
  394|      0|		struct datablock *data;
  395|      0|		data = (struct datablock *)malloc(sizeof(*data) + len - result);
  396|      0|		if (data) {
  397|      0|			data->next = NULL;
  398|      0|			data->done = 0;
  399|      0|			data->size = len - result;
  400|      0|			memcpy(data->buffer, cmd + result, len - result);
  401|      0|			result = len;
  402|      0|			if (!mbr_pending_data_head)
  403|      0|				mbr_pending_data_head = data;
  404|      0|			else
  405|      0|				mbr_pending_data_tail->next = data;
  406|      0|			mbr_pending_data_tail = data;
  407|      0|		}
  408|      0|	}
  409|      0|
  410|      0|	return result;
  411|      0|}
  412|       |
  413|       |static int mbrola_is_idle(void)
  414|      0|{
  415|      0|	char *p;
  416|      0|	char buffer[20]; // looking for "12345 (mbrola) S" so 20 is plenty
  417|      0|
  418|      0|	// look in /proc to determine if mbrola is still running or sleeping
  419|      0|	if (lseek(mbr_proc_stat, 0, SEEK_SET) != 0)
  420|      0|		return 0;
  421|      0|	if (read(mbr_proc_stat, buffer, sizeof(buffer)) != sizeof(buffer))
  422|      0|		return 0;
  423|      0|	p = (char *)memchr(buffer, ')', sizeof(buffer));
  424|      0|	if (!p || (unsigned)(p - buffer) >= sizeof(buffer) - 2)
  425|      0|		return 0;
  426|      0|	return p[1] == ' ' && p[2] == 'S';
  427|      0|}
  428|       |
  429|       |static ssize_t receive_from_mbrola(void *buffer, size_t bufsize)
  430|      0|{
  431|      0|	int result, wait = 1;
  432|      0|	size_t cursize = 0;
  433|      0|
  434|      0|	if (!mbr_pid)
  435|      0|		return -1;
  436|      0|
  437|      0|	do {
  438|      0|		struct pollfd pollfd[3];
  439|      0|		nfds_t nfds = 0;
  440|      0|		int idle;
  441|      0|
  442|      0|		pollfd[0].fd = mbr_audio_fd;
  443|      0|		pollfd[0].events = POLLIN;
  444|      0|		nfds++;
  445|      0|
  446|      0|		pollfd[1].fd = mbr_error_fd;
  447|      0|		pollfd[1].events = POLLIN;
  448|      0|		nfds++;
  449|      0|
  450|      0|		if (mbr_pending_data_head) {
  451|      0|			pollfd[2].fd = mbr_cmd_fd;
  452|      0|			pollfd[2].events = POLLOUT;
  453|      0|			nfds++;
  454|      0|		}
  455|      0|
  456|      0|		idle = mbrola_is_idle();
  457|      0|		result = poll(pollfd, nfds, idle ? 0 : wait);
  458|      0|		if (result == -1) {
  459|      0|			err("poll(): %s", strerror(errno));
  460|      0|			return -1;
  461|      0|		}
  462|      0|		if (result == 0) {
  463|      0|			if (idle) {
  464|      0|				mbr_state = MBR_IDLE;
  465|      0|				break;
  466|      0|			} else {
  467|      0|				if (wait >= 5000 * (4-1)/4) {
  468|      0|					mbr_state = MBR_WEDGED;
  469|      0|					err("mbrola process is stalled");
  470|      0|					break;
  471|      0|				} else {
  472|      0|					wait *= 4;
  473|      0|					continue;
  474|      0|				}
  475|      0|			}
  476|      0|		}
  477|      0|		wait = 1;
  478|      0|
  479|      0|		if (pollfd[1].revents && mbrola_has_errors())
  480|      0|			return -1;
  481|      0|
  482|      0|		if (mbr_pending_data_head && pollfd[2].revents) {
  483|      0|			struct datablock *head = mbr_pending_data_head;
  484|      0|			char *data = head->buffer + head->done;
  485|      0|			int left = head->size - head->done;
  486|      0|			result = write(mbr_cmd_fd, data, left);
  487|      0|			if (result == -1) {
  488|      0|				int error = errno;
  489|      0|				if (error == EPIPE && mbrola_has_errors())
  490|      0|					return -1;
  491|      0|				err("write(): %s", strerror(error));
  492|      0|				return -1;
  493|      0|			}
  494|      0|			if (result != left)
  495|      0|				head->done += result;
  496|      0|			else {
  497|      0|				mbr_pending_data_head = head->next;
  498|      0|				free(head);
  499|      0|				if (!mbr_pending_data_head)
  500|      0|					mbr_pending_data_tail = NULL;
  501|      0|				else
  502|      0|					continue;
  503|      0|			}
  504|      0|		}
  505|      0|
  506|      0|		if (pollfd[0].revents) {
  507|      0|			char *curpos = (char *)buffer + cursize;
  508|      0|			size_t space = bufsize - cursize;
  509|      0|			ssize_t obtained = read(mbr_audio_fd, curpos, space);
  510|      0|			if (obtained == -1) {
  511|      0|				err("read(): %s", strerror(errno));
  512|      0|				return -1;
  513|      0|			}
  514|      0|			cursize += obtained;
  515|      0|			mbr_state = MBR_AUDIO;
  516|      0|		}
  517|      0|	} while (cursize < bufsize);
  518|      0|
  519|      0|	return cursize;
  520|      0|}
  521|       |
  522|       |/*
  523|       | * API functions.
  524|       | */
  525|       |
  526|       |static int init_mbrola(char *voice_path)
  527|      0|{
  528|      0|	int error, result;
  529|      0|	unsigned char wavhdr[45];
  530|      0|
  531|      0|	error = start_mbrola(voice_path);
  532|      0|	if (error)
  533|      0|		return -1;
  534|      0|
  535|      0|	// Allow mbrola time to start when running on Windows Subsystem for
  536|      0|	// Linux (WSL). Otherwise, the receive_from_mbrola call to read the
  537|      0|	// wav header from mbrola will fail.
  538|      0|	usleep(100);
  539|      0|
  540|      0|	result = send_to_mbrola("#\n");
  541|      0|	if (result != 2) {
  542|      0|		stop_mbrola();
  543|      0|		return -1;
  544|      0|	}
  545|      0|
  546|      0|	// we should actually be getting only 44 bytes
  547|      0|	result = receive_from_mbrola(wavhdr, 45);
  548|      0|	if (result != 44) {
  549|      0|		if (result >= 0)
  550|      0|			err("unable to get .wav header from mbrola");
  551|      0|		stop_mbrola();
  552|      0|		return -1;
  553|      0|	}
  554|      0|
  555|      0|	// parse wavhdr to get mbrola voice samplerate
  556|      0|	if (memcmp(wavhdr, "RIFF", 4) != 0 ||
  557|      0|	    memcmp(wavhdr+8, "WAVEfmt ", 8) != 0) {
  558|      0|		err("mbrola did not return a .wav header");
  559|      0|		stop_mbrola();
  560|      0|		return -1;
  561|      0|	}
  562|      0|	mbr_samplerate = wavhdr[24] + (wavhdr[25]<<8) +
  563|      0|	                 (wavhdr[26]<<16) + (wavhdr[27]<<24);
  564|      0|
  565|      0|	// remember the voice path for setVolumeRatio_MBR()
  566|      0|	if (mbr_voice_path != voice_path) {
  567|      0|		free(mbr_voice_path);
  568|      0|		mbr_voice_path = strdup(voice_path);
  569|      0|	}
  570|      0|
  571|      0|	return 0;
  572|      0|}
  573|       |
  574|       |static void close_mbrola(void)
  575|      0|{
  576|      0|	stop_mbrola();
  577|      0|	free_pending_data();
  578|      0|	free(mbr_voice_path);
  579|      0|	mbr_voice_path = NULL;
  580|      0|	mbr_volume = 1.0;
  581|      0|}
  582|       |
  583|       |static void reset_mbrola(void)
  584|      0|{
  585|      0|	int result, success = 1;
  586|      0|	char dummybuf[4096];
  587|      0|
  588|      0|	if (mbr_state == MBR_IDLE)
  589|      0|		return;
  590|      0|	if (!mbr_pid)
  591|      0|		return;
  592|      0|	if (kill(mbr_pid, SIGUSR1) == -1)
  593|      0|		success = 0;
  594|      0|	free_pending_data();
  595|      0|	result = write(mbr_cmd_fd, "\n#\n", 3);
  596|      0|	if (result != 3)
  597|      0|		success = 0;
  598|      0|	do {
  599|      0|		result = read(mbr_audio_fd, dummybuf, sizeof(dummybuf));
  600|      0|	} while (result > 0);
  601|      0|	if (result != -1 || errno != EAGAIN)
  602|      0|		success = 0;
  603|      0|	if (!mbrola_has_errors() && success)
  604|      0|		mbr_state = MBR_IDLE;
  605|      0|}
  606|       |
  607|       |static int read_mbrola(short *buffer, int nb_samples)
  608|      0|{
  609|      0|	int result = receive_from_mbrola(buffer, nb_samples * 2);
  610|      0|	if (result > 0)
  611|      0|		result /= 2;
  612|      0|	return result;
  613|      0|}
  614|       |
  615|       |static int write_mbrola(char *data)
  616|      0|{
  617|      0|	mbr_state = MBR_NEWDATA;
  618|      0|	return send_to_mbrola(data);
  619|      0|}
  620|       |
  621|       |static int flush_mbrola(void)
  622|      0|{
  623|      0|	return send_to_mbrola("\n#\n") == 3;
  624|      0|}
  625|       |
  626|       |static int getFreq_mbrola(void)
  627|      0|{
  628|      0|	return mbr_samplerate;
  629|      0|}
  630|       |
  631|       |static void setVolumeRatio_mbrola(float value)
  632|      0|{
  633|      0|	if (value == mbr_volume)
  634|      0|		return;
  635|      0|	mbr_volume = value;
  636|      0|	if (mbr_state != MBR_IDLE)
  637|      0|		return;
  638|      0|	/*
  639|      0|	 * We have no choice but to kill and restart mbrola with
  640|      0|	 * the new argument here.
  641|      0|	 */
  642|      0|	stop_mbrola();
  643|      0|	init_MBR(mbr_voice_path);
  644|      0|}
  645|       |
  646|       |static char *lastErrorStr_mbrola(char *buffer, int bufsize)
  647|      0|{
  648|      0|	if (mbr_pid)
  649|      0|		mbrola_has_errors();
  650|      0|	snprintf(buffer, bufsize, "%s", mbr_errorbuf);
  651|      0|	return buffer;
  652|      0|}
  653|       |
  654|       |static void setNoError_mbrola(int no_error)
  655|      0|{
  656|      0|	(void)no_error; // unused
  657|      0|}
  658|       |
  659|       |BOOL load_MBR(void)
  660|      0|{
  661|      0|	init_MBR = init_mbrola;
  662|      0|	close_MBR = close_mbrola;
  663|      0|	reset_MBR = reset_mbrola;
  664|      0|	read_MBR = read_mbrola;
  665|      0|	write_MBR = write_mbrola;
  666|      0|	flush_MBR = flush_mbrola;
  667|      0|	getFreq_MBR = getFreq_mbrola;
  668|      0|	setVolumeRatio_MBR = setVolumeRatio_mbrola;
  669|      0|	lastErrorStr_MBR = lastErrorStr_mbrola;
  670|      0|	setNoError_MBR = setNoError_mbrola;
  671|      0|	return 1;
  672|      0|}
  673|       |
  674|       |void unload_MBR(void)
  675|      0|{
  676|      0|}
  677|       |
  678|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/mnemonics.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2014 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2013-2017 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <string.h>
   23|       |
   24|       |#include <espeak-ng/espeak_ng.h>
   25|       |
   26|       |#include "mnemonics.h"  // for MNEM_TAB, LookupMnem, LookupMnemName
   27|       |
   28|       |int LookupMnem(MNEM_TAB *table, const char *string)
   29|      0|{
   30|      0|	while (table->mnem != NULL) {
   31|      0|		if (string && strcmp(string, table->mnem) == 0)
   32|      0|			return table->value;
   33|      0|		table++;
   34|      0|	}
   35|      0|	return table->value;
   36|      0|}
   37|       |
   38|       |const char *LookupMnemName(MNEM_TAB *table, const int value)
   39|      0|{
   40|      0|	while (table->mnem != NULL) {
   41|      0|		if (table->value == value)
   42|      0|			return table->mnem;
   43|      0|		table++;
   44|      0|	}
   45|      0|	return ""; // not found
   46|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/numbers.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2015 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2016, 2020 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <ctype.h>
   23|       |#include <stdbool.h>
   24|       |#include <stdint.h>
   25|       |#include <stdio.h>
   26|       |#include <stdlib.h>
   27|       |#include <string.h>
   28|       |#include <wctype.h>
   29|       |
   30|       |#include <espeak-ng/espeak_ng.h>
   31|       |#include <espeak-ng/speak_lib.h>
   32|       |#include <espeak-ng/encoding.h>
   33|       |
   34|       |#include "numbers.h"
   35|       |#include "dictionary.h"  // for Lookup, TranslateRules, EncodePhonemes, Look...
   36|       |#include "phoneme.h"     // for phonSWITCH, PHONEME_TAB, phonEND_WORD, phonP...
   37|       |#include "readclause.h"  // for WordToString2, towlower2
   38|       |#include "synthdata.h"   // for SelectPhonemeTable
   39|       |#include "synthesize.h"  // for phoneme_tab
   40|       |#include "translate.h"   // for Translator, LANGUAGE_OPTIONS, IsDigit09, WOR...
   41|       |#include "voice.h"       // for voice, voice_t
   42|       |
   43|      0|#define M_LIGATURE  0x8000
   44|       |#define M_NAME      0
   45|       |#define M_SMALLCAP  1
   46|       |#define M_TURNED    2
   47|       |#define M_REVERSED  3
   48|       |#define M_CURL      4
   49|       |
   50|       |#define M_ACUTE     5
   51|       |#define M_BREVE     6
   52|       |#define M_CARON     7
   53|       |#define M_CEDILLA   8
   54|       |#define M_CIRCUMFLEX 9
   55|       |#define M_DIAERESIS 10
   56|       |#define M_DOUBLE_ACUTE 11
   57|       |#define M_DOT_ABOVE 12
   58|       |#define M_GRAVE     13
   59|       |#define M_MACRON    14
   60|       |#define M_OGONEK    15
   61|       |#define M_RING      16
   62|       |#define M_STROKE    17
   63|       |#define M_TILDE     18
   64|       |
   65|       |#define M_BAR       19
   66|       |#define M_RETROFLEX 20
   67|       |#define M_HOOK      21
   68|       |
   69|       |#define M_MIDDLE_DOT  M_DOT_ABOVE // duplicate of M_DOT_ABOVE
   70|       |#define M_IMPLOSIVE   M_HOOK
   71|       |
   72|       |static int n_digit_lookup;
   73|       |static char *digit_lookup;
   74|       |static int speak_missing_thousands;
   75|       |static int number_control;
   76|       |
   77|       |typedef struct {
   78|       |	const char *name;
   79|       |	int accent_flags;    // bit 0, say before the letter name
   80|       |} ACCENTS;
   81|       |
   82|       |// these are tokens to look up in the *_list file.
   83|       |static ACCENTS accents_tab[] = {
   84|       |	{ "_lig", 1 },
   85|       |	{ "_smc", 0 },  // smallcap
   86|       |	{ "_tur", 0 },  // turned
   87|       |	{ "_rev", 0 },  // reversed
   88|       |	{ "_crl", 0 },  // curl
   89|       |
   90|       |	{ "_acu", 0 },  // acute
   91|       |	{ "_brv", 0 },  // breve
   92|       |	{ "_hac", 0 },  // caron/hacek
   93|       |	{ "_ced", 0 },  // cedilla
   94|       |	{ "_cir", 0 },  // circumflex
   95|       |	{ "_dia", 0 },  // diaeresis
   96|       |	{ "_ac2", 0 },  // double acute
   97|       |	{ "_dot", 0 },  // dot
   98|       |	{ "_grv", 0 },  // grave
   99|       |	{ "_mcn", 0 },  // macron
  100|       |	{ "_ogo", 0 },  // ogonek
  101|       |	{ "_rng", 0 },  // ring
  102|       |	{ "_stk", 0 },  // stroke
  103|       |	{ "_tld", 0 },  // tilde
  104|       |
  105|       |	{ "_bar", 0 },  // bar
  106|       |	{ "_rfx", 0 },  // retroflex
  107|       |	{ "_hok", 0 },  // hook
  108|       |};
  109|       |
  110|       |#define CAPITAL  0
  111|       |#define LETTER(ch, mod1, mod2) (ch-59)+(mod1 << 6)+(mod2 << 11)
  112|       |#define LIGATURE(ch1, ch2, mod1) (ch1-59)+((ch2-59) << 6)+(mod1 << 12)+M_LIGATURE
  113|       |
  114|       |#define L_ALPHA   60 // U+3B1
  115|       |#define L_SCHWA   61 // U+259
  116|       |#define L_OPEN_E  62 // U+25B
  117|       |#define L_GAMMA   63 // U+3B3
  118|       |#define L_IOTA    64 // U+3B9
  119|       |
  120|       |#define L_PHI     67 // U+3C6
  121|       |#define L_ESH     68 // U+283
  122|       |#define L_UPSILON 69 // U+3C5
  123|       |#define L_EZH     70 // U+292
  124|       |#define L_GLOTTAL 71 // U+294
  125|       |#define L_RTAP    72 // U+27E
  126|       |#define L_RLONG   73 // U+27C
  127|       |
  128|       |static const short non_ascii_tab[] = {
  129|       |	0,
  130|       |	0x3b1, 0x259, 0x25b, 0x3b3, 0x3b9, 0x153, 0x3c9,
  131|       |	0x3c6, 0x283, 0x3c5, 0x292, 0x294, 0x27e, 0x27c
  132|       |};
  133|       |
  134|       |// characters U+00e0 to U+017f
  135|       |static const unsigned short letter_accents_0e0[] = {
  136|       |	LETTER('a', M_GRAVE, 0), // U+00e0
  137|       |	LETTER('a', M_ACUTE, 0),
  138|       |	LETTER('a', M_CIRCUMFLEX, 0),
  139|       |	LETTER('a', M_TILDE, 0),
  140|       |	LETTER('a', M_DIAERESIS, 0),
  141|       |	LETTER('a', M_RING, 0),
  142|       |	LIGATURE('a', 'e', 0),
  143|       |	LETTER('c', M_CEDILLA, 0),
  144|       |	LETTER('e', M_GRAVE, 0),
  145|       |	LETTER('e', M_ACUTE, 0),
  146|       |	LETTER('e', M_CIRCUMFLEX, 0),
  147|       |	LETTER('e', M_DIAERESIS, 0),
  148|       |	LETTER('i', M_GRAVE, 0),
  149|       |	LETTER('i', M_ACUTE, 0),
  150|       |	LETTER('i', M_CIRCUMFLEX, 0),
  151|       |	LETTER('i', M_DIAERESIS, 0),
  152|       |	LETTER('d', M_NAME, 0), // eth U+00f0
  153|       |	LETTER('n', M_TILDE, 0),
  154|       |	LETTER('o', M_GRAVE, 0),
  155|       |	LETTER('o', M_ACUTE, 0),
  156|       |	LETTER('o', M_CIRCUMFLEX, 0),
  157|       |	LETTER('o', M_TILDE, 0),
  158|       |	LETTER('o', M_DIAERESIS, 0),
  159|       |	0, // division sign
  160|       |	LETTER('o', M_STROKE, 0),
  161|       |	LETTER('u', M_GRAVE, 0),
  162|       |	LETTER('u', M_ACUTE, 0),
  163|       |	LETTER('u', M_CIRCUMFLEX, 0),
  164|       |	LETTER('u', M_DIAERESIS, 0),
  165|       |	LETTER('y', M_ACUTE, 0),
  166|       |	LETTER('t', M_NAME, 0), // thorn
  167|       |	LETTER('y', M_DIAERESIS, 0),
  168|       |	CAPITAL, // U+0100
  169|       |	LETTER('a', M_MACRON, 0),
  170|       |	CAPITAL,
  171|       |	LETTER('a', M_BREVE, 0),
  172|       |	CAPITAL,
  173|       |	LETTER('a', M_OGONEK, 0),
  174|       |	CAPITAL,
  175|       |	LETTER('c', M_ACUTE, 0),
  176|       |	CAPITAL,
  177|       |	LETTER('c', M_CIRCUMFLEX, 0),
  178|       |	CAPITAL,
  179|       |	LETTER('c', M_DOT_ABOVE, 0),
  180|       |	CAPITAL,
  181|       |	LETTER('c', M_CARON, 0),
  182|       |	CAPITAL,
  183|       |	LETTER('d', M_CARON, 0),
  184|       |	CAPITAL, // U+0110
  185|       |	LETTER('d', M_STROKE, 0),
  186|       |	CAPITAL,
  187|       |	LETTER('e', M_MACRON, 0),
  188|       |	CAPITAL,
  189|       |	LETTER('e', M_BREVE, 0),
  190|       |	CAPITAL,
  191|       |	LETTER('e', M_DOT_ABOVE, 0),
  192|       |	CAPITAL,
  193|       |	LETTER('e', M_OGONEK, 0),
  194|       |	CAPITAL,
  195|       |	LETTER('e', M_CARON, 0),
  196|       |	CAPITAL,
  197|       |	LETTER('g', M_CIRCUMFLEX, 0),
  198|       |	CAPITAL,
  199|       |	LETTER('g', M_BREVE, 0),
  200|       |	CAPITAL, // U+0120
  201|       |	LETTER('g', M_DOT_ABOVE, 0),
  202|       |	CAPITAL,
  203|       |	LETTER('g', M_CEDILLA, 0),
  204|       |	CAPITAL,
  205|       |	LETTER('h', M_CIRCUMFLEX, 0),
  206|       |	CAPITAL,
  207|       |	LETTER('h', M_STROKE, 0),
  208|       |	CAPITAL,
  209|       |	LETTER('i', M_TILDE, 0),
  210|       |	CAPITAL,
  211|       |	LETTER('i', M_MACRON, 0),
  212|       |	CAPITAL,
  213|       |	LETTER('i', M_BREVE, 0),
  214|       |	CAPITAL,
  215|       |	LETTER('i', M_OGONEK, 0),
  216|       |	CAPITAL, // U+0130
  217|       |	LETTER('i', M_NAME, 0), // dotless i
  218|       |	CAPITAL,
  219|       |	LIGATURE('i', 'j', 0),
  220|       |	CAPITAL,
  221|       |	LETTER('j', M_CIRCUMFLEX, 0),
  222|       |	CAPITAL,
  223|       |	LETTER('k', M_CEDILLA, 0),
  224|       |	LETTER('k', M_NAME, 0), // kra
  225|       |	CAPITAL,
  226|       |	LETTER('l', M_ACUTE, 0),
  227|       |	CAPITAL,
  228|       |	LETTER('l', M_CEDILLA, 0),
  229|       |	CAPITAL,
  230|       |	LETTER('l', M_CARON, 0),
  231|       |	CAPITAL,
  232|       |	LETTER('l', M_MIDDLE_DOT, 0), // U+0140
  233|       |	CAPITAL,
  234|       |	LETTER('l', M_STROKE, 0),
  235|       |	CAPITAL,
  236|       |	LETTER('n', M_ACUTE, 0),
  237|       |	CAPITAL,
  238|       |	LETTER('n', M_CEDILLA, 0),
  239|       |	CAPITAL,
  240|       |	LETTER('n', M_CARON, 0),
  241|       |	LETTER('n', M_NAME, 0), // apostrophe n
  242|       |	CAPITAL,
  243|       |	LETTER('n', M_NAME, 0), // eng
  244|       |	CAPITAL,
  245|       |	LETTER('o', M_MACRON, 0),
  246|       |	CAPITAL,
  247|       |	LETTER('o', M_BREVE, 0),
  248|       |	CAPITAL, // U+0150
  249|       |	LETTER('o', M_DOUBLE_ACUTE, 0),
  250|       |	CAPITAL,
  251|       |	LIGATURE('o', 'e', 0),
  252|       |	CAPITAL,
  253|       |	LETTER('r', M_ACUTE, 0),
  254|       |	CAPITAL,
  255|       |	LETTER('r', M_CEDILLA, 0),
  256|       |	CAPITAL,
  257|       |	LETTER('r', M_CARON, 0),
  258|       |	CAPITAL,
  259|       |	LETTER('s', M_ACUTE, 0),
  260|       |	CAPITAL,
  261|       |	LETTER('s', M_CIRCUMFLEX, 0),
  262|       |	CAPITAL,
  263|       |	LETTER('s', M_CEDILLA, 0),
  264|       |	CAPITAL, // U+0160
  265|       |	LETTER('s', M_CARON, 0),
  266|       |	CAPITAL,
  267|       |	LETTER('t', M_CEDILLA, 0),
  268|       |	CAPITAL,
  269|       |	LETTER('t', M_CARON, 0),
  270|       |	CAPITAL,
  271|       |	LETTER('t', M_STROKE, 0),
  272|       |	CAPITAL,
  273|       |	LETTER('u', M_TILDE, 0),
  274|       |	CAPITAL,
  275|       |	LETTER('u', M_MACRON, 0),
  276|       |	CAPITAL,
  277|       |	LETTER('u', M_BREVE, 0),
  278|       |	CAPITAL,
  279|       |	LETTER('u', M_RING, 0),
  280|       |	CAPITAL, // U+0170
  281|       |	LETTER('u', M_DOUBLE_ACUTE, 0),
  282|       |	CAPITAL,
  283|       |	LETTER('u', M_OGONEK, 0),
  284|       |	CAPITAL,
  285|       |	LETTER('w', M_CIRCUMFLEX, 0),
  286|       |	CAPITAL,
  287|       |	LETTER('y', M_CIRCUMFLEX, 0),
  288|       |	CAPITAL, // Y-DIAERESIS
  289|       |	CAPITAL,
  290|       |	LETTER('z', M_ACUTE, 0),
  291|       |	CAPITAL,
  292|       |	LETTER('z', M_DOT_ABOVE, 0),
  293|       |	CAPITAL,
  294|       |	LETTER('z', M_CARON, 0),
  295|       |	LETTER('s', M_NAME, 0), // long-s U+17f
  296|       |};
  297|       |
  298|       |// characters U+0250 to U+029F
  299|       |static const unsigned short letter_accents_250[] = {
  300|       |	LETTER('a', M_TURNED, 0), // U+250
  301|       |	LETTER(L_ALPHA, 0, 0),
  302|       |	LETTER(L_ALPHA, M_TURNED, 0),
  303|       |	LETTER('b', M_IMPLOSIVE, 0),
  304|       |	0, // open-o
  305|       |	LETTER('c', M_CURL, 0),
  306|       |	LETTER('d', M_RETROFLEX, 0),
  307|       |	LETTER('d', M_IMPLOSIVE, 0),
  308|       |	LETTER('e', M_REVERSED, 0), // U+258
  309|       |	0, // schwa
  310|       |	LETTER(L_SCHWA, M_HOOK, 0),
  311|       |	0, // open-e
  312|       |	LETTER(L_OPEN_E, M_REVERSED, 0),
  313|       |	LETTER(L_OPEN_E, M_HOOK, M_REVERSED),
  314|       |	0,
  315|       |	LETTER('j', M_BAR, 0),
  316|       |	LETTER('g', M_IMPLOSIVE, 0), // U+260
  317|       |	LETTER('g', 0, 0),
  318|       |	LETTER('g', M_SMALLCAP, 0),
  319|       |	LETTER(L_GAMMA, 0, 0),
  320|       |	0, // ramshorn
  321|       |	LETTER('h', M_TURNED, 0),
  322|       |	LETTER('h', M_HOOK, 0),
  323|       |	0,
  324|       |	LETTER('i', M_BAR, 0), // U+268
  325|       |	LETTER(L_IOTA, 0, 0),
  326|       |	LETTER('i', M_SMALLCAP, 0),
  327|       |	LETTER('l', M_TILDE, 0),
  328|       |	LETTER('l', M_BAR, 0),
  329|       |	LETTER('l', M_RETROFLEX, 0),
  330|       |	LIGATURE('l', 'z', 0),
  331|       |	LETTER('m', M_TURNED, 0),
  332|       |	0,
  333|       |	LETTER('m', M_HOOK, 0),
  334|       |	0,
  335|       |	LETTER('n', M_RETROFLEX, 0),
  336|       |	LETTER('n', M_SMALLCAP, 0),
  337|       |	LETTER('o', M_BAR, 0),
  338|       |	LIGATURE('o', 'e', M_SMALLCAP),
  339|       |	0,
  340|       |	LETTER(L_PHI, 0, 0), // U+278
  341|       |	LETTER('r', M_TURNED, 0),
  342|       |	LETTER(L_RLONG, M_TURNED, 0),
  343|       |	LETTER('r', M_RETROFLEX, M_TURNED),
  344|       |	0,
  345|       |	LETTER('r', M_RETROFLEX, 0),
  346|       |	0, // r-tap
  347|       |	LETTER(L_RTAP, M_REVERSED, 0),
  348|       |	LETTER('r', M_SMALLCAP, 0), // U+280
  349|       |	LETTER('r', M_TURNED, M_SMALLCAP),
  350|       |	LETTER('s', M_RETROFLEX, 0),
  351|       |	0, // esh
  352|       |	LETTER('j', M_HOOK, 0),
  353|       |	LETTER(L_ESH, M_REVERSED, 0),
  354|       |	LETTER(L_ESH, M_CURL, 0),
  355|       |	LETTER('t', M_TURNED, 0),
  356|       |	LETTER('t', M_RETROFLEX, 0), // U+288
  357|       |	LETTER('u', M_BAR, 0),
  358|       |	LETTER(L_UPSILON, 0, 0),
  359|       |	LETTER('v', M_HOOK, 0),
  360|       |	LETTER('v', M_TURNED, 0),
  361|       |	LETTER('w', M_TURNED, 0),
  362|       |	LETTER('y', M_TURNED, 0),
  363|       |	LETTER('y', M_SMALLCAP, 0),
  364|       |	LETTER('z', M_RETROFLEX, 0), // U+290
  365|       |	LETTER('z', M_CURL, 0),
  366|       |	0, // ezh
  367|       |	LETTER(L_EZH, M_CURL, 0),
  368|       |	0, // glottal stop
  369|       |	LETTER(L_GLOTTAL, M_REVERSED, 0),
  370|       |	LETTER(L_GLOTTAL, M_TURNED, 0),
  371|       |	0,
  372|       |	0, // bilabial click U+298
  373|       |	LETTER('b', M_SMALLCAP, 0),
  374|       |	0,
  375|       |	LETTER('g', M_IMPLOSIVE, M_SMALLCAP),
  376|       |	LETTER('h', M_SMALLCAP, 0),
  377|       |	LETTER('j', M_CURL, 0),
  378|       |	LETTER('k', M_TURNED, 0),
  379|       |	LETTER('l', M_SMALLCAP, 0),
  380|       |	LETTER('q', M_HOOK, 0), // U+2a0
  381|       |	LETTER(L_GLOTTAL, M_STROKE, 0),
  382|       |	LETTER(L_GLOTTAL, M_STROKE, M_REVERSED),
  383|       |	LIGATURE('d', 'z', 0),
  384|       |	0, // dezh
  385|       |	LIGATURE('d', 'z', M_CURL),
  386|       |	LIGATURE('t', 's', 0),
  387|       |	0, // tesh
  388|       |	LIGATURE('t', 's', M_CURL),
  389|       |};
  390|       |
  391|       |static int LookupLetter2(Translator *tr, unsigned int letter, char *ph_buf)
  392|      0|{
  393|      0|	int len;
  394|      0|	char single_letter[10];
  395|      0|
  396|      0|	single_letter[0] = 0;
  397|      0|	single_letter[1] = '_';
  398|      0|	len = utf8_out(letter, &single_letter[2]);
  399|      0|	single_letter[len+2] = ' ';
  400|      0|	single_letter[len+3] = 0;
  401|      0|
  402|      0|	if (Lookup(tr, &single_letter[1], ph_buf) == 0) {
  403|      0|		single_letter[1] = ' ';
  404|      0|		if (Lookup(tr, &single_letter[2], ph_buf) == 0)
  405|      0|			TranslateRules(tr, &single_letter[2], ph_buf, 20, NULL, 0, NULL);
  406|      0|	}
  407|      0|	return ph_buf[0];
  408|      0|}
  409|       |
  410|       |void LookupAccentedLetter(Translator *tr, unsigned int letter, char *ph_buf)
  411|      0|{
  412|      0|	// lookup the character in the accents table
  413|      0|	int accent_data = 0;
  414|      0|	int accent1 = 0;
  415|      0|	int accent2 = 0;
  416|      0|	int flags1, flags2;
  417|      0|	int basic_letter;
  418|      0|	int letter2 = 0;
  419|      0|	char ph_letter1[30];
  420|      0|	char ph_letter2[30];
  421|      0|	char ph_accent1[30];
  422|      0|	char ph_accent2[30];
  423|      0|
  424|      0|	ph_accent2[0] = 0;
  425|      0|
  426|      0|	if ((letter >= 0xe0) && (letter < 0x17f))
  427|      0|		accent_data = letter_accents_0e0[letter - 0xe0];
  428|      0|	else if ((letter >= 0x250) && (letter <= 0x2a8))
  429|      0|		accent_data = letter_accents_250[letter - 0x250];
  430|      0|
  431|      0|	if (accent_data != 0) {
  432|      0|		basic_letter = (accent_data & 0x3f) + 59;
  433|      0|		if (basic_letter < 'a')
  434|      0|			basic_letter = non_ascii_tab[basic_letter-59];
  435|      0|
  436|      0|		if (accent_data & M_LIGATURE) {
  437|      0|			letter2 = (accent_data >> 6) & 0x3f;
  438|      0|			letter2 += 59;
  439|      0|			accent2 = (accent_data >> 12) & 0x7;
  440|      0|		} else {
  441|      0|			accent1 = (accent_data >> 6) & 0x1f;
  442|      0|			accent2 = (accent_data >> 11) & 0xf;
  443|      0|		}
  444|      0|
  445|      0|		if ((accent1 == 0) && !(accent_data & M_LIGATURE)) {
  446|      0|			// just a letter name, not an accented character or ligature
  447|      0|			return;
  448|      0|		}
  449|      0|
  450|      0|		if ((flags1 = Lookup(tr, accents_tab[accent1].name, ph_accent1)) != 0) {
  451|      0|			if (LookupLetter2(tr, basic_letter, ph_letter1) != 0) {
  452|      0|				if (accent2 != 0) {
  453|      0|					flags2 = Lookup(tr, accents_tab[accent2].name, ph_accent2);
  454|      0|					if (flags2 & FLAG_ACCENT_BEFORE) {
  455|      0|						strcpy(ph_buf, ph_accent2);
  456|      0|						ph_buf += strlen(ph_buf);
  457|      0|						ph_accent2[0] = 0;
  458|      0|					}
  459|      0|				}
  460|      0|				if (letter2 != 0) {
  461|      0|					// ligature
  462|      0|					LookupLetter2(tr, letter2, ph_letter2);
  463|      0|					sprintf(ph_buf, "%s%c%s%c%s%s", ph_accent1, phonPAUSE_VSHORT, ph_letter1, phonSTRESS_P, ph_letter2, ph_accent2);
  464|      0|				} else {
  465|      0|					if (accent1 == 0)
  466|      0|						strcpy(ph_buf, ph_letter1);
  467|      0|					else if ((tr->langopts.accents & 1) || (flags1 & FLAG_ACCENT_BEFORE) || (accents_tab[accent1].accent_flags & 1))
  468|      0|						sprintf(ph_buf, "%s%c%c%s", ph_accent1, phonPAUSE_VSHORT, phonSTRESS_P, ph_letter1);
  469|      0|					else
  470|      0|						sprintf(ph_buf, "%c%s%c%s%c", phonSTRESS_2, ph_letter1, phonPAUSE_VSHORT, ph_accent1, phonPAUSE_VSHORT);
  471|      0|				}
  472|      0|			}
  473|      0|		}
  474|      0|	}
  475|      0|}
  476|       |
  477|       |void LookupLetter(Translator *tr, unsigned int letter, int next_byte, char *ph_buf1, int control)
  478|      0|{
  479|      0|	// control, bit 0:  not the first letter of a word
  480|      0|
  481|      0|	int len;
  482|      0|	static char single_letter[10] = { 0, 0 };
  483|      0|	unsigned int dict_flags[2];
  484|      0|	char ph_buf3[40];
  485|      0|
  486|      0|	ph_buf1[0] = 0;
  487|      0|	len = utf8_out(letter, &single_letter[2]);
  488|      0|	single_letter[len+2] = ' ';
  489|      0|
  490|      0|	if (next_byte == -1) {
  491|      0|		// speaking normal text, not individual characters
  492|      0|		if (Lookup(tr, &single_letter[2], ph_buf1) != 0)
  493|      0|			return;
  494|      0|
  495|      0|		single_letter[1] = '_';
  496|      0|		if (Lookup(tr, &single_letter[1], ph_buf3) != 0)
  497|      0|			return; // the character is specified as _* so ignore it when speaking normal text
  498|      0|
  499|      0|		// check whether this character is specified for English
  500|      0|		if (tr->translator_name == L('e', 'n'))
  501|      0|			return; // we are already using English
  502|      0|
  503|      0|		SetTranslator2(ESPEAKNG_DEFAULT_VOICE);
  504|      0|		if (Lookup(translator2, &single_letter[2], ph_buf3) != 0) {
  505|      0|			// yes, switch to English and re-translate the word
  506|      0|			sprintf(ph_buf1, "%c", phonSWITCH);
  507|      0|		}
  508|      0|		SelectPhonemeTable(voice->phoneme_tab_ix); // revert to original phoneme table
  509|      0|		return;
  510|      0|	}
  511|      0|
  512|      0|	if ((letter <= 32) || iswspace(letter)) {
  513|      0|		// lookup space as _&32 etc.
  514|      0|		sprintf(&single_letter[1], "_#%d ", letter);
  515|      0|		Lookup(tr, &single_letter[1], ph_buf1);
  516|      0|		return;
  517|      0|	}
  518|      0|
  519|      0|	if (next_byte != ' ')
  520|      0|		next_byte = RULE_SPELLING;
  521|      0|	single_letter[3+len] = next_byte; // follow by space-space if the end of the word, or space-31
  522|      0|
  523|      0|	single_letter[1] = '_';
  524|      0|
  525|      0|	// if the $accent flag is set for this letter, use the accents table (below)
  526|      0|	dict_flags[1] = 0;
  527|      0|
  528|      0|	if (Lookup(tr, &single_letter[1], ph_buf3) == 0) {
  529|      0|		single_letter[1] = ' ';
  530|      0|		if (Lookup(tr, &single_letter[2], ph_buf3) == 0)
  531|      0|			TranslateRules(tr, &single_letter[2], ph_buf3, sizeof(ph_buf3), NULL, FLAG_NO_TRACE, NULL);
  532|      0|	}
  533|      0|
  534|      0|	if (ph_buf3[0] == 0)
  535|      0|		LookupAccentedLetter(tr, letter, ph_buf3);
  536|      0|
  537|      0|	strcpy(ph_buf1, ph_buf3);
  538|      0|	if ((ph_buf1[0] == 0) || (ph_buf1[0] == phonSWITCH))
  539|      0|		return;
  540|      0|
  541|      0|	dict_flags[0] = 0;
  542|      0|	dict_flags[1] = 0;
  543|      0|	SetWordStress(tr, ph_buf1, dict_flags, -1, control & 1);
  544|      0|}
  545|       |
  546|       |// unicode ranges for non-ascii digits 0-9 (these must be in ascending order)
  547|       |static const int number_ranges[] = {
  548|       |	0x660, 0x6f0, // arabic
  549|       |	0x966, 0x9e6, 0xa66, 0xae6, 0xb66, 0xbe6, 0xc66, 0xce6, 0xd66, // indic
  550|       |	0xe50, 0xed0, 0xf20, 0x1040, 0x1090,
  551|       |	0
  552|       |};
  553|       |
  554|       |static int NonAsciiNumber(int letter)
  555|      0|{
  556|      0|	// Change non-ascii digit into ascii digit '0' to '9', (or -1 if not)
  557|      0|	const int *p;
  558|      0|	int base;
  559|      0|
  560|      0|	for (p = number_ranges; (base = *p) != 0; p++) {
  561|      0|		if (letter < base)
  562|      0|			break; // not found
  563|      0|		if (letter < (base+10))
  564|      0|			return letter-base+'0';
  565|      0|	}
  566|      0|	return -1;
  567|      0|}
  568|       |
  569|       |#define L_SUB 0x4000 // subscript
  570|       |#define L_SUP 0x8000 // superscript
  571|       |
  572|       |static const char *modifiers[] = { NULL, "_sub", "_sup", NULL };
  573|       |
  574|       |// this list must be in ascending order
  575|       |static unsigned short derived_letters[] = {
  576|       |	0x00aa, 'a'+L_SUP,
  577|       |	0x00b2, '2'+L_SUP,
  578|       |	0x00b3, '3'+L_SUP,
  579|       |	0x00b9, '1'+L_SUP,
  580|       |	0x00ba, 'o'+L_SUP,
  581|       |	0x02b0, 'h'+L_SUP,
  582|       |	0x02b1, 0x266+L_SUP,
  583|       |	0x02b2, 'j'+L_SUP,
  584|       |	0x02b3, 'r'+L_SUP,
  585|       |	0x02b4, 0x279+L_SUP,
  586|       |	0x02b5, 0x27b+L_SUP,
  587|       |	0x02b6, 0x281+L_SUP,
  588|       |	0x02b7, 'w'+L_SUP,
  589|       |	0x02b8, 'y'+L_SUP,
  590|       |	0x02c0, 0x294+L_SUP,
  591|       |	0x02c1, 0x295+L_SUP,
  592|       |	0x02e0, 0x263+L_SUP,
  593|       |	0x02e1, 'l'+L_SUP,
  594|       |	0x02e2, 's'+L_SUP,
  595|       |	0x02e3, 'x'+L_SUP,
  596|       |	0x2070, '0'+L_SUP,
  597|       |	0x2071, 'i'+L_SUP,
  598|       |	0x2074, '4'+L_SUP,
  599|       |	0x2075, '5'+L_SUP,
  600|       |	0x2076, '6'+L_SUP,
  601|       |	0x2077, '7'+L_SUP,
  602|       |	0x2078, '8'+L_SUP,
  603|       |	0x2079, '9'+L_SUP,
  604|       |	0x207a, '+'+L_SUP,
  605|       |	0x207b, '-'+L_SUP,
  606|       |	0x207c, '='+L_SUP,
  607|       |	0x207d, '('+L_SUP,
  608|       |	0x207e, ')'+L_SUP,
  609|       |	0x207f, 'n'+L_SUP,
  610|       |	0x2080, '0'+L_SUB,
  611|       |	0x2081, '1'+L_SUB,
  612|       |	0x2082, '2'+L_SUB,
  613|       |	0x2083, '3'+L_SUB,
  614|       |	0x2084, '4'+L_SUB,
  615|       |	0x2085, '5'+L_SUB,
  616|       |	0x2086, '6'+L_SUB,
  617|       |	0x2087, '7'+L_SUB,
  618|       |	0x2088, '8'+L_SUB,
  619|       |	0x2089, '9'+L_SUB,
  620|       |	0x208a, '+'+L_SUB,
  621|       |	0x208b, '-'+L_SUB,
  622|       |	0x208c, '='+L_SUB,
  623|       |	0x208d, '('+L_SUB,
  624|       |	0x208e, ')'+L_SUB,
  625|       |	0x2090, 'a'+L_SUB,
  626|       |	0x2091, 'e'+L_SUB,
  627|       |	0x2092, 'o'+L_SUB,
  628|       |	0x2093, 'x'+L_SUB,
  629|       |	0x2094, 0x259+L_SUB,
  630|       |	0x2095, 'h'+L_SUB,
  631|       |	0x2096, 'k'+L_SUB,
  632|       |	0x2097, 'l'+L_SUB,
  633|       |	0x2098, 'm'+L_SUB,
  634|       |	0x2099, 'n'+L_SUB,
  635|       |	0x209a, 'p'+L_SUB,
  636|       |	0x209b, 's'+L_SUB,
  637|       |	0x209c, 't'+L_SUB,
  638|       |	0, 0
  639|       |};
  640|       |
  641|       |// names, using phonemes available to all languages
  642|       |static const char *hex_letters[] = {
  643|       |	"'e:j",
  644|       |	"b'i:",
  645|       |	"s'i:",
  646|       |	"d'i:",
  647|       |	"'i:",
  648|       |	"'ef"
  649|       |};
  650|       |
  651|       |int IsSuperscript(int letter)
  652|      0|{
  653|      0|	// is this a subscript or superscript letter ?
  654|      0|	int ix;
  655|      0|	int c;
  656|      0|
  657|      0|	for (ix = 0; (c = derived_letters[ix]) != 0; ix += 2) {
  658|      0|		if (c > letter)
  659|      0|			break;
  660|      0|		if (c == letter)
  661|      0|			return derived_letters[ix+1];
  662|      0|	}
  663|      0|	return 0;
  664|      0|}
  665|       |
  666|       |int TranslateLetter(Translator *tr, char *word, char *phonemes, int control, ALPHABET *current_alphabet)
  667|      0|{
  668|      0|	// get pronunciation for an isolated letter
  669|      0|	// return number of bytes used by the letter
  670|      0|	// control bit 0:  a non-initial letter in a word
  671|      0|	//         bit 1:  say 'capital'
  672|      0|	//         bit 2:  say character code for unknown letters
  673|      0|
  674|      0|	int n_bytes;
  675|      0|	int letter;
  676|      0|	int len;
  677|      0|	int ix;
  678|      0|	int c;
  679|      0|	char *p2;
  680|      0|	char *pbuf;
  681|      0|	const char *modifier;
  682|      0|	ALPHABET *alphabet;
  683|      0|	int al_offset;
  684|      0|	int al_flags;
  685|      0|	int language;
  686|      0|	int number;
  687|      0|	int phontab_1;
  688|      0|	int speak_letter_number;
  689|      0|	char capital[30];
  690|      0|	char ph_buf[80];
  691|      0|	char ph_buf2[80];
  692|      0|	char ph_alphabet[80];
  693|      0|	char hexbuf[12];
  694|      0|	static char pause_string[] = { phonPAUSE, 0 };
  695|      0|
  696|      0|	ph_buf[0] = 0;
  697|      0|	ph_alphabet[0] = 0;
  698|      0|	capital[0] = 0;
  699|      0|	phontab_1 = translator->phoneme_tab_ix;
  700|      0|
  701|      0|	n_bytes = utf8_in(&letter, word);
  702|      0|
  703|      0|	if ((letter & 0xfff00) == 0x0e000)
  704|      0|		letter &= 0xff; // uncode private usage area
  705|      0|
  706|      0|	if (control & 2) {
  707|      0|		// include CAPITAL information
  708|      0|		if (iswupper(letter))
  709|      0|			Lookup(tr, "_cap", capital);
  710|      0|	}
  711|      0|	letter = towlower2(letter, tr);
  712|      0|	LookupLetter(tr, letter, word[n_bytes], ph_buf, control & 1);
  713|      0|
  714|      0|	if (ph_buf[0] == 0) {
  715|      0|		// is this a subscript or superscript letter ?
  716|      0|		if ((c = IsSuperscript(letter)) != 0) {
  717|      0|			letter = c & 0x3fff;
  718|      0|			if ((control & 4 ) && ((modifier = modifiers[c >> 14]) != NULL)) {
  719|      0|				// don't say "superscript" during normal text reading
  720|      0|				Lookup(tr, modifier, capital);
  721|      0|				if (capital[0] == 0) {
  722|      0|					capital[2] = SetTranslator2(ESPEAKNG_DEFAULT_VOICE); // overwrites previous contents of translator2
  723|      0|					Lookup(translator2, modifier, &capital[3]);
  724|      0|					if (capital[3] != 0) {
  725|      0|						capital[0] = phonPAUSE;
  726|      0|						capital[1] = phonSWITCH;
  727|      0|						len = strlen(&capital[3]);
  728|      0|						capital[len+3] = phonSWITCH;
  729|      0|						capital[len+4] = phontab_1;
  730|      0|						capital[len+5] = 0;
  731|      0|					}
  732|      0|				}
  733|      0|			}
  734|      0|		}
  735|      0|		LookupLetter(tr, letter, word[n_bytes], ph_buf, control & 1);
  736|      0|	}
  737|      0|
  738|      0|	if (ph_buf[0] == phonSWITCH) {
  739|      0|		strcpy(phonemes, ph_buf);
  740|      0|		return 0;
  741|      0|	}
  742|      0|
  743|      0|
  744|      0|	if ((ph_buf[0] == 0) && ((number = NonAsciiNumber(letter)) > 0)) {
  745|      0|		// convert a non-ascii number to 0-9
  746|      0|		LookupLetter(tr, number, 0, ph_buf, control & 1);
  747|      0|	}
  748|      0|
  749|      0|	al_offset = 0;
  750|      0|	al_flags = 0;
  751|      0|	if ((alphabet = AlphabetFromChar(letter)) != NULL) {
  752|      0|		al_offset = alphabet->offset;
  753|      0|		al_flags = alphabet->flags;
  754|      0|	}
  755|      0|
  756|      0|	if (alphabet != current_alphabet) {
  757|      0|		// speak the name of the alphabet
  758|      0|		current_alphabet = alphabet;
  759|      0|		if ((alphabet != NULL) && !(al_flags & AL_DONT_NAME) && (al_offset != translator->letter_bits_offset)) {
  760|      0|			if ((al_flags & AL_DONT_NAME) || (al_offset == translator->langopts.alt_alphabet) || (al_offset == translator->langopts.our_alphabet)) {
  761|      0|				// don't say the alphabet name
  762|      0|			} else {
  763|      0|				ph_buf2[0] = 0;
  764|      0|				if (Lookup(translator, alphabet->name, ph_alphabet) == 0) { // the original language for the current voice
  765|      0|					// Can't find the local name for this alphabet, use the English name
  766|      0|					ph_alphabet[2] = SetTranslator2(ESPEAKNG_DEFAULT_VOICE); // overwrites previous contents of translator2
  767|      0|					Lookup(translator2, alphabet->name, ph_buf2);
  768|      0|				} else if (translator != tr) {
  769|      0|					phontab_1 = tr->phoneme_tab_ix;
  770|      0|					strcpy(ph_buf2, ph_alphabet);
  771|      0|					ph_alphabet[2] = translator->phoneme_tab_ix;
  772|      0|				}
  773|      0|
  774|      0|				if (ph_buf2[0] != 0) {
  775|      0|					// we used a different language for the alphabet name (now in ph_buf2)
  776|      0|					ph_alphabet[0] = phonPAUSE;
  777|      0|					ph_alphabet[1] = phonSWITCH;
  778|      0|					strcpy(&ph_alphabet[3], ph_buf2);
  779|      0|					len = strlen(ph_buf2) + 3;
  780|      0|					ph_alphabet[len] = phonSWITCH;
  781|      0|					ph_alphabet[len+1] = phontab_1;
  782|      0|					ph_alphabet[len+2] = 0;
  783|      0|				}
  784|      0|			}
  785|      0|		}
  786|      0|	}
  787|      0|
  788|      0|	// caution: SetWordStress() etc don't expect phonSWITCH + phoneme table number
  789|      0|
  790|      0|	if (ph_buf[0] == 0) {
  791|      0|		if ((al_offset != 0) && (al_offset == translator->langopts.alt_alphabet))
  792|      0|			language = translator->langopts.alt_alphabet_lang;
  793|      0|		else if ((alphabet != NULL) && (alphabet->language != 0) && !(al_flags & AL_NOT_LETTERS))
  794|      0|			language = alphabet->language;
  795|      0|		else
  796|      0|			language = L('e', 'n');
  797|      0|
  798|      0|		if ((language != tr->translator_name) || (language == L('k', 'o'))) {
  799|      0|			char *p3;
  800|      0|			int initial, code;
  801|      0|			char hangul_buf[12];
  802|      0|
  803|      0|			// speak in the language for this alphabet (or English)
  804|      0|			ph_buf[2] = SetTranslator2(WordToString2(language));
  805|      0|
  806|      0|			if (translator2 != NULL) {
  807|      0|				if (((code = letter - 0xac00) >= 0) && (letter <= 0xd7af)) {
  808|      0|					// Special case for Korean letters.
  809|      0|					// break a syllable hangul into 2 or 3 individual jamo
  810|      0|
  811|      0|					hangul_buf[0] = ' ';
  812|      0|					p3 = &hangul_buf[1];
  813|      0|					if ((initial = (code/28)/21) != 11) {
  814|      0|						p3 += utf8_out(initial + 0x1100, p3);
  815|      0|					}
  816|      0|					utf8_out(((code/28) % 21) + 0x1161, p3); // medial
  817|      0|					utf8_out((code % 28) + 0x11a7, &p3[3]); // final
  818|      0|					p3[6] = ' ';
  819|      0|					p3[7] = 0;
  820|      0|					ph_buf[3] = 0;
  821|      0|					TranslateRules(translator2, &hangul_buf[1], &ph_buf[3], sizeof(ph_buf)-3, NULL, 0, NULL);
  822|      0|					SetWordStress(translator2, &ph_buf[3], NULL, -1, 0);
  823|      0|				} else
  824|      0|					LookupLetter(translator2, letter, word[n_bytes], &ph_buf[3], control & 1);
  825|      0|
  826|      0|				if (ph_buf[3] == phonSWITCH) {
  827|      0|					// another level of language change
  828|      0|					ph_buf[2] = SetTranslator2(&ph_buf[4]);
  829|      0|					LookupLetter(translator2, letter, word[n_bytes], &ph_buf[3], control & 1);
  830|      0|				}
  831|      0|
  832|      0|				SelectPhonemeTable(voice->phoneme_tab_ix); // revert to original phoneme table
  833|      0|
  834|      0|				if (ph_buf[3] != 0) {
  835|      0|					ph_buf[0] = phonPAUSE;
  836|      0|					ph_buf[1] = phonSWITCH;
  837|      0|					len = strlen(&ph_buf[3]) + 3;
  838|      0|					ph_buf[len] = phonSWITCH; // switch back
  839|      0|					ph_buf[len+1] = tr->phoneme_tab_ix;
  840|      0|					ph_buf[len+2] = 0;
  841|      0|				}
  842|      0|			}
  843|      0|		}
  844|      0|	}
  845|      0|
  846|      0|	if (ph_buf[0] == 0) {
  847|      0|		// character name not found
  848|      0|
  849|      0|		if (ph_buf[0] == 0) {
  850|      0|			speak_letter_number = 1;
  851|      0|			if (!(al_flags & AL_NO_SYMBOL)) {
  852|      0|				if (iswalpha(letter))
  853|      0|					Lookup(translator, "_?A", ph_buf);
  854|      0|
  855|      0|				if ((ph_buf[0] == 0) && !iswspace(letter))
  856|      0|					Lookup(translator, "_??", ph_buf);
  857|      0|
  858|      0|				if (ph_buf[0] == 0)
  859|      0|					EncodePhonemes("l'et@", ph_buf, NULL);
  860|      0|			}
  861|      0|
  862|      0|			if (!(control & 4) && (al_flags & AL_NOT_CODE)) {
  863|      0|				// don't speak the character code number, unless we want full details of this character
  864|      0|				speak_letter_number = 0;
  865|      0|			}
  866|      0|
  867|      0|			if (speak_letter_number) {
  868|      0|				if (al_offset == 0x2800) {
  869|      0|					// braille dots symbol, list the numbered dots
  870|      0|					p2 = hexbuf;
  871|      0|					for (ix = 0; ix < 8; ix++) {
  872|      0|						if (letter & (1 << ix))
  873|      0|							*p2++ = '1'+ix;
  874|      0|					}
  875|      0|					*p2 = 0;
  876|      0|				} else {
  877|      0|					// speak the hexadecimal number of the character code
  878|      0|					sprintf(hexbuf, "%x", letter);
  879|      0|				}
  880|      0|
  881|      0|				pbuf = ph_buf;
  882|      0|				for (p2 = hexbuf; *p2 != 0; p2++) {
  883|      0|					pbuf += strlen(pbuf);
  884|      0|					*pbuf++ = phonPAUSE_VSHORT;
  885|      0|					LookupLetter(translator, *p2, 0, pbuf, 1);
  886|      0|					if (((pbuf[0] == 0) || (pbuf[0] == phonSWITCH)) && (*p2 >= 'a')) {
  887|      0|						// This language has no translation for 'a' to 'f', speak English names using base phonemes
  888|      0|						EncodePhonemes(hex_letters[*p2 - 'a'], pbuf, NULL);
  889|      0|					}
  890|      0|				}
  891|      0|				strcat(pbuf, pause_string);
  892|      0|			}
  893|      0|		}
  894|      0|	}
  895|      0|
  896|      0|	len = strlen(phonemes);
  897|      0|
  898|      0|	if (tr->langopts.accents & 2)  // 'capital' before or after the word ?
  899|      0|		sprintf(ph_buf2, "%c%s%s%s", 0xff, ph_alphabet, ph_buf, capital);
  900|      0|	else
  901|      0|		sprintf(ph_buf2, "%c%s%s%s", 0xff, ph_alphabet, capital, ph_buf); // the 0xff marker will be removed or replaced in SetSpellingStress()
  902|      0|	if ((len + strlen(ph_buf2)) < N_WORD_PHONEMES)
  903|      0|		strcpy(&phonemes[len], ph_buf2);
  904|      0|	return n_bytes;
  905|      0|}
  906|       |
  907|       |void SetSpellingStress(Translator *tr, char *phonemes, int control, int n_chars)
  908|      0|{
  909|      0|	// Individual letter names, reduce the stress of some.
  910|      0|	int ix;
  911|      0|	unsigned int c;
  912|      0|	int n_stress = 0;
  913|      0|	int prev = 0;
  914|      0|	int count;
  915|      0|	unsigned char buf[N_WORD_PHONEMES];
  916|      0|
  917|      0|	for (ix = 0; (c = phonemes[ix]) != 0; ix++) {
  918|      0|		if ((c == phonSTRESS_P) && (prev != phonSWITCH))
  919|      0|			n_stress++;
  920|      0|		buf[ix] = prev = c;
  921|      0|	}
  922|      0|	buf[ix] = 0;
  923|      0|
  924|      0|	count = 0;
  925|      0|	prev = 0;
  926|      0|	for (ix = 0; (c = buf[ix]) != 0; ix++) {
  927|      0|		if ((c == phonSTRESS_P) && (n_chars > 1) && (prev != phonSWITCH)) {
  928|      0|			count++;
  929|      0|
  930|      0|			if (tr->langopts.spelling_stress == 1) {
  931|      0|				// stress on initial letter when spelling
  932|      0|				if (count > 1)
  933|      0|					c = phonSTRESS_3;
  934|      0|			} else {
  935|      0|				if (count != n_stress) {
  936|      0|					if (((count % 3) != 0) || (count == n_stress-1))
  937|      0|						c = phonSTRESS_3; // reduce to secondary stress
  938|      0|				}
  939|      0|			}
  940|      0|		} else if (c == 0xff) {
  941|      0|			if ((control < 2) || (ix == 0))
  942|      0|				continue; // don't insert pauses
  943|      0|
  944|      0|			if (((count % 3) == 0) || (control > 2))
  945|      0|				c = phonPAUSE_NOLINK; // pause following a primary stress
  946|      0|			else
  947|      0|				c = phonPAUSE_VSHORT;
  948|      0|		}
  949|      0|		*phonemes++ = prev = c;
  950|      0|	}
  951|      0|	if (control >= 2)
  952|      0|		*phonemes++ = phonPAUSE_NOLINK;
  953|      0|	*phonemes = 0;
  954|      0|}
  955|       |
  956|       |// Numbers
  957|       |
  958|       |static char ph_ordinal2[12];
  959|       |static char ph_ordinal2x[12];
  960|       |
  961|       |static int CheckDotOrdinal(Translator *tr, char *word, char *word_end, WORD_TAB *wtab, int roman)
  962|      0|{
  963|      0|	int ordinal = 0;
  964|      0|	int c2;
  965|      0|	int nextflags;
  966|      0|
  967|      0|	if ((tr->langopts.numbers & NUM_ORDINAL_DOT) && ((word_end[0] == '.') || (wtab[0].flags & FLAG_HAS_DOT)) && !(wtab[1].flags & FLAG_NOSPACE)) {
  968|      0|		if (roman || !(wtab[1].flags & FLAG_FIRST_UPPER)) {
  969|      0|			if (word_end[0] == '.')
  970|      0|				utf8_in(&c2, &word_end[2]);
  971|      0|			else
  972|      0|				utf8_in(&c2, &word_end[0]);
  973|      0|
  974|      0|			if ((word_end[0] != 0) && (word_end[1] != 0) && ((c2 == 0) || (wtab[0].flags & FLAG_COMMA_AFTER) || IsAlpha(c2))) {
  975|      0|				// ordinal number is indicated by dot after the number
  976|      0|				// but not if the next word starts with an upper-case letter
  977|      0|				// (c2 == 0) is for cases such as, "2.,"
  978|      0|				ordinal = 2;
  979|      0|				if (word_end[0] == '.')
  980|      0|					word_end[0] = ' ';
  981|      0|
  982|      0|				if ((roman == 0) && (tr->translator_name == L('h', 'u'))) {
  983|      0|					// lang=hu don't treat dot as ordinal indicator if the next word is a month name ($alt). It may have a suffix.
  984|      0|					nextflags = 0;
  985|      0|					if (IsAlpha(c2))
  986|      0|						nextflags = TranslateWord(tr, &word_end[2], NULL, NULL);
  987|      0|
  988|      0|					if ((tr->prev_dict_flags[0] & FLAG_ALT_TRANS) && ((c2 == 0) || (wtab[0].flags & FLAG_COMMA_AFTER) || iswdigit(c2)))
  989|      0|						ordinal = 0; // TEST  09.02.10
  990|      0|
  991|      0|					if (nextflags & FLAG_ALT_TRANS)
  992|      0|						ordinal = 0;
  993|      0|
  994|      0|					if (nextflags & FLAG_ALT3_TRANS) {
  995|      0|						if (word[-2] == '-')
  996|      0|							ordinal = 0; // e.g. december 2-5. között
  997|      0|
  998|      0|						if (tr->prev_dict_flags[0] & (FLAG_ALT_TRANS | FLAG_ALT3_TRANS))
  999|      0|							ordinal = 0x22;
 1000|      0|					}
 1001|      0|				}
 1002|      0|			}
 1003|      0|		}
 1004|      0|	}
 1005|      0|	return ordinal;
 1006|      0|}
 1007|       |
 1008|       |static int hu_number_e(const char *word, int thousandplex, int value)
 1009|      0|{
 1010|      0|	// lang-hu: variant form of numbers when followed by hyphen and a suffix starting with 'a' or 'e' (but not a, e, az, ez, azt, ezt, att. ett
 1011|      0|
 1012|      0|	if ((word[0] == 'a') || (word[0] == 'e')) {
 1013|      0|		if ((word[1] == ' ') || (word[1] == 'z') || ((word[1] == 't') && (word[2] == 't')))
 1014|      0|			return 0;
 1015|      0|
 1016|      0|		if (((thousandplex == 1) || ((value % 1000) == 0)) && (word[1] == 'l'))
 1017|      0|			return 0; // 1000-el
 1018|      0|
 1019|      0|		return 1;
 1020|      0|	}
 1021|      0|	return 0;
 1022|      0|}
 1023|       |
 1024|       |int TranslateRoman(Translator *tr, char *word, char *ph_out, WORD_TAB *wtab)
 1025|      0|{
 1026|      0|	int c;
 1027|      0|	char *p;
 1028|      0|	const char *p2;
 1029|      0|	int acc;
 1030|      0|	int prev;
 1031|      0|	int value;
 1032|      0|	int subtract;
 1033|      0|	int repeat = 0;
 1034|      0|	int n_digits = 0;
 1035|      0|	char *word_start;
 1036|      0|	int num_control = 0;
 1037|      0|	unsigned int flags[2];
 1038|      0|	char ph_roman[30];
 1039|      0|	char number_chars[N_WORD_BYTES];
 1040|      0|
 1041|      0|	static const char *roman_numbers = "ixcmvld";
 1042|      0|	static int roman_values[] = { 1, 10, 100, 1000, 5, 50, 500 };
 1043|      0|
 1044|      0|	acc = 0;
 1045|      0|	prev = 0;
 1046|      0|	subtract = 0x7fff;
 1047|      0|	ph_out[0] = 0;
 1048|      0|	flags[0] = 0;
 1049|      0|	flags[1] = 0;
 1050|      0|
 1051|      0|	if (((tr->langopts.numbers & NUM_ROMAN_CAPITALS) && !(wtab[0].flags & FLAG_ALL_UPPER)) || IsDigit09(word[-2]))
 1052|      0|		return 0; // not '2xx'
 1053|      0|
 1054|      0|	if (word[1] == ' ') {
 1055|      0|		if ((tr->langopts.numbers & (NUM_ROMAN_CAPITALS | NUM_ROMAN_ORDINAL | NUM_ORDINAL_DOT)) && (wtab[0].flags & FLAG_HAS_DOT)) {
 1056|      0|			// allow single letter Roman ordinal followed by dot.
 1057|      0|		} else
 1058|      0|			return 0; // only one letter, don't speak as a Roman Number
 1059|      0|	}
 1060|      0|
 1061|      0|	word_start = word;
 1062|      0|	while ((c = *word++) != ' ') {
 1063|      0|		if ((p2 = strchr(roman_numbers, c)) == NULL)
 1064|      0|			return 0;
 1065|      0|
 1066|      0|		value = roman_values[p2 - roman_numbers];
 1067|      0|		if (value == prev) {
 1068|      0|			repeat++;
 1069|      0|			if (repeat >= 3)
 1070|      0|				return 0;
 1071|      0|		} else
 1072|      0|			repeat = 0;
 1073|      0|
 1074|      0|		if ((prev > 1) && (prev != 10) && (prev != 100)) {
 1075|      0|			if (value >= prev)
 1076|      0|				return 0;
 1077|      0|		}
 1078|      0|		if ((prev != 0) && (prev < value)) {
 1079|      0|			if (((acc % 10) != 0) || ((prev*10) < value))
 1080|      0|				return 0;
 1081|      0|			subtract = prev;
 1082|      0|			value -= subtract;
 1083|      0|		} else if (value >= subtract)
 1084|      0|			return 0;
 1085|      0|		else
 1086|      0|			acc += prev;
 1087|      0|		prev = value;
 1088|      0|		n_digits++;
 1089|      0|	}
 1090|      0|
 1091|      0|	if (IsDigit09(word[0]))
 1092|      0|		return 0; // e.g. 'xx2'
 1093|      0|
 1094|      0|	acc += prev;
 1095|      0|	if (acc < tr->langopts.min_roman)
 1096|      0|		return 0;
 1097|      0|
 1098|      0|	if (acc > tr->langopts.max_roman)
 1099|      0|		return 0;
 1100|      0|
 1101|      0|	Lookup(tr, "_roman", ph_roman); // precede by "roman" if _rom is defined in *_list
 1102|      0|	p = &ph_out[0];
 1103|      0|
 1104|      0|	if ((tr->langopts.numbers & NUM_ROMAN_AFTER) == 0) {
 1105|      0|		strcpy(ph_out, ph_roman);
 1106|      0|		p = &ph_out[strlen(ph_roman)];
 1107|      0|	}
 1108|      0|
 1109|      0|	sprintf(number_chars, "  %d %s    ", acc, tr->langopts.roman_suffix);
 1110|      0|
 1111|      0|	if (word[0] == '.') {
 1112|      0|		// dot has not been removed.  This implies that there was no space after it
 1113|      0|		return 0;
 1114|      0|	}
 1115|      0|
 1116|      0|	if (CheckDotOrdinal(tr, word_start, word, wtab, 1))
 1117|      0|		wtab[0].flags |= FLAG_ORDINAL;
 1118|      0|
 1119|      0|	if (tr->langopts.numbers & NUM_ROMAN_ORDINAL) {
 1120|      0|		if (tr->translator_name == L('h', 'u')) {
 1121|      0|			if (!(wtab[0].flags & FLAG_ORDINAL)) {
 1122|      0|				if ((wtab[0].flags & FLAG_HYPHEN_AFTER) && hu_number_e(word, 0, acc)) {
 1123|      0|					// should use the 'e' form of the number
 1124|      0|					num_control |= 1;
 1125|      0|				} else
 1126|      0|					return 0;
 1127|      0|			}
 1128|      0|		} else
 1129|      0|			wtab[0].flags |= FLAG_ORDINAL;
 1130|      0|	}
 1131|      0|
 1132|      0|	tr->prev_dict_flags[0] = 0;
 1133|      0|	tr->prev_dict_flags[1] = 0;
 1134|      0|	TranslateNumber(tr, &number_chars[2], p, flags, wtab, num_control);
 1135|      0|
 1136|      0|	if (tr->langopts.numbers & NUM_ROMAN_AFTER)
 1137|      0|		strcat(ph_out, ph_roman);
 1138|      0|
 1139|      0|	return 1;
 1140|      0|}
 1141|       |
 1142|       |static const char *M_Variant(int value)
 1143|      0|{
 1144|      0|	// returns M, or perhaps MA or MB for some cases
 1145|      0|
 1146|      0|	bool teens = false;
 1147|      0|
 1148|      0|	if (((value % 100) > 10) && ((value % 100) < 20))
 1149|      0|		teens = true;
 1150|      0|
 1151|      0|	switch (translator->langopts.numbers2 & NUM2_THOUSANDS_VAR_BITS)
 1152|      0|	{
 1153|      0|	case NUM2_THOUSANDS_VAR1: // lang=ru  use singular for xx1 except for x11
 1154|      0|		if ((teens == false) && ((value % 10) == 1))
 1155|      0|			return "1M";
 1156|      0|		break;
 1157|      0|	case NUM2_THOUSANDS_VAR2: // lang=cs,sk
 1158|      0|		if ((value >= 2) && (value <= 4))
 1159|      0|			return "0MA";
 1160|      0|		break;
 1161|      0|	case NUM2_THOUSANDS_VAR3: // lang=pl
 1162|      0|		if ((teens == false) && (((value % 10) >= 2) && ((value % 10) <= 4)))
 1163|      0|			return "0MA";
 1164|      0|		break;
 1165|      0|	case NUM2_THOUSANDS_VAR4: // lang=lt
 1166|      0|		if ((teens == true) || ((value % 10) == 0))
 1167|      0|			return "0MB";
 1168|      0|		if ((value % 10) == 1)
 1169|      0|			return "0MA";
 1170|      0|		break;
 1171|      0|	case NUM2_THOUSANDS_VAR5: // lang=bs,hr,sr
 1172|      0|		if (teens == false) {
 1173|      0|			if ((value % 10) == 1)
 1174|      0|				return "1M";
 1175|      0|			if (((value % 10) >= 2) && ((value % 10) <= 4))
 1176|      0|				return "0MA";
 1177|      0|		}
 1178|      0|		break;
 1179|      0|	}
 1180|      0|	return "0M";
 1181|      0|}
 1182|       |
 1183|       |static int LookupThousands(Translator *tr, int value, int thousandplex, int thousands_exact, char *ph_out)
 1184|      0|{
 1185|      0|	// thousands_exact:  bit 0  no hundreds,tens,or units,  bit 1  ordinal numberr
 1186|      0|	int found;
 1187|      0|	int found_value = 0;
 1188|      0|	char string[12];
 1189|      0|	char ph_of[12];
 1190|      0|	char ph_thousands[40];
 1191|      0|	char ph_buf[40];
 1192|      0|
 1193|      0|	ph_of[0] = 0;
 1194|      0|
 1195|      0|	// first look for a match with the exact value of thousands
 1196|      0|	if (value > 0) {
 1197|      0|		if (thousands_exact & 1) {
 1198|      0|			if (thousands_exact & 2) {
 1199|      0|				// ordinal number
 1200|      0|				sprintf(string, "_%dM%do", value, thousandplex);
 1201|      0|				found_value = Lookup(tr, string, ph_thousands);
 1202|      0|			}
 1203|      0|			if (!found_value && (number_control & 1)) {
 1204|      0|				// look for the 'e' variant
 1205|      0|				sprintf(string, "_%dM%de", value, thousandplex);
 1206|      0|				found_value = Lookup(tr, string, ph_thousands);
 1207|      0|			}
 1208|      0|			if (!found_value) {
 1209|      0|				// is there a different pronunciation if there are no hundreds,tens,or units ? (LANG=ta)
 1210|      0|				sprintf(string, "_%dM%dx", value, thousandplex);
 1211|      0|				found_value = Lookup(tr, string, ph_thousands);
 1212|      0|			}
 1213|      0|		}
 1214|      0|		if (found_value == 0) {
 1215|      0|			sprintf(string, "_%dM%d", value, thousandplex);
 1216|      0|			found_value = Lookup(tr, string, ph_thousands);
 1217|      0|		}
 1218|      0|	}
 1219|      0|
 1220|      0|	if (found_value == 0) {
 1221|      0|		if ((value % 100) >= 20)
 1222|      0|			Lookup(tr, "_0of", ph_of);
 1223|      0|
 1224|      0|		found = 0;
 1225|      0|		if (thousands_exact & 1) {
 1226|      0|			if (thousands_exact & 2) {
 1227|      0|				// ordinal number
 1228|      0|				sprintf(string, "_%s%do", M_Variant(value), thousandplex);
 1229|      0|				found = Lookup(tr, string, ph_thousands);
 1230|      0|			}
 1231|      0|			if (!found && (number_control & 1)) {
 1232|      0|				// look for the 'e' variant
 1233|      0|				sprintf(string, "_%s%de", M_Variant(value), thousandplex);
 1234|      0|				found = Lookup(tr, string, ph_thousands);
 1235|      0|			}
 1236|      0|			if (!found) {
 1237|      0|				// is there a different pronunciation if there are no hundreds,tens,or units ?
 1238|      0|				sprintf(string, "_%s%dx", M_Variant(value), thousandplex);
 1239|      0|				found = Lookup(tr, string, ph_thousands);
 1240|      0|			}
 1241|      0|		}
 1242|      0|		if (found == 0) {
 1243|      0|			sprintf(string, "_%s%d", M_Variant(value), thousandplex);
 1244|      0|
 1245|      0|			if (Lookup(tr, string, ph_thousands) == 0) {
 1246|      0|				if (thousandplex > 3) {
 1247|      0|					sprintf(string, "_0M%d", thousandplex-1);
 1248|      0|					if (Lookup(tr, string, ph_buf) == 0) {
 1249|      0|						// say "millions" if this name is not available and neither is the next lower
 1250|      0|						Lookup(tr, "_0M2", ph_thousands);
 1251|      0|						speak_missing_thousands = 3;
 1252|      0|					}
 1253|      0|				}
 1254|      0|				if (ph_thousands[0] == 0) {
 1255|      0|					// repeat "thousand" if higher order names are not available
 1256|      0|					sprintf(string, "_%dM1", value);
 1257|      0|					if ((found_value = Lookup(tr, string, ph_thousands)) == 0)
 1258|      0|						Lookup(tr, "_0M1", ph_thousands);
 1259|      0|					speak_missing_thousands = 2;
 1260|      0|				}
 1261|      0|			}
 1262|      0|		}
 1263|      0|	}
 1264|      0|	sprintf(ph_out, "%s%s", ph_of, ph_thousands);
 1265|      0|
 1266|      0|	if ((value == 1) && (thousandplex == 1) && (tr->langopts.numbers & NUM_OMIT_1_THOUSAND))
 1267|      0|		return 1;
 1268|      0|
 1269|      0|	return found_value;
 1270|      0|}
 1271|       |
 1272|       |static int LookupNum2(Translator *tr, int value, int thousandplex, const int control, char *ph_out)
 1273|      0|{
 1274|      0|	// Lookup a 2 digit number
 1275|      0|	// control bit 0: ordinal number
 1276|      0|	// control bit 1: final tens and units (not number of thousands) (use special form of '1', LANG=de "eins")
 1277|      0|	// control bit 2: tens and units only, no higher digits
 1278|      0|	// control bit 3: use feminine form of '2' (for thousands
 1279|      0|	// control bit 4: speak zero tens
 1280|      0|	// control bit 5: variant of ordinal number (lang=hu)
 1281|      0|	//         bit 8   followed by decimal fraction
 1282|      0|	//         bit 9: use #f form for both tens and units (lang=ml)
 1283|      0|
 1284|      0|	int found;
 1285|      0|	int ix;
 1286|      0|	int units;
 1287|      0|	int tens;
 1288|      0|	int is_ordinal;
 1289|      0|	int used_and = 0;
 1290|      0|	int found_ordinal = 0;
 1291|      0|	int next_phtype;
 1292|      0|	int ord_type = 'o';
 1293|      0|	char string[12]; // for looking up entries in *_list
 1294|      0|	char ph_ordinal[20];
 1295|      0|	char ph_tens[50];
 1296|      0|	char ph_digits[50];
 1297|      0|	char ph_and[12];
 1298|      0|
 1299|      0|	units = value % 10;
 1300|      0|	tens = value / 10;
 1301|      0|
 1302|      0|	found = 0;
 1303|      0|	ph_ordinal[0] = 0;
 1304|      0|	ph_tens[0] = 0;
 1305|      0|	ph_digits[0] = 0;
 1306|      0|	ph_and[0] = 0;
 1307|      0|
 1308|      0|	if (control & 0x20)
 1309|      0|		ord_type = 'q';
 1310|      0|
 1311|      0|	is_ordinal = control & 1;
 1312|      0|
 1313|      0|	if ((control & 2) && (n_digit_lookup == 2)) {
 1314|      0|		// pronunciation of the final 2 digits has already been found
 1315|      0|		strcpy(ph_out, digit_lookup);
 1316|      0|	} else {
 1317|      0|		if (digit_lookup[0] == 0) {
 1318|      0|			// is there a special pronunciation for this 2-digit number
 1319|      0|			if (control & 8) {
 1320|      0|				// is there a feminine or thousands-variant form?
 1321|      0|				sprintf(string, "_%dfx", value);
 1322|      0|				if ((found = Lookup(tr, string, ph_digits)) == 0) {
 1323|      0|					sprintf(string, "_%df", value);
 1324|      0|					found = Lookup(tr, string, ph_digits);
 1325|      0|				}
 1326|      0|			} else if (is_ordinal) {
 1327|      0|				strcpy(ph_ordinal, ph_ordinal2);
 1328|      0|
 1329|      0|				if (control & 4) {
 1330|      0|					sprintf(string, "_%d%cx", value, ord_type); // LANG=hu, special word for 1. 2. when there are no higher digits
 1331|      0|					if ((found = Lookup(tr, string, ph_digits)) != 0) {
 1332|      0|						if (ph_ordinal2x[0] != 0)
 1333|      0|							strcpy(ph_ordinal, ph_ordinal2x); // alternate pronunciation (lang=an)
 1334|      0|					}
 1335|      0|				}
 1336|      0|				if (found == 0) {
 1337|      0|					sprintf(string, "_%d%c", value, ord_type);
 1338|      0|					found = Lookup(tr, string, ph_digits);
 1339|      0|				}
 1340|      0|				found_ordinal = found;
 1341|      0|			}
 1342|      0|
 1343|      0|			if (found == 0) {
 1344|      0|				if (control & 2) {
 1345|      0|					// the final tens and units of a number
 1346|      0|					if (number_control & 1) {
 1347|      0|						// look for 'e' variant
 1348|      0|						sprintf(string, "_%de", value);
 1349|      0|						found = Lookup(tr, string, ph_digits);
 1350|      0|					}
 1351|      0|				} else {
 1352|      0|					// followed by hundreds or thousands etc
 1353|      0|					if ((tr->langopts.numbers2 & NUM2_ORDINAL_AND_THOUSANDS) && (thousandplex <= 1))
 1354|      0|						sprintf(string, "_%do", value); // LANG=TA
 1355|      0|					else
 1356|      0|						sprintf(string, "_%da", value);
 1357|      0|					found = Lookup(tr, string, ph_digits);
 1358|      0|				}
 1359|      0|
 1360|      0|				if (!found) {
 1361|      0|					if ((is_ordinal) && (tr->langopts.numbers2 & NUM2_NO_TEEN_ORDINALS)) {
 1362|      0|						// don't use numbers 10-99 to make ordinals, always use _1Xo etc (lang=pt)
 1363|      0|					} else {
 1364|      0|						sprintf(string, "_%d", value);
 1365|      0|						found = Lookup(tr, string, ph_digits);
 1366|      0|					}
 1367|      0|				}
 1368|      0|			}
 1369|      0|		}
 1370|      0|
 1371|      0|		// no, speak as tens+units
 1372|      0|
 1373|      0|		if ((value < 10) && (control & 0x10)) {
 1374|      0|			// speak leading zero
 1375|      0|			Lookup(tr, "_0", ph_tens);
 1376|      0|		} else {
 1377|      0|			if (found)
 1378|      0|				ph_tens[0] = 0;
 1379|      0|			else {
 1380|      0|				if (is_ordinal) {
 1381|      0|					sprintf(string, "_%dX%c", tens, ord_type);
 1382|      0|					if (Lookup(tr, string, ph_tens) != 0) {
 1383|      0|						found_ordinal = 1;
 1384|      0|
 1385|      0|						if ((units != 0) && (tr->langopts.numbers2 & NUM2_MULTIPLE_ORDINAL)) {
 1386|      0|							// Use the ordinal form of tens as well as units. Add the ordinal ending
 1387|      0|							strcat(ph_tens, ph_ordinal2);
 1388|      0|						}
 1389|      0|					}
 1390|      0|				}
 1391|      0|				if (found_ordinal == 0) {
 1392|      0|					if (control & 0x200)
 1393|      0|						sprintf(string, "_%dXf", tens);
 1394|      0|					else
 1395|      0|						sprintf(string, "_%dX", tens);
 1396|      0|					Lookup(tr, string, ph_tens);
 1397|      0|				}
 1398|      0|
 1399|      0|				if ((ph_tens[0] == 0) && (tr->langopts.numbers & NUM_VIGESIMAL)) {
 1400|      0|					// tens not found,  (for example) 73 is 60+13
 1401|      0|					units = (value % 20);
 1402|      0|					sprintf(string, "_%dX", tens & 0xfe);
 1403|      0|					Lookup(tr, string, ph_tens);
 1404|      0|				}
 1405|      0|
 1406|      0|				ph_digits[0] = 0;
 1407|      0|				if (units > 0) {
 1408|      0|					found = 0;
 1409|      0|
 1410|      0|					if ((control & 2) && (digit_lookup[0] != 0)) {
 1411|      0|						// we have an entry for this digit (possibly together with the next word)
 1412|      0|						strcpy(ph_digits, digit_lookup);
 1413|      0|						found_ordinal = 1;
 1414|      0|						ph_ordinal[0] = 0;
 1415|      0|					} else {
 1416|      0|						if (control & 8) {
 1417|      0|							// is there a variant form of this number?
 1418|      0|							sprintf(string, "_%df", units);
 1419|      0|							found = Lookup(tr, string, ph_digits);
 1420|      0|						}
 1421|      0|						if ((is_ordinal) && ((tr->langopts.numbers & NUM_SWAP_TENS) == 0)) {
 1422|      0|							// ordinal
 1423|      0|							sprintf(string, "_%d%c", units, ord_type);
 1424|      0|							if ((found = Lookup(tr, string, ph_digits)) != 0)
 1425|      0|								found_ordinal = 1;
 1426|      0|						}
 1427|      0|						if (found == 0) {
 1428|      0|							if ((number_control & 1) && (control & 2)) {
 1429|      0|								// look for 'e' variant
 1430|      0|								sprintf(string, "_%de", units);
 1431|      0|								found = Lookup(tr, string, ph_digits);
 1432|      0|							} else if (((control & 2) == 0) || ((tr->langopts.numbers & NUM_SWAP_TENS) != 0)) {
 1433|      0|								// followed by hundreds or thousands (or tens)
 1434|      0|								if ((tr->langopts.numbers2 & NUM2_ORDINAL_AND_THOUSANDS) && (thousandplex <= 1))
 1435|      0|									sprintf(string, "_%do", units);  // LANG=TA,  only for 100s, 1000s
 1436|      0|								else
 1437|      0|									sprintf(string, "_%da", units);
 1438|      0|								found = Lookup(tr, string, ph_digits);
 1439|      0|							}
 1440|      0|						}
 1441|      0|						if (found == 0) {
 1442|      0|							sprintf(string, "_%d", units);
 1443|      0|							Lookup(tr, string, ph_digits);
 1444|      0|						}
 1445|      0|					}
 1446|      0|				}
 1447|      0|			}
 1448|      0|		}
 1449|      0|
 1450|      0|		if ((is_ordinal) && (found_ordinal == 0) && (ph_ordinal[0] == 0)) {
 1451|      0|			if ((value >= 20) && (((value % 10) == 0) || (tr->langopts.numbers & NUM_SWAP_TENS)))
 1452|      0|				Lookup(tr, "_ord20", ph_ordinal);
 1453|      0|			if (ph_ordinal[0] == 0)
 1454|      0|				Lookup(tr, "_ord", ph_ordinal);
 1455|      0|		}
 1456|      0|
 1457|      0|		if ((tr->langopts.numbers & (NUM_SWAP_TENS | NUM_AND_UNITS)) && (ph_tens[0] != 0) && (ph_digits[0] != 0)) {
 1458|      0|			Lookup(tr, "_0and", ph_and);
 1459|      0|
 1460|      0|			if ((is_ordinal) && (tr->langopts.numbers2 & NUM2_ORDINAL_NO_AND))
 1461|      0|				ph_and[0] = 0;
 1462|      0|
 1463|      0|			if (tr->langopts.numbers & NUM_SWAP_TENS)
 1464|      0|				sprintf(ph_out, "%s%s%s%s", ph_digits, ph_and, ph_tens, ph_ordinal);
 1465|      0|			else
 1466|      0|				sprintf(ph_out, "%s%s%s%s", ph_tens, ph_and, ph_digits, ph_ordinal);
 1467|      0|			used_and = 1;
 1468|      0|		} else {
 1469|      0|			if (tr->langopts.numbers & NUM_SINGLE_VOWEL) {
 1470|      0|				// remove vowel from the end of tens if units starts with a vowel (LANG=Italian)
 1471|      0|				if (((ix = strlen(ph_tens)-1) >= 0) && (ph_digits[0] != 0)) {
 1472|      0|					if ((next_phtype = phoneme_tab[(unsigned int)(ph_digits[0])]->type) == phSTRESS)
 1473|      0|						next_phtype = phoneme_tab[(unsigned int)(ph_digits[1])]->type;
 1474|      0|
 1475|      0|					if ((phoneme_tab[(unsigned int)(ph_tens[ix])]->type == phVOWEL) && (next_phtype == phVOWEL))
 1476|      0|						ph_tens[ix] = 0;
 1477|      0|				}
 1478|      0|			}
 1479|      0|
 1480|      0|			if ((tr->langopts.numbers2 & NUM2_ORDINAL_DROP_VOWEL) && (ph_ordinal[0] != 0)) {
 1481|      0|				ix = sprintf(ph_out, "%s%s", ph_tens, ph_digits);
 1482|      0|				if ((ix > 0) && (phoneme_tab[(unsigned char)(ph_out[ix-1])]->type == phVOWEL))
 1483|      0|					ix--;
 1484|      0|				sprintf(&ph_out[ix], "%s", ph_ordinal);
 1485|      0|			} else
 1486|      0|				sprintf(ph_out, "%s%s%s", ph_tens, ph_digits, ph_ordinal);
 1487|      0|		}
 1488|      0|	}
 1489|      0|
 1490|      0|	if (tr->langopts.numbers & NUM_SINGLE_STRESS_L) {
 1491|      0|		// only one primary stress, on the first part (tens)
 1492|      0|		found = 0;
 1493|      0|		for (ix = 0; ix < (signed)strlen(ph_out); ix++) {
 1494|      0|			if (ph_out[ix] == phonSTRESS_P) {
 1495|      0|				if (found)
 1496|      0|					ph_out[ix] = phonSTRESS_3;
 1497|      0|				else
 1498|      0|					found = 1;
 1499|      0|			}
 1500|      0|		}
 1501|      0|	} else if (tr->langopts.numbers & NUM_SINGLE_STRESS) {
 1502|      0|		// only one primary stress
 1503|      0|		found = 0;
 1504|      0|		for (ix = strlen(ph_out)-1; ix >= 0; ix--) {
 1505|      0|			if (ph_out[ix] == phonSTRESS_P) {
 1506|      0|				if (found)
 1507|      0|					ph_out[ix] = phonSTRESS_3;
 1508|      0|				else
 1509|      0|					found = 1;
 1510|      0|			}
 1511|      0|		}
 1512|      0|	}
 1513|      0|	return used_and;
 1514|      0|}
 1515|       |
 1516|       |static int LookupNum3(Translator *tr, int value, char *ph_out, bool suppress_null, int thousandplex, int control)
 1517|      0|{
 1518|      0|	// Translate a 3 digit number
 1519|      0|	//  control  bit 0,  previous thousands
 1520|      0|	//           bit 1,  ordinal number
 1521|      0|	//           bit 5   variant form of ordinal number
 1522|      0|	//           bit 8   followed by decimal fraction
 1523|      0|
 1524|      0|	int found;
 1525|      0|	int hundreds;
 1526|      0|	int tensunits;
 1527|      0|	int x;
 1528|      0|	int ix;
 1529|      0|	int exact;
 1530|      0|	int ordinal;
 1531|      0|	int tplex;
 1532|      0|	bool say_zero_hundred = false;
 1533|      0|	bool say_one_hundred;
 1534|      0|	char string[12]; // for looking up entries in **_list
 1535|      0|	char buf1[100];
 1536|      0|	char buf2[100];
 1537|      0|	char ph_100[20];
 1538|      0|	char ph_10T[20];
 1539|      0|	char ph_digits[50];
 1540|      0|	char ph_thousands[50];
 1541|      0|	char ph_hundred_and[12];
 1542|      0|	char ph_thousand_and[12];
 1543|      0|
 1544|      0|	ordinal = control & 0x22;
 1545|      0|	hundreds = value / 100;
 1546|      0|	tensunits = value % 100;
 1547|      0|	buf1[0] = 0;
 1548|      0|
 1549|      0|	ph_thousands[0] = 0;
 1550|      0|	ph_thousand_and[0] = 0;
 1551|      0|
 1552|      0|	if ((tr->langopts.numbers & NUM_ZERO_HUNDRED) && ((control & 1) || (hundreds >= 10)))
 1553|      0|		say_zero_hundred = true; // lang=vi
 1554|      0|
 1555|      0|	if ((hundreds > 0) || say_zero_hundred) {
 1556|      0|		found = 0;
 1557|      0|		if (ordinal && (tensunits == 0)) {
 1558|      0|			// ordinal number, with no tens or units
 1559|      0|			found = Lookup(tr, "_0Co", ph_100);
 1560|      0|		}
 1561|      0|		if (found == 0) {
 1562|      0|			if (tensunits == 0) {
 1563|      0|				// special form for exact hundreds?
 1564|      0|				found = Lookup(tr, "_0C0", ph_100);
 1565|      0|			}
 1566|      0|			if (!found)
 1567|      0|				Lookup(tr, "_0C", ph_100);
 1568|      0|		}
 1569|      0|
 1570|      0|		if (((tr->langopts.numbers & NUM_1900) != 0) && (hundreds == 19)) {
 1571|      0|			// speak numbers such as 1984 as years: nineteen-eighty-four
 1572|      0|		} else if (hundreds >= 10) {
 1573|      0|			ph_digits[0] = 0;
 1574|      0|
 1575|      0|			exact = 0;
 1576|      0|			if ((value % 1000) == 0)
 1577|      0|				exact = 1;
 1578|      0|
 1579|      0|			tplex = thousandplex+1;
 1580|      0|			if (tr->langopts.numbers2 & NUM2_MYRIADS)
 1581|      0|				tplex = 0;
 1582|      0|
 1583|      0|			if (LookupThousands(tr, hundreds / 10, tplex, exact | ordinal, ph_10T) == 0) {
 1584|      0|				x = 0;
 1585|      0|				if (tr->langopts.numbers2 & (1 << tplex))
 1586|      0|					x = 8; // use variant (feminine) for before thousands and millions
 1587|      0|				if (tr->translator_name == L('m', 'l'))
 1588|      0|					x = 0x208;
 1589|      0|				LookupNum2(tr, hundreds/10, thousandplex, x, ph_digits);
 1590|      0|			}
 1591|      0|
 1592|      0|			if (tr->langopts.numbers2 & NUM2_SWAP_THOUSANDS)
 1593|      0|				sprintf(ph_thousands, "%s%c%s%c", ph_10T, phonEND_WORD, ph_digits, phonEND_WORD);
 1594|      0|			else
 1595|      0|				sprintf(ph_thousands, "%s%c%s%c", ph_digits, phonEND_WORD, ph_10T, phonEND_WORD);
 1596|      0|
 1597|      0|			hundreds %= 10;
 1598|      0|			if ((hundreds == 0) && (say_zero_hundred == false))
 1599|      0|				ph_100[0] = 0;
 1600|      0|			suppress_null = true;
 1601|      0|			control |= 1;
 1602|      0|		}
 1603|      0|
 1604|      0|		ph_digits[0] = 0;
 1605|      0|
 1606|      0|		if ((hundreds > 0) || say_zero_hundred) {
 1607|      0|			if ((tr->langopts.numbers & NUM_AND_HUNDRED) && ((control & 1) || (ph_thousands[0] != 0)))
 1608|      0|				Lookup(tr, "_0and", ph_thousand_and);
 1609|      0|
 1610|      0|			suppress_null = true;
 1611|      0|
 1612|      0|			found = 0;
 1613|      0|			if ((ordinal)
 1614|      0|			    && ((tensunits == 0) || (tr->langopts.numbers2 & NUM2_MULTIPLE_ORDINAL))) {
 1615|      0|				// ordinal number
 1616|      0|				sprintf(string, "_%dCo", hundreds);
 1617|      0|				found = Lookup(tr, string, ph_digits);
 1618|      0|
 1619|      0|				if ((tr->langopts.numbers2 & NUM2_MULTIPLE_ORDINAL) && (tensunits > 0)) {
 1620|      0|					// Use ordinal form of hundreds, as well as for tens and units
 1621|      0|					// Add ordinal suffix to the hundreds
 1622|      0|					strcat(ph_digits, ph_ordinal2);
 1623|      0|				}
 1624|      0|			}
 1625|      0|
 1626|      0|			if ((hundreds == 0) && say_zero_hundred)
 1627|      0|				Lookup(tr, "_0", ph_digits);
 1628|      0|			else {
 1629|      0|				if ((hundreds == 1) && (tr->langopts.numbers2 & NUM2_OMIT_1_HUNDRED_ONLY) && ((control & 1) == 0)) {
 1630|      0|					// only look for special 100 if there are previous thousands
 1631|      0|				} else {
 1632|      0|					if ((!found) && (tensunits == 0)) {
 1633|      0|						// is there a special pronunciation for exactly n00 ?
 1634|      0|						sprintf(string, "_%dC0", hundreds);
 1635|      0|						found = Lookup(tr, string, ph_digits);
 1636|      0|					}
 1637|      0|
 1638|      0|					if (!found) {
 1639|      0|						sprintf(string, "_%dC", hundreds);
 1640|      0|						found = Lookup(tr, string, ph_digits);  // is there a specific pronunciation for n-hundred ?
 1641|      0|					}
 1642|      0|				}
 1643|      0|
 1644|      0|				if (found)
 1645|      0|					ph_100[0] = 0;
 1646|      0|				else {
 1647|      0|					say_one_hundred = true;
 1648|      0|					if (hundreds == 1) {
 1649|      0|						if ((tr->langopts.numbers & NUM_OMIT_1_HUNDRED) != 0)
 1650|      0|							say_one_hundred = false;
 1651|      0|					}
 1652|      0|
 1653|      0|					if (say_one_hundred == true)
 1654|      0|						LookupNum2(tr, hundreds, thousandplex, 0, ph_digits);
 1655|      0|				}
 1656|      0|			}
 1657|      0|		}
 1658|      0|
 1659|      0|		sprintf(buf1, "%s%s%s%s", ph_thousands, ph_thousand_and, ph_digits, ph_100);
 1660|      0|	}
 1661|      0|
 1662|      0|	ph_hundred_and[0] = 0;
 1663|      0|	if (tensunits > 0) {
 1664|      0|		if ((control & 2) && (tr->langopts.numbers2 & NUM2_MULTIPLE_ORDINAL)) {
 1665|      0|			// Don't use "and" if we apply ordinal to both hundreds and units
 1666|      0|		} else {
 1667|      0|			if ((value > 100) || ((control & 1) && (thousandplex == 0))) {
 1668|      0|				if ((tr->langopts.numbers & NUM_HUNDRED_AND) || ((tr->langopts.numbers & NUM_HUNDRED_AND_DIGIT) && (tensunits < 10)))
 1669|      0|					Lookup(tr, "_0and", ph_hundred_and);
 1670|      0|			}
 1671|      0|			if ((tr->langopts.numbers & NUM_THOUSAND_AND) && (hundreds == 0) && ((control & 1) || (ph_thousands[0] != 0)))
 1672|      0|				Lookup(tr, "_0and", ph_hundred_and);
 1673|      0|		}
 1674|      0|	}
 1675|      0|
 1676|      0|	buf2[0] = 0;
 1677|      0|
 1678|      0|	if ((tensunits != 0) || (suppress_null == false)) {
 1679|      0|		x = 0;
 1680|      0|		if (thousandplex == 0) {
 1681|      0|			x = 2; // allow "eins" for 1 rather than "ein"
 1682|      0|			if (ordinal)
 1683|      0|				x = 3; // ordinal number
 1684|      0|			if ((value < 100) && !(control & 1))
 1685|      0|				x |= 4; // tens and units only, no higher digits
 1686|      0|			if (ordinal & 0x20)
 1687|      0|				x |= 0x20; // variant form of ordinal number
 1688|      0|		} else if (tr->langopts.numbers2 & (1 << thousandplex))
 1689|      0|			x = 8; // use variant (feminine) for before thousands and millions
 1690|      0|
 1691|      0|		if ((tr->translator_name == L('m', 'l')) && (thousandplex == 1))
 1692|      0|			x |= 0x208; // use #f form for both tens and units
 1693|      0|
 1694|      0|		if ((tr->langopts.numbers2 & NUM2_ZERO_TENS) && ((control & 1) || (hundreds > 0))) {
 1695|      0|			// LANG=zh,
 1696|      0|			x |= 0x10;
 1697|      0|		}
 1698|      0|
 1699|      0|		if (LookupNum2(tr, tensunits, thousandplex, x | (control & 0x100), buf2) != 0) {
 1700|      0|			if (tr->langopts.numbers & NUM_SINGLE_AND)
 1701|      0|				ph_hundred_and[0] = 0; // don't put 'and' after 'hundred' if there's 'and' between tens and units
 1702|      0|		}
 1703|      0|	} else {
 1704|      0|		if (ph_ordinal2[0] != 0) {
 1705|      0|			ix = strlen(buf1);
 1706|      0|			if ((ix > 0) && (buf1[ix-1] == phonPAUSE_SHORT))
 1707|      0|				buf1[ix-1] = 0; // remove pause before adding ordinal suffix
 1708|      0|			strcpy(buf2, ph_ordinal2);
 1709|      0|		}
 1710|      0|	}
 1711|      0|
 1712|      0|	sprintf(ph_out, "%s%s%c%s", buf1, ph_hundred_and, phonEND_WORD, buf2);
 1713|      0|
 1714|      0|	return 0;
 1715|      0|}
 1716|       |
 1717|       |static bool CheckThousandsGroup(char *word, int group_len)
 1718|      0|{
 1719|      0|	// Is this a group of 3 digits which looks like a thousands group?
 1720|      0|	int ix;
 1721|      0|
 1722|      0|	if (IsDigit09(word[group_len]) || IsDigit09(-1))
 1723|      0|		return false;
 1724|      0|
 1725|      0|	for (ix = 0; ix < group_len; ix++) {
 1726|      0|		if (!IsDigit09(word[ix]))
 1727|      0|			return false;
 1728|      0|	}
 1729|      0|	return true;
 1730|      0|}
 1731|       |
 1732|       |static int TranslateNumber_1(Translator *tr, char *word, char *ph_out, unsigned int *flags, WORD_TAB *wtab, int control)
 1733|      0|{
 1734|      0|	//  Number translation with various options
 1735|      0|	// the "word" may be up to 4 digits
 1736|      0|	// "words" of 3 digits may be preceded by another number "word" for thousands or millions
 1737|      0|
 1738|      0|	int n_digits;
 1739|      0|	int value;
 1740|      0|	int ix;
 1741|      0|	int digix;
 1742|      0|	unsigned char c;
 1743|      0|	bool suppress_null = false;
 1744|      0|	int decimal_point = 0;
 1745|      0|	int thousandplex = 0;
 1746|      0|	int thousands_exact = 1;
 1747|      0|	int thousands_inc = 0;
 1748|      0|	int prev_thousands = 0;
 1749|      0|	int ordinal = 0;
 1750|      0|	int this_value;
 1751|      0|	int decimal_count;
 1752|      0|	int max_decimal_count;
 1753|      0|	int decimal_mode;
 1754|      0|	int suffix_ix;
 1755|      0|	int skipwords = 0;
 1756|      0|	int group_len;
 1757|      0|	int len;
 1758|      0|	char *p;
 1759|      0|	char string[32]; // for looking up entries in **_list
 1760|      0|	char buf1[100];
 1761|      0|	char ph_append[50];
 1762|      0|	char ph_buf[200];
 1763|      0|	char ph_buf2[50];
 1764|      0|	char ph_zeros[50];
 1765|      0|	char suffix[30]; // string[] must be long enough for sizeof(suffix)+2
 1766|      0|	char buf_digit_lookup[50];
 1767|      0|
 1768|      0|	static const char str_pause[2] = { phonPAUSE_NOLINK, 0 };
 1769|      0|
 1770|      0|	*flags = 0;
 1771|      0|	n_digit_lookup = 0;
 1772|      0|	buf_digit_lookup[0] = 0;
 1773|      0|	digit_lookup = buf_digit_lookup;
 1774|      0|	number_control = control;
 1775|      0|
 1776|      0|	for (ix = 0; IsDigit09(word[ix]); ix++) ;
 1777|      0|	n_digits = ix;
 1778|      0|	value = this_value = atoi(word);
 1779|      0|
 1780|      0|	group_len = 3;
 1781|      0|	if (tr->langopts.numbers2 & NUM2_MYRIADS)
 1782|      0|		group_len = 4;
 1783|      0|
 1784|      0|	// is there a previous thousands part (as a previous "word") ?
 1785|      0|	if ((n_digits == group_len) && (word[-2] == tr->langopts.thousands_sep) && IsDigit09(word[-3]))
 1786|      0|		prev_thousands = 1;
 1787|      0|	else if ((tr->langopts.thousands_sep == ' ') || (tr->langopts.numbers & NUM_ALLOW_SPACE)) {
 1788|      0|		// thousands groups can be separated by spaces
 1789|      0|		if ((n_digits == 3) && !(wtab->flags & FLAG_MULTIPLE_SPACES) && IsDigit09(word[-2]))
 1790|      0|			prev_thousands = 1;
 1791|      0|	}
 1792|      0|	if (prev_thousands == 0)
 1793|      0|		speak_missing_thousands = 0;
 1794|      0|
 1795|      0|	ph_ordinal2[0] = 0;
 1796|      0|	ph_zeros[0] = 0;
 1797|      0|
 1798|      0|	if (prev_thousands || (word[0] != '0')) {
 1799|      0|		// don't check for ordinal if the number has a leading zero
 1800|      0|		ordinal = CheckDotOrdinal(tr, word, &word[ix], wtab, 0);
 1801|      0|	}
 1802|      0|
 1803|      0|	if ((word[ix] == '.') && !IsDigit09(word[ix+1]) && !IsDigit09(word[ix+2]) && !(wtab[1].flags & FLAG_NOSPACE)) {
 1804|      0|		// remove dot unless followed by another number
 1805|      0|		word[ix] = 0;
 1806|      0|	}
 1807|      0|
 1808|      0|	if ((ordinal == 0) || (tr->translator_name == L('h', 'u'))) {
 1809|      0|		// NOTE lang=hu, allow both dot and ordinal suffix, eg. "december 21.-én"
 1810|      0|		// look for an ordinal number suffix after the number
 1811|      0|		ix++;
 1812|      0|		p = suffix;
 1813|      0|		if (wtab[0].flags & FLAG_HYPHEN_AFTER) {
 1814|      0|			*p++ = '-';
 1815|      0|			ix++;
 1816|      0|		}
 1817|      0|		while ((word[ix] != 0) && (word[ix] != ' ') && (ix < (int)(sizeof(suffix)-1)))
 1818|      0|			*p++ = word[ix++];
 1819|      0|		*p = 0;
 1820|      0|
 1821|      0|		if (suffix[0] != 0) {
 1822|      0|			if ((tr->langopts.ordinal_indicator != NULL) && (strcmp(suffix, tr->langopts.ordinal_indicator) == 0))
 1823|      0|				ordinal = 2;
 1824|      0|			else if (!IsDigit09(suffix[0])) { // not _#9 (tab)
 1825|      0|				sprintf(string, "_#%s", suffix);
 1826|      0|				if (Lookup(tr, string, ph_ordinal2)) {
 1827|      0|					// this is an ordinal suffix
 1828|      0|					ordinal = 2;
 1829|      0|					flags[0] |= FLAG_SKIPWORDS;
 1830|      0|					skipwords = 1;
 1831|      0|					sprintf(string, "_x#%s", suffix);
 1832|      0|					Lookup(tr, string, ph_ordinal2x); // is there an alternate pronunciation?
 1833|      0|				}
 1834|      0|			}
 1835|      0|		}
 1836|      0|	}
 1837|      0|
 1838|      0|	if (wtab[0].flags & FLAG_ORDINAL)
 1839|      0|		ordinal = 2;
 1840|      0|
 1841|      0|	ph_append[0] = 0;
 1842|      0|	ph_buf2[0] = 0;
 1843|      0|
 1844|      0|	if ((word[0] == '0') && (prev_thousands == 0) && (word[1] != ' ') && (word[1] != tr->langopts.decimal_sep)) {
 1845|      0|		if ((n_digits == 2) && (word[3] == ':') && IsDigit09(word[5]) && isspace(word[7])) {
 1846|      0|			// looks like a time 02:30, omit the leading zero
 1847|      0|		} else {
 1848|      0|			if (n_digits > 3) {
 1849|      0|				flags[0] &= ~FLAG_SKIPWORDS;
 1850|      0|				return 0; // long number string with leading zero, speak as individual digits
 1851|      0|			}
 1852|      0|
 1853|      0|			// speak leading zeros
 1854|      0|			for (ix = 0; (word[ix] == '0') && (ix < (n_digits-1)); ix++)
 1855|      0|				Lookup(tr, "_0", &ph_zeros[strlen(ph_zeros)]);
 1856|      0|		}
 1857|      0|	}
 1858|      0|
 1859|      0|	if ((tr->langopts.numbers & NUM_ALLOW_SPACE) && (word[n_digits] == ' '))
 1860|      0|		thousands_inc = 1;
 1861|      0|	else if (word[n_digits] == tr->langopts.thousands_sep)
 1862|      0|		thousands_inc = 2;
 1863|      0|
 1864|      0|	suffix_ix = n_digits+2;
 1865|      0|	if (thousands_inc > 0) {
 1866|      0|		// if the following "words" are three-digit groups, count them and add
 1867|      0|		// a "thousand"/"million" suffix to this one
 1868|      0|		digix = n_digits + thousands_inc;
 1869|      0|
 1870|      0|		while (((wtab[thousandplex+1].flags & FLAG_MULTIPLE_SPACES) == 0) && CheckThousandsGroup(&word[digix], group_len)) {
 1871|      0|			for (ix = 0; ix < group_len; ix++) {
 1872|      0|				if (word[digix+ix] != '0') {
 1873|      0|					thousands_exact = 0;
 1874|      0|					break;
 1875|      0|				}
 1876|      0|			}
 1877|      0|
 1878|      0|			thousandplex++;
 1879|      0|			digix += group_len;
 1880|      0|			if ((word[digix] == tr->langopts.thousands_sep) || ((tr->langopts.numbers & NUM_ALLOW_SPACE) && (word[digix] == ' '))) {
 1881|      0|				suffix_ix = digix+2;
 1882|      0|				digix += thousands_inc;
 1883|      0|			} else
 1884|      0|				break;
 1885|      0|		}
 1886|      0|	}
 1887|      0|
 1888|      0|	if ((value == 0) && prev_thousands)
 1889|      0|		suppress_null = true;
 1890|      0|
 1891|      0|	if (tr->translator_name == L('h', 'u')) {
 1892|      0|		// variant form of numbers when followed by hyphen and a suffix starting with 'a' or 'e' (but not a, e, az, ez, azt, ezt
 1893|      0|		if ((wtab[thousandplex].flags & FLAG_HYPHEN_AFTER) && (thousands_exact == 1) && hu_number_e(&word[suffix_ix], thousandplex, value))
 1894|      0|			number_control |= 1; // use _1e variant of number
 1895|      0|	}
 1896|      0|
 1897|      0|	if ((word[n_digits] == tr->langopts.decimal_sep) && IsDigit09(word[n_digits+1])) {
 1898|      0|		// this "word" ends with a decimal point
 1899|      0|		Lookup(tr, "_dpt", ph_append);
 1900|      0|		decimal_point = 0x100;
 1901|      0|	} else if (suppress_null == false) {
 1902|      0|		if (thousands_inc > 0) {
 1903|      0|			if (thousandplex > 0) {
 1904|      0|				if ((suppress_null == false) && (LookupThousands(tr, value, thousandplex, thousands_exact, ph_append))) {
 1905|      0|					// found an exact match for N thousand
 1906|      0|					value = 0;
 1907|      0|					suppress_null = true;
 1908|      0|				}
 1909|      0|			}
 1910|      0|		}
 1911|      0|	} else if (speak_missing_thousands == 1) {
 1912|      0|		// speak this thousandplex if there was no word for the previous thousandplex
 1913|      0|		sprintf(string, "_0M%d", thousandplex+1);
 1914|      0|		if (Lookup(tr, string, buf1) == 0) {
 1915|      0|			sprintf(string, "_0M%d", thousandplex);
 1916|      0|			Lookup(tr, string, ph_append);
 1917|      0|		}
 1918|      0|	}
 1919|      0|
 1920|      0|	if ((ph_append[0] == 0) && (word[n_digits] == '.') && (thousandplex == 0))
 1921|      0|		Lookup(tr, "_.", ph_append);
 1922|      0|
 1923|      0|	if (thousandplex == 0) {
 1924|      0|		char *p2;
 1925|      0|		// look for combinations of the number with the next word
 1926|      0|		p = word;
 1927|      0|		while (IsDigit09(p[1])) p++; // just use the last digit
 1928|      0|		if (IsDigit09(p[-1])) {
 1929|      0|			p2 = p - 1;
 1930|      0|			if (LookupDictList(tr, &p2, buf_digit_lookup, flags, FLAG_SUFX, wtab)) // lookup 2 digits
 1931|      0|				n_digit_lookup = 2;
 1932|      0|		}
 1933|      0|
 1934|      0|		if ((buf_digit_lookup[0] == 0) && (*p != '0')) {
 1935|      0|			// LANG=hu ?
 1936|      0|			// not found, lookup only the last digit (?? but not if dot-ordinal has been found)
 1937|      0|			if (LookupDictList(tr, &p, buf_digit_lookup, flags, FLAG_SUFX, wtab)) // don't match '0', or entries with $only
 1938|      0|				n_digit_lookup = 1;
 1939|      0|		}
 1940|      0|
 1941|      0|		if (prev_thousands == 0) {
 1942|      0|			if ((decimal_point == 0) && (ordinal == 0)) {
 1943|      0|				// Look for special pronunciation for this number in isolation (LANG=kl)
 1944|      0|				sprintf(string, "_%dn", value);
 1945|      0|				if (Lookup(tr, string, ph_out))
 1946|      0|					return 1;
 1947|      0|			}
 1948|      0|
 1949|      0|			if (tr->langopts.numbers2 & NUM2_PERCENT_BEFORE) {
 1950|      0|				// LANG=si, say "percent" before the number
 1951|      0|				p2 = word;
 1952|      0|				while ((*p2 != ' ') && (*p2 != 0))
 1953|      0|					p2++;
 1954|      0|				if (p2[1] == '%') {
 1955|      0|					Lookup(tr, "%", ph_out);
 1956|      0|					ph_out += strlen(ph_out);
 1957|      0|					p2[1] = ' ';
 1958|      0|				}
 1959|      0|			}
 1960|      0|		}
 1961|      0|
 1962|      0|	}
 1963|      0|
 1964|      0|	LookupNum3(tr, value, ph_buf, suppress_null, thousandplex, prev_thousands | ordinal | decimal_point);
 1965|      0|	if ((thousandplex > 0) && (tr->langopts.numbers2 & NUM2_SWAP_THOUSANDS))
 1966|      0|		sprintf(ph_out, "%s%s%c%s%s", ph_zeros, ph_append, phonEND_WORD, ph_buf2, ph_buf);
 1967|      0|	else
 1968|      0|		sprintf(ph_out, "%s%s%s%c%s", ph_zeros, ph_buf2, ph_buf, phonEND_WORD, ph_append);
 1969|      0|
 1970|      0|
 1971|      0|	while (decimal_point) {
 1972|      0|		n_digits++;
 1973|      0|
 1974|      0|		decimal_count = 0;
 1975|      0|		while (IsDigit09(word[n_digits+decimal_count]))
 1976|      0|			decimal_count++;
 1977|      0|
 1978|      0|		max_decimal_count = 2;
 1979|      0|		switch (decimal_mode = (tr->langopts.numbers & NUM_DFRACTION_BITS))
 1980|      0|		{
 1981|      0|		case NUM_DFRACTION_4:
 1982|      0|			max_decimal_count = 5;
 1983|      0|			// fallthrough:
 1984|      0|		case NUM_DFRACTION_2:
 1985|      0|			// French/Polish decimal fraction
 1986|      0|			while (word[n_digits] == '0') {
 1987|      0|				Lookup(tr, "_0", buf1);
 1988|      0|				strcat(ph_out, buf1);
 1989|      0|				decimal_count--;
 1990|      0|				n_digits++;
 1991|      0|			}
 1992|      0|			if ((decimal_count <= max_decimal_count) && IsDigit09(word[n_digits])) {
 1993|      0|				LookupNum3(tr, atoi(&word[n_digits]), buf1, false, 0, 0);
 1994|      0|				strcat(ph_out, buf1);
 1995|      0|				n_digits += decimal_count;
 1996|      0|			}
 1997|      0|			break;
 1998|      0|		case NUM_DFRACTION_1: // italian, say "hundredths" if leading zero
 1999|      0|		case NUM_DFRACTION_5: // hungarian, always say "tenths" etc.
 2000|      0|		case NUM_DFRACTION_6: // kazakh, always say "tenths" etc, before the decimal fraction
 2001|      0|			LookupNum3(tr, atoi(&word[n_digits]), ph_buf, false, 0, 0);
 2002|      0|			if ((word[n_digits] == '0') || (decimal_mode != NUM_DFRACTION_1)) {
 2003|      0|				// decimal part has leading zeros, so add a "hundredths" or "thousandths" suffix
 2004|      0|				sprintf(string, "_0Z%d", decimal_count);
 2005|      0|				if (Lookup(tr, string, buf1) == 0)
 2006|      0|					break; // revert to speaking single digits
 2007|      0|
 2008|      0|				if (decimal_mode == NUM_DFRACTION_6)
 2009|      0|					strcat(ph_out, buf1);
 2010|      0|				else
 2011|      0|					strcat(ph_buf, buf1);
 2012|      0|			}
 2013|      0|			strcat(ph_out, ph_buf);
 2014|      0|			n_digits += decimal_count;
 2015|      0|			break;
 2016|      0|		case NUM_DFRACTION_3:
 2017|      0|			// Romanian decimal fractions
 2018|      0|			if ((decimal_count <= 4) && (word[n_digits] != '0')) {
 2019|      0|				LookupNum3(tr, atoi(&word[n_digits]), buf1, false, 0, 0);
 2020|      0|				strcat(ph_out, buf1);
 2021|      0|				n_digits += decimal_count;
 2022|      0|			}
 2023|      0|			break;
 2024|      0|		case NUM_DFRACTION_7:
 2025|      0|			// alternative form of decimal fraction digits, except the final digit
 2026|      0|			while (decimal_count-- > 1) {
 2027|      0|				sprintf(string, "_%cd", word[n_digits]);
 2028|      0|				if (Lookup(tr, string, buf1) == 0)
 2029|      0|					break;
 2030|      0|				n_digits++;
 2031|      0|				strcat(ph_out, buf1);
 2032|      0|			}
 2033|      0|		}
 2034|      0|
 2035|      0|		while (IsDigit09(c = word[n_digits]) && (strlen(ph_out) < (N_WORD_PHONEMES - 10))) {
 2036|      0|			// speak any remaining decimal fraction digits individually
 2037|      0|			value = word[n_digits++] - '0';
 2038|      0|			LookupNum2(tr, value, 0, 2, buf1);
 2039|      0|			len = strlen(ph_out);
 2040|      0|			sprintf(&ph_out[len], "%c%s", phonEND_WORD, buf1);
 2041|      0|		}
 2042|      0|
 2043|      0|		// something after the decimal part ?
 2044|      0|		if (Lookup(tr, "_dpt2", buf1))
 2045|      0|			strcat(ph_out, buf1);
 2046|      0|
 2047|      0|		if ((c == tr->langopts.decimal_sep) && IsDigit09(word[n_digits+1])) {
 2048|      0|			Lookup(tr, "_dpt", buf1);
 2049|      0|			strcat(ph_out, buf1);
 2050|      0|		} else
 2051|      0|			decimal_point = 0;
 2052|      0|	}
 2053|      0|	if ((ph_out[0] != 0) && (ph_out[0] != phonSWITCH)) {
 2054|      0|		int next_char;
 2055|      0|		char *p;
 2056|      0|		p = &word[n_digits+1];
 2057|      0|
 2058|      0|		p += utf8_in(&next_char, p);
 2059|      0|		if ((tr->langopts.numbers & NUM_NOPAUSE) && (next_char == ' '))
 2060|      0|			utf8_in(&next_char, p);
 2061|      0|
 2062|      0|		if (!iswalpha(next_char) && (thousands_exact == 0))
 2063|      0|			strcat(ph_out, str_pause); // don't add pause for 100s,  6th, etc.
 2064|      0|	}
 2065|      0|
 2066|      0|	*flags |= FLAG_FOUND;
 2067|      0|	speak_missing_thousands--;
 2068|      0|
 2069|      0|	if (skipwords)
 2070|      0|		dictionary_skipwords = skipwords;
 2071|      0|	return 1;
 2072|      0|}
 2073|       |
 2074|       |int TranslateNumber(Translator *tr, char *word1, char *ph_out, unsigned int *flags, WORD_TAB *wtab, int control)
 2075|      0|{
 2076|      0|	if ((option_sayas == SAYAS_DIGITS1) || (wtab[0].flags & FLAG_INDIVIDUAL_DIGITS))
 2077|      0|		return 0; // speak digits individually
 2078|      0|
 2079|      0|	if (tr->langopts.numbers != 0)
 2080|      0|		return TranslateNumber_1(tr, word1, ph_out, flags, wtab, control);
 2081|      0|	return 0;
 2082|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/phoneme.h:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2010 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2017 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#ifndef ESPEAK_NG_PHONEME_H
   21|       |#define ESPEAK_NG_PHONEME_H
   22|       |
   23|       |#include <espeak-ng/espeak_ng.h>
   24|       |
   25|       |#ifdef __cplusplus
   26|       |extern "C"
   27|       |{
   28|       |#endif
   29|       |
   30|       |// See docs/phonemes.md for the list of supported features.
   31|       |typedef enum {
   32|       |#	define FEATURE_T(a, b, c) ((a << 16) | (b << 8) | (c))
   33|       |	// invalid phoneme feature name
   34|       |	inv = 0,
   35|       |	// manner of articulation
   36|       |	nas = FEATURE_T('n', 'a', 's'),
   37|       |	stp = FEATURE_T('s', 't', 'p'),
   38|       |	afr = FEATURE_T('a', 'f', 'r'),
   39|       |	frc = FEATURE_T('f', 'r', 'c'),
   40|       |	flp = FEATURE_T('f', 'l', 'p'),
   41|       |	trl = FEATURE_T('t', 'r', 'l'),
   42|       |	apr = FEATURE_T('a', 'p', 'r'),
   43|       |	clk = FEATURE_T('c', 'l', 'k'),
   44|       |	ejc = FEATURE_T('e', 'j', 'c'),
   45|       |	imp = FEATURE_T('i', 'm', 'p'),
   46|       |	vwl = FEATURE_T('v', 'w', 'l'),
   47|       |	lat = FEATURE_T('l', 'a', 't'),
   48|       |	sib = FEATURE_T('s', 'i', 'b'),
   49|       |	// place of articulation
   50|       |	blb = FEATURE_T('b', 'l', 'b'),
   51|       |	lbd = FEATURE_T('l', 'b', 'd'),
   52|       |	bld = FEATURE_T('b', 'l', 'd'),
   53|       |	dnt = FEATURE_T('d', 'n', 't'),
   54|       |	alv = FEATURE_T('a', 'l', 'v'),
   55|       |	pla = FEATURE_T('p', 'l', 'a'),
   56|       |	rfx = FEATURE_T('r', 'f', 'x'),
   57|       |	alp = FEATURE_T('a', 'l', 'p'),
   58|       |	pal = FEATURE_T('p', 'a', 'l'),
   59|       |	vel = FEATURE_T('v', 'e', 'l'),
   60|       |	lbv = FEATURE_T('l', 'b', 'v'),
   61|       |	uvl = FEATURE_T('u', 'v', 'l'),
   62|       |	phr = FEATURE_T('p', 'h', 'r'),
   63|       |	glt = FEATURE_T('g', 'l', 't'),
   64|       |	// voice
   65|       |	vcd = FEATURE_T('v', 'c', 'd'),
   66|       |	vls = FEATURE_T('v', 'l', 's'),
   67|       |	// vowel height
   68|       |	hgh = FEATURE_T('h', 'g', 'h'),
   69|       |	smh = FEATURE_T('s', 'm', 'h'),
   70|       |	umd = FEATURE_T('u', 'm', 'd'),
   71|       |	mid = FEATURE_T('m', 'i', 'd'),
   72|       |	lmd = FEATURE_T('l', 'm', 'd'),
   73|       |	sml = FEATURE_T('s', 'm', 'l'),
   74|       |	low = FEATURE_T('l', 'o', 'w'),
   75|       |	// vowel backness
   76|       |	fnt = FEATURE_T('f', 'n', 't'),
   77|       |	cnt = FEATURE_T('c', 'n', 't'),
   78|       |	bck = FEATURE_T('b', 'c', 'k'),
   79|       |	// rounding
   80|       |	unr = FEATURE_T('u', 'n', 'r'),
   81|       |	rnd = FEATURE_T('r', 'n', 'd'),
   82|       |	// articulation
   83|       |	lgl = FEATURE_T('l', 'g', 'l'),
   84|       |	idt = FEATURE_T('i', 'd', 't'),
   85|       |	apc = FEATURE_T('a', 'p', 'c'),
   86|       |	lmn = FEATURE_T('l', 'm', 'n'),
   87|       |	// air flow
   88|       |	egs = FEATURE_T('e', 'g', 's'),
   89|       |	igs = FEATURE_T('i', 'g', 's'),
   90|       |	// phonation
   91|       |	brv = FEATURE_T('b', 'r', 'v'),
   92|       |	slv = FEATURE_T('s', 'l', 'v'),
   93|       |	stv = FEATURE_T('s', 't', 'v'),
   94|       |	crv = FEATURE_T('c', 'r', 'v'),
   95|       |	glc = FEATURE_T('g', 'l', 'c'),
   96|       |	// rounding and labialization
   97|       |	ptr = FEATURE_T('p', 't', 'r'),
   98|       |	cmp = FEATURE_T('c', 'm', 'p'),
   99|       |	mrd = FEATURE_T('m', 'r', 'd'),
  100|       |	lrd = FEATURE_T('l', 'r', 'd'),
  101|       |	// syllabicity
  102|       |	syl = FEATURE_T('s', 'y', 'l'),
  103|       |	nsy = FEATURE_T('n', 's', 'y'),
  104|       |	// consonant release
  105|       |	asp = FEATURE_T('a', 's', 'p'),
  106|       |	nrs = FEATURE_T('n', 'r', 's'),
  107|       |	lrs = FEATURE_T('l', 'r', 's'),
  108|       |	unx = FEATURE_T('u', 'n', 'x'),
  109|       |	// coarticulation
  110|       |	pzd = FEATURE_T('p', 'z', 'd'),
  111|       |	vzd = FEATURE_T('v', 'z', 'd'),
  112|       |	fzd = FEATURE_T('f', 'z', 'd'),
  113|       |	nzd = FEATURE_T('n', 'z', 'd'),
  114|       |	rzd = FEATURE_T('r', 'z', 'd'),
  115|       |	// tongue root
  116|       |	atr = FEATURE_T('a', 't', 'r'),
  117|       |	rtr = FEATURE_T('r', 't', 'r'),
  118|       |	// fortis and lenis
  119|       |	fts = FEATURE_T('f', 't', 's'),
  120|       |	lns = FEATURE_T('l', 'n', 's'),
  121|       |	// length
  122|       |	est = FEATURE_T('e', 's', 't'),
  123|       |	hlg = FEATURE_T('h', 'l', 'g'),
  124|       |	lng = FEATURE_T('l', 'n', 'g'),
  125|       |	elg = FEATURE_T('e', 'l', 'g'),
  126|       |#	undef FEATURE_T
  127|       |} phoneme_feature_t;
  128|       |
  129|       |phoneme_feature_t phoneme_feature_from_string(const char *feature);
  130|       |
  131|       |// phoneme types
  132|      0|#define phPAUSE   0
  133|      0|#define phSTRESS  1
  134|      0|#define phVOWEL   2
  135|      0|#define phLIQUID  3
  136|      0|#define phSTOP    4
  137|      0|#define phVSTOP   5
  138|      0|#define phFRICATIVE 6
  139|      0|#define phVFRICATIVE 7
  140|      0|#define phNASAL   8
  141|       |#define phVIRTUAL 9
  142|       |#define phDELETED 14
  143|      0|#define phINVALID 15
  144|       |
  145|       |// places of articulation (phARTICULATION)
  146|       |#define phPLACE_BILABIAL 1
  147|       |#define phPLACE_LABIODENTAL 2
  148|       |#define phPLACE_DENTAL 3
  149|       |#define phPLACE_ALVEOLAR 4
  150|       |#define phPLACE_RETROFLEX 5
  151|       |#define phPLACE_PALATO_ALVEOLAR 6
  152|       |#define phPLACE_PALATAL 7
  153|       |#define phPLACE_VELAR 8
  154|       |#define phPLACE_LABIO_VELAR 9
  155|       |#define phPLACE_UVULAR 10
  156|       |#define phPLACE_PHARYNGEAL 11
  157|       |#define phPLACE_GLOTTAL 12
  158|       |
  159|       |// phflags
  160|      0|#define phFLAGBIT_UNSTRESSED 1
  161|      0|#define phFLAGBIT_VOICELESS 3
  162|      0|#define phFLAGBIT_VOICED 4
  163|      0|#define phFLAGBIT_SIBILANT 5
  164|       |#define phFLAGBIT_NOLINK 6
  165|      0|#define phFLAGBIT_TRILL 7
  166|       |#define phFLAGBIT_PALATAL 9
  167|      0|#define phFLAGBIT_BRKAFTER 14 // [*] add a post-pause
  168|       |#define phARTICULATION 0xf0000 // bits 16-19
  169|      0|#define phFLAGBIT_NONSYLLABIC 20 // don't count this vowel as a syllable when finding the stress position
  170|      0|#define phFLAGBIT_LONG 21
  171|      0|#define phFLAGBIT_LENGTHENSTOP 22 // make the pre-pause slightly longer
  172|       |#define phFLAGBIT_RHOTIC 23
  173|      0|#define phFLAGBIT_NOPAUSE 24
  174|      0|#define phFLAGBIT_PREVOICE 25 // for voiced stops
  175|       |#define phFLAGBIT_FLAG1 28
  176|       |#define phFLAGBIT_FLAG2 29
  177|       |#define phFLAGBIT_LOCAL 31 // used during compilation
  178|       |
  179|       |// phoneme properties
  180|      0|#define phUNSTRESSED   (1U << phFLAGBIT_UNSTRESSED)
  181|      0|#define phVOICELESS    (1U << phFLAGBIT_VOICELESS)
  182|      0|#define phVOICED       (1U << phFLAGBIT_VOICED)
  183|      0|#define phSIBILANT     (1U << phFLAGBIT_SIBILANT)
  184|       |#define phNOLINK       (1U << phFLAGBIT_NOLINK)
  185|      0|#define phTRILL        (1U << phFLAGBIT_TRILL)
  186|       |#define phPALATAL      (1U << phFLAGBIT_PALATAL)
  187|      0|#define phBRKAFTER     (1U << phFLAGBIT_BRKAFTER)
  188|      0|#define phNONSYLLABIC  (1U << phFLAGBIT_NONSYLLABIC)
  189|      0|#define phLONG         (1U << phFLAGBIT_LONG)
  190|      0|#define phLENGTHENSTOP (1U << phFLAGBIT_LENGTHENSTOP)
  191|       |#define phRHOTIC       (1U << phFLAGBIT_RHOTIC)
  192|      0|#define phNOPAUSE      (1U << phFLAGBIT_NOPAUSE)
  193|      0|#define phPREVOICE     (1U << phFLAGBIT_PREVOICE)
  194|       |#define phFLAG1        (1U << phFLAGBIT_FLAG1)
  195|       |#define phFLAG2        (1U << phFLAGBIT_FLAG2)
  196|       |#define phLOCAL        (1U << phFLAGBIT_LOCAL)
  197|       |
  198|       |// fixed phoneme code numbers, these can be used from the program code
  199|       |#define phonCONTROL     1
  200|       |#define phonSTRESS_U    2
  201|       |#define phonSTRESS_D    3
  202|      0|#define phonSTRESS_2    4
  203|      0|#define phonSTRESS_3    5
  204|      0|#define phonSTRESS_P    6
  205|      0|#define phonSTRESS_P2   7    // priority stress within a word
  206|      0|#define phonSTRESS_PREV 8
  207|      0|#define phonPAUSE       9
  208|      0|#define phonPAUSE_SHORT 10
  209|      0|#define phonPAUSE_NOLINK 11
  210|      0|#define phonLENGTHEN    12
  211|      0|#define phonSCHWA       13
  212|       |#define phonSCHWA_SHORT 14
  213|      0|#define phonEND_WORD    15
  214|      0|#define phonDEFAULTTONE 17
  215|      0|#define phonCAPITAL     18
  216|       |#define phonGLOTTALSTOP 19
  217|      0|#define phonSYLLABIC    20
  218|      0|#define phonSWITCH      21
  219|      0|#define phonX1          22      // a language specific action
  220|      0|#define phonPAUSE_VSHORT 23
  221|      0|#define phonPAUSE_LONG  24
  222|       |#define phonT_REDUCED   25
  223|       |#define phonSTRESS_TONIC 26
  224|      0|#define phonPAUSE_CLAUSE 27
  225|      0|#define phonVOWELTYPES   28  // 28 to 33
  226|       |
  227|       |#define N_PHONEME_TABS     150     // number of phoneme tables
  228|       |#define N_PHONEME_TAB      256     // max phonemes in a phoneme table
  229|      0|#define N_PHONEME_TAB_NAME  32     // must be multiple of 4
  230|       |
  231|       |// main table of phonemes, index by phoneme number (1-254)
  232|       |
  233|       |typedef struct {
  234|       |	unsigned int mnemonic;       // Up to 4 characters.  The first char is in the l.s.byte
  235|       |	unsigned int phflags;        // bits 16-19 place of articulation
  236|       |	unsigned short program;      // index into phondata file
  237|       |	unsigned char code;          // the phoneme number
  238|       |	unsigned char type;          // phVOWEL, phPAUSE, phSTOP etc
  239|       |	unsigned char start_type;
  240|       |	unsigned char end_type;      // vowels: endtype; consonant: voicing switch
  241|       |	unsigned char std_length;    // for vowels, in mS/2;  for phSTRESS phonemes, this is the stress/tone type
  242|       |	unsigned char length_mod;    // a length_mod group number, used to access length_mod_tab
  243|       |} PHONEME_TAB;
  244|       |
  245|       |espeak_ng_STATUS
  246|       |phoneme_add_feature(PHONEME_TAB *phoneme,
  247|       |                    phoneme_feature_t feature);
  248|       |
  249|       |// Several phoneme tables may be loaded into memory. phoneme_tab points to
  250|       |// one for the current voice
  251|       |extern int n_phoneme_tab;
  252|       |extern int current_phoneme_table;
  253|       |extern PHONEME_TAB *phoneme_tab[N_PHONEME_TAB];
  254|       |
  255|       |typedef struct {
  256|       |	char name[N_PHONEME_TAB_NAME];
  257|       |	PHONEME_TAB *phoneme_tab_ptr;
  258|       |	int n_phonemes;
  259|       |	int includes;            // also include the phonemes from this other phoneme table
  260|       |} PHONEME_TAB_LIST;
  261|       |
  262|       |// table of phonemes to be replaced with different phonemes, for the current voice
  263|      0|#define N_REPLACE_PHONEMES   60
  264|       |typedef struct {
  265|       |	unsigned char old_ph;
  266|       |	unsigned char new_ph;
  267|       |	char type;   // 0=always replace, 1=only at end of word
  268|       |} REPLACE_PHONEMES;
  269|       |
  270|       |extern int n_replace_phonemes;
  271|       |extern REPLACE_PHONEMES replace_phonemes[N_REPLACE_PHONEMES];
  272|       |
  273|       |// Table of phoneme programs and lengths.  Used by MakeVowelLists
  274|       |typedef struct {
  275|       |	unsigned int addr;
  276|       |	unsigned int length;
  277|       |} PHONEME_PROG_LOG;
  278|       |
  279|      0|#define PhonemeCode2(c1, c2) PhonemeCode((c2<<8)+c1)
  280|       |
  281|       |extern PHONEME_TAB_LIST phoneme_tab_list[N_PHONEME_TABS];
  282|       |extern int phoneme_tab_number;
  283|       |
  284|       |#ifdef __cplusplus
  285|       |}
  286|       |#endif
  287|       |
  288|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/phonemelist.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2014 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2016 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <stdbool.h>
   23|       |#include <stdint.h>
   24|       |#include <stdio.h>
   25|       |#include <stdlib.h>
   26|       |#include <string.h>
   27|       |
   28|       |#include <espeak-ng/espeak_ng.h>
   29|       |#include <espeak-ng/speak_lib.h>
   30|       |#include <espeak-ng/encoding.h>
   31|       |
   32|       |#include "phonemelist.h"
   33|       |#include "phoneme.h"     // for PHONEME_TAB, phVOWEL, REPLACE_PHONEMES, phPAUSE
   34|       |#include "synthdata.h"   // for InterpretPhoneme, SelectPhonemeTable
   35|       |#include "synthesize.h"  // for PHONEME_LIST, PHONEME_LIST2, phoneme_tab
   36|       |#include "translate.h"   // for Translator, LANGUAGE_OPTIONS, option_wordgap
   37|       |
   38|       |#include "phoneme.h"
   39|       |#include "synthesize.h"
   40|       |#include "translate.h"
   41|       |
   42|       |const unsigned char pause_phonemes[8] = {
   43|       |	0, phonPAUSE_VSHORT, phonPAUSE_SHORT, phonPAUSE, phonPAUSE_LONG, phonGLOTTALSTOP, phonPAUSE_LONG, phonPAUSE_LONG
   44|       |};
   45|       |
   46|       |extern int n_ph_list2;
   47|       |extern PHONEME_LIST2 ph_list2[N_PHONEME_LIST]; // first stage of text->phonemes
   48|       |
   49|       |static int SubstitutePhonemes(PHONEME_LIST *plist_out)
   50|      0|{
   51|      0|	// Copy the phonemes list and perform any substitutions that are required for the
   52|      0|	// current voice
   53|      0|	int ix;
   54|      0|	int k;
   55|      0|	int replace_flags;
   56|      0|	int n_plist_out = 0;
   57|      0|	bool word_end;
   58|      0|	PHONEME_LIST2 *plist2;
   59|      0|	PHONEME_TAB *next = NULL;
   60|      0|	int deleted_sourceix = -1;
   61|      0|
   62|      0|	for (ix = 0; (ix < n_ph_list2) && (n_plist_out < N_PHONEME_LIST); ix++) {
   63|      0|		plist2 = &ph_list2[ix];
   64|      0|		if (deleted_sourceix != -1) {
   65|      0|			plist2->sourceix = deleted_sourceix;
   66|      0|			deleted_sourceix = -1;
   67|      0|		}
   68|      0|
   69|      0|		// don't do any substitution if the language has been temporarily changed
   70|      0|		if (!(plist2->synthflags & SFLAG_SWITCHED_LANG)) {
   71|      0|			if (ix < (n_ph_list2 -1))
   72|      0|				next = phoneme_tab[ph_list2[ix+1].phcode];
   73|      0|
   74|      0|			word_end = false;
   75|      0|			if ((plist2+1)->sourceix || ((next != 0) && (next->type == phPAUSE)))
   76|      0|				word_end = true; // this phoneme is the end of a word
   77|      0|
   78|      0|			// check whether a Voice has specified that we should replace this phoneme
   79|      0|			for (k = 0; k < n_replace_phonemes; k++) {
   80|      0|				if (plist2->phcode == replace_phonemes[k].old_ph) {
   81|      0|					replace_flags = replace_phonemes[k].type;
   82|      0|
   83|      0|					if ((replace_flags & 1) && (word_end == false))
   84|      0|						continue; // this replacement only occurs at the end of a word
   85|      0|
   86|      0|					if ((replace_flags & 2) && ((plist2->stresslevel & 0x7) > 3))
   87|      0|						continue; // this replacement doesn't occur in stressed syllables
   88|      0|
   89|      0|					if ((replace_flags & 4) && (plist2->sourceix == 0))
   90|      0|						continue; // this replacement only occurs at the start of a word
   91|      0|
   92|      0|					// substitute the replacement phoneme
   93|      0|					plist2->phcode = replace_phonemes[k].new_ph;
   94|      0|					if ((plist2->stresslevel > 1) && (phoneme_tab[plist2->phcode]->phflags & phUNSTRESSED))
   95|      0|						plist2->stresslevel = 0; // the replacement must be unstressed
   96|      0|					break;
   97|      0|				}
   98|      0|			}
   99|      0|
  100|      0|			if (plist2->phcode == 0) {
  101|      0|				deleted_sourceix = plist2->sourceix;
  102|      0|				continue; // phoneme has been replaced by NULL, so don't copy it
  103|      0|			}
  104|      0|		}
  105|      0|
  106|      0|		// copy phoneme into the output list
  107|      0|		memcpy(&plist_out[n_plist_out], plist2, sizeof(PHONEME_LIST2));
  108|      0|		plist_out[n_plist_out].ph = phoneme_tab[plist2->phcode];
  109|      0|		plist_out[n_plist_out].type = plist_out[n_plist_out].ph->type;
  110|      0|		n_plist_out++;
  111|      0|	}
  112|      0|	return n_plist_out;
  113|      0|}
  114|       |
  115|       |void MakePhonemeList(Translator *tr, int post_pause, bool start_sentence)
  116|      0|{
  117|      0|	int ix = 0;
  118|      0|	int j;
  119|      0|	int insert_ph = 0;
  120|      0|	PHONEME_LIST *phlist;
  121|      0|	PHONEME_TAB *ph;
  122|      0|	PHONEME_TAB *next, *next2;
  123|      0|	int unstress_count = 0;
  124|      0|	int word_stress = 0;
  125|      0|	int current_phoneme_tab;
  126|      0|	int max_stress;
  127|      0|	int voicing;
  128|      0|	int regression;
  129|      0|	int end_sourceix;
  130|      0|	int alternative;
  131|      0|	int delete_count;
  132|      0|	int word_start;
  133|      0|	bool inserted;
  134|      0|	bool deleted;
  135|      0|	PHONEME_DATA phdata;
  136|      0|	bool start_of_clause = true;
  137|      0|
  138|      0|	int n_ph_list3;
  139|      0|	PHONEME_LIST *plist3;
  140|      0|	PHONEME_LIST *plist3_inserted = NULL;
  141|      0|	PHONEME_LIST ph_list3[N_PHONEME_LIST];
  142|      0|
  143|      0|	PHONEME_LIST2 *plist2;
  144|      0|	WORD_PH_DATA worddata;
  145|      0|
  146|      0|	memset(&worddata, 0, sizeof(worddata));
  147|      0|	plist2 = ph_list2;
  148|      0|	phlist = phoneme_list;
  149|      0|	end_sourceix = plist2[n_ph_list2-1].sourceix;
  150|      0|
  151|      0|	// is the last word of the clause unstressed ?
  152|      0|	max_stress = 0;
  153|      0|	for (j = n_ph_list2-3; j >= 0; j--) {
  154|      0|		// start with the last phoneme (before the terminating pauses) and move backwards
  155|      0|		if ((plist2[j].stresslevel & 0x7f) > max_stress)
  156|      0|			max_stress = plist2[j].stresslevel & 0x7f;
  157|      0|		if (plist2[j].sourceix != 0)
  158|      0|			break;
  159|      0|	}
  160|      0|	if (max_stress < 4) {
  161|      0|		// the last word is unstressed, look for a previous word that can be stressed
  162|      0|		while (--j >= 0) {
  163|      0|			if (plist2[j].synthflags & SFLAG_PROMOTE_STRESS) { // dictionary flags indicated that this stress can be promoted
  164|      0|				plist2[j].stresslevel = 4; // promote to stressed
  165|      0|				break;
  166|      0|			}
  167|      0|			if (plist2[j].stresslevel >= 4) {
  168|      0|				// found a stressed syllable, so stop looking
  169|      0|				break;
  170|      0|			}
  171|      0|		}
  172|      0|	}
  173|      0|
  174|      0|	// look for switch of phoneme tables
  175|      0|	delete_count = 0;
  176|      0|	current_phoneme_tab = tr->phoneme_tab_ix;
  177|      0|	int deleted_sourceix = -1;
  178|      0|	for (j = 0; j < n_ph_list2; j++) {
  179|      0|		if (current_phoneme_tab != tr->phoneme_tab_ix)
  180|      0|			plist2[j].synthflags |= SFLAG_SWITCHED_LANG;
  181|      0|
  182|      0|		if (delete_count > 0) {
  183|      0|			memcpy(&plist2[j-delete_count], &plist2[j], sizeof(plist2[0]));
  184|      0|			if (deleted_sourceix != -1) {
  185|      0|				plist2[j-delete_count].sourceix = deleted_sourceix;
  186|      0|				deleted_sourceix = -1;
  187|      0|			}
  188|      0|		}
  189|      0|
  190|      0|		if (plist2[j].phcode == phonSWITCH) {
  191|      0|			if ((!(plist2[j].synthflags & SFLAG_EMBEDDED)) && (
  192|      0|			        (plist2[j].tone_ph == current_phoneme_tab) ||
  193|      0|			        (plist2[j+1].phcode == phonSWITCH) ||
  194|      0|			        ((plist2[j+1].phcode == phonPAUSE) && (plist2[j+2].phcode == phonSWITCH))
  195|      0|			        )) {
  196|      0|				// delete this phonSWITCH if it's switching to the current phoneme table, or
  197|      0|				// delete this phonSWITCH if its followed by another phonSWITCH
  198|      0|				if (deleted_sourceix == -1 && plist2[j].sourceix != 0)
  199|      0|					deleted_sourceix = plist2[j].sourceix;
  200|      0|				delete_count++;
  201|      0|			} else
  202|      0|				current_phoneme_tab = plist2[j].tone_ph;
  203|      0|		}
  204|      0|
  205|      0|	}
  206|      0|	n_ph_list2 -= delete_count;
  207|      0|
  208|      0|	if ((regression = tr->langopts.param[LOPT_REGRESSIVE_VOICING]) != 0) {
  209|      0|		// set consonant clusters to all voiced or all unvoiced
  210|      0|		// Regressive
  211|      0|		int type;
  212|      0|		bool stop_propagation = false;
  213|      0|		voicing = 0;
  214|      0|
  215|      0|		for (j = n_ph_list2-1; j >= 0; j--) {
  216|      0|			ph = phoneme_tab[plist2[j].phcode];
  217|      0|			if (ph == NULL)
  218|      0|				continue;
  219|      0|
  220|      0|			if (plist2[j].synthflags & SFLAG_SWITCHED_LANG) {
  221|      0|				stop_propagation = false;
  222|      0|				voicing = 0;
  223|      0|				if (regression & 0x100)
  224|      0|					voicing = 1; // word-end devoicing
  225|      0|				continue;
  226|      0|			}
  227|      0|
  228|      0|			type = ph->type;
  229|      0|
  230|      0|			if (regression & 0x2) {
  231|      0|				// [v] amd [v;] don't cause regression, or [R^]
  232|      0|				if (((ph->mnemonic & 0xff) == 'v') || ((ph->mnemonic & 0xff) == 'R')) {
  233|      0|					stop_propagation = true;
  234|      0|					if (regression & 0x10)
  235|      0|						voicing = 0;
  236|      0|				}
  237|      0|			}
  238|      0|
  239|      0|			if ((type == phSTOP) || type == (phFRICATIVE)) {
  240|      0|				if ((voicing == 0) && (regression & 0xf))
  241|      0|					voicing = 1;
  242|      0|				else if ((voicing == 2) && (ph->end_type != 0)) // use end_type field for voicing_switch for consonants
  243|      0|					plist2[j].phcode = ph->end_type; // change to voiced equivalent
  244|      0|			} else if ((type == phVSTOP) || type == (phVFRICATIVE)) {
  245|      0|				if ((voicing == 0) && (regression & 0xf))
  246|      0|					voicing = 2;
  247|      0|				else if ((voicing == 1) && (ph->end_type != 0))
  248|      0|					plist2[j].phcode = ph->end_type; // change to unvoiced equivalent
  249|      0|			} else {
  250|      0|				if (regression & 0x8) {
  251|      0|					// LANG=Polish, propagate through liquids and nasals
  252|      0|					if ((type == phPAUSE) || (type == phVOWEL))
  253|      0|						voicing = 0;
  254|      0|				} else
  255|      0|					voicing = 0;
  256|      0|			}
  257|      0|			if (stop_propagation) {
  258|      0|				voicing = 0;
  259|      0|				stop_propagation = false;
  260|      0|			}
  261|      0|
  262|      0|			if (plist2[j].sourceix) {
  263|      0|				if (regression & 0x04) {
  264|      0|					// stop propagation at a word boundary
  265|      0|					voicing = 0;
  266|      0|				}
  267|      0|				if (regression & 0x100) {
  268|      0|					// devoice word-final consonants, unless propagating voiced
  269|      0|					if (voicing == 0)
  270|      0|						voicing = 1;
  271|      0|				}
  272|      0|			}
  273|      0|		}
  274|      0|	}
  275|      0|
  276|      0|	n_ph_list3 = SubstitutePhonemes(ph_list3) - 2;
  277|      0|
  278|      0|	for (j = 0; (j < n_ph_list3) && (ix < N_PHONEME_LIST-3);) {
  279|      0|		if (ph_list3[j].sourceix) {
  280|      0|			// start of a word
  281|      0|			int k;
  282|      0|			int nextw;
  283|      0|			word_stress = 0;
  284|      0|
  285|      0|			// find the highest stress level in this word
  286|      0|			for (nextw = j; nextw < n_ph_list3;) {
  287|      0|				if (ph_list3[nextw].stresslevel > word_stress)
  288|      0|					word_stress = ph_list3[nextw].stresslevel;
  289|      0|
  290|      0|				nextw++;
  291|      0|				if (ph_list3[nextw].sourceix)
  292|      0|					break; // start of the next word
  293|      0|			}
  294|      0|			for (k = j; k < nextw; k++)
  295|      0|				ph_list3[k].wordstress = word_stress;
  296|      0|			j = nextw;
  297|      0|		} else
  298|      0|			j++;
  299|      0|	}
  300|      0|
  301|      0|	// transfer all the phonemes of the clause into phoneme_list
  302|      0|	ph = phoneme_tab[phonPAUSE];
  303|      0|	ph_list3[0].ph = ph;
  304|      0|	word_start = 1;
  305|      0|
  306|      0|	for (j = 0; insert_ph || ((j < n_ph_list3) && (ix < N_PHONEME_LIST-3)); j++) {
  307|      0|		plist3 = &ph_list3[j];
  308|      0|
  309|      0|		inserted = false;
  310|      0|		deleted = false;
  311|      0|		if (insert_ph != 0) {
  312|      0|			// we have a (linking) phoneme which we need to insert here
  313|      0|			next = phoneme_tab[plist3->phcode];      // this phoneme, i.e. after the insert
  314|      0|
  315|      0|			// re-use the previous entry for the inserted phoneme.
  316|      0|			// That's OK because we don't look backwards from plist3   *** but CountVowelPosition() and isAfterStress does !!!
  317|      0|			j--;
  318|      0|			plist3 = plist3_inserted = &ph_list3[j];
  319|      0|			if (j > 0) {
  320|      0|				// move all previous phonemes in the word back one place
  321|      0|				int k;
  322|      0|				if (word_start > 0) {
  323|      0|					k = word_start;
  324|      0|					word_start--;
  325|      0|				} else
  326|      0|					k = 2;   // No more space, don't loose the start of word mark at ph_list2[word_start]
  327|      0|				for (; k <= j; k++)
  328|      0|					memcpy(&ph_list3[k-1], &ph_list3[k], sizeof(*plist3));
  329|      0|			}
  330|      0|			memset(&plist3[0], 0, sizeof(*plist3));
  331|      0|			plist3->phcode = insert_ph;
  332|      0|			ph = phoneme_tab[insert_ph];
  333|      0|			plist3->ph = ph;
  334|      0|			insert_ph = 0;
  335|      0|			inserted = true; // don't insert the same phoneme repeatedly
  336|      0|		} else {
  337|      0|			// otherwise get the next phoneme from the list
  338|      0|			if (plist3->sourceix != 0)
  339|      0|				word_start = j;
  340|      0|
  341|      0|			ph = phoneme_tab[plist3->phcode];
  342|      0|			plist3[0].ph = ph;
  343|      0|
  344|      0|			if (plist3->phcode == phonSWITCH) {
  345|      0|				// change phoneme table
  346|      0|				SelectPhonemeTable(plist3->tone_ph);
  347|      0|			}
  348|      0|			next = phoneme_tab[plist3[1].phcode]; // the phoneme after this one
  349|      0|			plist3[1].ph = next;
  350|      0|		}
  351|      0|
  352|      0|		if (ph == NULL) continue;
  353|      0|
  354|      0|		InterpretPhoneme(tr, 0x100, plist3, &phdata, &worddata);
  355|      0|
  356|      0|		if ((alternative = phdata.pd_param[pd_CHANGE_NEXTPHONEME]) > 0) {
  357|      0|			ph_list3[j+1].ph = phoneme_tab[alternative];
  358|      0|			ph_list3[j+1].phcode = alternative;
  359|      0|			ph_list3[j+1].type = phoneme_tab[alternative]->type;
  360|      0|			next = phoneme_tab[alternative];
  361|      0|		}
  362|      0|
  363|      0|		if (((alternative = phdata.pd_param[pd_INSERTPHONEME]) > 0) && (inserted == false)) {
  364|      0|			// PROBLEM: if we insert a phoneme before a vowel then we loose the stress.
  365|      0|			PHONEME_TAB *ph2;
  366|      0|			ph2 = ph;
  367|      0|
  368|      0|			insert_ph = plist3->phcode;
  369|      0|			ph = phoneme_tab[alternative];
  370|      0|			plist3->ph = ph;
  371|      0|			plist3->phcode = alternative;
  372|      0|
  373|      0|			if (ph->type == phVOWEL) {
  374|      0|				plist3->synthflags |= SFLAG_SYLLABLE;
  375|      0|				if (ph2->type != phVOWEL)
  376|      0|					plist3->stresslevel = 0; // change from non-vowel to vowel, make sure it's unstressed
  377|      0|			} else
  378|      0|				plist3->synthflags &= ~SFLAG_SYLLABLE;
  379|      0|
  380|      0|			// re-interpret the changed phoneme
  381|      0|			// But it doesn't obey a second ChangePhoneme()
  382|      0|			InterpretPhoneme(tr, 0x100, plist3, &phdata, &worddata);
  383|      0|		}
  384|      0|
  385|      0|		if ((alternative = phdata.pd_param[pd_CHANGEPHONEME]) > 0) {
  386|      0|			PHONEME_TAB *ph2;
  387|      0|			ph2 = ph;
  388|      0|			ph = phoneme_tab[alternative];
  389|      0|			plist3->ph = ph;
  390|      0|			plist3->phcode = alternative;
  391|      0|
  392|      0|			if (alternative == 1)
  393|      0|				deleted = true; // NULL phoneme, discard
  394|      0|			else {
  395|      0|				if (ph->type == phVOWEL) {
  396|      0|					plist3->synthflags |= SFLAG_SYLLABLE;
  397|      0|					if (ph2->type != phVOWEL)
  398|      0|						plist3->stresslevel = 0; // change from non-vowel to vowel, make sure it's unstressed
  399|      0|				} else
  400|      0|					plist3->synthflags &= ~SFLAG_SYLLABLE;
  401|      0|
  402|      0|				// re-interpret the changed phoneme
  403|      0|				// But it doesn't obey a second ChangePhoneme()
  404|      0|				InterpretPhoneme(tr, 0x100, plist3, &phdata, &worddata);
  405|      0|			}
  406|      0|		}
  407|      0|
  408|      0|		if ((ph->type == phVOWEL) && (deleted == false)) {
  409|      0|			PHONEME_LIST *p;
  410|      0|
  411|      0|			// Check for consecutive unstressed syllables, even across word boundaries.
  412|      0|			// Do this after changing phonemes according to stress level.
  413|      0|			if (plist3->stresslevel <= 1) {
  414|      0|				// an unstressed vowel
  415|      0|				unstress_count++;
  416|      0|
  417|      0|				if (tr->langopts.stress_flags & 0x08) {
  418|      0|					// change sequences of consecutive unstressed vowels in unstressed words to diminished stress (TEST)
  419|      0|					for (p = plist3+1; p->type != phPAUSE; p++) {
  420|      0|						if (p->type == phVOWEL) {
  421|      0|							if (p->stresslevel <= 1) {
  422|      0|								if (plist3->wordstress < 4)
  423|      0|									plist3->stresslevel = 0;
  424|      0|								if (p->wordstress < 4)
  425|      0|									p->stresslevel = 0;
  426|      0|							}
  427|      0|							break;
  428|      0|						}
  429|      0|					}
  430|      0|				} else {
  431|      0|					if ((unstress_count > 1) && ((unstress_count & 1) == 0)) {
  432|      0|						// in a sequence of unstressed syllables, reduce alternate syllables to 'diminished'
  433|      0|						// stress.  But not for the last phoneme of a stressed word
  434|      0|						if ((tr->langopts.stress_flags & S_NO_DIM) || ((word_stress > 3) && ((plist3+1)->sourceix != 0))) {
  435|      0|							// An unstressed final vowel of a stressed word
  436|      0|							unstress_count = 1; // try again for next syllable
  437|      0|						} else
  438|      0|							plist3->stresslevel = 0; // change stress to 'diminished'
  439|      0|					}
  440|      0|				}
  441|      0|			} else
  442|      0|				unstress_count = 0;
  443|      0|		}
  444|      0|
  445|      0|		if ((plist3+1)->synthflags & SFLAG_LENGTHEN) {
  446|      0|			static char types_double[] = { phFRICATIVE, phVFRICATIVE, phNASAL, phLIQUID, 0 };
  447|      0|			if ((j > 0) && (strchr(types_double, next->type))) {
  448|      0|				// lengthen this consonant by doubling it
  449|      0|				// BUT, can't insert a phoneme at position plist3[0] because it crashes PrevPh()
  450|      0|				insert_ph = next->code;
  451|      0|				(plist3+1)->synthflags ^= SFLAG_LENGTHEN;
  452|      0|			}
  453|      0|		}
  454|      0|
  455|      0|		if ((plist3+1)->sourceix != 0) {
  456|      0|			int x;
  457|      0|
  458|      0|			if (tr->langopts.vowel_pause && (ph->type != phPAUSE)) {
  459|      0|
  460|      0|				if ((ph->type != phVOWEL) && (tr->langopts.vowel_pause & 0x200)) {
  461|      0|					// add a pause after a word which ends in a consonant
  462|      0|					insert_ph = phonPAUSE_NOLINK;
  463|      0|				}
  464|      0|
  465|      0|				if (next->type == phVOWEL) {
  466|      0|					if ((x = tr->langopts.vowel_pause & 0x0c) != 0) {
  467|      0|						// break before a word which starts with a vowel
  468|      0|						if (x == 0xc)
  469|      0|							insert_ph = phonPAUSE_NOLINK;
  470|      0|						else
  471|      0|							insert_ph = phonPAUSE_VSHORT;
  472|      0|					}
  473|      0|
  474|      0|					if ((ph->type == phVOWEL) && ((x = tr->langopts.vowel_pause & 0x03) != 0)) {
  475|      0|						// adjacent vowels over a word boundary
  476|      0|						if (x == 2)
  477|      0|							insert_ph = phonPAUSE_SHORT;
  478|      0|						else
  479|      0|							insert_ph = phonPAUSE_VSHORT;
  480|      0|					}
  481|      0|
  482|      0|					if (((plist3+1)->stresslevel >= 4) && (tr->langopts.vowel_pause & 0x100)) {
  483|      0|						// pause before a words which starts with a stressed vowel
  484|      0|						insert_ph = phonPAUSE_SHORT;
  485|      0|					}
  486|      0|				}
  487|      0|			}
  488|      0|
  489|      0|			if ((plist3 != plist3_inserted) && (ix > 0)) {
  490|      0|				if ((x = (tr->langopts.word_gap & 0x7)) != 0) {
  491|      0|					if ((x > 1) || ((insert_ph != phonPAUSE_SHORT) && (insert_ph != phonPAUSE_NOLINK))) {
  492|      0|						// don't reduce the pause
  493|      0|						insert_ph = pause_phonemes[x];
  494|      0|					}
  495|      0|				}
  496|      0|				if (option_wordgap > 0)
  497|      0|					insert_ph = phonPAUSE_LONG;
  498|      0|			}
  499|      0|		}
  500|      0|
  501|      0|		next2 = phoneme_tab[plist3[2].phcode];
  502|      0|		plist3[2].ph = next2;
  503|      0|
  504|      0|		if ((insert_ph == 0) && (phdata.pd_param[pd_APPENDPHONEME] != 0))
  505|      0|			insert_ph = phdata.pd_param[pd_APPENDPHONEME];
  506|      0|
  507|      0|		if (deleted == false) {
  508|      0|			phlist[ix].ph = ph;
  509|      0|			phlist[ix].type = ph->type;
  510|      0|			phlist[ix].env = PITCHfall; // default, can be changed in the "intonation" module
  511|      0|			phlist[ix].synthflags = plist3->synthflags;
  512|      0|			phlist[ix].stresslevel = plist3->stresslevel & 0xf;
  513|      0|			phlist[ix].wordstress = plist3->wordstress;
  514|      0|			phlist[ix].tone_ph = plist3->tone_ph;
  515|      0|			phlist[ix].sourceix = 0;
  516|      0|			phlist[ix].phcode = ph->code;
  517|      0|
  518|      0|			if (plist3->sourceix != 0) {
  519|      0|				phlist[ix].sourceix = plist3->sourceix;
  520|      0|				phlist[ix].newword = PHLIST_START_OF_WORD;
  521|      0|
  522|      0|				if (start_sentence) {
  523|      0|					phlist[ix].newword |= PHLIST_START_OF_SENTENCE;
  524|      0|					start_sentence = false;
  525|      0|				}
  526|      0|
  527|      0|				if (start_of_clause) {
  528|      0|					phlist[ix].newword |= PHLIST_START_OF_CLAUSE;
  529|      0|					start_of_clause = false;
  530|      0|				}
  531|      0|			} else
  532|      0|				phlist[ix].newword = 0;
  533|      0|
  534|      0|			phlist[ix].length = phdata.pd_param[i_SET_LENGTH]*2;
  535|      0|			if ((ph->code == phonPAUSE_LONG) && (option_wordgap > 0) && (plist3[1].sourceix != 0)) {
  536|      0|				phlist[ix].ph = phoneme_tab[phonPAUSE_SHORT];
  537|      0|				phlist[ix].length = option_wordgap*14; // 10mS per unit at the default speed
  538|      0|			}
  539|      0|
  540|      0|			if (ph->type == phVOWEL || ph->type == phLIQUID || ph->type == phNASAL || ph->type == phVSTOP || ph->type == phVFRICATIVE || (ph->phflags & phPREVOICE)) {
  541|      0|				phlist[ix].length = 128; // length_mod
  542|      0|				phlist[ix].env = PITCHfall;
  543|      0|			}
  544|      0|
  545|      0|			phlist[ix].prepause = 0;
  546|      0|			phlist[ix].amp = 20; // default, will be changed later
  547|      0|			phlist[ix].pitch1 = 255;
  548|      0|			phlist[ix].pitch2 = 255;
  549|      0|			ix++;
  550|      0|		}
  551|      0|	}
  552|      0|
  553|      0|	phlist[ix].newword = PHLIST_END_OF_CLAUSE;
  554|      0|
  555|      0|	phlist[ix].phcode = phonPAUSE;
  556|      0|	phlist[ix].type = phPAUSE; // terminate with 2 Pause phonemes
  557|      0|	phlist[ix].length = post_pause; // length of the pause, depends on the punctuation
  558|      0|	phlist[ix].sourceix = end_sourceix;
  559|      0|	phlist[ix].synthflags = 0;
  560|      0|	phlist[ix++].ph = phoneme_tab[phonPAUSE];
  561|      0|
  562|      0|	phlist[ix].phcode = phonPAUSE;
  563|      0|	phlist[ix].type = phPAUSE;
  564|      0|	phlist[ix].length = 0;
  565|      0|	phlist[ix].sourceix = 0;
  566|      0|	phlist[ix].synthflags = 0;
  567|      0|	phlist[ix++].ph = phoneme_tab[phonPAUSE_SHORT];
  568|      0|
  569|      0|	n_phoneme_list = ix;
  570|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/readclause.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2015 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2017 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <ctype.h>
   23|       |#include <errno.h>
   24|       |#include <locale.h>
   25|       |#include <math.h>
   26|       |#include <stdint.h>
   27|       |#include <stdio.h>
   28|       |#include <stdlib.h>
   29|       |#include <string.h>
   30|       |#include <unistd.h>
   31|       |#include <wchar.h>
   32|       |#include <wctype.h>
   33|       |
   34|       |#include <espeak-ng/espeak_ng.h>
   35|       |#include <espeak-ng/speak_lib.h>
   36|       |#include <espeak-ng/encoding.h>
   37|       |#include <ucd/ucd.h>
   38|       |
   39|       |#include "readclause.h"
   40|       |#include "config.h"               // for HAVE_MKSTEMP
   41|       |#include "dictionary.h"           // for LookupDictList, DecodePhonemes, Set...
   42|       |#include "error.h"                // for create_file_error_context
   43|       |#include "phoneme.h"              // for phonSWITCH
   44|       |#include "soundicon.h"               // for LookupSoundIcon
   45|       |#include "speech.h"               // for GetFileLength, LookupMnem, PATHSEP
   46|       |#include "ssml.h"                 // for SSML_STACK, ProcessSsmlTag, N_PARAM...
   47|       |#include "synthdata.h"            // for SelectPhonemeTable
   48|       |#include "translate.h"            // for Translator, utf8_out, CLAUSE_OPTION...
   49|       |#include "voice.h"                // for voice, voice_t, current_voice_selected
   50|       |
   51|      0|#define N_XML_BUF   500
   52|       |
   53|       |static const char *xmlbase = ""; // base URL from <speak>
   54|       |
   55|       |static int namedata_ix = 0;
   56|       |static int n_namedata = 0;
   57|       |char *namedata = NULL;
   58|       |
   59|       |static int ungot_char2 = 0;
   60|       |espeak_ng_TEXT_DECODER *p_decoder = NULL;
   61|       |static int ungot_char;
   62|       |
   63|       |static bool ignore_text = false; // set during <sub> ... </sub>  to ignore text which has been replaced by an alias
   64|       |static bool audio_text = false; // set during <audio> ... </audio>
   65|       |static bool clear_skipping_text = false; // next clause should clear the skipping_text flag
   66|       |int count_characters = 0;
   67|       |static int sayas_mode;
   68|       |static int sayas_start;
   69|       |
   70|       |#define N_SSML_STACK  20
   71|       |static int n_ssml_stack;
   72|       |static SSML_STACK ssml_stack[N_SSML_STACK];
   73|       |
   74|       |static espeak_VOICE base_voice;
   75|       |static char base_voice_variant_name[40] = { 0 };
   76|       |static char current_voice_id[40] = { 0 };
   77|       |
   78|       |static int n_param_stack;
   79|       |PARAM_STACK param_stack[N_PARAM_STACK];
   80|       |
   81|       |static int speech_parameters[N_SPEECH_PARAM]; // current values, from param_stack
   82|       |int saved_parameters[N_SPEECH_PARAM]; // Parameters saved on synthesis start
   83|       |
   84|      0|#define ESPEAKNG_CLAUSE_TYPE_PROPERTY_MASK 0xFFF0000000000000ull
   85|       |
   86|       |int clause_type_from_codepoint(uint32_t c)
   87|      0|{
   88|      0|	ucd_category cat = ucd_lookup_category(c);
   89|      0|	ucd_property props = ucd_properties(c, cat);
   90|      0|
   91|      0|	switch (props & ESPEAKNG_CLAUSE_TYPE_PROPERTY_MASK)
   92|      0|	{
   93|      0|	case ESPEAKNG_PROPERTY_FULL_STOP:
   94|      0|		return CLAUSE_PERIOD;
   95|      0|	case ESPEAKNG_PROPERTY_FULL_STOP | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER:
   96|      0|		return CLAUSE_PERIOD | CLAUSE_OPTIONAL_SPACE_AFTER;
   97|      0|	case ESPEAKNG_PROPERTY_QUESTION_MARK:
   98|      0|		return CLAUSE_QUESTION;
   99|      0|	case ESPEAKNG_PROPERTY_QUESTION_MARK | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER:
  100|      0|		return CLAUSE_QUESTION | CLAUSE_OPTIONAL_SPACE_AFTER;
  101|      0|	case ESPEAKNG_PROPERTY_QUESTION_MARK | ESPEAKNG_PROPERTY_PUNCTUATION_IN_WORD:
  102|      0|		return CLAUSE_QUESTION | CLAUSE_PUNCTUATION_IN_WORD;
  103|      0|	case ESPEAKNG_PROPERTY_EXCLAMATION_MARK:
  104|      0|		return CLAUSE_EXCLAMATION;
  105|      0|	case ESPEAKNG_PROPERTY_EXCLAMATION_MARK | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER:
  106|      0|		return CLAUSE_EXCLAMATION | CLAUSE_OPTIONAL_SPACE_AFTER;
  107|      0|	case ESPEAKNG_PROPERTY_EXCLAMATION_MARK | ESPEAKNG_PROPERTY_PUNCTUATION_IN_WORD:
  108|      0|		return CLAUSE_EXCLAMATION | CLAUSE_PUNCTUATION_IN_WORD;
  109|      0|	case ESPEAKNG_PROPERTY_COMMA:
  110|      0|		return CLAUSE_COMMA;
  111|      0|	case ESPEAKNG_PROPERTY_COMMA | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER:
  112|      0|		return CLAUSE_COMMA | CLAUSE_OPTIONAL_SPACE_AFTER;
  113|      0|	case ESPEAKNG_PROPERTY_COLON:
  114|      0|		return CLAUSE_COLON;
  115|      0|	case ESPEAKNG_PROPERTY_COLON | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER:
  116|      0|		return CLAUSE_COLON | CLAUSE_OPTIONAL_SPACE_AFTER;
  117|      0|	case ESPEAKNG_PROPERTY_SEMI_COLON:
  118|      0|	case ESPEAKNG_PROPERTY_EXTENDED_DASH:
  119|      0|		return CLAUSE_SEMICOLON;
  120|      0|	case ESPEAKNG_PROPERTY_SEMI_COLON | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER:
  121|      0|	case ESPEAKNG_PROPERTY_QUESTION_MARK | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER | ESPEAKNG_PROPERTY_INVERTED_TERMINAL_PUNCTUATION:
  122|      0|	case ESPEAKNG_PROPERTY_EXCLAMATION_MARK | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER | ESPEAKNG_PROPERTY_INVERTED_TERMINAL_PUNCTUATION:
  123|      0|		return CLAUSE_SEMICOLON | CLAUSE_OPTIONAL_SPACE_AFTER;
  124|      0|	case ESPEAKNG_PROPERTY_ELLIPSIS:
  125|      0|		return CLAUSE_SEMICOLON | CLAUSE_SPEAK_PUNCTUATION_NAME | CLAUSE_OPTIONAL_SPACE_AFTER;
  126|      0|	case ESPEAKNG_PROPERTY_PARAGRAPH_SEPARATOR:
  127|      0|		return CLAUSE_PARAGRAPH;
  128|      0|	}
  129|      0|
  130|      0|	return CLAUSE_NONE;
  131|      0|}
  132|       |
  133|      0|int is_str_totally_null(const char* str, int size) {
  134|      0|	// Tests if all bytes of str are null up to size
  135|      0|	// This should never be reimplemented with integers, because
  136|      0|	// this function has to work with unaligned char*
  137|      0|	// (casting to int when unaligned may result in ungaranteed behaviors)
  138|      0|	return (*str == 0 && memcmp(str, str+1, size-1) == 0);
  139|      0|}
  140|       |
  141|       |int towlower2(unsigned int c, Translator *translator)
  142|      0|{
  143|      0|	// check for non-standard upper to lower case conversions
  144|      0|	if (c == 'I' && translator->langopts.dotless_i)
  145|      0|		return 0x131; // I -> ı
  146|      0|
  147|      0|	return ucd_tolower(c);
  148|      0|}
  149|       |
  150|       |static int IsRomanU(unsigned int c)
  151|      0|{
  152|      0|	if ((c == 'I') || (c == 'V') || (c == 'X') || (c == 'L'))
  153|      0|		return 1;
  154|      0|	return 0;
  155|      0|}
  156|       |
  157|       |int Eof(void)
  158|      0|{
  159|      0|	if (ungot_char != 0)
  160|      0|		return 0;
  161|      0|
  162|      0|	return text_decoder_eof(p_decoder);
  163|      0|}
  164|       |
  165|       |static int GetC(void)
  166|      0|{
  167|      0|	int c1;
  168|      0|
  169|      0|	if ((c1 = ungot_char) != 0) {
  170|      0|		ungot_char = 0;
  171|      0|		return c1;
  172|      0|	}
  173|      0|
  174|      0|	count_characters++;
  175|      0|	return text_decoder_getc(p_decoder);
  176|      0|}
  177|       |
  178|       |static void UngetC(int c)
  179|      0|{
  180|      0|	ungot_char = c;
  181|      0|}
  182|       |
  183|       |const char *WordToString2(unsigned int word)
  184|      0|{
  185|      0|	// Convert a language mnemonic word into a string
  186|      0|	int ix;
  187|      0|	static char buf[5];
  188|      0|	char *p;
  189|      0|
  190|      0|	p = buf;
  191|      0|	for (ix = 3; ix >= 0; ix--) {
  192|      0|		if ((*p = word >> (ix*8)) != 0)
  193|      0|			p++;
  194|      0|	}
  195|      0|	*p = 0;
  196|      0|	return buf;
  197|      0|}
  198|       |
  199|       |static const char *LookupSpecial(Translator *tr, const char *string, char *text_out)
  200|      0|{
  201|      0|	unsigned int flags[2];
  202|      0|	char phonemes[55];
  203|      0|	char phonemes2[55];
  204|      0|	char *string1 = (char *)string;
  205|      0|
  206|      0|	flags[0] = flags[1] = 0;
  207|      0|	if (LookupDictList(tr, &string1, phonemes, flags, 0, NULL)) {
  208|      0|		SetWordStress(tr, phonemes, flags, -1, 0);
  209|      0|		DecodePhonemes(phonemes, phonemes2);
  210|      0|		sprintf(text_out, "[\002%s]]", phonemes2);
  211|      0|		return text_out;
  212|      0|	}
  213|      0|	return NULL;
  214|      0|}
  215|       |
  216|       |static const char *LookupCharName(Translator *tr, int c, int only)
  217|      0|{
  218|      0|	// Find the phoneme string (in ascii) to speak the name of character c
  219|      0|	// Used for punctuation characters and symbols
  220|      0|
  221|      0|	int ix;
  222|      0|	unsigned int flags[2];
  223|      0|	char single_letter[24];
  224|      0|	char phonemes[60];
  225|      0|	char phonemes2[60];
  226|      0|	const char *lang_name = NULL;
  227|      0|	char *string;
  228|      0|	static char buf[60];
  229|      0|
  230|      0|	buf[0] = 0;
  231|      0|	flags[0] = 0;
  232|      0|	flags[1] = 0;
  233|      0|	single_letter[0] = 0;
  234|      0|	single_letter[1] = '_';
  235|      0|	ix = utf8_out(c, &single_letter[2]);
  236|      0|	single_letter[2+ix] = 0;
  237|      0|
  238|      0|	if (only) {
  239|      0|		string = &single_letter[2];
  240|      0|		LookupDictList(tr, &string, phonemes, flags, 0, NULL);
  241|      0|	} else {
  242|      0|		string = &single_letter[1];
  243|      0|		if (LookupDictList(tr, &string, phonemes, flags, 0, NULL) == 0) {
  244|      0|			// try _* then *
  245|      0|			string = &single_letter[2];
  246|      0|			if (LookupDictList(tr, &string, phonemes, flags, 0, NULL) == 0) {
  247|      0|				// now try the rules
  248|      0|				single_letter[1] = ' ';
  249|      0|				TranslateRules(tr, &single_letter[2], phonemes, sizeof(phonemes), NULL, 0, NULL);
  250|      0|			}
  251|      0|		}
  252|      0|	}
  253|      0|
  254|      0|	if ((only == 0) && ((phonemes[0] == 0) || (phonemes[0] == phonSWITCH)) && (tr->translator_name != L('e', 'n'))) {
  255|      0|		// not found, try English
  256|      0|		SetTranslator2(ESPEAKNG_DEFAULT_VOICE);
  257|      0|		string = &single_letter[1];
  258|      0|		single_letter[1] = '_';
  259|      0|		if (LookupDictList(translator2, &string, phonemes, flags, 0, NULL) == 0) {
  260|      0|			string = &single_letter[2];
  261|      0|			LookupDictList(translator2, &string, phonemes, flags, 0, NULL);
  262|      0|		}
  263|      0|		if (phonemes[0])
  264|      0|			lang_name = ESPEAKNG_DEFAULT_VOICE;
  265|      0|		else
  266|      0|			SelectPhonemeTable(voice->phoneme_tab_ix); // revert to original phoneme table
  267|      0|	}
  268|      0|
  269|      0|	if (phonemes[0]) {
  270|      0|		if (lang_name) {
  271|      0|			SetWordStress(translator2, phonemes, flags, -1, 0);
  272|      0|			DecodePhonemes(phonemes, phonemes2);
  273|      0|			sprintf(buf, "[\002_^_%s %s _^_%s]]", ESPEAKNG_DEFAULT_VOICE, phonemes2, WordToString2(tr->translator_name));
  274|      0|			SelectPhonemeTable(voice->phoneme_tab_ix); // revert to original phoneme table
  275|      0|		} else {
  276|      0|			SetWordStress(tr, phonemes, flags, -1, 0);
  277|      0|			DecodePhonemes(phonemes, phonemes2);
  278|      0|			sprintf(buf, "[\002%s]] ", phonemes2);
  279|      0|		}
  280|      0|	} else if (only == 0)
  281|      0|		strcpy(buf, "[\002(X1)(X1)(X1)]]");
  282|      0|
  283|      0|	return buf;
  284|      0|}
  285|       |
  286|       |int Read4Bytes(FILE *f)
  287|      0|{
  288|      0|	// Read 4 bytes (least significant first) into a word
  289|      0|	int ix;
  290|      0|	unsigned char c;
  291|      0|	int acc = 0;
  292|      0|
  293|      0|	for (ix = 0; ix < 4; ix++) {
  294|      0|		c = fgetc(f) & 0xff;
  295|      0|		acc += (c << (ix*8));
  296|      0|	}
  297|      0|	return acc;
  298|      0|}
  299|       |
  300|       |static int AnnouncePunctuation(Translator *tr, int c1, int *c2_ptr, char *output, int *bufix, int end_clause)
  301|      0|{
  302|      0|	// announce punctuation names
  303|      0|	// c1:  the punctuation character
  304|      0|	// c2:  the following character
  305|      0|
  306|      0|	int punct_count;
  307|      0|	const char *punctname = NULL;
  308|      0|	int soundicon;
  309|      0|	int attributes;
  310|      0|	int short_pause;
  311|      0|	int c2;
  312|      0|	int len;
  313|      0|	int bufix1;
  314|      0|	char buf[200];
  315|      0|	char buf2[80];
  316|      0|	char ph_buf[30];
  317|      0|
  318|      0|	c2 = *c2_ptr;
  319|      0|	buf[0] = 0;
  320|      0|
  321|      0|	if ((soundicon = LookupSoundicon(c1)) >= 0) {
  322|      0|		// add an embedded command to play the soundicon
  323|      0|		sprintf(buf, "\001%dI ", soundicon);
  324|      0|		UngetC(c2);
  325|      0|	} else {
  326|      0|		if ((c1 == '.') && (end_clause) && (c2 != '.')) {
  327|      0|			if (LookupSpecial(tr, "_.p", ph_buf))
  328|      0|				punctname = ph_buf; // use word for 'period' instead of 'dot'
  329|      0|		}
  330|      0|		if (punctname == NULL)
  331|      0|			punctname = LookupCharName(tr, c1, 0);
  332|      0|
  333|      0|		if (punctname == NULL)
  334|      0|			return -1;
  335|      0|
  336|      0|		if ((*bufix == 0) || (end_clause == 0) || (tr->langopts.param[LOPT_ANNOUNCE_PUNCT] & 2)) {
  337|      0|			punct_count = 1;
  338|      0|			while ((c2 == c1) && (c1 != '<')) { // don't eat extra '<', it can miss XML tags
  339|      0|				punct_count++;
  340|      0|				c2 = GetC();
  341|      0|			}
  342|      0|			*c2_ptr = c2;
  343|      0|			if (end_clause)
  344|      0|				UngetC(c2);
  345|      0|
  346|      0|			if (punct_count == 1)
  347|      0|				sprintf(buf, " %s", punctname); // we need the space before punctname, to ensure it doesn't merge with the previous word  (eg.  "2.-a")
  348|      0|			else if (punct_count < 4) {
  349|      0|				buf[0] = 0;
  350|      0|				if (embedded_value[EMBED_S] < 300)
  351|      0|					sprintf(buf, "\001+10S"); // Speak punctuation name faster, unless we are already speaking fast.  It would upset Sonic SpeedUp
  352|      0|
  353|      0|				while (punct_count-- > 0) {
  354|      0|					sprintf(buf2, " %s", punctname);
  355|      0|					strcat(buf, buf2);
  356|      0|				}
  357|      0|
  358|      0|				if (embedded_value[EMBED_S] < 300) {
  359|      0|					sprintf(buf2, " \001-10S");
  360|      0|					strcat(buf, buf2);
  361|      0|				}
  362|      0|			} else
  363|      0|				sprintf(buf, " %s %d %s",
  364|      0|				        punctname, punct_count, punctname);
  365|      0|		} else {
  366|      0|			// end the clause now and pick up the punctuation next time
  367|      0|			UngetC(c2);
  368|      0|			ungot_char2 = c1;
  369|      0|			buf[0] = ' ';
  370|      0|			buf[1] = 0;
  371|      0|		}
  372|      0|	}
  373|      0|
  374|      0|	bufix1 = *bufix;
  375|      0|	len = strlen(buf);
  376|      0|	strcpy(&output[*bufix], buf);
  377|      0|	*bufix += len;
  378|      0|
  379|      0|	if (end_clause == 0)
  380|      0|		return -1;
  381|      0|
  382|      0|	if (c1 == '-')
  383|      0|		return CLAUSE_NONE; // no pause
  384|      0|
  385|      0|	attributes = clause_type_from_codepoint(c1);
  386|      0|
  387|      0|	short_pause = CLAUSE_SHORTFALL;
  388|      0|	if ((attributes & CLAUSE_INTONATION_TYPE) == 0x1000)
  389|      0|		short_pause = CLAUSE_SHORTCOMMA;
  390|      0|
  391|      0|	if ((bufix1 > 0) && !(tr->langopts.param[LOPT_ANNOUNCE_PUNCT] & 2)) {
  392|      0|		if ((attributes & ~CLAUSE_OPTIONAL_SPACE_AFTER) == CLAUSE_SEMICOLON)
  393|      0|			return CLAUSE_SHORTFALL;
  394|      0|		return short_pause;
  395|      0|	}
  396|      0|
  397|      0|	if (attributes & CLAUSE_TYPE_SENTENCE)
  398|      0|		return attributes;
  399|      0|
  400|      0|	return short_pause;
  401|      0|}
  402|       |
  403|       |int AddNameData(const char *name, int wide)
  404|      0|{
  405|      0|	// Add the name to the namedata and return its position
  406|      0|	// (Used by the Windows SAPI wrapper)
  407|      0|
  408|      0|	int ix;
  409|      0|	int len;
  410|      0|	void *vp;
  411|      0|
  412|      0|	if (wide) {
  413|      0|		len = (wcslen((const wchar_t *)name)+1)*sizeof(wchar_t);
  414|      0|		n_namedata = (n_namedata + sizeof(wchar_t) - 1) % sizeof(wchar_t);  // round to wchar_t boundary
  415|      0|	} else
  416|      0|		len = strlen(name)+1;
  417|      0|
  418|      0|	if (namedata_ix+len >= n_namedata) {
  419|      0|		// allocate more space for marker names
  420|      0|		if ((vp = realloc(namedata, namedata_ix+len + 1000)) == NULL)
  421|      0|			return -1;  // failed to allocate, original data is unchanged but ignore this new name
  422|      0|		// !!! Bug?? If the allocated data shifts position, then pointers given to user application will be invalid
  423|      0|
  424|      0|		namedata = (char *)vp;
  425|      0|		n_namedata = namedata_ix+len + 1000;
  426|      0|	}
  427|      0|	memcpy(&namedata[ix = namedata_ix], name, len);
  428|      0|	namedata_ix += len;
  429|      0|	return ix;
  430|      0|}
  431|       |
  432|       |void SetVoiceStack(espeak_VOICE *v, const char *variant_name)
  433|      0|{
  434|      0|	SSML_STACK *sp;
  435|      0|	sp = &ssml_stack[0];
  436|      0|
  437|      0|	if (v == NULL) {
  438|      0|		memset(sp, 0, sizeof(ssml_stack[0]));
  439|      0|		return;
  440|      0|	}
  441|      0|	if (v->languages != NULL)
  442|      0|		strcpy(sp->language, v->languages);
  443|      0|	if (v->name != NULL)
  444|      0|		strncpy0(sp->voice_name, v->name, sizeof(sp->voice_name));
  445|      0|	sp->voice_variant_number = v->variant;
  446|      0|	sp->voice_age = v->age;
  447|      0|	sp->voice_gender = v->gender;
  448|      0|
  449|      0|	if (variant_name[0] == '!' && variant_name[1] == 'v' && variant_name[2] == PATHSEP)
  450|      0|		variant_name += 3; // strip variant directory name, !v plus PATHSEP
  451|      0|	strncpy0(base_voice_variant_name, variant_name, sizeof(base_voice_variant_name));
  452|      0|	memcpy(&base_voice, &current_voice_selected, sizeof(base_voice));
  453|      0|}
  454|       |
  455|       |static void RemoveChar(char *p)
  456|      0|{
  457|      0|	// Replace a UTF-8 character by spaces
  458|      0|	int c;
  459|      0|
  460|      0|	memset(p, ' ', utf8_in(&c, p));
  461|      0|}
  462|       |
  463|       |int ReadClause(Translator *tr, char *buf, short *charix, int *charix_top, int n_buf, int *tone_type, char *voice_change)
  464|      0|{
  465|      0|	/* Find the end of the current clause.
  466|      0|	    Write the clause into  buf
  467|      0|
  468|      0|	    returns: clause type (bits 0-7: pause x10mS, bits 8-11 intonation type)
  469|      0|
  470|      0|	    Also checks for blank line (paragraph) as end-of-clause indicator.
  471|      0|
  472|      0|	    Does not end clause for:
  473|      0|	        punctuation immediately followed by alphanumeric  eg.  1.23  !Speak  :path
  474|      0|	        repeated punctuation, eg.   ...   !!!
  475|      0|	 */
  476|      0|
  477|      0|	int c1 = ' '; // current character
  478|      0|	int c2; // next character
  479|      0|	int cprev = ' '; // previous character
  480|      0|	int cprev2 = ' ';
  481|      0|	int c_next;
  482|      0|	int parag;
  483|      0|	int ix = 0;
  484|      0|	int j;
  485|      0|	int nl_count;
  486|      0|	int linelength = 0;
  487|      0|	int phoneme_mode = 0;
  488|      0|	int n_xml_buf;
  489|      0|	int terminator;
  490|      0|	bool any_alnum = false;
  491|      0|	int punct_data = 0;
  492|      0|	bool is_end_clause;
  493|      0|	int announced_punctuation = 0;
  494|      0|	bool stressed_word = false;
  495|      0|	int end_clause_after_tag = 0;
  496|      0|	int end_clause_index = 0;
  497|      0|	wchar_t xml_buf[N_XML_BUF+1];
  498|      0|
  499|      0|	#define N_XML_BUF2 20
  500|      0|	char xml_buf2[N_XML_BUF2+2]; // for &<name> and &<number> sequences
  501|      0|	static char ungot_string[N_XML_BUF2+4];
  502|      0|	static int ungot_string_ix = -1;
  503|      0|
  504|      0|	if (clear_skipping_text) {
  505|      0|		skipping_text = false;
  506|      0|		clear_skipping_text = false;
  507|      0|	}
  508|      0|
  509|      0|	tr->phonemes_repeat_count = 0;
  510|      0|	tr->clause_upper_count = 0;
  511|      0|	tr->clause_lower_count = 0;
  512|      0|	*tone_type = 0;
  513|      0|	*voice_change = 0;
  514|      0|
  515|      0|	if (ungot_char2 != 0) {
  516|      0|		c2 = ungot_char2;
  517|      0|	} else if (Eof()) {
  518|      0|		c2 = 0;
  519|      0|	} else {
  520|      0|		c2 = GetC();
  521|      0|	}
  522|      0|
  523|      0|	while (!Eof() || (ungot_char != 0) || (ungot_char2 != 0) || (ungot_string_ix >= 0)) {
  524|      0|		if (!iswalnum(c1)) {
  525|      0|			if ((end_character_position > 0) && (count_characters > end_character_position)) {
  526|      0|				return CLAUSE_EOF;
  527|      0|			}
  528|      0|
  529|      0|			if ((skip_characters > 0) && (count_characters >= skip_characters)) {
  530|      0|				// reached the specified start position
  531|      0|				// don't break a word
  532|      0|				clear_skipping_text = true;
  533|      0|				skip_characters = 0;
  534|      0|				UngetC(c2);
  535|      0|				return CLAUSE_NONE;
  536|      0|			}
  537|      0|		}
  538|      0|
  539|      0|		cprev2 = cprev;
  540|      0|		cprev = c1;
  541|      0|		c1 = c2;
  542|      0|
  543|      0|		if (ungot_string_ix >= 0) {
  544|      0|			if (ungot_string[ungot_string_ix] == 0)
  545|      0|				ungot_string_ix = -1;
  546|      0|		}
  547|      0|
  548|      0|		if ((ungot_string_ix == 0) && (ungot_char2 == 0))
  549|      0|			c1 = ungot_string[ungot_string_ix++];
  550|      0|		if (ungot_string_ix >= 0) {
  551|      0|			c2 = ungot_string[ungot_string_ix++];
  552|      0|		} else if (Eof()) {
  553|      0|			c2 = ' ';
  554|      0|		} else {
  555|      0|			c2 = GetC();
  556|      0|		}
  557|      0|
  558|      0|		ungot_char2 = 0;
  559|      0|
  560|      0|		if ((option_ssml) && (phoneme_mode == 0)) {
  561|      0|			if ((c1 == '&') && ((c2 == '#') || ((c2 >= 'a') && (c2 <= 'z')))) {
  562|      0|				n_xml_buf = 0;
  563|      0|				c1 = c2;
  564|      0|				while (!Eof() && (iswalnum(c1) || (c1 == '#')) && (n_xml_buf < N_XML_BUF2)) {
  565|      0|					xml_buf2[n_xml_buf++] = c1;
  566|      0|					c1 = GetC();
  567|      0|				}
  568|      0|				xml_buf2[n_xml_buf] = 0;
  569|      0|				if (Eof()) {
  570|      0|					c2 = '\0';
  571|      0|				} else {
  572|      0|					c2 = GetC();
  573|      0|				}
  574|      0|				sprintf(ungot_string, "%s%c%c", &xml_buf2[0], c1, c2);
  575|      0|
  576|      0|				int found = -1;
  577|      0|				if (c1 == ';') {
  578|      0|					found = ParseSsmlReference(xml_buf2, &c1, &c2);
  579|      0|				}
  580|      0|
  581|      0|				if (found <= 0) {
  582|      0|					ungot_string_ix = 0;
  583|      0|					c1 = '&';
  584|      0|					c2 = ' ';
  585|      0|				}
  586|      0|
  587|      0|				if ((c1 <= 0x20) && ((sayas_mode == SAYAS_SINGLE_CHARS) || (sayas_mode == SAYAS_KEY)))
  588|      0|					c1 += 0xe000; // move into unicode private usage area
  589|      0|			} else if (c1 == '<') {
  590|      0|				if ((c2 == '/') || iswalpha(c2) || c2 == '!' || c2 == '?') {
  591|      0|					// check for space in the output buffer for embedded commands produced by the SSML tag
  592|      0|					if (ix > (n_buf - 20)) {
  593|      0|						// Perhaps not enough room, end the clause before the SSML tag
  594|      0|						UngetC(c2);
  595|      0|						ungot_char2 = c1;
  596|      0|						buf[ix] = ' ';
  597|      0|						buf[ix+1] = 0;
  598|      0|						return CLAUSE_NONE;
  599|      0|					}
  600|      0|
  601|      0|					// SSML Tag
  602|      0|					n_xml_buf = 0;
  603|      0|					c1 = c2;
  604|      0|					while (!Eof() && (c1 != '>') && (n_xml_buf < N_XML_BUF)) {
  605|      0|						xml_buf[n_xml_buf++] = c1;
  606|      0|						c1 = GetC();
  607|      0|					}
  608|      0|					xml_buf[n_xml_buf] = 0;
  609|      0|					c2 = ' ';
  610|      0|
  611|      0|					terminator = ProcessSsmlTag(xml_buf, buf, &ix, n_buf, xmlbase, &audio_text, current_voice_id, &base_voice, base_voice_variant_name, &ignore_text, &clear_skipping_text, &sayas_mode, &sayas_start, ssml_stack, &n_ssml_stack, &n_param_stack, (int *)speech_parameters);
  612|      0|
  613|      0|					if (terminator != 0) {
  614|      0|						buf[ix] = ' ';
  615|      0|						buf[ix++] = 0;
  616|      0|
  617|      0|						if (terminator & CLAUSE_TYPE_VOICE_CHANGE)
  618|      0|							strcpy(voice_change, current_voice_id);
  619|      0|						return terminator;
  620|      0|					}
  621|      0|					c1 = ' ';
  622|      0|					if (!Eof()) {
  623|      0|						c2 = GetC();
  624|      0|					}
  625|      0|					continue;
  626|      0|				}
  627|      0|			}
  628|      0|		}
  629|      0|
  630|      0|		if (ignore_text)
  631|      0|			continue;
  632|      0|
  633|      0|		if ((c2 == '\n') && (option_linelength == -1)) {
  634|      0|			// single-line mode, return immediately on NL
  635|      0|			if ((terminator = clause_type_from_codepoint(c1)) == CLAUSE_NONE) {
  636|      0|				charix[ix] = count_characters - clause_start_char;
  637|      0|				*charix_top = ix;
  638|      0|				ix += utf8_out(c1, &buf[ix]);
  639|      0|				terminator = CLAUSE_PERIOD; // line doesn't end in punctuation, assume period
  640|      0|			}
  641|      0|			buf[ix] = ' ';
  642|      0|			buf[ix+1] = 0;
  643|      0|			return terminator;
  644|      0|		}
  645|      0|
  646|      0|		if (c1 == CTRL_EMBEDDED) {
  647|      0| 			// an embedded command. If it's a voice change, end the clause
  648|      0|			if (c2 == 'V') {
  649|      0|				buf[ix++] = 0; // end the clause at this point
  650|      0|				while (!iswspace(c1 = GetC()) && !Eof() && (ix < (n_buf-1)))
  651|      0|					buf[ix++] = c1; // add voice name to end of buffer, after the text
  652|      0|				buf[ix++] = 0;
  653|      0|				return CLAUSE_VOICE;
  654|      0|			} else if (c2 == 'B') {
  655|      0|				// set the punctuation option from an embedded command
  656|      0|				//  B0     B1     B<punct list><space>
  657|      0|				strcpy(&buf[ix], "   ");
  658|      0|				ix += 3;
  659|      0|
  660|      0|				if ((c2 = GetC()) == '0')
  661|      0|					option_punctuation = 0;
  662|      0|				else {
  663|      0|					option_punctuation = 1;
  664|      0|					option_punctlist[0] = 0;
  665|      0|					if (c2 != '1') {
  666|      0|						// a list of punctuation characters to be spoken, terminated by space
  667|      0|						j = 0;
  668|      0|						while (!iswspace(c2) && !Eof()) {
  669|      0|							option_punctlist[j++] = c2;
  670|      0|							c2 = GetC();
  671|      0|							buf[ix++] = ' ';
  672|      0|						}
  673|      0|						option_punctlist[j] = 0; // terminate punctuation list
  674|      0|						option_punctuation = 2;
  675|      0|					}
  676|      0|				}
  677|      0|				c2 = GetC();
  678|      0|				continue;
  679|      0|			}
  680|      0|		}
  681|      0|
  682|      0|		linelength++;
  683|      0|
  684|      0|		if ((j = lookupwchar2(tr->chars_ignore, c1)) != 0) {
  685|      0|			if (j == 1) {
  686|      0|				// ignore this character (eg. zero-width-non-joiner U+200C)
  687|      0|				continue;
  688|      0|			}
  689|      0|			c1 = j; // replace the character
  690|      0|		}
  691|      0|
  692|      0|		if (iswalnum(c1))
  693|      0|			any_alnum = true;
  694|      0|		else {
  695|      0|			if (stressed_word) {
  696|      0|				stressed_word = false;
  697|      0|				c1 = CHAR_EMPHASIS; // indicate this word is stressed
  698|      0|				UngetC(c2);
  699|      0|				c2 = ' ';
  700|      0|			}
  701|      0|
  702|      0|			if (c1 == 0xf0b)
  703|      0|				c1 = ' '; // Tibet inter-syllabic mark, ?? replace by space ??
  704|      0|
  705|      0|			if (c1 == 0xd4d) {
  706|      0|				// Malayalam virama, check if next character is Zero-width-joiner
  707|      0|				if (c2 == 0x200d)
  708|      0|					c1 = 0xd4e; // use this unofficial code for chillu-virama
  709|      0|			}
  710|      0|		}
  711|      0|
  712|      0|		if (iswupper(c1)) {
  713|      0|			tr->clause_upper_count++;
  714|      0|
  715|      0|			if ((option_capitals == 2) && (sayas_mode == 0) && !iswupper(cprev)) {
  716|      0|				char text_buf[30];
  717|      0|				if (LookupSpecial(tr, "_cap", text_buf) != NULL) {
  718|      0|					j = strlen(text_buf);
  719|      0|					if ((ix + j) < n_buf) {
  720|      0|						strcpy(&buf[ix], text_buf);
  721|      0|						ix += j;
  722|      0|					}
  723|      0|				}
  724|      0|			}
  725|      0|		} else if (iswalpha(c1))
  726|      0|			tr->clause_lower_count++;
  727|      0|
  728|      0|		if (option_phoneme_input) {
  729|      0|			if (phoneme_mode > 0)
  730|      0|				phoneme_mode--;
  731|      0|			else if ((c1 == '[') && (c2 == '['))
  732|      0|				phoneme_mode = -1; // input is phoneme mnemonics, so don't look for punctuation
  733|      0|			else if ((c1 == ']') && (c2 == ']'))
  734|      0|				phoneme_mode = 2; // set phoneme_mode to zero after the next two characters
  735|      0|		}
  736|      0|
  737|      0|		if (c1 == '\n') {
  738|      0|			parag = 0;
  739|      0|
  740|      0|			// count consecutive newlines, ignoring other spaces
  741|      0|			while (!Eof() && iswspace(c2)) {
  742|      0|				if (c2 == '\n')
  743|      0|					parag++;
  744|      0|				c2 = GetC();
  745|      0|			}
  746|      0|			if (parag > 0) {
  747|      0|				// 2nd newline, assume paragraph
  748|      0|				UngetC(c2);
  749|      0|
  750|      0|				if (end_clause_after_tag)
  751|      0|					RemoveChar(&buf[end_clause_index]); // delete clause-end punctiation
  752|      0|				buf[ix] = ' ';
  753|      0|				buf[ix+1] = 0;
  754|      0|				if (parag > 3)
  755|      0|					parag = 3;
  756|      0|				if (option_ssml) parag = 1;
  757|      0|				return (CLAUSE_PARAGRAPH-30) + 30*parag; // several blank lines, longer pause
  758|      0|			}
  759|      0|
  760|      0|			if (linelength <= option_linelength) {
  761|      0|				// treat lines shorter than a specified length as end-of-clause
  762|      0|				UngetC(c2);
  763|      0|				buf[ix] = ' ';
  764|      0|				buf[ix+1] = 0;
  765|      0|				return CLAUSE_COLON;
  766|      0|			}
  767|      0|
  768|      0|			linelength = 0;
  769|      0|		}
  770|      0|
  771|      0|		announced_punctuation = 0;
  772|      0|
  773|      0|		if ((phoneme_mode == 0) && (sayas_mode == 0)) {
  774|      0|			is_end_clause = false;
  775|      0|
  776|      0|			if (end_clause_after_tag) {
  777|      0|				// Because of an xml tag, we are waiting for the
  778|      0|				// next non-blank character to decide whether to end the clause
  779|      0|				// i.e. is dot followed by an upper-case letter?
  780|      0|
  781|      0|				if (!iswspace(c1)) {
  782|      0|					if (!IsAlpha(c1) || !iswlower(c1)) {
  783|      0|						UngetC(c2);
  784|      0|						ungot_char2 = c1;
  785|      0|						buf[end_clause_index] = ' '; // delete the end-clause punctuation
  786|      0|						buf[end_clause_index+1] = 0;
  787|      0|						return end_clause_after_tag;
  788|      0|					}
  789|      0|					end_clause_after_tag = 0;
  790|      0|				}
  791|      0|			}
  792|      0|
  793|      0|			if ((c1 == '.') && (c2 == '.')) {
  794|      0|				while ((c_next = GetC()) == '.') {
  795|      0|					// 3 or more dots, replace by elipsis
  796|      0|					c1 = 0x2026;
  797|      0|					c2 = ' ';
  798|      0|				}
  799|      0|				if (c1 == 0x2026)
  800|      0|					c2 = c_next;
  801|      0|				else
  802|      0|					UngetC(c_next);
  803|      0|			}
  804|      0|
  805|      0|			punct_data = 0;
  806|      0|			if ((punct_data = clause_type_from_codepoint(c1)) != CLAUSE_NONE) {
  807|      0|
  808|      0|				// Handling of sequences of ? and ! like ??!?, !!??!, ?!! etc
  809|      0|				// Use only first char as determinant
  810|      0|				if(punct_data & (CLAUSE_QUESTION | CLAUSE_EXCLAMATION)) {
  811|      0|					while(clause_type_from_codepoint(c2) & (CLAUSE_QUESTION | CLAUSE_EXCLAMATION)) {
  812|      0|						c_next = GetC();
  813|      0|						c2 = c_next;
  814|      0|					}
  815|      0|				}
  816|      0|
  817|      0|				if (punct_data & CLAUSE_PUNCTUATION_IN_WORD) {
  818|      0|					// Armenian punctuation inside a word
  819|      0|					stressed_word = true;
  820|      0|					*tone_type = punct_data >> 12 & 0xf; // override the end-of-sentence type
  821|      0|					continue;
  822|      0|				}
  823|      0|
  824|      0|				if (iswspace(c2) || (punct_data & CLAUSE_OPTIONAL_SPACE_AFTER) || IsBracket(c2) || (c2 == '?') || Eof() || c2 == CTRL_EMBEDDED) { // don't check for '-' because it prevents recognizing ':-)'
  825|      0|					// note: (c2='?') is for when a smart-quote has been replaced by '?'
  826|      0|					is_end_clause = true;
  827|      0|				}
  828|      0|			}
  829|      0|
  830|      0|			// don't announce punctuation for the alternative text inside inside <audio> ... </audio>
  831|      0|			if (c1 == 0xe000+'<')  c1 = '<';
  832|      0|			if (option_punctuation && iswpunct(c1) && (audio_text == false)) {
  833|      0|				// option is set to explicitly speak punctuation characters
  834|      0|				// if a list of allowed punctuation has been set up, check whether the character is in it
  835|      0|				if ((option_punctuation == 1) || (wcschr(option_punctlist, c1) != NULL)) {
  836|      0|					tr->phonemes_repeat_count = 0;
  837|      0|					if ((terminator = AnnouncePunctuation(tr, c1, &c2, buf, &ix, is_end_clause)) >= 0)
  838|      0|						return terminator;
  839|      0|					announced_punctuation = c1;
  840|      0|				}
  841|      0|			}
  842|      0|
  843|      0|			if ((punct_data & CLAUSE_SPEAK_PUNCTUATION_NAME) && (announced_punctuation == 0)) {
  844|      0|				// used for elipsis (and 3 dots) if a pronunciation for elipsis is given in *_list
  845|      0|				char *p2;
  846|      0|
  847|      0|				p2 = &buf[ix];
  848|      0|				sprintf(p2, "%s", LookupCharName(tr, c1, 1));
  849|      0|				if (p2[0] != 0) {
  850|      0|					ix += strlen(p2);
  851|      0|					announced_punctuation = c1;
  852|      0|					punct_data = punct_data & ~CLAUSE_INTONATION_TYPE; // change intonation type to 0 (full-stop)
  853|      0|				}
  854|      0|			}
  855|      0|
  856|      0|			if (is_end_clause) {
  857|      0|				nl_count = 0;
  858|      0|				c_next = c2;
  859|      0|
  860|      0|				if (iswspace(c_next)) {
  861|      0|					while (!Eof() && iswspace(c_next)) {
  862|      0|						if (c_next == '\n')
  863|      0|							nl_count++;
  864|      0|						c_next = GetC(); // skip past space(s)
  865|      0|					}
  866|      0|				}
  867|      0|
  868|      0|				if ((c1 == '.') && (nl_count < 2))
  869|      0|					punct_data |= CLAUSE_DOT_AFTER_LAST_WORD;
  870|      0|
  871|      0|				if (nl_count == 0) {
  872|      0|					if ((c1 == ',') && (cprev == '.') && (tr->translator_name == L('h', 'u')) && iswdigit(cprev2) && (iswdigit(c_next) || (iswlower(c_next)))) {
  873|      0|						// lang=hu, fix for ordinal numbers, eg:  "december 2., szerda", ignore ',' after ordinal number
  874|      0|						c1 = CHAR_COMMA_BREAK;
  875|      0|						is_end_clause = false;
  876|      0|					}
  877|      0|
  878|      0|					if (c1 == '.' && c_next == '\'' && text_decoder_peekc(p_decoder) == 's') {
  879|      0|					 	// A special case to handle english acronym + genitive, eg. u.s.a.'s
  880|      0|						// But avoid breaking clause handling if anything else follows the apostrophe.
  881|      0|						is_end_clause = false;
  882|      0|					}
  883|      0|
  884|      0|					if (c1 == '.') {
  885|      0|						if ((tr->langopts.numbers & NUM_ORDINAL_DOT) &&
  886|      0|						    (iswdigit(cprev) || (IsRomanU(cprev) && (IsRomanU(cprev2) || iswspace(cprev2))))) { // lang=hu
  887|      0|							// dot after a number indicates an ordinal number
  888|      0|							if (!iswdigit(cprev))
  889|      0|								is_end_clause = false; // Roman number followed by dot
  890|      0|							else if (iswlower(c_next) || (c_next == '-')) // hyphen is needed for lang-hu (eg. 2.-kal)
  891|      0|								is_end_clause = false; // only if followed by lower-case, (or if there is a XML tag)
  892|      0|						} 
  893|      0|						if (iswlower(c_next) && tr->langopts.lowercase_sentence == false) {
  894|      0|							// next word has no capital letter, this dot is probably from an abbreviation
  895|      0|							is_end_clause = false;
  896|      0|						}
  897|      0|						if (any_alnum == false) {
  898|      0|							// no letters or digits yet, so probably not a sentence terminator
  899|      0|							// Here, dot is followed by space or bracket
  900|      0|							c1 = ' ';
  901|      0|							is_end_clause = false;
  902|      0|						}
  903|      0|					} else {
  904|      0|						if (any_alnum == false) {
  905|      0|							// no letters or digits yet, so probably not a sentence terminator
  906|      0|							is_end_clause = false;
  907|      0|						}
  908|      0|					}
  909|      0|
  910|      0|					if (is_end_clause && (c1 == '.') && (c_next == '<') && option_ssml) {
  911|      0|						// wait until after the end of the xml tag, then look for upper-case letter
  912|      0|						is_end_clause = false;
  913|      0|						end_clause_index = ix;
  914|      0|						end_clause_after_tag = punct_data;
  915|      0|					}
  916|      0|				}
  917|      0|
  918|      0|				if (is_end_clause) {
  919|      0|					UngetC(c_next);
  920|      0|					buf[ix] = ' ';
  921|      0|					buf[ix+1] = 0;
  922|      0|
  923|      0|					if (iswdigit(cprev) && !IsAlpha(c_next)) // ????
  924|      0|						punct_data &= ~CLAUSE_DOT_AFTER_LAST_WORD;
  925|      0|					if (nl_count > 1) {
  926|      0|						if ((punct_data == CLAUSE_QUESTION) || (punct_data == CLAUSE_EXCLAMATION))
  927|      0|							return punct_data + 35; // with a longer pause
  928|      0|						return CLAUSE_PARAGRAPH;
  929|      0|					}
  930|      0|					return punct_data; // only recognise punctuation if followed by a blank or bracket/quote
  931|      0|				} else if (!Eof()) {
  932|      0|					if (iswspace(c2))
  933|      0|						UngetC(c_next);
  934|      0|				}
  935|      0|			}
  936|      0|		}
  937|      0|
  938|      0|		if (speech_parameters[espeakSILENCE] == 1)
  939|      0|			continue;
  940|      0|
  941|      0|		if (c1 == announced_punctuation) {
  942|      0|			// This character has already been announced, so delete it so that it isn't spoken a second time.
  943|      0|			// Unless it's a hyphen or apostrophe (which is used by TranslateClause() )
  944|      0|			if (IsBracket(c1))
  945|      0|				c1 = 0xe000 + '('; // Unicode private useage area.  So TranslateRules() knows the bracket name has been spoken
  946|      0|			else if (c1 != '-')
  947|      0|				c1 = ' ';
  948|      0|		}
  949|      0|
  950|      0|		j = ix+1;
  951|      0|
  952|      0|		if (c1 == 0xe000 + '<') c1 = '<';
  953|      0|
  954|      0|		ix += utf8_out(c1, &buf[ix]);
  955|      0|		if (!iswspace(c1) && !IsBracket(c1)) {
  956|      0|			charix[ix] = count_characters - clause_start_char;
  957|      0|			while (j < ix)
  958|      0|				charix[j++] = -1; // subsequent bytes of a multibyte character
  959|      0|		}
  960|      0|		*charix_top = ix;
  961|      0|
  962|      0|		if (((ix > (n_buf-75)) && !IsAlpha(c1) && !iswdigit(c1))  ||  (ix >= (n_buf-4))) {
  963|      0|			// clause too long, getting near end of buffer, so break here
  964|      0|			// try to break at a word boundary (unless we actually reach the end of buffer).
  965|      0|			// (n_buf-4) is to allow for 3 bytes of multibyte character plus terminator.
  966|      0|			buf[ix] = ' ';
  967|      0|			buf[ix+1] = 0;
  968|      0|			UngetC(c2);
  969|      0|			return CLAUSE_NONE;
  970|      0|		}
  971|      0|	}
  972|      0|
  973|      0|	if (stressed_word)
  974|      0|		ix += utf8_out(CHAR_EMPHASIS, &buf[ix]);
  975|      0|	if (end_clause_after_tag)
  976|      0|		RemoveChar(&buf[end_clause_index]); // delete clause-end punctiation
  977|      0|	buf[ix] = ' ';
  978|      0|	buf[ix+1] = 0;
  979|      0|	return CLAUSE_EOF; // end of file
  980|      0|}
  981|       |
  982|       |void InitNamedata(void)
  983|      0|{
  984|      0|	namedata_ix = 0;
  985|      0|	if (namedata != NULL) {
  986|      0|		free(namedata);
  987|      0|		namedata = NULL;
  988|      0|		n_namedata = 0;
  989|      0|	}
  990|      0|}
  991|       |
  992|       |void InitText2(void)
  993|      0|{
  994|      0|	int param;
  995|      0|
  996|      0|	ungot_char = 0;
  997|      0|	ungot_char2 = 0;
  998|      0|
  999|      0|	n_ssml_stack = 1;
 1000|      0|	n_param_stack = 1;
 1001|      0|	ssml_stack[0].tag_type = 0;
 1002|      0|
 1003|      0|	for (param = 0; param < N_SPEECH_PARAM; param++)
 1004|      0|		speech_parameters[param] = param_stack[0].parameter[param]; // set all speech parameters to defaults
 1005|      0|
 1006|      0|	option_punctuation = speech_parameters[espeakPUNCTUATION];
 1007|      0|	option_capitals = speech_parameters[espeakCAPITALS];
 1008|      0|
 1009|      0|	current_voice_id[0] = 0;
 1010|      0|
 1011|      0|	ignore_text = false;
 1012|      0|	audio_text = false;
 1013|      0|	clear_skipping_text = false;
 1014|      0|	count_characters = -1;
 1015|      0|	sayas_mode = 0;
 1016|      0|
 1017|      0|	xmlbase = NULL;
 1018|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/sPlayer.c:
    1|       |#include <espeak-ng/espeak_ng.h>
    2|       |#include <espeak-ng/speak_lib.h>
    3|       |#include "sPlayer.h"
    4|       |
    5|       |extern unsigned char *out_ptr;
    6|       |extern unsigned char *out_end;
    7|       |
    8|       |static speechPlayer_handle_t speechPlayerHandle=NULL;
    9|       |static const unsigned int minFadeLength=110;
   10|       |
   11|      0|static int MIN(int a, int b) { return((a) < (b) ? a : b); }
   12|       |
   13|      0|static bool needsMixWaveFile(WGEN_DATA *wdata) {
   14|      0|	return (bool)wdata->n_mix_wavefile;
   15|      0|}
   16|       |
   17|       |// mixes the currently queued espeak consonant wave file into the existing content in the given sample buffer.
   18|       |// This would be used for voiced consonants where the voiced part is generated by speechPlayer, but the consonant comes from a wave file in eSpeak.
   19|       |// e.g. z, v. 
   20|       |// @param maxNumSamples the maximum number of samples that can be mixed into the sample buffer.
   21|       |// @param sampleBuf the buffer of existing samples.
   22|      0|static void mixWaveFile(WGEN_DATA *wdata, unsigned int maxNumSamples, sample* sampleBuf) {
   23|      0|	unsigned int i=0;
   24|      0|	for(;wdata->mix_wavefile_ix<wdata->n_mix_wavefile;++wdata->mix_wavefile_ix) {
   25|      0|		if(i>=maxNumSamples) break;
   26|      0|		int val;
   27|      0|		if(wdata->mix_wave_scale==0) {
   28|      0|			val=wdata->mix_wavefile[wdata->mix_wavefile_ix+wdata->mix_wavefile_offset];
   29|      0|			++(wdata->mix_wavefile_ix);
   30|      0|			signed char c=wdata->mix_wavefile[wdata->mix_wavefile_ix+wdata->mix_wavefile_offset];
   31|      0|			val+=(c*256);
   32|      0|		} else {
   33|      0|			val=(signed char)wdata->mix_wavefile[wdata->mix_wavefile_ix+wdata->mix_wavefile_offset]*wdata->mix_wave_scale;
   34|      0|		}
   35|      0|		val*=(wdata->amplitude_v/1024.0);
   36|      0|		val=(val*wdata->mix_wave_amp)/40;
   37|      0|		sampleBuf[i].value+=val;
   38|      0|		if((wdata->mix_wavefile_ix+wdata->mix_wavefile_offset)>=wdata->mix_wavefile_max) {
   39|      0|			wdata->mix_wavefile_offset-=(wdata->mix_wavefile_max*3)/4;
   40|      0|		}
   41|      0|		++i;
   42|      0|	}
   43|      0|}
   44|       |
   45|      0|static bool isKlattFrameFollowing() {
   46|      0|	// eSpeak implements its command queue with a circular buffer.
   47|      0|	// Thus to walk it, we start from the head, walking to the tail, which may wrap around to the beginning of the buffer as it is circular.
   48|      0|	for(int i=(wcmdq_head+1)%N_WCMDQ;i!=wcmdq_tail;i=(i+1)%N_WCMDQ) {
   49|      0|		int cmd=wcmdq[i][0];
   50|      0|		if(cmd==WCMD_PAUSE||cmd==WCMD_WAVE) {
   51|      0|			break;
   52|      0|		}
   53|      0|		if(cmd==WCMD_KLATT) {
   54|      0|			return true;
   55|      0|		}
   56|      0|	}
   57|      0|	return false;
   58|      0|}
   59|       |
   60|      0|static void fillSpeechPlayerFrame(WGEN_DATA *wdata, voice_t *wvoice, frame_t * eFrame, speechPlayer_frame_t* spFrame) {
   61|      0|	// eSpeak stores pitch in 4096ths of a hz. Specifically comments in voice.h  mentions pitch<<12.
   62|      0|	// SpeechPlayer deals with floating point values  of hz.
   63|      0|	spFrame->voicePitch=(wdata->pitch)/4096.0;
   64|      0|	// eSpeak stores voicing amplitude with 64 representing 100% according to comments in voice.h.
   65|      0|	// speechPlayer uses floating point value of 1 as 100%.
   66|      0|	spFrame->voiceAmplitude=(wvoice->voicing)/64.0;
   67|      0|	spFrame->aspirationAmplitude=(wvoice->breath[1])/64.0;
   68|      0|	// All of eSpeak's relative formant frequency ratio values are stored with 256 representing 100% according to comments in voice.h. 
   69|      0|	spFrame->cf1=(eFrame->ffreq[1]*wvoice->freq[1]/256.0)+wvoice->freqadd[1];
   70|      0|	spFrame->cf2=(eFrame->ffreq[2]*wvoice->freq[2]/256.0)+wvoice->freqadd[2];
   71|      0|	spFrame->cf3=(eFrame->ffreq[3]*wvoice->freq[3]/256.0)+wvoice->freqadd[3];
   72|      0|	spFrame->cf4=(eFrame->ffreq[4]*wvoice->freq[4]/256.0)+wvoice->freqadd[4];
   73|      0|	spFrame->cf5=(eFrame->ffreq[5]*wvoice->freq[5]/256.0)+wvoice->freqadd[5];
   74|      0|	spFrame->cf6=(eFrame->ffreq[6]*wvoice->freq[6]/256.0)+wvoice->freqadd[6];
   75|      0|	spFrame->cfNP=200;
   76|      0|	spFrame->cfN0=250;
   77|      0|	if(eFrame->klattp[KLATT_FNZ]>0) {
   78|      0|		spFrame->caNP=1;
   79|      0|		spFrame->cfN0=eFrame->klattp[KLATT_FNZ]*2;
   80|      0|	} else {
   81|      0|		spFrame->caNP=0;
   82|      0|	}
   83|      0|	spFrame->cb1=eFrame->bw[1]*2*(wvoice->width[1]/256.0);
   84|      0|	spFrame->cb2=eFrame->bw[2]*2*(wvoice->width[2]/256.0);
   85|      0|	spFrame->cb3=eFrame->bw[3]*2*(wvoice->width[3]/256.0);
   86|      0|	spFrame->cb4=eFrame->bw[4]*2*(wvoice->width[4]/256.0);
   87|      0|	spFrame->cb5=1000;
   88|      0|	spFrame->cb6=1000;
   89|      0|	spFrame->cbNP=100;
   90|      0|	spFrame->cbN0=100;
   91|      0|	spFrame->preFormantGain=1;
   92|      0|	spFrame->outputGain=3*(wdata->amplitude/100.0);
   93|      0|	spFrame->endVoicePitch=spFrame->voicePitch;
   94|      0|}
   95|       |
   96|      0|void KlattInitSP() {
   97|      0|	speechPlayerHandle=speechPlayer_initialize(22050);
   98|      0|}
   99|       |
  100|      0|void KlattResetSP() {
  101|      0|	speechPlayer_terminate(speechPlayerHandle);
  102|      0|	speechPlayerHandle=speechPlayer_initialize(22050);
  103|      0|}
  104|       |
  105|      0|int Wavegen_KlattSP(WGEN_DATA *wdata, voice_t *wvoice, int length, int resume, frame_t *fr1, frame_t *fr2){
  106|      0|	if(!resume) {
  107|      0|		speechPlayer_frame_t spFrame1={0};
  108|      0|		fillSpeechPlayerFrame(wdata, wvoice, fr1,&spFrame1);
  109|      0|		speechPlayer_frame_t spFrame2={0};
  110|      0|		fillSpeechPlayerFrame(wdata, wvoice, fr2,&spFrame2);
  111|      0|		wdata->pitch_ix+=(wdata->pitch_inc*(length/STEPSIZE));
  112|      0|		wdata->pitch=((wdata->pitch_env[MIN(wdata->pitch_ix>>8,127)]*wdata->pitch_range)>>8)+wdata->pitch_base;
  113|      0|		spFrame2.endVoicePitch=wdata->pitch/4096;
  114|      0|		bool willMixWaveFile=needsMixWaveFile(wdata);
  115|      0|		if(willMixWaveFile) {
  116|      0|			spFrame1.outputGain/=5;
  117|      0|			spFrame2.outputGain/=5;
  118|      0|		}
  119|      0|		int mainLength=length;
  120|      0|		speechPlayer_queueFrame(speechPlayerHandle,&spFrame1,minFadeLength,minFadeLength,-1,false);
  121|      0|		mainLength-=minFadeLength;
  122|      0|		bool fadeOut=!isKlattFrameFollowing();
  123|      0|		if(fadeOut) {
  124|      0|			mainLength-=minFadeLength;
  125|      0|		}
  126|      0|		if(mainLength>=1) {
  127|      0|			speechPlayer_queueFrame(speechPlayerHandle,&spFrame2,mainLength,mainLength,-1,false);
  128|      0|		}
  129|      0|		if(fadeOut) {
  130|      0|			spFrame2.voicePitch=spFrame2.endVoicePitch;
  131|      0|			spFrame2.preFormantGain=0;
  132|      0|			speechPlayer_queueFrame(speechPlayerHandle,&spFrame2,minFadeLength/2,minFadeLength/2,-1,false);
  133|      0|			spFrame2.outputGain=0;
  134|      0|			speechPlayer_queueFrame(speechPlayerHandle,&spFrame2,minFadeLength/2,minFadeLength/2,-1,false);
  135|      0|		}
  136|      0|	}
  137|      0|	unsigned int maxLength=(out_end-out_ptr)/sizeof(sample);
  138|      0|	unsigned int outLength=speechPlayer_synthesize(speechPlayerHandle,maxLength,(sample*)out_ptr);
  139|      0|	mixWaveFile(wdata, outLength,(sample*)out_ptr);
  140|      0|	out_ptr=out_ptr+(sizeof(sample)*outLength);
  141|      0|	if(out_ptr>=out_end) return 1;
  142|      0|	return 0;
  143|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/setlengths.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2011 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2016 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <errno.h>
   23|       |#include <stdint.h>
   24|       |#include <stdio.h>
   25|       |#include <stdlib.h>
   26|       |
   27|       |#include <espeak-ng/espeak_ng.h>
   28|       |#include <espeak-ng/speak_lib.h>
   29|       |#include <espeak-ng/encoding.h>
   30|       |
   31|       |#include "readclause.h"
   32|       |#include "setlengths.h"
   33|       |#include "synthdata.h"
   34|       |#include "wavegen.h"
   35|       |
   36|       |#include "phoneme.h"
   37|       |#include "voice.h"
   38|       |#include "synthesize.h"
   39|       |#include "translate.h"
   40|       |
   41|       |extern int saved_parameters[];
   42|       |
   43|       |// convert from words-per-minute to internal speed factor
   44|       |// Use this to calibrate speed for wpm 80-450 (espeakRATE_MINIMUM - espeakRATE_MAXIMUM)
   45|       |static unsigned char speed_lookup[] = {
   46|       |	255, 255, 255, 255, 255, //  80
   47|       |	253, 249, 245, 242, 238, //  85
   48|       |	235, 232, 228, 225, 222, //  90
   49|       |	218, 216, 213, 210, 207, //  95
   50|       |	204, 201, 198, 196, 193, // 100
   51|       |	191, 188, 186, 183, 181, // 105
   52|       |	179, 176, 174, 172, 169, // 110
   53|       |	168, 165, 163, 161, 159, // 115
   54|       |	158, 155, 153, 152, 150, // 120
   55|       |	148, 146, 145, 143, 141, // 125
   56|       |	139, 137, 136, 135, 133, // 130
   57|       |	131, 130, 129, 127, 126, // 135
   58|       |	124, 123, 122, 120, 119, // 140
   59|       |	118, 117, 115, 114, 113, // 145
   60|       |	112, 111, 110, 109, 107, // 150
   61|       |	106, 105, 104, 103, 102, // 155
   62|       |	101, 100,  99,  98,  97, // 160
   63|       |	 96,  95,  94,  93,  92, // 165
   64|       |	 91,  90,  89,  89,  88, // 170
   65|       |	 87,  86,  85,  84,  83, // 175
   66|       |	 82,  82,  81,  80,  80, // 180
   67|       |	 79,  78,  77,  76,  76, // 185
   68|       |	 75,  75,  74,  73,  72, // 190
   69|       |	 71,  71,  70,  69,  69, // 195
   70|       |	 68,  67,  67,  66,  66, // 200
   71|       |	 65,  64,  64,  63,  62, // 205
   72|       |	 62,  61,  61,  60,  59, // 210
   73|       |	 59,  58,  58,  57,  57, // 215
   74|       |	 56,  56,  55,  54,  54, // 220
   75|       |	 53,  53,  52,  52,  52, // 225
   76|       |	 51,  50,  50,  49,  49, // 230
   77|       |	 48,  48,  47,  47,  46, // 235
   78|       |	 46,  46,  45,  45,  44, // 240
   79|       |	 44,  44,  43,  43,  42, // 245
   80|       |	 41,  40,  40,  40,  39, // 250
   81|       |	 39,  39,  38,  38,  38, // 255
   82|       |	 37,  37,  37,  36,  36, // 260
   83|       |	 35,  35,  35,  35,  34, // 265
   84|       |	 34,  34,  33,  33,  33, // 270
   85|       |	 32,  32,  31,  31,  31, // 275
   86|       |	 30,  30,  30,  29,  29, // 280
   87|       |	 29,  29,  28,  28,  27, // 285
   88|       |	 27,  27,  27,  26,  26, // 290
   89|       |	 26,  26,  25,  25,  25, // 295
   90|       |	 24,  24,  24,  24,  23, // 300
   91|       |	 23,  23,  23,  22,  22, // 305
   92|       |	 22,  21,  21,  21,  21, // 310
   93|       |	 20,  20,  20,  20,  19, // 315
   94|       |	 19,  19,  18,  18,  17, // 320
   95|       |	 17,  17,  16,  16,  16, // 325
   96|       |	 16,  16,  16,  15,  15, // 330
   97|       |	 15,  15,  14,  14,  14, // 335
   98|       |	 13,  13,  13,  12,  12, // 340
   99|       |	 12,  12,  11,  11,  11, // 345
  100|       |	 11,  10,  10,  10,   9, // 350
  101|       |	  9,   9,   8,   8,   8, // 355
  102|       |};
  103|       |
  104|       |// speed_factor1 adjustments for speeds 350 to 374: pauses
  105|       |static unsigned char pause_factor_350[] = {
  106|       |	22, 22, 22, 22, 22, 22, 22, 21, 21, 21, // 350
  107|       |	21, 20, 20, 19, 19, 18, 17, 16, 15, 15, // 360
  108|       |	15, 15, 15, 15, 15                      // 370
  109|       |};
  110|       |
  111|       |// wav_factor adjustments for speeds 350 to 450
  112|       |// Use this to calibrate speed for wpm 350-450
  113|       |static unsigned char wav_factor_350[] = {
  114|       |	120, 121, 120, 119, 119, // 350
  115|       |	118, 118, 117, 116, 116, // 355
  116|       |	115, 114, 113, 112, 112, // 360
  117|       |	111, 111, 110, 109, 108, // 365
  118|       |	107, 106, 106, 104, 103, // 370
  119|       |	103, 102, 102, 102, 101, // 375
  120|       |	101,  99,  98,  98,  97, // 380
  121|       |	 96,  96,  95,  94,  93, // 385
  122|       |	 91,  90,  91,  90,  89, // 390
  123|       |	 88,  86,  85,  86,  85, // 395
  124|       |	 85,  84,  82,  81,  80, // 400
  125|       |	 79,  77,  78,  78,  76, // 405
  126|       |	 77,  75,  75,  74,  73, // 410
  127|       |	 71,  72,  70,  69,  69, // 415
  128|       |	 69,  67,  65,  64,  63, // 420
  129|       |	 63,  63,  61,  61,  59, // 425
  130|       |	 59,  59,  58,  56,  57, // 430
  131|       |	 58,  56,  54,  53,  52, // 435
  132|       |	 52,  53,  52,  52,  50, // 440
  133|       |	 48,  47,  47,  45,  46, // 445
  134|       |	 45                      // 450
  135|       |};
  136|       |
  137|       |static int speed1 = 130;
  138|       |static int speed2 = 121;
  139|       |static int speed3 = 118;
  140|       |
  141|       |#if HAVE_SONIC_H
  142|       |
  143|       |void SetSpeed(int control)
  144|       |{
  145|       |	int x;
  146|       |	int s1;
  147|       |	int wpm;
  148|       |	int wpm2;
  149|       |	int wpm_value;
  150|       |	double sonic;
  151|       |
  152|       |	speed.min_sample_len = espeakRATE_MAXIMUM;
  153|       |	speed.lenmod_factor = 110; // controls the effect of FRFLAG_LEN_MOD reduce length change
  154|       |	speed.lenmod2_factor = 100;
  155|       |	speed.min_pause = 5;
  156|       |
  157|       |	wpm = embedded_value[EMBED_S];
  158|       |	if (control == 2)
  159|       |		wpm = embedded_value[EMBED_S2];
  160|       |
  161|       |	wpm_value = wpm;
  162|       |
  163|       |	if (voice->speed_percent > 0)
  164|       |		wpm = (wpm * voice->speed_percent)/100;
  165|       |
  166|       |	if (control & 2)
  167|       |		DoSonicSpeed(1 * 1024);
  168|       |	if ((wpm_value >= espeakRATE_MAXIMUM) || ((wpm_value > speed.fast_settings) && (wpm > 350))) {
  169|       |		wpm2 = wpm;
  170|       |		wpm = espeakRATE_NORMAL;
  171|       |
  172|       |		// set special eSpeak speed parameters for Sonic use
  173|       |		// The eSpeak output will be speeded up by at least x2
  174|       |		x = 73;
  175|       |		if (control & 1) {
  176|       |			speed1 = (x * voice->speedf1)/256;
  177|       |			speed2 = (x * voice->speedf2)/256;
  178|       |			speed3 = (x * voice->speedf3)/256;
  179|       |		}
  180|       |		if (control & 2) {
  181|       |			sonic = ((double)wpm2)/wpm;
  182|       |			DoSonicSpeed((int)(sonic * 1024));
  183|       |			speed.pause_factor = 85;
  184|       |			speed.clause_pause_factor = espeakRATE_MINIMUM;
  185|       |			speed.min_pause = 22;
  186|       |			speed.min_sample_len = espeakRATE_MAXIMUM*2;
  187|       |			speed.wav_factor = 211;
  188|       |			speed.lenmod_factor = 210;
  189|       |			speed.lenmod2_factor = 170;
  190|       |		}
  191|       |		return;
  192|       |	}
  193|       |
  194|       |	if (wpm > espeakRATE_MAXIMUM)
  195|       |		wpm = espeakRATE_MAXIMUM;
  196|       |
  197|       |	wpm2 = wpm;
  198|       |	if (wpm > 359) wpm2 = 359;
  199|       |	if (wpm < espeakRATE_MINIMUM) wpm2 = espeakRATE_MINIMUM;
  200|       |	x = speed_lookup[wpm2-espeakRATE_MINIMUM];
  201|       |
  202|       |	if (wpm >= 380)
  203|       |		x = 7;
  204|       |	if (wpm >= 400)
  205|       |		x = 6;
  206|       |
  207|       |	if (control & 1) {
  208|       |		// set speed factors for different syllable positions within a word
  209|       |		// these are used in CalcLengths()
  210|       |		speed1 = (x * voice->speedf1)/256;
  211|       |		speed2 = (x * voice->speedf2)/256;
  212|       |		speed3 = (x * voice->speedf3)/256;
  213|       |
  214|       |		if (x <= 7) {
  215|       |			speed1 = x;
  216|       |			speed2 = speed3 = x - 1;
  217|       |		}
  218|       |	}
  219|       |
  220|       |	if (control & 2) {
  221|       |		// these are used in synthesis file
  222|       |
  223|       |		if (wpm > 350) {
  224|       |			speed.lenmod_factor = 85 - (wpm - 350) / 3;
  225|       |			speed.lenmod2_factor = 60 - (wpm - 350) / 8;
  226|       |		} else if (wpm > 250) {
  227|       |			speed.lenmod_factor = 110 - (wpm - 250)/4;
  228|       |			speed.lenmod2_factor = 110 - (wpm - 250)/2;
  229|       |		}
  230|       |
  231|       |		s1 = (x * voice->speedf1)/256;
  232|       |
  233|       |		if (wpm >= 170)
  234|       |			speed.wav_factor = 110 + (150*s1)/128; // reduced speed adjustment, used for playing recorded sounds
  235|       |		else
  236|       |			speed.wav_factor = 128 + (128*s1)/130; // = 215 at 170 wpm
  237|       |
  238|       |		if (wpm >= 350)
  239|       |			speed.wav_factor = wav_factor_350[wpm-350];
  240|       |
  241|       |		if (wpm >= 390) {
  242|       |			speed.min_sample_len = espeakRATE_MAXIMUM - (wpm - 400)/2;
  243|       |			if (wpm > 440)
  244|       |				speed.min_sample_len = 420 - (wpm - 440);
  245|       |		}
  246|       |
  247|       |		// adjust for different sample rates
  248|       |		speed.min_sample_len = (speed.min_sample_len * samplerate_native) / 22050;
  249|       |
  250|       |		speed.pause_factor = (256 * s1)/115; // full speed adjustment, used for pause length
  251|       |		speed.clause_pause_factor = 0;
  252|       |
  253|       |		if (wpm > 430)
  254|       |			speed.pause_factor = 12;
  255|       |		else if (wpm > 400)
  256|       |			speed.pause_factor = 13;
  257|       |		else if (wpm > 374)
  258|       |			speed.pause_factor = 14;
  259|       |		else if (wpm > 350)
  260|       |			speed.pause_factor = pause_factor_350[wpm - 350];
  261|       |
  262|       |		if (speed.clause_pause_factor == 0) {
  263|       |			// restrict the reduction of pauses between clauses
  264|       |			if ((speed.clause_pause_factor = speed.pause_factor) < 16)
  265|       |				speed.clause_pause_factor = 16;
  266|       |		}
  267|       |	}
  268|       |}
  269|       |
  270|       |#else
  271|       |
  272|       |void SetSpeed(int control)
  273|      0|{
  274|      0|	// This is the earlier version of SetSpeed() before sonic speed-up was added
  275|      0|	int x;
  276|      0|	int s1;
  277|      0|	int wpm;
  278|      0|	int wpm2;
  279|      0|
  280|      0|	speed.min_sample_len = espeakRATE_MAXIMUM;
  281|      0|	speed.lenmod_factor = 110; // controls the effect of FRFLAG_LEN_MOD reduce length change
  282|      0|	speed.lenmod2_factor = 100;
  283|      0|
  284|      0|	wpm = embedded_value[EMBED_S];
  285|      0|	if (control == 2)
  286|      0|		wpm = embedded_value[EMBED_S2];
  287|      0|
  288|      0|	if (voice->speed_percent > 0)
  289|      0|		wpm = (wpm * voice->speed_percent)/100;
  290|      0|	if (wpm > espeakRATE_MAXIMUM)
  291|      0|		wpm = espeakRATE_MAXIMUM;
  292|      0|
  293|      0|	wpm2 = wpm;
  294|      0|	if (wpm > 359) wpm2 = 359;
  295|      0|	if (wpm < espeakRATE_MINIMUM) wpm2 = espeakRATE_MINIMUM;
  296|      0|	x = speed_lookup[wpm2-espeakRATE_MINIMUM];
  297|      0|
  298|      0|	if (wpm >= 380)
  299|      0|		x = 7;
  300|      0|	if (wpm >= 400)
  301|      0|		x = 6;
  302|      0|
  303|      0|	if (control & 1) {
  304|      0|		// set speed factors for different syllable positions within a word
  305|      0|		// these are used in CalcLengths()
  306|      0|		speed1 = (x * voice->speedf1)/256;
  307|      0|		speed2 = (x * voice->speedf2)/256;
  308|      0|		speed3 = (x * voice->speedf3)/256;
  309|      0|
  310|      0|		if (x <= 7) {
  311|      0|			speed1 = x;
  312|      0|			speed2 = speed3 = x - 1;
  313|      0|		}
  314|      0|	}
  315|      0|
  316|      0|	if (control & 2) {
  317|      0|		// these are used in synthesis file
  318|      0|
  319|      0|		if (wpm > 350) {
  320|      0|			speed.lenmod_factor = 85 - (wpm - 350) / 3;
  321|      0|			speed.lenmod2_factor = 60 - (wpm - 350) / 8;
  322|      0|		} else if (wpm > 250) {
  323|      0|			speed.lenmod_factor = 110 - (wpm - 250)/4;
  324|      0|			speed.lenmod2_factor = 110 - (wpm - 250)/2;
  325|      0|		}
  326|      0|
  327|      0|		s1 = (x * voice->speedf1)/256;
  328|      0|
  329|      0|		if (wpm >= 170)
  330|      0|			speed.wav_factor = 110 + (150*s1)/128; // reduced speed adjustment, used for playing recorded sounds
  331|      0|		else
  332|      0|			speed.wav_factor = 128 + (128*s1)/130; // = 215 at 170 wpm
  333|      0|
  334|      0|		if (wpm >= 350)
  335|      0|			speed.wav_factor = wav_factor_350[wpm-350];
  336|      0|
  337|      0|		if (wpm >= 390) {
  338|      0|			speed.min_sample_len = espeakRATE_MAXIMUM - (wpm - 400)/2;
  339|      0|			if (wpm > 440)
  340|      0|				speed.min_sample_len = 420 - (wpm - 440);
  341|      0|		}
  342|      0|
  343|      0|		speed.pause_factor = (256 * s1)/115; // full speed adjustment, used for pause length
  344|      0|		speed.clause_pause_factor = 0;
  345|      0|
  346|      0|		if (wpm > 430)
  347|      0|			speed.pause_factor = 12;
  348|      0|		else if (wpm > 400)
  349|      0|			speed.pause_factor = 13;
  350|      0|		else if (wpm > 374)
  351|      0|			speed.pause_factor = 14;
  352|      0|		else if (wpm > 350)
  353|      0|			speed.pause_factor = pause_factor_350[wpm - 350];
  354|      0|
  355|      0|		if (speed.clause_pause_factor == 0) {
  356|      0|			// restrict the reduction of pauses between clauses
  357|      0|			if ((speed.clause_pause_factor = speed.pause_factor) < 16)
  358|      0|				speed.clause_pause_factor = 16;
  359|      0|		}
  360|      0|	}
  361|      0|}
  362|       |
  363|       |#endif
  364|       |
  365|       |espeak_ng_STATUS SetParameter(int parameter, int value, int relative)
  366|      0|{
  367|      0|	// parameter: reset-all, amp, pitch, speed, linelength, expression, capitals, number grouping
  368|      0|	// relative 0=absolute  1=relative
  369|      0|
  370|      0|	int new_value = value;
  371|      0|	int default_value;
  372|      0|	extern const int param_defaults[N_SPEECH_PARAM];
  373|      0|
  374|      0|	if (relative) {
  375|      0|		if (parameter < 5) {
  376|      0|			default_value = param_defaults[parameter];
  377|      0|			new_value = default_value + (default_value * value)/100;
  378|      0|		}
  379|      0|	}
  380|      0|	param_stack[0].parameter[parameter] = new_value;
  381|      0|	saved_parameters[parameter] = new_value;
  382|      0|
  383|      0|	switch (parameter)
  384|      0|	{
  385|      0|	case espeakRATE:
  386|      0|		embedded_value[EMBED_S] = new_value;
  387|      0|		embedded_value[EMBED_S2] = new_value;
  388|      0|		SetSpeed(3);
  389|      0|		break;
  390|      0|	case espeakVOLUME:
  391|      0|		embedded_value[EMBED_A] = new_value;
  392|      0|		GetAmplitude();
  393|      0|		break;
  394|      0|	case espeakPITCH:
  395|      0|		if (new_value > 99) new_value = 99;
  396|      0|		if (new_value < 0) new_value = 0;
  397|      0|		embedded_value[EMBED_P] = new_value;
  398|      0|		break;
  399|      0|	case espeakRANGE:
  400|      0|		if (new_value > 99) new_value = 99;
  401|      0|		embedded_value[EMBED_R] = new_value;
  402|      0|		break;
  403|      0|	case espeakLINELENGTH:
  404|      0|		option_linelength = new_value;
  405|      0|		break;
  406|      0|	case espeakWORDGAP:
  407|      0|		option_wordgap = new_value;
  408|      0|		break;
  409|      0|	case espeakINTONATION:
  410|      0|		if ((new_value & 0xff) != 0)
  411|      0|			translator->langopts.intonation_group = new_value & 0xff;
  412|      0|		option_tone_flags = new_value;
  413|      0|		break;
  414|      0|	default:
  415|      0|		return EINVAL;
  416|      0|	}
  417|      0|	return ENS_OK;
  418|      0|}
  419|       |
  420|       |static void DoEmbedded2(int *embix)
  421|      0|{
  422|      0|	// There were embedded commands in the text at this point
  423|      0|
  424|      0|	unsigned int word;
  425|      0|
  426|      0|	do {
  427|      0|		word = embedded_list[(*embix)++];
  428|      0|
  429|      0|		if ((word & 0x1f) == EMBED_S) {
  430|      0|			// speed
  431|      0|			SetEmbedded(word & 0x7f, word >> 8); // adjusts embedded_value[EMBED_S]
  432|      0|			SetSpeed(1);
  433|      0|		}
  434|      0|	} while ((word & 0x80) == 0);
  435|      0|}
  436|       |
  437|       |void CalcLengths(Translator *tr)
  438|      0|{
  439|      0|	int ix;
  440|      0|	int ix2;
  441|      0|	PHONEME_LIST *prev;
  442|      0|	PHONEME_LIST *next;
  443|      0|	PHONEME_LIST *next2;
  444|      0|	PHONEME_LIST *next3;
  445|      0|	PHONEME_LIST *p;
  446|      0|	PHONEME_LIST *p2;
  447|      0|
  448|      0|	int stress;
  449|      0|	int type;
  450|      0|	static int more_syllables = 0;
  451|      0|	bool pre_sonorant = false;
  452|      0|	bool pre_voiced = false;
  453|      0|	int last_pitch = 0;
  454|      0|	int pitch_start;
  455|      0|	int length_mod;
  456|      0|	int next2type;
  457|      0|	int len;
  458|      0|	int env2;
  459|      0|	int end_of_clause;
  460|      0|	int embedded_ix = 0;
  461|      0|	int min_drop;
  462|      0|	int pitch1;
  463|      0|	int emphasized;
  464|      0|	int tone_mod;
  465|      0|	unsigned char *pitch_env = NULL;
  466|      0|	PHONEME_DATA phdata_tone;
  467|      0|
  468|      0|	for (ix = 1; ix < n_phoneme_list; ix++) {
  469|      0|		prev = &phoneme_list[ix-1];
  470|      0|		p = &phoneme_list[ix];
  471|      0|		stress = p->stresslevel & 0x7;
  472|      0|		emphasized = p->stresslevel & 0x8;
  473|      0|
  474|      0|		next = &phoneme_list[ix+1];
  475|      0|
  476|      0|		if (p->synthflags & SFLAG_EMBEDDED)
  477|      0|			DoEmbedded2(&embedded_ix);
  478|      0|
  479|      0|		type = p->type;
  480|      0|		if (p->synthflags & SFLAG_SYLLABLE)
  481|      0|			type = phVOWEL;
  482|      0|
  483|      0|		switch (type)
  484|      0|		{
  485|      0|		case phPAUSE:
  486|      0|			last_pitch = 0;
  487|      0|			break;
  488|      0|		case phSTOP:
  489|      0|			last_pitch = 0;
  490|      0|			if (prev->type == phFRICATIVE)
  491|      0|				p->prepause = 25;
  492|      0|			else if ((more_syllables > 0) || (stress < 4))
  493|      0|				p->prepause = 48;
  494|      0|			else
  495|      0|				p->prepause = 60;
  496|      0|
  497|      0|			if (prev->type == phSTOP)
  498|      0|				p->prepause = 60;
  499|      0|
  500|      0|			if ((tr->langopts.word_gap & 0x10) && (p->newword))
  501|      0|				p->prepause = 60;
  502|      0|
  503|      0|			if (p->ph->phflags & phLENGTHENSTOP)
  504|      0|				p->prepause += 30;
  505|      0|
  506|      0|			if (p->synthflags & SFLAG_LENGTHEN)
  507|      0|				p->prepause += tr->langopts.long_stop;
  508|      0|			break;
  509|      0|		case phVFRICATIVE:
  510|      0|		case phFRICATIVE:
  511|      0|			if (p->newword) {
  512|      0|				if ((prev->type == phVOWEL) && (p->ph->phflags & phNOPAUSE)) {
  513|      0|				} else
  514|      0|					p->prepause = 15;
  515|      0|			}
  516|      0|
  517|      0|			if (next->type == phPAUSE && prev->type == phNASAL && !(p->ph->phflags&phVOICELESS))
  518|      0|				p->prepause = 25;
  519|      0|
  520|      0|			if (prev->ph->phflags & phBRKAFTER)
  521|      0|				p->prepause = 30;
  522|      0|
  523|      0|			if ((tr->langopts.word_gap & 0x10) && (p->newword))
  524|      0|				p->prepause = 30;
  525|      0|
  526|      0|			if ((p->ph->phflags & phSIBILANT) && next->type == phSTOP && !next->newword) {
  527|      0|				if (prev->type == phVOWEL)
  528|      0|					p->length = 200; // ?? should do this if it's from a prefix
  529|      0|				else
  530|      0|					p->length = 150;
  531|      0|			} else
  532|      0|				p->length = 256;
  533|      0|
  534|      0|			if (type == phVFRICATIVE) {
  535|      0|				if (next->type == phVOWEL)
  536|      0|					pre_voiced = true;
  537|      0|				if ((prev->type == phVOWEL) || (prev->type == phLIQUID))
  538|      0|					p->length = (255 + prev->length)/2;
  539|      0|			}
  540|      0|			break;
  541|      0|		case phVSTOP:
  542|      0|			if (prev->type == phVFRICATIVE || prev->type == phFRICATIVE || (prev->ph->phflags & phSIBILANT) || (prev->type == phLIQUID))
  543|      0|				p->prepause = 30;
  544|      0|
  545|      0|			if (next->type == phVOWEL || next->type == phLIQUID) {
  546|      0|				if ((next->type == phVOWEL) || !next->newword)
  547|      0|					pre_voiced = true;
  548|      0|
  549|      0|				p->prepause = 40;
  550|      0|
  551|      0|				if (prev->type == phVOWEL) {
  552|      0|					p->prepause = 0; // use murmur instead to link from the preceding vowel
  553|      0|				} else if (prev->type == phPAUSE) {
  554|      0|					// reduce by the length of the preceding pause
  555|      0|					if (prev->length < p->prepause)
  556|      0|						p->prepause -= prev->length;
  557|      0|					else
  558|      0|						p->prepause = 0;
  559|      0|				} else if (p->newword == 0) {
  560|      0|					if (prev->type == phLIQUID)
  561|      0|						p->prepause = 20;
  562|      0|					if (prev->type == phNASAL)
  563|      0|						p->prepause = 12;
  564|      0|
  565|      0|					if (prev->type == phSTOP && !(prev->ph->phflags & phVOICELESS))
  566|      0|						p->prepause = 0;
  567|      0|				}
  568|      0|			}
  569|      0|			if ((tr->langopts.word_gap & 0x10) && (p->newword) && (p->prepause < 20))
  570|      0|				p->prepause = 20;
  571|      0|			break;
  572|      0|		case phLIQUID:
  573|      0|		case phNASAL:
  574|      0|			p->amp = tr->stress_amps[0]; // unless changed later
  575|      0|			p->length = 256; //  TEMPORARY
  576|      0|
  577|      0|			if (p->newword) {
  578|      0|				if (prev->type == phLIQUID)
  579|      0|					p->prepause = 25;
  580|      0|				if (prev->type == phVOWEL) {
  581|      0|					if (!(p->ph->phflags & phNOPAUSE))
  582|      0|						p->prepause = 12;
  583|      0|				}
  584|      0|			}
  585|      0|
  586|      0|			if (next->type == phVOWEL)
  587|      0|				pre_sonorant = true;
  588|      0|			else {
  589|      0|				p->pitch2 = last_pitch;
  590|      0|
  591|      0|				if ((prev->type == phVOWEL) || (prev->type == phLIQUID)) {
  592|      0|					p->length = prev->length;
  593|      0|
  594|      0|					if (p->type == phLIQUID)
  595|      0|						p->length = speed1;
  596|      0|
  597|      0|					if (next->type == phVSTOP)
  598|      0|						p->length = (p->length * 160)/100;
  599|      0|					if (next->type == phVFRICATIVE)
  600|      0|						p->length = (p->length * 120)/100;
  601|      0|				} else {
  602|      0|					for (ix2 = ix; ix2 < n_phoneme_list; ix2++) {
  603|      0|						if (phoneme_list[ix2].type == phVOWEL) {
  604|      0|							p->pitch2 = phoneme_list[ix2].pitch2;
  605|      0|							break;
  606|      0|						}
  607|      0|					}
  608|      0|				}
  609|      0|
  610|      0|				p->pitch1 = p->pitch2-16;
  611|      0|				if (p->pitch2 < 16)
  612|      0|					p->pitch1 = 0;
  613|      0|				p->env = PITCHfall;
  614|      0|				pre_voiced = false;
  615|      0|			}
  616|      0|			break;
  617|      0|		case phVOWEL:
  618|      0|			min_drop = 0;
  619|      0|			next2 = &phoneme_list[ix+2];
  620|      0|			next3 = &phoneme_list[ix+3];
  621|      0|
  622|      0|			if (stress > 7) stress = 7;
  623|      0|
  624|      0|			if (stress <= 1)
  625|      0|				stress = stress ^ 1; // swap diminished and unstressed (until we swap stress_amps,stress_lengths in tr_languages)
  626|      0|			if (pre_sonorant)
  627|      0|				p->amp = tr->stress_amps[stress]-1;
  628|      0|			else
  629|      0|				p->amp = tr->stress_amps[stress];
  630|      0|
  631|      0|			if (emphasized)
  632|      0|				p->amp = 25;
  633|      0|
  634|      0|			if (ix >= (n_phoneme_list-3)) {
  635|      0|				// last phoneme of a clause, limit its amplitude
  636|      0|				if (p->amp > tr->langopts.param[LOPT_MAXAMP_EOC])
  637|      0|					p->amp = tr->langopts.param[LOPT_MAXAMP_EOC];
  638|      0|			}
  639|      0|
  640|      0|			// is the last syllable of a word ?
  641|      0|			more_syllables = 0;
  642|      0|			end_of_clause = 0;
  643|      0|			for (p2 = p+1; p2->newword == 0; p2++) {
  644|      0|				if ((p2->type == phVOWEL) && !(p2->ph->phflags & phNONSYLLABIC))
  645|      0|					more_syllables++;
  646|      0|
  647|      0|				if (p2->ph->code == phonPAUSE_CLAUSE)
  648|      0|					end_of_clause = 2;
  649|      0|			}
  650|      0|			if (p2->ph->code == phonPAUSE_CLAUSE)
  651|      0|				end_of_clause = 2;
  652|      0|
  653|      0|			if ((p2->newword & PHLIST_END_OF_CLAUSE) && (more_syllables == 0))
  654|      0|				end_of_clause = 2;
  655|      0|
  656|      0|			// calc length modifier
  657|      0|			if ((next->ph->code == phonPAUSE_VSHORT) && (next2->type == phPAUSE)) {
  658|      0|				// if PAUSE_VSHORT is followed by a pause, then use that
  659|      0|				next = next2;
  660|      0|				next2 = next3;
  661|      0|				next3 = &phoneme_list[ix+4];
  662|      0|			}
  663|      0|
  664|      0|			next2type = next2->ph->length_mod;
  665|      0|			if (more_syllables == 0) {
  666|      0|				if (next->newword || next2->newword) {
  667|      0|					// don't use 2nd phoneme over a word boundary, unless it's a pause
  668|      0|					if (next2type != 1)
  669|      0|						next2type = 0;
  670|      0|				}
  671|      0|
  672|      0|				len = tr->langopts.length_mods0[next2type *10+ next->ph->length_mod];
  673|      0|
  674|      0|				if ((next->newword) && (tr->langopts.word_gap & 0x20)) {
  675|      0|					// consider as a pause + first phoneme of the next word
  676|      0|					length_mod = (len + tr->langopts.length_mods0[next->ph->length_mod *10+ 1])/2;
  677|      0|				} else
  678|      0|					length_mod = len;
  679|      0|			} else {
  680|      0|				length_mod = tr->langopts.length_mods[next2type *10+ next->ph->length_mod];
  681|      0|
  682|      0|				if ((next->type == phNASAL) && (next2->type == phSTOP || next2->type == phVSTOP) && (next3->ph->phflags & phVOICELESS))
  683|      0|					length_mod -= 15;
  684|      0|			}
  685|      0|
  686|      0|			if (more_syllables == 0)
  687|      0|				length_mod *= speed1;
  688|      0|			else if (more_syllables == 1)
  689|      0|				length_mod *= speed2;
  690|      0|			else
  691|      0|				length_mod *= speed3;
  692|      0|
  693|      0|			length_mod = length_mod / 128;
  694|      0|
  695|      0|			if (length_mod < 8)
  696|      0|				length_mod = 8; // restrict how much lengths can be reduced
  697|      0|
  698|      0|			if (stress >= 7) {
  699|      0|				// tonic syllable, include a constant component so it doesn't decrease directly with speed
  700|      0|				length_mod += tr->langopts.lengthen_tonic;
  701|      0|				if (emphasized)
  702|      0|					length_mod += (tr->langopts.lengthen_tonic/2);
  703|      0|			} else if (emphasized)
  704|      0|				length_mod += tr->langopts.lengthen_tonic;
  705|      0|
  706|      0|			if ((len = tr->stress_lengths[stress]) == 0)
  707|      0|				len = tr->stress_lengths[6];
  708|      0|
  709|      0|			length_mod = length_mod * len;
  710|      0|
  711|      0|			if (p->tone_ph != 0) {
  712|      0|				if ((tone_mod = phoneme_tab[p->tone_ph]->std_length) > 0) {
  713|      0|					// a tone phoneme specifies a percentage change to the length
  714|      0|					length_mod = (length_mod * tone_mod) / 100;
  715|      0|				}
  716|      0|			}
  717|      0|
  718|      0|			if ((end_of_clause == 2) && !(tr->langopts.stress_flags & S_NO_EOC_LENGTHEN)) {
  719|      0|				// this is the last syllable in the clause, lengthen it - more for short vowels
  720|      0|				len = (p->ph->std_length * 2);
  721|      0|				if (tr->langopts.stress_flags & S_EO_CLAUSE1)
  722|      0|					len = 200; // don't lengthen short vowels more than long vowels at end-of-clause
  723|      0|				length_mod = length_mod * (256 + (280 - len)/3)/256;
  724|      0|			}
  725|      0|
  726|      0|			if (length_mod > tr->langopts.max_lengthmod*speed1) {
  727|      0|				// limit the vowel length adjustment for some languages
  728|      0|				length_mod = (tr->langopts.max_lengthmod*speed1);
  729|      0|			}
  730|      0|
  731|      0|			length_mod = length_mod / 128;
  732|      0|
  733|      0|			if (p->type != phVOWEL) {
  734|      0|				length_mod = 256; // syllabic consonant
  735|      0|				min_drop = 16;
  736|      0|			}
  737|      0|			p->length = length_mod;
  738|      0|
  739|      0|			if (p->env >= (N_ENVELOPE_DATA-1)) {
  740|      0|				fprintf(stderr, "espeak: Bad intonation data\n");
  741|      0|				p->env = 0;
  742|      0|			}
  743|      0|
  744|      0|			// pre-vocalic part
  745|      0|			// set last-pitch
  746|      0|			env2 = p->env + 1; // version for use with preceding semi-vowel
  747|      0|
  748|      0|			if (p->tone_ph != 0) {
  749|      0|				InterpretPhoneme2(p->tone_ph, &phdata_tone);
  750|      0|				pitch_env = GetEnvelope(phdata_tone.pitch_env);
  751|      0|			} else
  752|      0|				pitch_env = envelope_data[env2];
  753|      0|
  754|      0|			pitch_start = p->pitch1 + ((p->pitch2-p->pitch1)*pitch_env[0])/256;
  755|      0|
  756|      0|			if (pre_sonorant || pre_voiced) {
  757|      0|				// set pitch for pre-vocalic part
  758|      0|				if (pitch_start == 255)
  759|      0|					last_pitch = pitch_start; // pitch is not set
  760|      0|
  761|      0|				if (pitch_start - last_pitch > 16)
  762|      0|					last_pitch = pitch_start - 16;
  763|      0|
  764|      0|				prev->pitch1 = last_pitch;
  765|      0|				prev->pitch2 = pitch_start;
  766|      0|				if (last_pitch < pitch_start) {
  767|      0|					prev->env = PITCHrise;
  768|      0|					p->env = env2;
  769|      0|				} else
  770|      0|					prev->env = PITCHfall;
  771|      0|
  772|      0|				prev->length = length_mod;
  773|      0|
  774|      0|				prev->amp = p->amp;
  775|      0|				if ((prev->type != phLIQUID) && (prev->amp > 18))
  776|      0|					prev->amp = 18;
  777|      0|			}
  778|      0|
  779|      0|			// vowel & post-vocalic part
  780|      0|			next->synthflags &= ~SFLAG_SEQCONTINUE;
  781|      0|			if (next->type == phNASAL && next2->type != phVOWEL)
  782|      0|				next->synthflags |= SFLAG_SEQCONTINUE;
  783|      0|
  784|      0|			if (next->type == phLIQUID) {
  785|      0|				next->synthflags |= SFLAG_SEQCONTINUE;
  786|      0|
  787|      0|				if (next2->type == phVOWEL)
  788|      0|					next->synthflags &= ~SFLAG_SEQCONTINUE;
  789|      0|
  790|      0|				if (next2->type != phVOWEL) {
  791|      0|					if (next->ph->mnemonic == ('/'*256+'r'))
  792|      0|						next->synthflags &= ~SFLAG_SEQCONTINUE;
  793|      0|				}
  794|      0|			}
  795|      0|
  796|      0|			if ((min_drop > 0) && ((p->pitch2 - p->pitch1) < min_drop)) {
  797|      0|				pitch1 = p->pitch2 - min_drop;
  798|      0|				if (pitch1 < 0)
  799|      0|					pitch1 = 0;
  800|      0|				p->pitch1 = pitch1;
  801|      0|			}
  802|      0|
  803|      0|			last_pitch = p->pitch1 + ((p->pitch2-p->pitch1)*envelope_data[p->env][127])/256;
  804|      0|			pre_sonorant = false;
  805|      0|			pre_voiced = false;
  806|      0|			break;
  807|      0|		}
  808|      0|	}
  809|      0|}
  810|       |// Tables of the relative lengths of vowels, depending on the
  811|       |// type of the two phonemes that follow
  812|       |// indexes are the "length_mod" value for the following phonemes
  813|       |
  814|       |// use this table if vowel is not the last in the word
  815|       |static unsigned char length_mods_en[100] = {
  816|       |//	a    ,    t    s    n    d    z    r    N    <- next
  817|       |	100, 120, 100, 105, 100, 110, 110, 100,  95, 100, // a  <- next2
  818|       |	105, 120, 105, 110, 125, 130, 135, 115, 125, 100, // ,
  819|       |	105, 120,  75, 100,  75, 105, 120,  85,  75, 100, // t
  820|       |	105, 120,  85, 105,  95, 115, 120, 100,  95, 100, // s
  821|       |	110, 120,  95, 105, 100, 115, 120, 100, 100, 100, // n
  822|       |	105, 120, 100, 105,  95, 115, 120, 110,  95, 100, // d
  823|       |	105, 120, 100, 105, 105, 122, 125, 110, 105, 100, // z
  824|       |	105, 120, 100, 105, 105, 122, 125, 110, 105, 100, // r
  825|       |	105, 120,  95, 105, 100, 115, 120, 110, 100, 100, // N
  826|       |	100, 120, 100, 100, 100, 100, 100, 100, 100, 100
  827|       |};
  828|       |
  829|       |// as above, but for the last syllable in a word
  830|       |static unsigned char length_mods_en0[100] = {
  831|       |//	a    ,    t    s    n    d    z    r    N    <- next
  832|       |	100, 150, 100, 105, 110, 115, 110, 110, 110, 100, // a  <- next2
  833|       |	105, 150, 105, 110, 125, 135, 140, 115, 135, 100, // ,
  834|       |	105, 150,  90, 105,  90, 122, 135, 100,  90, 100, // t
  835|       |	105, 150, 100, 105, 100, 122, 135, 100, 100, 100, // s
  836|       |	105, 150, 100, 105, 105, 115, 135, 110, 105, 100, // n
  837|       |	105, 150, 100, 105, 105, 122, 130, 120, 125, 100, // d
  838|       |	105, 150, 100, 105, 110, 122, 125, 115, 110, 100, // z
  839|       |	105, 150, 100, 105, 105, 122, 135, 120, 105, 100, // r
  840|       |	105, 150, 100, 105, 105, 115, 135, 110, 105, 100, // N
  841|       |	100, 100, 100, 100, 100, 100, 100, 100, 100, 100
  842|       |};
  843|       |
  844|       |
  845|       |static unsigned char length_mods_equal[100] = {
  846|       |//	a    ,    t    s    n    d    z    r    N    <- next
  847|       |	110, 120, 100, 110, 110, 110, 110, 110, 110, 110, // a  <- next2
  848|       |	110, 120, 100, 110, 110, 110, 110, 110, 110, 110, // ,
  849|       |	110, 120, 100, 110, 100, 110, 110, 110, 100, 110, // t
  850|       |	110, 120, 100, 110, 110, 110, 110, 110, 110, 110, // s
  851|       |	110, 120, 100, 110, 110, 110, 110, 110, 110, 110, // n
  852|       |	110, 120, 100, 110, 110, 110, 110, 110, 110, 110, // d
  853|       |	110, 120, 100, 110, 110, 110, 110, 110, 110, 110, // z
  854|       |	110, 120, 100, 110, 110, 110, 110, 110, 110, 110, // r
  855|       |	110, 120, 100, 110, 110, 110, 110, 110, 110, 110, // N
  856|       |	110, 120, 100, 110, 110, 110, 110, 110, 110, 110
  857|       |};
  858|       |
  859|       |static unsigned char *length_mod_tabs[6] = {
  860|       |	length_mods_en,
  861|       |	length_mods_en,    // 1
  862|       |	length_mods_en0,   // 2
  863|       |	length_mods_equal, // 3
  864|       |	length_mods_equal, // 4
  865|       |	length_mods_equal  // 5
  866|       |};
  867|       |
  868|       |void SetLengthMods(Translator *tr, int value)
  869|      0|{
  870|      0|	int value2;
  871|      0|
  872|      0|	tr->langopts.length_mods0 = tr->langopts.length_mods = length_mod_tabs[value % 100];
  873|      0|	if ((value2 = value / 100) != 0)
  874|      0|		tr->langopts.length_mods0 = length_mod_tabs[value2];
  875|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/soundicon.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2015 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2017 Reece H. Dunn
    5|       | * Copyright (C) 2021 Juho Hiltunen
    6|       | * 
    7|       | * This program is free software; you can redistribute it and/or modify
    8|       | * it under the terms of the GNU General Public License as published by
    9|       | * the Free Software Foundation; either version 3 of the License, or
   10|       | * (at your option) any later version.
   11|       | *
   12|       | * This program is distributed in the hope that it will be useful,
   13|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   14|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   15|       | * GNU General Public License for more details.
   16|       | *
   17|       | * You should have received a copy of the GNU General Public License
   18|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   19|       | */
   20|       |
   21|       |#include "config.h"
   22|       |
   23|       |#include <ctype.h>
   24|       |#include <errno.h>
   25|       |#include <locale.h>
   26|       |#include <math.h>
   27|       |#include <stdint.h>
   28|       |#include <stdio.h>
   29|       |#include <stdlib.h>
   30|       |#include <string.h>
   31|       |#include <unistd.h>
   32|       |
   33|       |#include <espeak-ng/espeak_ng.h>
   34|       |#include <espeak-ng/speak_lib.h>
   35|       |#include <espeak-ng/encoding.h>
   36|       |#include <ucd/ucd.h>
   37|       |
   38|       |#include "soundicon.h" 
   39|       |#include "error.h"                // for create_file_error_context
   40|       |#include "readclause.h"               // for Read4Bytes
   41|       |#include "speech.h"                   // for path_home, GetFileLength, PATHSEP
   42|       |#include "synthesize.h"                   // for samplerate
   43|       |
   44|       |int n_soundicon_tab = 0;
   45|       |SOUND_ICON soundicon_tab[N_SOUNDICON_TAB];
   46|       |
   47|       |
   48|       |static espeak_ng_STATUS LoadSoundFile(const char *fname, int index, espeak_ng_ERROR_CONTEXT *context)
   49|      0|{
   50|      0|	FILE *f;
   51|      0|	char *p;
   52|      0|	int *ip;
   53|      0|	int length;
   54|      0|	char fname_temp[100];
   55|      0|	char fname2[sizeof(path_home)+13+40];
   56|      0|
   57|      0|	if (fname == NULL) {
   58|      0|		// filename is already in the table
   59|      0|		fname = soundicon_tab[index].filename;
   60|      0|	}
   61|      0|
   62|      0|	if (fname == NULL)
   63|      0|		return EINVAL;
   64|      0|
   65|      0|	if (fname[0] != '/') {
   66|      0|		// a relative path, look in espeak-ng-data/soundicons
   67|      0|		sprintf(fname2, "%s%csoundicons%c%s", path_home, PATHSEP, PATHSEP, fname);
   68|      0|		fname = fname2;
   69|      0|	}
   70|      0|
   71|      0|	f = NULL;
   72|      0|	if ((f = fopen(fname, "rb")) != NULL) {
   73|      0|		int ix;
   74|      0|		int fd_temp;
   75|      0|		int header[3];
   76|      0|		char command[sizeof(fname2)+sizeof(fname2)+40];
   77|      0|
   78|      0|		if (fseek(f, 20, SEEK_SET) == -1) {
   79|      0|			int error = errno;
   80|      0|			fclose(f);
   81|      0|			return create_file_error_context(context, error, fname);
   82|      0|		}
   83|      0|
   84|      0|		for (ix = 0; ix < 3; ix++)
   85|      0|			header[ix] = Read4Bytes(f);
   86|      0|
   87|      0|		// if the sound file is not mono, 16 bit signed, at the correct sample rate, then convert it
   88|      0|		if ((header[0] != 0x10001) || (header[1] != samplerate) || (header[2] != samplerate*2)) {
   89|      0|			fclose(f);
   90|      0|			f = NULL;
   91|      0|
   92|      0|#ifdef HAVE_MKSTEMP
   93|      0|			strcpy(fname_temp, "/tmp/espeakXXXXXX");
   94|      0|			if ((fd_temp = mkstemp(fname_temp)) >= 0)
   95|      0|				close(fd_temp);
   96|       |#else
   97|       |			strcpy(fname_temp, tmpnam(NULL));
   98|       |#endif
   99|       |
  100|      0|			sprintf(command, "sox \"%s\" -r %d -c1 -b 16 -t wav %s\n", fname, samplerate, fname_temp);
  101|      0|			if (system(command) == 0)
  102|      0|				fname = fname_temp;
  103|      0|		}
  104|      0|	}
  105|      0|
  106|      0|	if (f == NULL) {
  107|      0|		f = fopen(fname, "rb");
  108|      0|		if (f == NULL)
  109|      0|			return create_file_error_context(context, errno, fname);
  110|      0|	}
  111|      0|
  112|      0|	length = GetFileLength(fname);
  113|      0|	if (length < 0) { // length == -errno
  114|      0|		fclose(f);
  115|      0|		return create_file_error_context(context, -length, fname);
  116|      0|	}
  117|      0|	if (fseek(f, 0, SEEK_SET) == -1) {
  118|      0|		int error = errno;
  119|      0|		fclose(f);
  120|      0|		return create_file_error_context(context, error, fname);
  121|      0|	}
  122|      0|	if ((p = (char *)realloc(soundicon_tab[index].data, length)) == NULL) {
  123|      0|		fclose(f);
  124|      0|		return ENOMEM;
  125|      0|	}
  126|      0|	if (fread(p, 1, length, f) != length) {
  127|      0|		int error = errno;
  128|      0|		fclose(f);
  129|      0|		remove(fname_temp);
  130|      0|		free(p);
  131|      0|		return create_file_error_context(context, error, fname);
  132|      0|	}
  133|      0|	fclose(f);
  134|      0|	remove(fname_temp);
  135|      0|
  136|      0|	ip = (int *)(&p[40]);
  137|      0|	soundicon_tab[index].length = (*ip) / 2; // length in samples
  138|      0|	soundicon_tab[index].data = p;
  139|      0|	return ENS_OK;
  140|      0|}
  141|       |
  142|       |int LookupSoundicon(int c)
  143|      0|{
  144|      0|	// Find the sound icon number for a punctuation character and load the audio file if it's not yet loaded
  145|      0|	int ix;
  146|      0|
  147|      0|	for (ix = 0; ix < n_soundicon_tab; ix++) {
  148|      0|		if (soundicon_tab[ix].name == c) {
  149|      0|			if (soundicon_tab[ix].length == 0) { // not yet loaded, load now
  150|      0|				if (LoadSoundFile(NULL, ix, NULL) != ENS_OK) {
  151|      0|					return -1; // sound file is not available
  152|      0|				}
  153|      0|			}
  154|      0|			return ix;
  155|      0|		}
  156|      0|	}
  157|      0|	return -1;
  158|      0|}
  159|       |
  160|       |int LoadSoundFile2(const char *fname)
  161|      0|{
  162|      0|	// Load a sound file into the sound icon table and memory
  163|      0|	// (if it's not already loaded)
  164|      0|	// returns -1 on error or the index of loaded file on success
  165|      0|
  166|      0|	int ix;
  167|      0|	for (ix = 0; ix < n_soundicon_tab; ix++) {
  168|      0|		if (((soundicon_tab[ix].filename != NULL) && strcmp(fname, soundicon_tab[ix].filename) == 0)) {
  169|      0|			// the file information is found. If length = 0 it needs to be loaded to memory
  170|      0|			if (soundicon_tab[ix].length == 0) {
  171|      0|				if (LoadSoundFile(NULL, ix, NULL) != ENS_OK)
  172|      0|					return -1; // sound file is not available
  173|      0|			}
  174|      0|			return ix; // sound file already loaded to memory
  175|      0|		}
  176|      0|	}
  177|      0|
  178|      0|	// load the file into the current slot and increase index
  179|      0|	if (LoadSoundFile(fname, n_soundicon_tab, NULL) != ENS_OK)
  180|      0|		return -1;
  181|      0|
  182|      0|	soundicon_tab[n_soundicon_tab].filename = (char *)realloc(soundicon_tab[n_soundicon_tab].filename, strlen(fname)+1);
  183|      0|	strcpy(soundicon_tab[n_soundicon_tab].filename, fname);
  184|      0|	n_soundicon_tab++;
  185|      0|	return n_soundicon_tab - 1;
  186|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/speech.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2013 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2013-2017 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <assert.h>
   23|       |#include <ctype.h>
   24|       |#include <errno.h>
   25|       |#include <locale.h>
   26|       |#include <stdbool.h>
   27|       |#include <stdint.h>
   28|       |#include <stdio.h>
   29|       |#include <stdlib.h>
   30|       |#include <string.h>
   31|       |#include <sys/stat.h>
   32|       |#include <time.h>
   33|       |#include <unistd.h>
   34|       |#include <wchar.h>
   35|       |
   36|       |#ifdef HAVE_PCAUDIOLIB_AUDIO_H
   37|       |#include <pcaudiolib/audio.h>
   38|       |#endif
   39|       |
   40|       |#if defined(_WIN32) || defined(_WIN64)
   41|       |#include <fcntl.h>
   42|       |#include <io.h>
   43|       |#include <windows.h>
   44|       |#include <winreg.h>
   45|       |#endif
   46|       |
   47|       |#include <espeak-ng/espeak_ng.h>
   48|       |#include <espeak-ng/speak_lib.h>
   49|       |#include <espeak-ng/encoding.h>
   50|       |
   51|       |#include "speech.h"
   52|       |#include "dictionary.h"           // for GetTranslatedPhonemeString, strncpy0
   53|       |#include "espeak_command.h"       // for delete_espeak_command, SetParameter
   54|       |#include "event.h"                // for event_declare, event_clear_all, eve...
   55|       |#include "fifo.h"                 // for fifo_add_command, fifo_add_commands
   56|       |#include "mbrola.h"               // for mbrola_delay
   57|       |#include "readclause.h"           // for PARAM_STACK, param_stack
   58|       |#include "synthdata.h"            // for FreePhData, LoadConfig, LoadPhData
   59|       |#include "synthesize.h"           // for SpeakNextClause, Generate, Synthesi...
   60|       |#include "translate.h"            // for p_decoder, InitText, translator
   61|       |#include "voice.h"                // for FreeVoiceList, VoiceReset, current_...
   62|       |#include "wavegen.h"              // for WavegenFill, WavegenInit, WcmdqUsed
   63|       |
   64|       |unsigned char *outbuf = NULL;
   65|       |int outbuf_size = 0;
   66|       |unsigned char *out_start;
   67|       |
   68|       |espeak_EVENT *event_list = NULL;
   69|       |int event_list_ix = 0;
   70|       |int n_event_list;
   71|       |long count_samples;
   72|       |#ifdef HAVE_PCAUDIOLIB_AUDIO_H
   73|       |struct audio_object *my_audio = NULL;
   74|       |#endif
   75|       |
   76|       |static unsigned int my_unique_identifier = 0;
   77|       |static void *my_user_data = NULL;
   78|       |static espeak_ng_OUTPUT_MODE my_mode = ENOUTPUT_MODE_SYNCHRONOUS;
   79|       |static int out_samplerate = 0;
   80|       |static int voice_samplerate = 22050;
   81|       |static int min_buffer_length = 60; // minimum buffer length in ms
   82|       |static espeak_ng_STATUS err = ENS_OK;
   83|       |
   84|       |t_espeak_callback *synth_callback = NULL;
   85|       |int (*uri_callback)(int, const char *, const char *) = NULL;
   86|       |int (*phoneme_callback)(const char *) = NULL;
   87|       |
   88|       |char path_home[N_PATH_HOME]; // this is the espeak-ng-data directory
   89|       |extern int saved_parameters[N_SPEECH_PARAM]; // Parameters saved on synthesis start
   90|       |
   91|       |void cancel_audio(void)
   92|      0|{
   93|       |#ifdef HAVE_PCAUDIOLIB_AUDIO_H
   94|       |	if ((my_mode & ENOUTPUT_MODE_SPEAK_AUDIO) == ENOUTPUT_MODE_SPEAK_AUDIO) {
   95|       |		audio_object_flush(my_audio);
   96|       |	}
   97|       |#endif
   98|       |}
   99|       |
  100|       |static int dispatch_audio(short *outbuf, int length, espeak_EVENT *event)
  101|      0|{
  102|      0|	int a_wave_can_be_played = 1;
  103|      0|#ifdef USE_ASYNC
  104|      0|	if ((my_mode & ENOUTPUT_MODE_SYNCHRONOUS) == 0)
  105|      0|		a_wave_can_be_played = fifo_is_command_enabled();
  106|      0|#endif
  107|      0|
  108|      0|	switch ((int)my_mode)
  109|      0|	{
  110|      0|	case ENOUTPUT_MODE_SPEAK_AUDIO:
  111|      0|	case ENOUTPUT_MODE_SPEAK_AUDIO | ENOUTPUT_MODE_SYNCHRONOUS:
  112|      0|	{
  113|      0|		int event_type = 0;
  114|      0|		if (event)
  115|      0|			event_type = event->type;
  116|      0|
  117|      0|		if (event_type == espeakEVENT_SAMPLERATE) {
  118|      0|			voice_samplerate = event->id.number;
  119|      0|
  120|      0|			if (out_samplerate != voice_samplerate) {
  121|       |#ifdef HAVE_PCAUDIOLIB_AUDIO_H
  122|       |				if (out_samplerate != 0) {
  123|       |					// sound was previously open with a different sample rate
  124|       |					audio_object_close(my_audio);
  125|       |					out_samplerate = 0;
  126|       |#ifdef HAVE_SLEEP
  127|       |					sleep(1);
  128|       |#endif
  129|       |				}
  130|       |#endif
  131|       |#ifdef HAVE_PCAUDIOLIB_AUDIO_H
  132|       |				int error = audio_object_open(my_audio, AUDIO_OBJECT_FORMAT_S16LE, voice_samplerate, 1);
  133|       |				if (error != 0) {
  134|       |					fprintf(stderr, "error: %s\n", audio_object_strerror(my_audio, error));
  135|       |					err = ENS_AUDIO_ERROR;
  136|       |					return -1;
  137|       |				}
  138|       |#endif
  139|       |				out_samplerate = voice_samplerate;
  140|      0|#ifdef USE_ASYNC
  141|      0|				if ((my_mode & ENOUTPUT_MODE_SYNCHRONOUS) == 0)
  142|      0|					event_init();
  143|      0|#endif
  144|      0|			}
  145|      0|		}
  146|      0|
  147|       |#ifdef HAVE_PCAUDIOLIB_AUDIO_H
  148|       |		if (out_samplerate == 0) {
  149|       |			int error = audio_object_open(my_audio, AUDIO_OBJECT_FORMAT_S16LE, voice_samplerate, 1);
  150|       |			if (error != 0) {
  151|       |				fprintf(stderr, "error: %s\n", audio_object_strerror(my_audio, error));
  152|       |				err = ENS_AUDIO_ERROR;
  153|       |				return -1;
  154|       |			}
  155|       |			out_samplerate = voice_samplerate;
  156|       |		}
  157|       |#endif
  158|       |
  159|       |#ifdef HAVE_PCAUDIOLIB_AUDIO_H
  160|       |		if (outbuf && length && a_wave_can_be_played) {
  161|       |			int error = audio_object_write(my_audio, (char *)outbuf, 2*length);
  162|       |			if (error != 0)
  163|       |				fprintf(stderr, "error: %s\n", audio_object_strerror(my_audio, error));
  164|       |		}
  165|       |#endif
  166|       |
  167|      0|#ifdef USE_ASYNC
  168|      0|		while (event && a_wave_can_be_played) {
  169|      0|			// TBD: some event are filtered here but some insight might be given
  170|      0|			// TBD: in synthesise.cpp for avoiding to create WORDs with size=0.
  171|      0|			// TBD: For example sentence "or ALT)." returns three words
  172|      0|			// "or", "ALT" and "".
  173|      0|			// TBD: the last one has its size=0.
  174|      0|			if ((event->type == espeakEVENT_WORD) && (event->length == 0))
  175|      0|				break;
  176|      0|			if ((my_mode & ENOUTPUT_MODE_SYNCHRONOUS) == 0) {
  177|      0|				err = event_declare(event);
  178|      0|				if (err != ENS_EVENT_BUFFER_FULL)
  179|      0|					break;
  180|      0|				usleep(10000);
  181|      0|				a_wave_can_be_played = fifo_is_command_enabled();
  182|      0|			} else
  183|      0|				break;
  184|      0|		}
  185|      0|#endif
  186|      0|	}
  187|      0|		break;
  188|      0|	case 0:
  189|      0|		if (synth_callback)
  190|      0|			synth_callback(outbuf, length, event);
  191|      0|		break;
  192|      0|	}
  193|      0|
  194|      0|	return a_wave_can_be_played == 0; // 1 = stop synthesis, -1 = error
  195|      0|}
  196|       |
  197|       |static int create_events(short *outbuf, int length, espeak_EVENT *event_list)
  198|      0|{
  199|      0|	int finished;
  200|      0|	int i = 0;
  201|      0|
  202|      0|	// The audio data are written to the output device.
  203|      0|	// The list of events in event_list (index: event_list_ix) is read:
  204|      0|	// Each event is declared to the "event" object which stores them internally.
  205|      0|	// The event object is responsible of calling the external callback
  206|      0|	// as soon as the relevant audio sample is played.
  207|      0|
  208|      0|	do { // for each event
  209|      0|		espeak_EVENT *event;
  210|      0|		if (event_list_ix == 0)
  211|      0|			event = NULL;
  212|      0|		else
  213|      0|			event = event_list + i;
  214|      0|		finished = dispatch_audio((short *)outbuf, length, event);
  215|      0|		length = 0; // the wave data are played once.
  216|      0|		i++;
  217|      0|	} while ((i < event_list_ix) && !finished);
  218|      0|	return finished;
  219|      0|}
  220|       |
  221|       |#ifdef USE_ASYNC
  222|       |
  223|       |int sync_espeak_terminated_msg(uint32_t unique_identifier, void *user_data)
  224|      0|{
  225|      0|	int finished = 0;
  226|      0|
  227|      0|	memset(event_list, 0, 2*sizeof(espeak_EVENT));
  228|      0|
  229|      0|	event_list[0].type = espeakEVENT_MSG_TERMINATED;
  230|      0|	event_list[0].unique_identifier = unique_identifier;
  231|      0|	event_list[0].user_data = user_data;
  232|      0|	event_list[1].type = espeakEVENT_LIST_TERMINATED;
  233|      0|	event_list[1].unique_identifier = unique_identifier;
  234|      0|	event_list[1].user_data = user_data;
  235|      0|
  236|      0|	if (my_mode == ENOUTPUT_MODE_SPEAK_AUDIO) {
  237|      0|		while (1) {
  238|      0|			err = event_declare(event_list);
  239|      0|			if (err != ENS_EVENT_BUFFER_FULL)
  240|      0|				break;
  241|      0|			usleep(10000);
  242|      0|		}
  243|      0|	} else if (synth_callback)
  244|      0|		finished = synth_callback(NULL, 0, event_list);
  245|      0|	return finished;
  246|      0|}
  247|       |
  248|       |#endif
  249|       |
  250|       |static int check_data_path(const char *path, int allow_directory)
  251|      0|{
  252|      0|	if (!path) return 0;
  253|      0|
  254|      0|	snprintf(path_home, sizeof(path_home), "%s/espeak-ng-data", path);
  255|      0|	if (GetFileLength(path_home) == -EISDIR)
  256|      0|		return 1;
  257|      0|
  258|      0|	if (!allow_directory)
  259|      0|		return 0;
  260|      0|
  261|      0|	snprintf(path_home, sizeof(path_home), "%s", path);
  262|      0|	return GetFileLength(path_home) == -EISDIR;
  263|      0|}
  264|       |
  265|       |#pragma GCC visibility push(default)
  266|       |
  267|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_InitializeOutput(espeak_ng_OUTPUT_MODE output_mode, int buffer_length, const char *device)
  268|      0|{
  269|      0|	(void)device; // unused if HAVE_PCAUDIOLIB_AUDIO_H is not defined
  270|      0|
  271|      0|	my_mode = output_mode;
  272|      0|	out_samplerate = 0;
  273|      0|
  274|       |#ifdef HAVE_PCAUDIOLIB_AUDIO_H
  275|       |	if (my_audio == NULL)
  276|       |		my_audio = create_audio_device_object(device, "eSpeak", "Text-to-Speech");
  277|       |#endif
  278|       |
  279|      0|
  280|      0|	// Don't allow buffer be smaller than safe minimum
  281|      0|	if (buffer_length < min_buffer_length)
  282|      0|		buffer_length = min_buffer_length;
  283|      0|
  284|      0|	// allocate 2 bytes per sample
  285|      0|	// Always round up to the nearest sample and the nearest byte.
  286|      0|	int millisamples = buffer_length * samplerate;
  287|      0|	outbuf_size = (millisamples + 1000 - millisamples % 1000) / 500;
  288|      0|	out_start = (unsigned char *)realloc(outbuf, outbuf_size);
  289|      0|	if (out_start == NULL)
  290|      0|		return ENOMEM;
  291|      0|	else
  292|      0|		outbuf = out_start;
  293|      0|
  294|      0|	// allocate space for event list.  Allow 200 events per second.
  295|      0|	// Add a constant to allow for very small buffer_length
  296|      0|	n_event_list = (buffer_length*200)/1000 + 20;
  297|      0|	espeak_EVENT *new_event_list = (espeak_EVENT *)realloc(event_list, sizeof(espeak_EVENT) * n_event_list);
  298|      0|	if (new_event_list == NULL)
  299|      0|		return ENOMEM;
  300|      0|	event_list = new_event_list;
  301|      0|
  302|      0|	return ENS_OK;
  303|      0|}
  304|       |
  305|       |int GetFileLength(const char *filename)
  306|      0|{
  307|      0|	struct stat statbuf;
  308|      0|
  309|      0|	if (stat(filename, &statbuf) != 0)
  310|      0|		return -errno;
  311|      0|
  312|      0|	if (S_ISDIR(statbuf.st_mode))
  313|      0|		return -EISDIR;
  314|      0|
  315|      0|	return statbuf.st_size;
  316|      0|}
  317|       |
  318|       |ESPEAK_NG_API void espeak_ng_InitializePath(const char *path)
  319|      0|{
  320|      0|	if (check_data_path(path, 1))
  321|      0|		return;
  322|      0|
  323|       |#ifdef PLATFORM_WINDOWS
  324|       |	HKEY RegKey;
  325|       |	unsigned long size;
  326|       |	unsigned long var_type;
  327|       |	unsigned char buf[sizeof(path_home)-13];
  328|       |
  329|       |	if (check_data_path(getenv("ESPEAK_DATA_PATH"), 1))
  330|       |		return;
  331|       |
  332|       |	buf[0] = 0;
  333|       |	RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\eSpeak NG", 0, KEY_READ, &RegKey);
  334|       |	if (RegKey == NULL)
  335|       |		RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\WOW6432Node\\eSpeak NG", 0, KEY_READ, &RegKey);
  336|       |	size = sizeof(buf);
  337|       |	var_type = REG_SZ;
  338|       |	RegQueryValueExA(RegKey, "Path", 0, &var_type, buf, &size);
  339|       |
  340|       |	if (check_data_path(buf, 1))
  341|       |		return;
  342|       |#elif !defined(PLATFORM_DOS)
  343|      0|	if (check_data_path(getenv("ESPEAK_DATA_PATH"), 1))
  344|      0|		return;
  345|      0|
  346|      0|	if (check_data_path(getenv("HOME"), 0))
  347|      0|		return;
  348|      0|#endif
  349|      0|
  350|      0|	strcpy(path_home, PATH_ESPEAK_DATA);
  351|      0|}
  352|       |
  353|       |const int param_defaults[N_SPEECH_PARAM] = {
  354|       |	0,   // silence (internal use)
  355|       |	espeakRATE_NORMAL, // rate wpm
  356|       |	100, // volume
  357|       |	50,  // pitch
  358|       |	50,  // range
  359|       |	0,   // punctuation
  360|       |	0,   // capital letters
  361|       |	0,   // wordgap
  362|       |	0,   // options
  363|       |	0,   // intonation
  364|       |	0,
  365|       |	0,
  366|       |	0,   // emphasis
  367|       |	0,   // line length
  368|       |	0,   // voice type
  369|       |};
  370|       |
  371|       |
  372|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_Initialize(espeak_ng_ERROR_CONTEXT *context)
  373|      0|{
  374|      0|	int param;
  375|      0|	int srate = 22050; // default sample rate 22050 Hz
  376|      0|
  377|      0|	// It seems that the wctype functions don't work until the locale has been set
  378|      0|	// to something other than the default "C".  Then, not only Latin1 but also the
  379|      0|	// other characters give the correct results with iswalpha() etc.
  380|      0|	if (setlocale(LC_CTYPE, "C.UTF-8") == NULL) {
  381|      0|		if (setlocale(LC_CTYPE, "UTF-8") == NULL) {
  382|      0|			if (setlocale(LC_CTYPE, "en_US.UTF-8") == NULL)
  383|      0|				setlocale(LC_CTYPE, "");
  384|      0|		}
  385|      0|	}
  386|      0|
  387|      0|	espeak_ng_STATUS result = LoadPhData(&srate, context);
  388|      0|	if (result != ENS_OK)
  389|      0|		return result;
  390|      0|
  391|      0|	WavegenInit(srate, 0);
  392|      0|	LoadConfig();
  393|      0|
  394|      0|	memset(&current_voice_selected, 0, sizeof(current_voice_selected));
  395|      0|	SetVoiceStack(NULL, "");
  396|      0|	SynthesizeInit();
  397|      0|	InitNamedata();
  398|      0|
  399|      0|	VoiceReset(0);
  400|      0|
  401|      0|	for (param = 0; param < N_SPEECH_PARAM; param++)
  402|      0|		param_stack[0].parameter[param] = saved_parameters[param] = param_defaults[param];
  403|      0|
  404|      0|	SetParameter(espeakRATE, espeakRATE_NORMAL, 0);
  405|      0|	SetParameter(espeakVOLUME, 100, 0);
  406|      0|	SetParameter(espeakCAPITALS, option_capitals, 0);
  407|      0|	SetParameter(espeakPUNCTUATION, option_punctuation, 0);
  408|      0|	SetParameter(espeakWORDGAP, 0, 0);
  409|      0|
  410|      0|#ifdef USE_ASYNC
  411|      0|	fifo_init();
  412|      0|#endif
  413|      0|
  414|      0|	option_phonemes = 0;
  415|      0|	option_phoneme_events = 0;
  416|      0|
  417|      0|	return ENS_OK;
  418|      0|}
  419|       |
  420|       |ESPEAK_NG_API int espeak_ng_GetSampleRate(void)
  421|      0|{
  422|      0|	return samplerate;
  423|      0|}
  424|       |
  425|       |#pragma GCC visibility pop
  426|       |
  427|       |static espeak_ng_STATUS Synthesize(unsigned int unique_identifier, const void *text, int flags)
  428|      0|{
  429|      0|	// Fill the buffer with output sound
  430|      0|	int length;
  431|      0|	int finished = 0;
  432|      0|	int count_buffers = 0;
  433|      0|
  434|      0|	if ((outbuf == NULL) || (event_list == NULL))
  435|      0|		return ENS_NOT_INITIALIZED;
  436|      0|
  437|      0|	option_ssml = flags & espeakSSML;
  438|      0|	option_phoneme_input = flags & espeakPHONEMES;
  439|      0|	option_endpause = flags & espeakENDPAUSE;
  440|      0|
  441|      0|	count_samples = 0;
  442|      0|
  443|      0|	espeak_ng_STATUS status;
  444|      0|	if (translator == NULL) {
  445|      0|		status = espeak_ng_SetVoiceByName(ESPEAKNG_DEFAULT_VOICE);
  446|      0|		if (status != ENS_OK)
  447|      0|			return status;
  448|      0|	}
  449|      0|
  450|      0|	if (p_decoder == NULL)
  451|      0|		p_decoder = create_text_decoder();
  452|      0|
  453|      0|	status = text_decoder_decode_string_multibyte(p_decoder, text, translator->encoding, flags);
  454|      0|	if (status != ENS_OK)
  455|      0|		return status;
  456|      0|
  457|      0|	SpeakNextClause(0);
  458|      0|
  459|      0|	for (;;) {
  460|      0|		out_ptr = outbuf;
  461|      0|		out_end = &outbuf[outbuf_size];
  462|      0|		event_list_ix = 0;
  463|      0|		WavegenFill();
  464|      0|
  465|      0|		length = (out_ptr - outbuf)/2;
  466|      0|		count_samples += length;
  467|      0|		event_list[event_list_ix].type = espeakEVENT_LIST_TERMINATED; // indicates end of event list
  468|      0|		event_list[event_list_ix].unique_identifier = unique_identifier;
  469|      0|		event_list[event_list_ix].user_data = my_user_data;
  470|      0|
  471|      0|		count_buffers++;
  472|      0|		if ((my_mode & ENOUTPUT_MODE_SPEAK_AUDIO) == ENOUTPUT_MODE_SPEAK_AUDIO) {
  473|      0|			finished = create_events((short *)outbuf, length, event_list);
  474|      0|			if (finished < 0)
  475|      0|				return ENS_AUDIO_ERROR;
  476|      0|		} else if (synth_callback)
  477|      0|			finished = synth_callback((short *)outbuf, length, event_list);
  478|      0|		if (finished) {
  479|      0|			SpeakNextClause(2); // stop
  480|      0|			return ENS_SPEECH_STOPPED;
  481|      0|		}
  482|      0|
  483|      0|		if (Generate(phoneme_list, &n_phoneme_list, 1) == 0) {
  484|      0|			if (WcmdqUsed() == 0) {
  485|      0|				// don't process the next clause until the previous clause has finished generating speech.
  486|      0|				// This ensures that <audio> tag (which causes end-of-clause) is at a sound buffer boundary
  487|      0|
  488|      0|				event_list[0].type = espeakEVENT_LIST_TERMINATED;
  489|      0|				event_list[0].unique_identifier = my_unique_identifier;
  490|      0|				event_list[0].user_data = my_user_data;
  491|      0|
  492|      0|				if (SpeakNextClause(1) == 0) {
  493|      0|					finished = 0;
  494|      0|					if ((my_mode & ENOUTPUT_MODE_SPEAK_AUDIO) == ENOUTPUT_MODE_SPEAK_AUDIO) {
  495|      0|						if (dispatch_audio(NULL, 0, NULL) < 0)
  496|      0|							return ENS_AUDIO_ERROR;
  497|      0|					} else if (synth_callback)
  498|      0|						finished = synth_callback(NULL, 0, event_list); // NULL buffer ptr indicates end of data
  499|      0|					if (finished) {
  500|      0|						SpeakNextClause(2); // stop
  501|      0|						return ENS_SPEECH_STOPPED;
  502|      0|					}
  503|      0|					return ENS_OK;
  504|      0|				}
  505|      0|			}
  506|      0|		}
  507|      0|	}
  508|      0|}
  509|       |
  510|       |void MarkerEvent(int type, unsigned int char_position, int value, int value2, unsigned char *out_ptr)
  511|      0|{
  512|      0|	// type: 1=word, 2=sentence, 3=named mark, 4=play audio, 5=end, 7=phoneme
  513|      0|	espeak_EVENT *ep;
  514|      0|	double time;
  515|      0|
  516|      0|	if ((event_list == NULL) || (event_list_ix >= (n_event_list-2)))
  517|      0|		return;
  518|      0|
  519|      0|	ep = &event_list[event_list_ix++];
  520|      0|	ep->type = (espeak_EVENT_TYPE)type;
  521|      0|	ep->unique_identifier = my_unique_identifier;
  522|      0|	ep->user_data = my_user_data;
  523|      0|	ep->text_position = char_position & 0xffffff;
  524|      0|	ep->length = char_position >> 24;
  525|      0|
  526|      0|	time = ((double)(count_samples + mbrola_delay + (out_ptr - out_start)/2)*1000.0)/samplerate;
  527|      0|	ep->audio_position = (int)time;
  528|      0|	ep->sample = (count_samples + mbrola_delay + (out_ptr - out_start)/2);
  529|      0|
  530|      0|	if ((type == espeakEVENT_MARK) || (type == espeakEVENT_PLAY))
  531|      0|		ep->id.name = &namedata[value];
  532|      0|	else if (type == espeakEVENT_PHONEME) {
  533|      0|		int *p;
  534|      0|		p = (int *)(ep->id.string);
  535|      0|		p[0] = value;
  536|      0|		p[1] = value2;
  537|      0|	} else
  538|      0|		ep->id.number = value;
  539|      0|}
  540|       |
  541|       |espeak_ng_STATUS sync_espeak_Synth(unsigned int unique_identifier, const void *text,
  542|       |                                   unsigned int position, espeak_POSITION_TYPE position_type,
  543|       |                                   unsigned int end_position, unsigned int flags, void *user_data)
  544|      0|{
  545|      0|	InitText(flags);
  546|      0|	my_unique_identifier = unique_identifier;
  547|      0|	my_user_data = user_data;
  548|      0|
  549|      0|	for (int i = 0; i < N_SPEECH_PARAM; i++)
  550|      0|		saved_parameters[i] = param_stack[0].parameter[i];
  551|      0|
  552|      0|	switch (position_type)
  553|      0|	{
  554|      0|	case POS_CHARACTER:
  555|      0|		skip_characters = position;
  556|      0|		break;
  557|      0|	case POS_WORD:
  558|      0|		skip_words = position;
  559|      0|		break;
  560|      0|	case POS_SENTENCE:
  561|      0|		skip_sentences = position;
  562|      0|		break;
  563|      0|
  564|      0|	}
  565|      0|	if (skip_characters || skip_words || skip_sentences)
  566|      0|		skipping_text = true;
  567|      0|
  568|      0|	end_character_position = end_position;
  569|      0|
  570|      0|	espeak_ng_STATUS aStatus = Synthesize(unique_identifier, text, flags);
  571|       |#ifdef HAVE_PCAUDIOLIB_AUDIO_H
  572|       |	if ((my_mode & ENOUTPUT_MODE_SPEAK_AUDIO) == ENOUTPUT_MODE_SPEAK_AUDIO) {
  573|       |		int error = (aStatus == ENS_SPEECH_STOPPED)
  574|       |		          ? audio_object_flush(my_audio)
  575|       |		          : audio_object_drain(my_audio);
  576|       |		if (error != 0)
  577|       |			fprintf(stderr, "error: %s\n", audio_object_strerror(my_audio, error));
  578|       |	}
  579|       |#endif
  580|       |
  581|      0|	return aStatus;
  582|      0|}
  583|       |
  584|       |espeak_ng_STATUS sync_espeak_Synth_Mark(unsigned int unique_identifier, const void *text,
  585|       |                                        const char *index_mark, unsigned int end_position,
  586|       |                                        unsigned int flags, void *user_data)
  587|      0|{
  588|      0|	InitText(flags);
  589|      0|
  590|      0|	my_unique_identifier = unique_identifier;
  591|      0|	my_user_data = user_data;
  592|      0|
  593|      0|	if (index_mark != NULL) {
  594|      0|		strncpy0(skip_marker, index_mark, sizeof(skip_marker));
  595|      0|		skipping_text = true;
  596|      0|	}
  597|      0|
  598|      0|	end_character_position = end_position;
  599|      0|
  600|      0|	return Synthesize(unique_identifier, text, flags | espeakSSML);
  601|      0|}
  602|       |
  603|       |espeak_ng_STATUS sync_espeak_Key(const char *key)
  604|      0|{
  605|      0|	// symbolic name, symbolicname_character  - is there a system resource of symbolic names per language?
  606|      0|	int letter;
  607|      0|	int ix;
  608|      0|
  609|      0|	ix = utf8_in(&letter, key);
  610|      0|	if (key[ix] == 0) // a single character
  611|      0|		return sync_espeak_Char(letter);
  612|      0|
  613|      0|	my_unique_identifier = 0;
  614|      0|	my_user_data = NULL;
  615|      0|	return Synthesize(0, key, 0); // speak key as a text string
  616|      0|}
  617|       |
  618|       |espeak_ng_STATUS sync_espeak_Char(wchar_t character)
  619|      0|{
  620|      0|	// is there a system resource of character names per language?
  621|      0|	char buf[80];
  622|      0|	my_unique_identifier = 0;
  623|      0|	my_user_data = NULL;
  624|      0|
  625|      0|	sprintf(buf, "<say-as interpret-as=\"tts:char\">&#%d;</say-as>", character);
  626|      0|	return Synthesize(0, buf, espeakSSML);
  627|      0|}
  628|       |
  629|       |void sync_espeak_SetPunctuationList(const wchar_t *punctlist)
  630|      0|{
  631|      0|	// Set the list of punctuation which are spoken for "some".
  632|      0|	my_unique_identifier = 0;
  633|      0|	my_user_data = NULL;
  634|      0|
  635|      0|	option_punctlist[0] = 0;
  636|      0|	if (punctlist != NULL) {
  637|      0|		wcsncpy(option_punctlist, punctlist, N_PUNCTLIST);
  638|      0|		option_punctlist[N_PUNCTLIST-1] = 0;
  639|      0|	}
  640|      0|}
  641|       |
  642|       |#pragma GCC visibility push(default)
  643|       |
  644|       |ESPEAK_API void espeak_SetSynthCallback(t_espeak_callback *SynthCallback)
  645|      0|{
  646|      0|	synth_callback = SynthCallback;
  647|      0|#ifdef USE_ASYNC
  648|      0|	event_set_callback(synth_callback);
  649|      0|#endif
  650|      0|}
  651|       |
  652|       |ESPEAK_API void espeak_SetUriCallback(int (*UriCallback)(int, const char *, const char *))
  653|      0|{
  654|      0|	uri_callback = UriCallback;
  655|      0|}
  656|       |
  657|       |ESPEAK_API void espeak_SetPhonemeCallback(int (*PhonemeCallback)(const char *))
  658|      0|{
  659|      0|	phoneme_callback = PhonemeCallback;
  660|      0|}
  661|       |
  662|       |ESPEAK_NG_API espeak_ng_STATUS
  663|       |espeak_ng_Synthesize(const void *text, size_t size,
  664|       |                     unsigned int position,
  665|       |                     espeak_POSITION_TYPE position_type,
  666|       |                     unsigned int end_position, unsigned int flags,
  667|       |                     unsigned int *unique_identifier, void *user_data)
  668|      0|{
  669|      0|	(void)size; // unused in non-async modes
  670|      0|
  671|      0|	static unsigned int temp_identifier;
  672|      0|
  673|      0|	if (unique_identifier == NULL)
  674|      0|		unique_identifier = &temp_identifier;
  675|      0|	*unique_identifier = 0;
  676|      0|
  677|      0|	if (my_mode & ENOUTPUT_MODE_SYNCHRONOUS)
  678|      0|		return sync_espeak_Synth(0, text, position, position_type, end_position, flags, user_data);
  679|      0|
  680|      0|#ifdef USE_ASYNC
  681|      0|	// Create the text command
  682|      0|	t_espeak_command *c1 = create_espeak_text(text, size, position, position_type, end_position, flags, user_data);
  683|      0|	if (c1) {
  684|      0|		// Retrieve the unique identifier
  685|      0|		*unique_identifier = c1->u.my_text.unique_identifier;
  686|      0|	}
  687|      0|
  688|      0|	// Create the "terminated msg" command (same uid)
  689|      0|	t_espeak_command *c2 = create_espeak_terminated_msg(*unique_identifier, user_data);
  690|      0|
  691|      0|	// Try to add these 2 commands (single transaction)
  692|      0|	if (c1 && c2) {
  693|      0|		espeak_ng_STATUS status = fifo_add_commands(c1, c2);
  694|      0|		if (status != ENS_OK) {
  695|      0|			delete_espeak_command(c1);
  696|      0|			delete_espeak_command(c2);
  697|      0|		}
  698|      0|		return status;
  699|      0|	}
  700|      0|
  701|      0|	delete_espeak_command(c1);
  702|      0|	delete_espeak_command(c2);
  703|      0|	return ENOMEM;
  704|       |#else
  705|       |	return sync_espeak_Synth(0, text, position, position_type, end_position, flags, user_data);
  706|       |#endif
  707|       |}
  708|       |
  709|       |ESPEAK_NG_API espeak_ng_STATUS
  710|       |espeak_ng_SynthesizeMark(const void *text,
  711|       |                         size_t size,
  712|       |                         const char *index_mark,
  713|       |                         unsigned int end_position,
  714|       |                         unsigned int flags,
  715|       |                         unsigned int *unique_identifier,
  716|       |                         void *user_data)
  717|      0|{
  718|      0|	(void)size; // unused in non-async modes
  719|      0|
  720|      0|	static unsigned int temp_identifier;
  721|      0|
  722|      0|	if (unique_identifier == NULL)
  723|      0|		unique_identifier = &temp_identifier;
  724|      0|	*unique_identifier = 0;
  725|      0|
  726|      0|	if (my_mode & ENOUTPUT_MODE_SYNCHRONOUS)
  727|      0|		return sync_espeak_Synth_Mark(0, text, index_mark, end_position, flags, user_data);
  728|      0|
  729|      0|#ifdef USE_ASYNC
  730|      0|	// Create the mark command
  731|      0|	t_espeak_command *c1 = create_espeak_mark(text, size, index_mark, end_position,
  732|      0|	                                          flags, user_data);
  733|      0|	if (c1) {
  734|      0|		// Retrieve the unique identifier
  735|      0|		*unique_identifier = c1->u.my_mark.unique_identifier;
  736|      0|	}
  737|      0|
  738|      0|	// Create the "terminated msg" command (same uid)
  739|      0|	t_espeak_command *c2 = create_espeak_terminated_msg(*unique_identifier, user_data);
  740|      0|
  741|      0|	// Try to add these 2 commands (single transaction)
  742|      0|	if (c1 && c2) {
  743|      0|		espeak_ng_STATUS status = fifo_add_commands(c1, c2);
  744|      0|		if (status != ENS_OK) {
  745|      0|			delete_espeak_command(c1);
  746|      0|			delete_espeak_command(c2);
  747|      0|		}
  748|      0|		return status;
  749|      0|	}
  750|      0|
  751|      0|	delete_espeak_command(c1);
  752|      0|	delete_espeak_command(c2);
  753|      0|	return ENOMEM;
  754|       |#else
  755|       |	return sync_espeak_Synth_Mark(0, text, index_mark, end_position, flags, user_data);
  756|       |#endif
  757|       |}
  758|       |
  759|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_SpeakKeyName(const char *key_name)
  760|      0|{
  761|      0|	// symbolic name, symbolicname_character  - is there a system resource of symbolicnames per language
  762|      0|
  763|      0|	if (my_mode & ENOUTPUT_MODE_SYNCHRONOUS)
  764|      0|		return sync_espeak_Key(key_name);
  765|      0|
  766|      0|#ifdef USE_ASYNC
  767|      0|	t_espeak_command *c = create_espeak_key(key_name, NULL);
  768|      0|	espeak_ng_STATUS status = fifo_add_command(c);
  769|      0|	if (status != ENS_OK)
  770|      0|		delete_espeak_command(c);
  771|      0|	return status;
  772|       |#else
  773|       |	return sync_espeak_Key(key_name);
  774|       |#endif
  775|       |}
  776|       |
  777|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_SpeakCharacter(wchar_t character)
  778|      0|{
  779|      0|	// is there a system resource of character names per language?
  780|      0|
  781|      0|#ifdef USE_ASYNC
  782|      0|	if (my_mode & ENOUTPUT_MODE_SYNCHRONOUS)
  783|      0|		return sync_espeak_Char(character);
  784|      0|
  785|      0|	t_espeak_command *c = create_espeak_char(character, NULL);
  786|      0|	espeak_ng_STATUS status = fifo_add_command(c);
  787|      0|	if (status != ENS_OK)
  788|      0|		delete_espeak_command(c);
  789|      0|	return status;
  790|       |#else
  791|       |	return sync_espeak_Char(character);
  792|       |#endif
  793|       |}
  794|       |
  795|       |ESPEAK_API int espeak_GetParameter(espeak_PARAMETER parameter, int current)
  796|      0|{
  797|      0|	// current: 0=default value, 1=current value
  798|      0|	if (current)
  799|      0|		return param_stack[0].parameter[parameter];
  800|      0|	return param_defaults[parameter];
  801|      0|}
  802|       |
  803|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_SetParameter(espeak_PARAMETER parameter, int value, int relative)
  804|      0|{
  805|      0|#ifdef USE_ASYNC
  806|      0|	if (my_mode & ENOUTPUT_MODE_SYNCHRONOUS)
  807|      0|		return SetParameter(parameter, value, relative);
  808|      0|
  809|      0|	t_espeak_command *c = create_espeak_parameter(parameter, value, relative);
  810|      0|
  811|      0|	espeak_ng_STATUS status = fifo_add_command(c);
  812|      0|	if (status != ENS_OK)
  813|      0|		delete_espeak_command(c);
  814|      0|	return status;
  815|       |#else
  816|       |	return SetParameter(parameter, value, relative);
  817|       |#endif
  818|       |}
  819|       |
  820|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_SetPunctuationList(const wchar_t *punctlist)
  821|      0|{
  822|      0|	// Set the list of punctuation which are spoken for "some".
  823|      0|
  824|      0|#ifdef USE_ASYNC
  825|      0|	if (my_mode & ENOUTPUT_MODE_SYNCHRONOUS) {
  826|      0|		sync_espeak_SetPunctuationList(punctlist);
  827|      0|		return ENS_OK;
  828|      0|	}
  829|      0|
  830|      0|	t_espeak_command *c = create_espeak_punctuation_list(punctlist);
  831|      0|	espeak_ng_STATUS status = fifo_add_command(c);
  832|      0|	if (status != ENS_OK)
  833|      0|		delete_espeak_command(c);
  834|      0|	return status;
  835|       |#else
  836|       |	sync_espeak_SetPunctuationList(punctlist);
  837|       |	return ENS_OK;
  838|       |#endif
  839|       |}
  840|       |
  841|       |ESPEAK_API void espeak_SetPhonemeTrace(int phonememode, FILE *stream)
  842|      0|{
  843|      0|	/* phonememode:  Controls the output of phoneme symbols for the text
  844|      0|	      bits 0-2:
  845|      0|	         value=0  No phoneme output (default)
  846|      0|	         value=1  Output the translated phoneme symbols for the text
  847|      0|	         value=2  as (1), but produces IPA phoneme names rather than ascii
  848|      0|	      bit 3:   output a trace of how the translation was done (showing the matching rules and list entries)
  849|      0|	      bit 4:   produce pho data for mbrola
  850|      0|	      bit 7:   use (bits 8-23) as a tie within multi-letter phonemes names
  851|      0|	      bits 8-23:  separator character, between phoneme names
  852|      0|
  853|      0|	   stream   output stream for the phoneme symbols (and trace).  If stream=NULL then it uses stdout.
  854|      0|	*/
  855|      0|
  856|      0|	option_phonemes = phonememode;
  857|      0|	f_trans = stream;
  858|      0|	if (stream == NULL)
  859|      0|		f_trans = stderr;
  860|      0|}
  861|       |
  862|       |ESPEAK_API const char *espeak_TextToPhonemes(const void **textptr, int textmode, int phonememode)
  863|      0|{
  864|      0|	/* phoneme_mode
  865|      0|	    bit 1:   0=eSpeak's ascii phoneme names, 1= International Phonetic Alphabet (as UTF-8 characters).
  866|      0|	    bit 7:   use (bits 8-23) as a tie within multi-letter phonemes names
  867|      0|	    bits 8-23:  separator character, between phoneme names
  868|      0|	 */
  869|      0|
  870|      0|	if (p_decoder == NULL)
  871|      0|		p_decoder = create_text_decoder();
  872|      0|
  873|      0|	if (text_decoder_decode_string_multibyte(p_decoder, *textptr, translator->encoding, textmode) != ENS_OK)
  874|      0|		return NULL;
  875|      0|
  876|      0|	TranslateClause(translator, NULL, NULL);
  877|      0|	*textptr = text_decoder_get_buffer(p_decoder);
  878|      0|
  879|      0|	return GetTranslatedPhonemeString(phonememode);
  880|      0|}
  881|       |
  882|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_Cancel(void)
  883|      0|{
  884|      0|#ifdef USE_ASYNC
  885|      0|	fifo_stop();
  886|      0|	event_clear_all();
  887|      0|#endif
  888|      0|
  889|       |#ifdef HAVE_PCAUDIOLIB_AUDIO_H
  890|       |	if ((my_mode & ENOUTPUT_MODE_SPEAK_AUDIO) == ENOUTPUT_MODE_SPEAK_AUDIO)
  891|       |		audio_object_flush(my_audio);
  892|       |#endif
  893|      0|	embedded_value[EMBED_T] = 0; // reset echo for pronunciation announcements
  894|      0|
  895|      0|	for (int i = 0; i < N_SPEECH_PARAM; i++)
  896|      0|		SetParameter(i, saved_parameters[i], 0);
  897|      0|
  898|      0|	return ENS_OK;
  899|      0|}
  900|       |
  901|       |ESPEAK_API int espeak_IsPlaying(void)
  902|      0|{
  903|      0|#ifdef USE_ASYNC
  904|      0|	return fifo_is_busy();
  905|       |#else
  906|       |	return 0;
  907|       |#endif
  908|       |}
  909|       |
  910|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_Synchronize(void)
  911|      0|{
  912|      0|	espeak_ng_STATUS berr = err;
  913|      0|#ifdef USE_ASYNC
  914|      0|	while (espeak_IsPlaying())
  915|      0|		usleep(20000);
  916|      0|#endif
  917|      0|	err = ENS_OK;
  918|      0|	return berr;
  919|      0|}
  920|       |
  921|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_Terminate(void)
  922|      0|{
  923|      0|#ifdef USE_ASYNC
  924|      0|	fifo_stop();
  925|      0|	fifo_terminate();
  926|      0|	event_terminate();
  927|      0|#endif
  928|      0|
  929|      0|	if ((my_mode & ENOUTPUT_MODE_SPEAK_AUDIO) == ENOUTPUT_MODE_SPEAK_AUDIO) {
  930|       |#ifdef HAVE_PCAUDIOLIB_AUDIO_H
  931|       |		audio_object_close(my_audio);
  932|       |		audio_object_destroy(my_audio);
  933|       |		my_audio = NULL;
  934|       |#endif
  935|       |		out_samplerate = 0;
  936|      0|	}
  937|      0|
  938|      0|	free(event_list);
  939|      0|	event_list = NULL;
  940|      0|
  941|      0|	free(outbuf);
  942|      0|	outbuf = NULL;
  943|      0|
  944|      0|	FreePhData();
  945|      0|	FreeVoiceList();
  946|      0|
  947|      0|	DeleteTranslator(translator);
  948|      0|	translator = NULL;
  949|      0|
  950|      0|	if (p_decoder != NULL) {
  951|      0|		destroy_text_decoder(p_decoder);
  952|      0|		p_decoder = NULL;
  953|      0|	}
  954|      0|
  955|      0|	return ENS_OK;
  956|      0|}
  957|       |
  958|       |const char *version_string = PACKAGE_VERSION;
  959|       |ESPEAK_API const char *espeak_Info(const char **ptr)
  960|      0|{
  961|      0|	if (ptr != NULL)
  962|      0|		*ptr = path_home;
  963|      0|	return version_string;
  964|      0|}
  965|       |
  966|       |#pragma GCC visibility pop

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/speech.h:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2007 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2013-2015 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#ifndef ESPEAK_NG_SPEECH_H
   21|       |#define ESPEAK_NG_SPEECH_H
   22|       |
   23|       |#include <endian.h>               // for BYTE_ORDER, BIG_ENDIAN
   24|       |#include <espeak-ng/espeak_ng.h>
   25|       |
   26|       |
   27|       |#ifdef __cplusplus
   28|       |extern "C"
   29|       |{
   30|       |#endif
   31|       |
   32|       |#if defined(BYTE_ORDER) && BYTE_ORDER == BIG_ENDIAN
   33|       |#define ARCH_BIG
   34|       |#endif
   35|       |
   36|       |#ifdef __QNX__
   37|       |#define NO_VARIADIC_MACROS
   38|       |#endif
   39|       |
   40|       |#if defined(_WIN32) || defined(_WIN64) // Windows
   41|       |
   42|       |#define PLATFORM_WINDOWS
   43|       |#define PATHSEP '\\'
   44|       |#define N_PATH_HOME  230
   45|       |#define NO_VARIADIC_MACROS
   46|       |
   47|       |#else
   48|       |
   49|       |#define PLATFORM_POSIX
   50|      0|#define PATHSEP  '/'
   51|       |#define N_PATH_HOME  160
   52|       |#define USE_NANOSLEEP
   53|       |#define __cdecl
   54|       |
   55|       |#endif
   56|       |
   57|       |// will look for espeak_data directory here, and also in user's home directory
   58|       |#ifndef PATH_ESPEAK_DATA
   59|       |   #define PATH_ESPEAK_DATA  "/usr/share/espeak-ng-data"
   60|       |#endif
   61|       |
   62|       |void cancel_audio(void);
   63|       |
   64|       |extern char path_home[N_PATH_HOME];    // this is the espeak-ng-data directory
   65|       |
   66|       |extern ESPEAK_NG_API int GetFileLength(const char *filename);
   67|       |
   68|       |#ifdef __cplusplus
   69|       |}
   70|       |#endif
   71|       |
   72|       |#endif // SPEECH_H

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/ssml.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2015 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2017 Reece H. Dunn
    5|       | * Copyright (C) 2018 Juho Hiltunen
    6|       | *
    7|       | * This program is free software; you can redistribute it and/or modify
    8|       | * it under the terms of the GNU General Public License as published by
    9|       | * the Free Software Foundation; either version 3 of the License, or
   10|       | * (at your option) any later version.
   11|       | *
   12|       | * This program is distributed in the hope that it will be useful,
   13|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   14|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   15|       | * GNU General Public License for more details.
   16|       | *
   17|       | * You should have received a copy of the GNU General Public License
   18|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   19|       | */
   20|       |
   21|       |
   22|       |#include "config.h"
   23|       |
   24|       |#include <ctype.h>
   25|       |#include <errno.h>
   26|       |#include <locale.h>
   27|       |#include <math.h>
   28|       |#include <stdint.h>
   29|       |#include <stdio.h>
   30|       |#include <stdlib.h>
   31|       |#include <string.h>
   32|       |#include <unistd.h>
   33|       |#include <wchar.h>
   34|       |#include <wctype.h>
   35|       |
   36|       |
   37|       |#include <espeak-ng/espeak_ng.h>
   38|       |#include <espeak-ng/speak_lib.h>
   39|       |#include <espeak-ng/encoding.h>
   40|       |#include <ucd/ucd.h>
   41|       |
   42|       |#include "ssml.h"
   43|       |#include "dictionary.h"           // for strncpy0
   44|       |#include "mnemonics.h"               // for LookupMnemName, MNEM_TAB, 
   45|       |#include "readclause.h"           // for PARAM_STACK, param_stack, AddNameData
   46|       |#include "soundicon.h"               // for LoadSoundFile2
   47|       |#include "synthesize.h"           // for SPEED_FACTORS, speed
   48|       |#include "translate.h"            // for CTRL_EMBEDDED, IsDigit09, utf8_out
   49|       |#include "voice.h"                // for SelectVoice, SelectVoiceByName
   50|       |
   51|       |static MNEM_TAB ssmltags[] = {
   52|       |	{ "speak",     SSML_SPEAK },
   53|       |	{ "voice",     SSML_VOICE },
   54|       |	{ "prosody",   SSML_PROSODY },
   55|       |	{ "say-as",    SSML_SAYAS },
   56|       |	{ "mark",      SSML_MARK },
   57|       |	{ "s",         SSML_SENTENCE },
   58|       |	{ "p",         SSML_PARAGRAPH },
   59|       |	{ "phoneme",   SSML_PHONEME },
   60|       |	{ "sub",       SSML_SUB },
   61|       |	{ "tts:style", SSML_STYLE },
   62|       |	{ "audio",     SSML_AUDIO },
   63|       |	{ "emphasis",  SSML_EMPHASIS },
   64|       |	{ "break",     SSML_BREAK },
   65|       |	{ "metadata",  SSML_IGNORE_TEXT },
   66|       |
   67|       |	{ "br",     HTML_BREAK },
   68|       |	{ "li",     HTML_BREAK },
   69|       |	{ "dd",     HTML_BREAK },
   70|       |	{ "img",    HTML_BREAK },
   71|       |	{ "td",     HTML_BREAK },
   72|       |	{ "h1",     SSML_PARAGRAPH },
   73|       |	{ "h2",     SSML_PARAGRAPH },
   74|       |	{ "h3",     SSML_PARAGRAPH },
   75|       |	{ "h4",     SSML_PARAGRAPH },
   76|       |	{ "hr",     SSML_PARAGRAPH },
   77|       |	{ "script", SSML_IGNORE_TEXT },
   78|       |	{ "style",  SSML_IGNORE_TEXT },
   79|       |	{ "font",   HTML_NOSPACE },
   80|       |	{ "b",      HTML_NOSPACE },
   81|       |	{ "i",      HTML_NOSPACE },
   82|       |	{ "strong", HTML_NOSPACE },
   83|       |	{ "em",     HTML_NOSPACE },
   84|       |	{ "code",   HTML_NOSPACE },
   85|       |
   86|       |	{ NULL, 0 }
   87|       |};
   88|       |
   89|       |static int attrcmp(const wchar_t *string1, const char *string2)
   90|      0|{
   91|      0|	int ix;
   92|      0|
   93|      0|	if (string1 == NULL)
   94|      0|		return 1;
   95|      0|
   96|      0|	for (ix = 0; (string1[ix] == string2[ix]) && (string1[ix] != 0); ix++)
   97|      0|		;
   98|      0|	if (((string1[ix] == '"') || (string1[ix] == '\'')) && (string2[ix] == 0))
   99|      0|		return 0;
  100|      0|	return 1;
  101|      0|}
  102|       |
  103|       |
  104|       |static int attrlookup(const wchar_t *string1, const MNEM_TAB *mtab)
  105|      0|{
  106|      0|	int ix;
  107|      0|
  108|      0|	for (ix = 0; mtab[ix].mnem != NULL; ix++) {
  109|      0|		if (attrcmp(string1, mtab[ix].mnem) == 0)
  110|      0|			return mtab[ix].value;
  111|      0|	}
  112|      0|	return mtab[ix].value;
  113|      0|}
  114|       |
  115|       |static int attrnumber(const wchar_t *pw, int default_value, int type)
  116|      0|{
  117|      0|	int value = 0;
  118|      0|
  119|      0|	if ((pw == NULL) || !IsDigit09(*pw))
  120|      0|		return default_value;
  121|      0|
  122|      0|	while (IsDigit09(*pw))
  123|      0|		value = value*10 + *pw++ - '0';
  124|      0|	if ((type == 1) && (ucd_tolower(*pw) == 's')) {
  125|      0|		// time: seconds rather than ms
  126|      0|		value *= 1000;
  127|      0|	}
  128|      0|	return value;
  129|      0|}
  130|       |
  131|       |static int attrcopy_utf8(char *buf, const wchar_t *pw, int len)
  132|      0|{
  133|      0|	// Convert attribute string into utf8, write to buf, and return its utf8 length
  134|      0|	unsigned int c;
  135|      0|	int ix = 0;
  136|      0|	int n;
  137|      0|	int prev_c = 0;
  138|      0|
  139|      0|	if (pw != NULL) {
  140|      0|		while ((ix < (len-4)) && ((c = *pw++) != 0)) {
  141|      0|			if ((c == '"') && (prev_c != '\\'))
  142|      0|				break; // " indicates end of attribute, unless preceded by backstroke
  143|      0|			n = utf8_out(c, &buf[ix]);
  144|      0|			ix += n;
  145|      0|			prev_c = c;
  146|      0|		}
  147|      0|	}
  148|      0|	buf[ix] = 0;
  149|      0|	return ix;
  150|      0|}
  151|       |
  152|       |static int attr_prosody_value(int param_type, const wchar_t *pw, int *value_out)
  153|      0|{
  154|      0|	int sign = 0;
  155|      0|	wchar_t *tail;
  156|      0|	double value;
  157|      0|
  158|      0|	while (iswspace(*pw)) pw++;
  159|      0|	if (*pw == '+') {
  160|      0|		pw++;
  161|      0|		sign = 1;
  162|      0|	}
  163|      0|	if (*pw == '-') {
  164|      0|		pw++;
  165|      0|		sign = -1;
  166|      0|	}
  167|      0|	value = (double)wcstod(pw, &tail);
  168|      0|	if (tail == pw) {
  169|      0|		// failed to find a number, return 100%
  170|      0|		*value_out = 100;
  171|      0|		return 2;
  172|      0|	}
  173|      0|
  174|      0|	if (*tail == '%') {
  175|      0|		if (sign != 0)
  176|      0|			value = 100 + (sign * value);
  177|      0|		*value_out = (int)value;
  178|      0|		return 2; // percentage
  179|      0|	}
  180|      0|
  181|      0|	if ((tail[0] == 's') && (tail[1] == 't')) {
  182|      0|		double x;
  183|      0|		// convert from semitones to a  frequency percentage
  184|      0|		x = pow((double)2.0, (double)((value*sign)/12)) * 100;
  185|      0|		*value_out = (int)x;
  186|      0|		return 2; // percentage
  187|      0|	}
  188|      0|
  189|      0|	if (param_type == espeakRATE) {
  190|      0|		if (sign == 0)
  191|      0|			*value_out = (int)(value * 100);
  192|      0|		else
  193|      0|			*value_out = 100 + (int)(sign * value * 100);
  194|      0|		return 2; // percentage
  195|      0|	}
  196|      0|
  197|      0|	*value_out = (int)value;
  198|      0|	return sign;   // -1, 0, or 1
  199|      0|}
  200|       |
  201|       |static const char *VoiceFromStack(SSML_STACK *ssml_stack, int n_ssml_stack, espeak_VOICE *base_voice, char base_voice_variant_name[40])
  202|      0|{
  203|      0|	// Use the voice properties from the SSML stack to choose a voice, and switch
  204|      0|	// to that voice if it's not the current voice
  205|      0|
  206|      0|	int ix;
  207|      0|	const char *p;
  208|      0|	SSML_STACK *sp;
  209|      0|	const char *v_id;
  210|      0|	int voice_name_specified;
  211|      0|	int voice_found;
  212|      0|	espeak_VOICE voice_select;
  213|      0|	static char voice_name[40];
  214|      0|	char language[40];
  215|      0|	char buf[80];
  216|      0|
  217|      0|	strcpy(voice_name, ssml_stack[0].voice_name);
  218|      0|	strcpy(language, ssml_stack[0].language);
  219|      0|	voice_select.age = ssml_stack[0].voice_age;
  220|      0|	voice_select.gender = ssml_stack[0].voice_gender;
  221|      0|	voice_select.variant = ssml_stack[0].voice_variant_number;
  222|      0|	voice_select.identifier = NULL;
  223|      0|
  224|      0|	for (ix = 0; ix < n_ssml_stack; ix++) {
  225|      0|		sp = &ssml_stack[ix];
  226|      0|		voice_name_specified = 0;
  227|      0|
  228|      0|		if ((sp->voice_name[0] != 0) && (SelectVoiceByName(NULL, sp->voice_name) != NULL)) {
  229|      0|			voice_name_specified = 1;
  230|      0|			strcpy(voice_name, sp->voice_name);
  231|      0|			language[0] = 0;
  232|      0|			voice_select.gender = ENGENDER_UNKNOWN;
  233|      0|			voice_select.age = 0;
  234|      0|			voice_select.variant = 0;
  235|      0|		}
  236|      0|		if (sp->language[0] != 0) {
  237|      0|			strcpy(language, sp->language);
  238|      0|
  239|      0|			// is this language provided by the base voice?
  240|      0|			p = base_voice->languages;
  241|      0|			while (*p++ != 0) {
  242|      0|				if (strcmp(p, language) == 0) {
  243|      0|					// yes, change the language to the main language of the base voice
  244|      0|					strcpy(language, &base_voice->languages[1]);
  245|      0|					break;
  246|      0|				}
  247|      0|				p += (strlen(p) + 1);
  248|      0|			}
  249|      0|
  250|      0|			if (voice_name_specified == 0)
  251|      0|				voice_name[0] = 0; // forget a previous voice name if a language is specified
  252|      0|		}
  253|      0|		if (sp->voice_gender != ENGENDER_UNKNOWN)
  254|      0|			voice_select.gender = sp->voice_gender;
  255|      0|
  256|      0|		if (sp->voice_age != 0)
  257|      0|			voice_select.age = sp->voice_age;
  258|      0|		if (sp->voice_variant_number != 0)
  259|      0|			voice_select.variant = sp->voice_variant_number;
  260|      0|	}
  261|      0|
  262|      0|	voice_select.name = voice_name;
  263|      0|	voice_select.languages = language;
  264|      0|	v_id = SelectVoice(&voice_select, &voice_found);
  265|      0|	if (v_id == NULL)
  266|      0|		return "default";
  267|      0|
  268|      0|	if ((strchr(v_id, '+') == NULL) && ((voice_select.gender == ENGENDER_UNKNOWN) || (voice_select.gender == base_voice->gender)) && (base_voice_variant_name[0] != 0)) {
  269|      0|		// a voice variant has not been selected, use the original voice variant
  270|      0|		sprintf(buf, "%s+%s", v_id, base_voice_variant_name);
  271|      0|		strncpy0(voice_name, buf, sizeof(voice_name));
  272|      0|		return voice_name;
  273|      0|	}
  274|      0|	return v_id;
  275|      0|}
  276|       |
  277|       |
  278|       |static wchar_t *GetSsmlAttribute(wchar_t *pw, const char *name)
  279|      0|{
  280|      0|	// Gets the value string for an attribute.
  281|      0|	// Returns NULL if the attribute is not present
  282|      0|
  283|      0|	int ix;
  284|      0|	static wchar_t empty[1] = { 0 };
  285|      0|
  286|      0|	while (*pw != 0) {
  287|      0|		if (iswspace(pw[-1])) {
  288|      0|			ix = 0;
  289|      0|			while (*pw == name[ix]) {
  290|      0|				pw++;
  291|      0|				ix++;
  292|      0|			}
  293|      0|			if (name[ix] == 0) {
  294|      0|				// found the attribute, now get the value
  295|      0|				while (iswspace(*pw)) pw++;
  296|      0|				if (*pw == '=') pw++;
  297|      0|				while (iswspace(*pw)) pw++;
  298|      0|				if ((*pw == '"') || (*pw == '\'')) // allow single-quotes ?
  299|      0|					return pw+1;
  300|      0|				else
  301|      0|					return empty;
  302|      0|			}
  303|      0|		}
  304|      0|		pw++;
  305|      0|	}
  306|      0|	return NULL;
  307|      0|}
  308|       |
  309|       |
  310|       |static int GetVoiceAttributes(wchar_t *pw, int tag_type, SSML_STACK *ssml_sp, SSML_STACK *ssml_stack, int n_ssml_stack, char current_voice_id[40], espeak_VOICE *base_voice, char *base_voice_variant_name)
  311|      0|{
  312|      0|	// Determines whether voice attribute are specified in this tag, and if so, whether this means
  313|      0|	// a voice change.
  314|      0|	// If it's a closing tag, delete the top frame of the stack and determine whether this implies
  315|      0|	// a voice change.
  316|      0|	// Returns  CLAUSE_TYPE_VOICE_CHANGE if there is a voice change
  317|      0|
  318|      0|	wchar_t *lang;
  319|      0|	wchar_t *gender;
  320|      0|	wchar_t *name;
  321|      0|	wchar_t *age;
  322|      0|	wchar_t *variant;
  323|      0|	int value;
  324|      0|	const char *new_voice_id;
  325|      0|
  326|      0|	static const MNEM_TAB mnem_gender[] = {
  327|      0|		{ "male", ENGENDER_MALE },
  328|      0|		{ "female", ENGENDER_FEMALE },
  329|      0|		{ "neutral", ENGENDER_NEUTRAL },
  330|      0|		{ NULL, ENGENDER_UNKNOWN }
  331|      0|	};
  332|      0|
  333|      0|	if (tag_type & SSML_CLOSE) {
  334|      0|		// delete a stack frame
  335|      0|		if (n_ssml_stack > 1)
  336|      0|			n_ssml_stack--;
  337|      0|	} else {
  338|      0|		// add a stack frame if any voice details are specified
  339|      0|		lang = GetSsmlAttribute(pw, "xml:lang");
  340|      0|
  341|      0|		if (tag_type != SSML_VOICE) {
  342|      0|			// only expect an xml:lang attribute
  343|      0|			name = NULL;
  344|      0|			variant = NULL;
  345|      0|			age = NULL;
  346|      0|			gender = NULL;
  347|      0|		} else {
  348|      0|			name = GetSsmlAttribute(pw, "name");
  349|      0|			variant = GetSsmlAttribute(pw, "variant");
  350|      0|			age = GetSsmlAttribute(pw, "age");
  351|      0|			gender = GetSsmlAttribute(pw, "gender");
  352|      0|		}
  353|      0|
  354|      0|		if ((tag_type != SSML_VOICE) && (lang == NULL))
  355|      0|			return 0; // <s> or <p> without language spec, nothing to do
  356|      0|
  357|      0|		ssml_sp = &ssml_stack[n_ssml_stack++];
  358|      0|
  359|      0|		attrcopy_utf8(ssml_sp->language, lang, sizeof(ssml_sp->language));
  360|      0|		attrcopy_utf8(ssml_sp->voice_name, name, sizeof(ssml_sp->voice_name));
  361|      0|		if ((value = attrnumber(variant, 1, 0)) > 0)
  362|      0|			value--; // variant='0' and variant='1' the same
  363|      0|		ssml_sp->voice_variant_number = value;
  364|      0|		ssml_sp->voice_age = attrnumber(age, 0, 0);
  365|      0|		ssml_sp->voice_gender = attrlookup(gender, mnem_gender);
  366|      0|		ssml_sp->tag_type = tag_type;
  367|      0|	}
  368|      0|
  369|      0|	new_voice_id = VoiceFromStack(ssml_stack, n_ssml_stack, base_voice, base_voice_variant_name);
  370|      0|	if (strcmp(new_voice_id, current_voice_id) != 0) {
  371|      0|		// add an embedded command to change the voice
  372|      0|		strcpy(current_voice_id, new_voice_id);
  373|      0|		return CLAUSE_TYPE_VOICE_CHANGE;
  374|      0|	}
  375|      0|
  376|      0|	return 0;
  377|      0|}
  378|       |
  379|       |static void ProcessParamStack(char *outbuf, int *outix, int n_param_stack, PARAM_STACK *param_stack, int *speech_parameters)
  380|      0|{
  381|      0|	// Set the speech parameters from the parameter stack
  382|      0|	int param;
  383|      0|	int ix;
  384|      0|	int value;
  385|      0|	char buf[20];
  386|      0|	int new_parameters[N_SPEECH_PARAM];
  387|      0|	static char cmd_letter[N_SPEECH_PARAM] = { 0, 'S', 'A', 'P', 'R', 0, 'C', 0, 0, 0, 0, 0, 'F' }; // embedded command letters
  388|      0|
  389|      0|	for (param = 0; param < N_SPEECH_PARAM; param++)
  390|      0|		new_parameters[param] = -1;
  391|      0|
  392|      0|	for (ix = 0; ix < n_param_stack; ix++) {
  393|      0|		for (param = 0; param < N_SPEECH_PARAM; param++) {
  394|      0|			if (param_stack[ix].parameter[param] >= 0)
  395|      0|				new_parameters[param] = param_stack[ix].parameter[param];
  396|      0|		}
  397|      0|	}
  398|      0|
  399|      0|	for (param = 0; param < N_SPEECH_PARAM; param++) {
  400|      0|		if ((value = new_parameters[param]) != speech_parameters[param]) {
  401|      0|			buf[0] = 0;
  402|      0|
  403|      0|			switch (param)
  404|      0|			{
  405|      0|			case espeakPUNCTUATION:
  406|      0|				option_punctuation = value-1;
  407|      0|				break;
  408|      0|			case espeakCAPITALS:
  409|      0|				option_capitals = value;
  410|      0|				break;
  411|      0|			case espeakRATE:
  412|      0|			case espeakVOLUME:
  413|      0|			case espeakPITCH:
  414|      0|			case espeakRANGE:
  415|      0|			case espeakEMPHASIS:
  416|      0|				sprintf(buf, "%c%d%c", CTRL_EMBEDDED, value, cmd_letter[param]);
  417|      0|				break;
  418|      0|			}
  419|      0|
  420|      0|			speech_parameters[param] = new_parameters[param];
  421|      0|			strcpy(&outbuf[*outix], buf);
  422|      0|			*outix += strlen(buf);
  423|      0|		}
  424|      0|	}
  425|      0|}
  426|       |
  427|       |static PARAM_STACK *PushParamStack(int tag_type, int *n_param_stack, PARAM_STACK *param_stack)
  428|      0|{
  429|      0|	int ix;
  430|      0|	PARAM_STACK *sp;
  431|      0|
  432|      0|	sp = &param_stack[*n_param_stack];
  433|      0|	if (*n_param_stack < (N_PARAM_STACK-1))
  434|      0|		(*n_param_stack)++;
  435|      0|
  436|      0|	sp->type = tag_type;
  437|      0|	for (ix = 0; ix < N_SPEECH_PARAM; ix++)
  438|      0|		sp->parameter[ix] = -1;
  439|      0|	return sp;
  440|      0|}
  441|       |
  442|       |static void PopParamStack(int tag_type, char *outbuf, int *outix, int *n_param_stack, PARAM_STACK *param_stack, int *speech_parameters)
  443|      0|{
  444|      0|	// unwind the stack up to and including the previous tag of this type
  445|      0|	int ix;
  446|      0|	int top = 0;
  447|      0|
  448|      0|	if (tag_type >= SSML_CLOSE)
  449|      0|		tag_type -= SSML_CLOSE;
  450|      0|
  451|      0|	for (ix = 0; ix < *n_param_stack; ix++) {
  452|      0|		if (param_stack[ix].type == tag_type)
  453|      0|			top = ix;
  454|      0|	}
  455|      0|	if (top > 0)
  456|      0|		*n_param_stack = top;
  457|      0|	ProcessParamStack(outbuf, outix, *n_param_stack, param_stack, speech_parameters);
  458|      0|}
  459|       |
  460|       |static int ReplaceKeyName(char *outbuf, int index, int *outix)
  461|      0|{
  462|      0|	// Replace some key-names by single characters, so they can be pronounced in different languages
  463|      0|	static MNEM_TAB keynames[] = {
  464|      0|		{ "space ",        0xe020 },
  465|      0|		{ "tab ",          0xe009 },
  466|      0|		{ "underscore ",   0xe05f },
  467|      0|		{ "double-quote ", '"' },
  468|      0|		{ NULL,            0 }
  469|      0|	};
  470|      0|
  471|      0|	int ix;
  472|      0|	int letter;
  473|      0|	char *p;
  474|      0|
  475|      0|	p = &outbuf[index];
  476|      0|
  477|      0|	if ((letter = LookupMnem(keynames, p)) != 0) {
  478|      0|		ix = utf8_out(letter, p);
  479|      0|		*outix = index + ix;
  480|      0|		return letter;
  481|      0|	}
  482|      0|	return 0;
  483|      0|}
  484|       |
  485|       |static void SetProsodyParameter(int param_type, wchar_t *attr1, PARAM_STACK *sp, PARAM_STACK *param_stack, int *speech_parameters)
  486|      0|{
  487|      0|	int value;
  488|      0|	int sign;
  489|      0|
  490|      0|	static const MNEM_TAB mnem_volume[] = {
  491|      0|		{ "default", 100 },
  492|      0|		{ "silent",    0 },
  493|      0|		{ "x-soft",   30 },
  494|      0|		{ "soft",     65 },
  495|      0|		{ "medium",  100 },
  496|      0|		{ "loud",    150 },
  497|      0|		{ "x-loud",  230 },
  498|      0|		{ NULL,       -1 }
  499|      0|	};
  500|      0|
  501|      0|	static const MNEM_TAB mnem_rate[] = {
  502|      0|		{ "default", 100 },
  503|      0|		{ "x-slow",   60 },
  504|      0|		{ "slow",     80 },
  505|      0|		{ "medium",  100 },
  506|      0|		{ "fast",    125 },
  507|      0|		{ "x-fast",  160 },
  508|      0|		{ NULL,       -1 }
  509|      0|	};
  510|      0|
  511|      0|	static const MNEM_TAB mnem_pitch[] = {
  512|      0|		{ "default", 100 },
  513|      0|		{ "x-low",    70 },
  514|      0|		{ "low",      85 },
  515|      0|		{ "medium",  100 },
  516|      0|		{ "high",    110 },
  517|      0|		{ "x-high",  120 },
  518|      0|		{ NULL,       -1 }
  519|      0|	};
  520|      0|
  521|      0|	static const MNEM_TAB mnem_range[] = {
  522|      0|		{ "default", 100 },
  523|      0|		{ "x-low",    20 },
  524|      0|		{ "low",      50 },
  525|      0|		{ "medium",  100 },
  526|      0|		{ "high",    140 },
  527|      0|		{ "x-high",  180 },
  528|      0|		{ NULL,       -1 }
  529|      0|	};
  530|      0|
  531|      0|	static const MNEM_TAB *mnem_tabs[5] = {
  532|      0|		NULL, mnem_rate, mnem_volume, mnem_pitch, mnem_range
  533|      0|	};
  534|      0|
  535|      0|	if ((value = attrlookup(attr1, mnem_tabs[param_type])) >= 0) {
  536|      0|		// mnemonic specifies a value as a percentage of the base pitch/range/rate/volume
  537|      0|		sp->parameter[param_type] = (param_stack[0].parameter[param_type] * value)/100;
  538|      0|	} else {
  539|      0|		sign = attr_prosody_value(param_type, attr1, &value);
  540|      0|
  541|      0|		if (sign == 0)
  542|      0|			sp->parameter[param_type] = value; // absolute value in Hz
  543|      0|		else if (sign == 2) {
  544|      0|			// change specified as percentage or in semitones
  545|      0|			sp->parameter[param_type] = (speech_parameters[param_type] * value)/100;
  546|      0|		} else {
  547|      0|			// change specified as plus or minus Hz
  548|      0|			sp->parameter[param_type] = speech_parameters[param_type] + (value*sign);
  549|      0|		}
  550|      0|	}
  551|      0|}
  552|       |
  553|       |int ProcessSsmlTag(wchar_t *xml_buf, char *outbuf, int *outix, int n_outbuf, const char *xmlbase, bool *audio_text, char *current_voice_id, espeak_VOICE *base_voice, char *base_voice_variant_name, bool *ignore_text, bool *clear_skipping_text, int *sayas_mode, int *sayas_start, SSML_STACK *ssml_stack, int *n_ssml_stack, int *n_param_stack, int *speech_parameters)
  554|      0|{
  555|      0|	// xml_buf is the tag and attributes with a zero terminator in place of the original '>'
  556|      0|	// returns a clause terminator value.
  557|      0|
  558|      0|	unsigned int ix;
  559|      0|	int index;
  560|      0|	int c;
  561|      0|	int tag_type;
  562|      0|	int value;
  563|      0|	int value2;
  564|      0|	int value3;
  565|      0|	int voice_change_flag;
  566|      0|	wchar_t *px;
  567|      0|	wchar_t *attr1;
  568|      0|	wchar_t *attr2;
  569|      0|	wchar_t *attr3;
  570|      0|	int terminator;
  571|      0|	char *uri;
  572|      0|	int param_type;
  573|      0|	char tag_name[40];
  574|      0|	char buf[80];
  575|      0|	PARAM_STACK *sp;
  576|      0|	SSML_STACK *ssml_sp;
  577|      0|
  578|      0|	// don't process comments and xml declarations
  579|      0|	if (wcsncmp(xml_buf, (wchar_t *) "!--", 3) == 0 || wcsncmp(xml_buf, (wchar_t *) "?xml", 4) == 0) {
  580|      0|		return 0;
  581|      0|		}
  582|      0|
  583|      0|	// these tags have no effect if they are self-closing, eg. <voice />
  584|      0|	static char ignore_if_self_closing[] = { 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0 };
  585|      0|
  586|      0|	bool self_closing = false;
  587|      0|	int len;
  588|      0|	len = wcslen(xml_buf);
  589|      0|	if (xml_buf[len - 1] == '/') {
  590|      0|		// a self-closing tag
  591|      0|		xml_buf[len - 1] = ' ';
  592|      0|		self_closing = true;
  593|      0|	}
  594|      0|
  595|      0|	static const MNEM_TAB mnem_phoneme_alphabet[] = {
  596|      0|		{ "espeak", 1 },
  597|      0|		{ NULL,    -1 }
  598|      0|	};
  599|      0|
  600|      0|	static const MNEM_TAB mnem_punct[] = {
  601|      0|		{ "none", 1 },
  602|      0|		{ "all",  2 },
  603|      0|		{ "some", 3 },
  604|      0|		{ NULL,  -1 }
  605|      0|	};
  606|      0|
  607|      0|	static const MNEM_TAB mnem_capitals[] = {
  608|      0|		{ "no",        0 },
  609|      0|		{ "icon",      1 },
  610|      0|		{ "spelling",  2 },
  611|      0|		{ "pitch",    20 },  // this is the amount by which to raise the pitch
  612|      0|		{ NULL,       -1 }
  613|      0|	};
  614|      0|
  615|      0|	static const MNEM_TAB mnem_interpret_as[] = {
  616|      0|		{ "characters", SAYAS_CHARS },
  617|      0|		{ "tts:char",   SAYAS_SINGLE_CHARS },
  618|      0|		{ "tts:key",    SAYAS_KEY },
  619|      0|		{ "tts:digits", SAYAS_DIGITS },
  620|      0|		{ "telephone",  SAYAS_DIGITS1 },
  621|      0|		{ NULL,         -1 }
  622|      0|	};
  623|      0|
  624|      0|	static const MNEM_TAB mnem_sayas_format[] = {
  625|      0|		{ "glyphs", 1 },
  626|      0|		{ NULL,    -1 }
  627|      0|	};
  628|      0|
  629|      0|	static const MNEM_TAB mnem_break[] = {
  630|      0|		{ "none",     0 },
  631|      0|		{ "x-weak",   1 },
  632|      0|		{ "weak",     2 },
  633|      0|		{ "medium",   3 },
  634|      0|		{ "strong",   4 },
  635|      0|		{ "x-strong", 5 },
  636|      0|		{ NULL,      -1 }
  637|      0|	};
  638|      0|
  639|      0|	static const MNEM_TAB mnem_emphasis[] = {
  640|      0|		{ "none",     1 },
  641|      0|		{ "reduced",  2 },
  642|      0|		{ "moderate", 3 },
  643|      0|		{ "strong",   4 },
  644|      0|		{ "x-strong", 5 },
  645|      0|		{ NULL,      -1 }
  646|      0|	};
  647|      0|
  648|      0|	static const char *prosody_attr[5] = {
  649|      0|		NULL, "rate", "volume", "pitch", "range"
  650|      0|	};
  651|      0|
  652|      0|	for (ix = 0; ix < (sizeof(tag_name)-1); ix++) {
  653|      0|		if (((c = xml_buf[ix]) == 0) || iswspace(c))
  654|      0|			break;
  655|      0|		tag_name[ix] = tolower((char)c);
  656|      0|	}
  657|      0|	tag_name[ix] = 0;
  658|      0|
  659|      0|	px = &xml_buf[ix]; // the tag's attributes
  660|      0|
  661|      0|	if (tag_name[0] == '/') {
  662|      0|		// closing tag
  663|      0|		if ((tag_type = LookupMnem(ssmltags, &tag_name[1])) != HTML_NOSPACE)
  664|      0|			outbuf[(*outix)++] = ' ';
  665|      0|		tag_type += SSML_CLOSE;
  666|      0|	} else {
  667|      0|		if ((tag_type = LookupMnem(ssmltags, tag_name)) != HTML_NOSPACE) {
  668|      0|			// separate SSML tags from the previous word (but not HMTL tags such as <b> <font> which can occur inside a word)
  669|      0|			outbuf[(*outix)++] = ' ';
  670|      0|		}
  671|      0|
  672|      0|		if (self_closing && ignore_if_self_closing[tag_type])
  673|      0|			return 0;
  674|      0|	}
  675|      0|
  676|      0|	voice_change_flag = 0;
  677|      0|	ssml_sp = &ssml_stack[*n_ssml_stack-1];
  678|      0|
  679|      0|	switch (tag_type)
  680|      0|	{
  681|      0|	case SSML_STYLE:
  682|      0|		sp = PushParamStack(tag_type, n_param_stack, (PARAM_STACK *) param_stack);
  683|      0|		attr1 = GetSsmlAttribute(px, "field");
  684|      0|		attr2 = GetSsmlAttribute(px, "mode");
  685|      0|
  686|      0|
  687|      0|		if (attrcmp(attr1, "punctuation") == 0) {
  688|      0|			value = attrlookup(attr2, mnem_punct);
  689|      0|			sp->parameter[espeakPUNCTUATION] = value;
  690|      0|		} else if (attrcmp(attr1, "capital_letters") == 0) {
  691|      0|			value = attrlookup(attr2, mnem_capitals);
  692|      0|			sp->parameter[espeakCAPITALS] = value;
  693|      0|		}
  694|      0|		ProcessParamStack(outbuf, outix, *n_param_stack, param_stack, speech_parameters);
  695|      0|		break;
  696|      0|	case SSML_PROSODY:
  697|      0|		sp = PushParamStack(tag_type, n_param_stack, (PARAM_STACK *) param_stack);
  698|      0|
  699|      0|		// look for attributes:  rate, volume, pitch, range
  700|      0|		for (param_type = espeakRATE; param_type <= espeakRANGE; param_type++) {
  701|      0|			if ((attr1 = GetSsmlAttribute(px, prosody_attr[param_type])) != NULL)
  702|      0|				SetProsodyParameter(param_type, attr1, sp, param_stack, speech_parameters);
  703|      0|		}
  704|      0|
  705|      0|		ProcessParamStack(outbuf, outix, *n_param_stack, param_stack, speech_parameters);
  706|      0|		break;
  707|      0|	case SSML_EMPHASIS:
  708|      0|		sp = PushParamStack(tag_type, n_param_stack, (PARAM_STACK *) param_stack);
  709|      0|		value = 3; // default is "moderate"
  710|      0|		if ((attr1 = GetSsmlAttribute(px, "level")) != NULL)
  711|      0|			value = attrlookup(attr1, mnem_emphasis);
  712|      0|
  713|      0|		if (translator->langopts.tone_language == 1) {
  714|      0|			static unsigned char emphasis_to_pitch_range[] = { 50, 50, 40, 70, 90, 100 };
  715|      0|			static unsigned char emphasis_to_volume[] = { 100, 100, 70, 110, 135, 150 };
  716|      0|			// tone language (eg.Chinese) do emphasis by increasing the pitch range.
  717|      0|			sp->parameter[espeakRANGE] = emphasis_to_pitch_range[value];
  718|      0|			sp->parameter[espeakVOLUME] = emphasis_to_volume[value];
  719|      0|		} else {
  720|      0|			static unsigned char emphasis_to_volume2[] = { 100, 100, 75, 100, 120, 150 };
  721|      0|			sp->parameter[espeakVOLUME] = emphasis_to_volume2[value];
  722|      0|			sp->parameter[espeakEMPHASIS] = value;
  723|      0|		}
  724|      0|		ProcessParamStack(outbuf, outix, *n_param_stack, param_stack, speech_parameters);
  725|      0|		break;
  726|      0|	case SSML_STYLE + SSML_CLOSE:
  727|      0|	case SSML_PROSODY + SSML_CLOSE:
  728|      0|	case SSML_EMPHASIS + SSML_CLOSE:
  729|      0|		PopParamStack(tag_type, outbuf, outix, n_param_stack, (PARAM_STACK *) param_stack, (int *) speech_parameters);
  730|      0|		break;
  731|      0|	case SSML_PHONEME:
  732|      0|		attr1 = GetSsmlAttribute(px, "alphabet");
  733|      0|		attr2 = GetSsmlAttribute(px, "ph");
  734|      0|		value = attrlookup(attr1, mnem_phoneme_alphabet);
  735|      0|		if (value == 1) { // alphabet="espeak"
  736|      0|			outbuf[(*outix)++] = '[';
  737|      0|			outbuf[(*outix)++] = '[';
  738|      0|			*outix += attrcopy_utf8(&outbuf[*outix], attr2, n_outbuf-*outix);
  739|      0|			outbuf[(*outix)++] = ']';
  740|      0|			outbuf[(*outix)++] = ']';
  741|      0|		}
  742|      0|		break;
  743|      0|	case SSML_SAYAS:
  744|      0|		attr1 = GetSsmlAttribute(px, "interpret-as");
  745|      0|		attr2 = GetSsmlAttribute(px, "format");
  746|      0|		attr3 = GetSsmlAttribute(px, "detail");
  747|      0|		value = attrlookup(attr1, mnem_interpret_as);
  748|      0|		value2 = attrlookup(attr2, mnem_sayas_format);
  749|      0|		if (value2 == 1)
  750|      0|			value = SAYAS_GLYPHS;
  751|      0|
  752|      0|		value3 = attrnumber(attr3, 0, 0);
  753|      0|
  754|      0|		if (value == SAYAS_DIGITS) {
  755|      0|			if (value3 <= 1)
  756|      0|				value = SAYAS_DIGITS1;
  757|      0|			else
  758|      0|				value = SAYAS_DIGITS + value3;
  759|      0|		}
  760|      0|
  761|      0|		sprintf(buf, "%c%dY", CTRL_EMBEDDED, value);
  762|      0|		strcpy(&outbuf[*outix], buf);
  763|      0|		*outix += strlen(buf);
  764|      0|
  765|      0|		*sayas_start = *outix;
  766|      0|		*sayas_mode = value; // punctuation doesn't end clause during SAY-AS
  767|      0|		break;
  768|      0|	case SSML_SAYAS + SSML_CLOSE:
  769|      0|		if (*sayas_mode == SAYAS_KEY) {
  770|      0|			outbuf[*outix] = 0;
  771|      0|			ReplaceKeyName(outbuf, *sayas_start, outix);
  772|      0|		}
  773|      0|
  774|      0|		outbuf[(*outix)++] = CTRL_EMBEDDED;
  775|      0|		outbuf[(*outix)++] = 'Y';
  776|      0|		*sayas_mode = 0;
  777|      0|		break;
  778|      0|	case SSML_SUB:
  779|      0|		if ((attr1 = GetSsmlAttribute(px, "alias")) != NULL) {
  780|      0|			// use the alias  rather than the text
  781|      0|			*ignore_text = true;
  782|      0|			*outix += attrcopy_utf8(&outbuf[*outix], attr1, n_outbuf-*outix);
  783|      0|		}
  784|      0|		break;
  785|      0|	case SSML_IGNORE_TEXT:
  786|      0|		*ignore_text = true;
  787|      0|		break;
  788|      0|	case SSML_SUB + SSML_CLOSE:
  789|      0|	case SSML_IGNORE_TEXT + SSML_CLOSE:
  790|      0|		*ignore_text = false;
  791|      0|		break;
  792|      0|	case SSML_MARK:
  793|      0|		if ((attr1 = GetSsmlAttribute(px, "name")) != NULL) {
  794|      0|			// add name to circular buffer of marker names
  795|      0|			attrcopy_utf8(buf, attr1, sizeof(buf));
  796|      0|
  797|      0|			if (strcmp(skip_marker, buf) == 0) {
  798|      0|				// This is the marker we are waiting for before starting to speak
  799|      0|				*clear_skipping_text = true;
  800|      0|				skip_marker[0] = 0;
  801|      0|				return CLAUSE_NONE;
  802|      0|			}
  803|      0|
  804|      0|			if ((index = AddNameData(buf, 0)) >= 0) {
  805|      0|				sprintf(buf, "%c%dM", CTRL_EMBEDDED, index);
  806|      0|				strcpy(&outbuf[*outix], buf);
  807|      0|				*outix += strlen(buf);
  808|      0|			}
  809|      0|		}
  810|      0|		break;
  811|      0|	case SSML_AUDIO:
  812|      0|		sp = PushParamStack(tag_type, n_param_stack, (PARAM_STACK *)param_stack);
  813|      0|
  814|      0|		if ((attr1 = GetSsmlAttribute(px, "src")) != NULL) {
  815|      0|			char fname[256];
  816|      0|			attrcopy_utf8(buf, attr1, sizeof(buf));
  817|      0|
  818|      0|			if (uri_callback == NULL) {
  819|      0|				if ((xmlbase != NULL) && (buf[0] != '/')) {
  820|      0|					sprintf(fname, "%s/%s", xmlbase, buf);
  821|      0|					index = LoadSoundFile2(fname);
  822|      0|				} else
  823|      0|					index = LoadSoundFile2(buf);
  824|      0|				if (index >= 0) {
  825|      0|					sprintf(buf, "%c%dI", CTRL_EMBEDDED, index);
  826|      0|					strcpy(&outbuf[*outix], buf);
  827|      0|					*outix += strlen(buf);
  828|      0|					sp->parameter[espeakSILENCE] = 1;
  829|      0|				}
  830|      0|			} else {
  831|      0|				if ((index = AddNameData(buf, 0)) >= 0) {
  832|      0|					uri = &namedata[index];
  833|      0|					if (uri_callback(1, uri, xmlbase) == 0) {
  834|      0|						sprintf(buf, "%c%dU", CTRL_EMBEDDED, index);
  835|      0|						strcpy(&outbuf[*outix], buf);
  836|      0|						*outix += strlen(buf);
  837|      0|						sp->parameter[espeakSILENCE] = 1;
  838|      0|					}
  839|      0|				}
  840|      0|			}
  841|      0|		}
  842|      0|		ProcessParamStack(outbuf, outix, *n_param_stack, param_stack, speech_parameters);
  843|      0|
  844|      0|		if (self_closing)
  845|      0|			PopParamStack(tag_type, outbuf, outix, n_param_stack, (PARAM_STACK *) param_stack, (int *) speech_parameters);
  846|      0|		else
  847|      0|			*audio_text = true;
  848|      0|		return CLAUSE_NONE;
  849|      0|	case SSML_AUDIO + SSML_CLOSE:
  850|      0|		PopParamStack(tag_type, outbuf, outix, n_param_stack, (PARAM_STACK *) param_stack, (int *) speech_parameters);
  851|      0|		*audio_text = false;
  852|      0|		return CLAUSE_NONE;
  853|      0|	case SSML_BREAK:
  854|      0|		value = 21;
  855|      0|		terminator = CLAUSE_NONE;
  856|      0|
  857|      0|		if ((attr1 = GetSsmlAttribute(px, "strength")) != NULL) {
  858|      0|			static int break_value[6] = { 0, 7, 14, 21, 40, 80 }; // *10mS
  859|      0|			value = attrlookup(attr1, mnem_break);
  860|      0|			if (value < 3) {
  861|      0|				// adjust prepause on the following word
  862|      0|				sprintf(&outbuf[*outix], "%c%dB", CTRL_EMBEDDED, value);
  863|      0|				*outix += 3;
  864|      0|				terminator = 0;
  865|      0|			}
  866|      0|			value = break_value[value];
  867|      0|		}
  868|      0|		if ((attr2 = GetSsmlAttribute(px, "time")) != NULL) {
  869|      0|			value2 = attrnumber(attr2, 0, 1);   // pause in mS
  870|      0|
  871|      0|			// compensate for speaking speed to keep constant pause length, see function PauseLength()
  872|      0|			// 'value' here is x 10mS
  873|      0|			value = (value2 * 256) / (speed.clause_pause_factor * 10);
  874|      0|			if (value < 200)
  875|      0|				value = (value2 * 256) / (speed.pause_factor * 10);
  876|      0|
  877|      0|			if (terminator == 0)
  878|      0|				terminator = CLAUSE_NONE;
  879|      0|		}
  880|      0|		if (terminator) {
  881|      0|			if (value > 0xfff) {
  882|      0|				// scale down the value and set a scaling indicator bit
  883|      0|				value = value / 32;
  884|      0|				if (value > 0xfff)
  885|      0|					value = 0xfff;
  886|      0|				terminator |= CLAUSE_PAUSE_LONG;
  887|      0|			}
  888|      0|			return terminator + value;
  889|      0|		}
  890|      0|		break;
  891|      0|	case SSML_SPEAK:
  892|      0|		if ((attr1 = GetSsmlAttribute(px, "xml:base")) != NULL) {
  893|      0|			attrcopy_utf8(buf, attr1, sizeof(buf));
  894|      0|			if ((index = AddNameData(buf, 0)) >= 0)
  895|      0|				xmlbase = &namedata[index];
  896|      0|		}
  897|      0|		if (GetVoiceAttributes(px, tag_type, ssml_sp, ssml_stack, *n_ssml_stack, current_voice_id, base_voice, base_voice_variant_name) == 0)
  898|      0|			return 0; // no voice change
  899|      0|		return CLAUSE_VOICE;
  900|      0|	case SSML_VOICE:
  901|      0|		if (GetVoiceAttributes(px, tag_type, ssml_sp, ssml_stack, *n_ssml_stack, current_voice_id, base_voice, base_voice_variant_name) == 0)
  902|      0|			return 0; // no voice change
  903|      0|		return CLAUSE_VOICE;
  904|      0|	case SSML_SPEAK + SSML_CLOSE:
  905|      0|		// unwind stack until the previous <voice> or <speak> tag
  906|      0|		while ((*n_ssml_stack > 1) && (ssml_stack[*n_ssml_stack-1].tag_type != SSML_SPEAK))
  907|      0|			(*n_ssml_stack)--;
  908|      0|		return CLAUSE_PERIOD + GetVoiceAttributes(px, tag_type, ssml_sp, ssml_stack, *n_ssml_stack, current_voice_id, base_voice, base_voice_variant_name);
  909|      0|	case SSML_VOICE + SSML_CLOSE:
  910|      0|		// unwind stack until the previous <voice> or <speak> tag
  911|      0|		while ((*n_ssml_stack > 1) && (ssml_stack[*n_ssml_stack-1].tag_type != SSML_VOICE))
  912|      0|			(*n_ssml_stack)--;
  913|      0|
  914|      0|		terminator = 0; // ??  Sentence intonation, but no pause ??
  915|      0|		return terminator + GetVoiceAttributes(px, tag_type, ssml_sp, ssml_stack, *n_ssml_stack, current_voice_id, base_voice, base_voice_variant_name);
  916|      0|	case HTML_BREAK:
  917|      0|	case HTML_BREAK + SSML_CLOSE:
  918|      0|		return CLAUSE_COLON;
  919|      0|	case SSML_SENTENCE:
  920|      0|		if (ssml_sp->tag_type == SSML_SENTENCE) {
  921|      0|			// new sentence implies end-of-sentence
  922|      0|			voice_change_flag = GetVoiceAttributes(px, SSML_SENTENCE+SSML_CLOSE, ssml_sp, ssml_stack, *n_ssml_stack, current_voice_id, base_voice, base_voice_variant_name);
  923|      0|		}
  924|      0|		voice_change_flag |= GetVoiceAttributes(px, tag_type, ssml_sp, ssml_stack, *n_ssml_stack, current_voice_id, base_voice, base_voice_variant_name);
  925|      0|		return CLAUSE_PARAGRAPH + voice_change_flag;
  926|      0|	case SSML_PARAGRAPH:
  927|      0|		if (ssml_sp->tag_type == SSML_SENTENCE) {
  928|      0|			// new paragraph implies end-of-sentence or end-of-paragraph
  929|      0|			voice_change_flag = GetVoiceAttributes(px, SSML_SENTENCE+SSML_CLOSE, ssml_sp, ssml_stack, *n_ssml_stack, current_voice_id, base_voice, base_voice_variant_name);
  930|      0|		}
  931|      0|		if (ssml_sp->tag_type == SSML_PARAGRAPH) {
  932|      0|			// new paragraph implies end-of-sentence or end-of-paragraph
  933|      0|			voice_change_flag |= GetVoiceAttributes(px, SSML_PARAGRAPH+SSML_CLOSE, ssml_sp, ssml_stack, *n_ssml_stack, current_voice_id, base_voice, base_voice_variant_name);
  934|      0|		}
  935|      0|		voice_change_flag |= GetVoiceAttributes(px, tag_type, ssml_sp, ssml_stack, *n_ssml_stack, current_voice_id, base_voice, base_voice_variant_name);
  936|      0|		return CLAUSE_PARAGRAPH + voice_change_flag;
  937|      0|	case SSML_SENTENCE + SSML_CLOSE:
  938|      0|		if (ssml_sp->tag_type == SSML_SENTENCE) {
  939|      0|			// end of a sentence which specified a language
  940|      0|			voice_change_flag = GetVoiceAttributes(px, tag_type, ssml_sp, ssml_stack, *n_ssml_stack, current_voice_id, base_voice, base_voice_variant_name);
  941|      0|		}
  942|      0|		return CLAUSE_PERIOD + voice_change_flag;
  943|      0|	case SSML_PARAGRAPH + SSML_CLOSE:
  944|      0|		if ((ssml_sp->tag_type == SSML_SENTENCE) || (ssml_sp->tag_type == SSML_PARAGRAPH)) {
  945|      0|			// End of a paragraph which specified a language.
  946|      0|			// (End-of-paragraph also implies end-of-sentence)
  947|      0|			return GetVoiceAttributes(px, tag_type, ssml_sp, ssml_stack, *n_ssml_stack, current_voice_id, base_voice, base_voice_variant_name) + CLAUSE_PARAGRAPH;
  948|      0|		}
  949|      0|		return CLAUSE_PARAGRAPH;
  950|      0|	}
  951|      0|	return 0;
  952|      0|}
  953|       |
  954|       |static MNEM_TAB xml_entity_mnemonics[] = {
  955|       |	{ "gt",   '>' },
  956|       |	{ "lt",   0xe000 + '<' },   // private usage area, to avoid confusion with XML tag
  957|       |	{ "amp",  '&' },
  958|       |	{ "quot", '"' },
  959|       |	{ "nbsp", ' ' },
  960|       |	{ "apos", '\'' },
  961|       |	{ NULL,   -1 }
  962|       |};
  963|       |
  964|      0|int ParseSsmlReference(char *ref, int *c1, int *c2) {
  965|      0|	// Check if buffer *ref contains an XML character or entity reference
  966|      0|	// if found, set *c1 to the replacement char
  967|      0|	// change *c2 for entity references
  968|      0|	// returns >= 0 on success
  969|      0|
  970|      0|	if (ref[0] == '#') {
  971|      0|		// character reference
  972|      0|		if (ref[1] == 'x')
  973|      0|			return sscanf(&ref[2], "%x", c1);
  974|      0|		else
  975|      0|			return sscanf(&ref[1], "%d", c1);
  976|      0|	} else { 
  977|      0|		// entity reference
  978|      0|		int found;
  979|      0|		if ((found = LookupMnem(xml_entity_mnemonics, ref)) != -1) {
  980|      0|			*c1 = found;
  981|      0|			if (*c2 == 0)
  982|      0|				*c2 = ' ';
  983|      0|			return found;
  984|      0|		}
  985|      0|	}
  986|      0|	return -1;
  987|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/ssml.h:
    1|       |/* SSML (Speech Synthesis Markup Language) processing APIs.
    2|       | *
    3|       | * Copyright (C) 2005 to 2015 by Jonathan Duddington
    4|       | * email: jonsd@users.sourceforge.net
    5|       | * Copyright (C) 2015-2018 Reece H. Dunn
    6|       | * Copyright (C) 2018 Juho Hiltunen
    7|       | *
    8|       | * This program is free software; you can redistribute it and/or modify
    9|       | * it under the terms of the GNU General Public License as published by
   10|       | * the Free Software Foundation; either version 3 of the License, or
   11|       | * (at your option) any later version.
   12|       | *
   13|       | * This program is distributed in the hope that it will be useful,
   14|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   15|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   16|       | * GNU General Public License for more details.
   17|       | *
   18|       | * You should have received a copy of the GNU General Public License
   19|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   20|       | */
   21|       |#ifndef ESPEAK_NG_SSML_API
   22|       |#define ESPEAK_NG_SSML_API
   23|       |
   24|       |#include <stdbool.h>
   25|       |#include <wchar.h>
   26|       |
   27|       |#include <espeak-ng/speak_lib.h>
   28|       |
   29|       |#ifdef __cplusplus
   30|       |extern "C"
   31|       |{
   32|       |#endif
   33|       |
   34|       |// stack for language and voice properties
   35|       |// frame 0 is for the defaults, before any ssml tags.
   36|       |typedef struct {
   37|       |        int tag_type;
   38|       |        int voice_variant_number;
   39|       |        int voice_gender;
   40|       |        int voice_age;
   41|       |        char voice_name[40];
   42|       |        char language[20];
   43|       |} SSML_STACK;
   44|       |
   45|      0|#define N_PARAM_STACK  20
   46|       |
   47|      0|#define SSML_SPEAK        1
   48|      0|#define SSML_VOICE        2
   49|      0|#define SSML_PROSODY      3
   50|      0|#define SSML_SAYAS        4
   51|      0|#define SSML_MARK         5
   52|      0|#define SSML_SENTENCE     6
   53|      0|#define SSML_PARAGRAPH    7
   54|      0|#define SSML_PHONEME      8
   55|      0|#define SSML_SUB          9
   56|      0|#define SSML_STYLE       10
   57|      0|#define SSML_AUDIO       11
   58|      0|#define SSML_EMPHASIS    12
   59|      0|#define SSML_BREAK       13
   60|      0|#define SSML_IGNORE_TEXT 14
   61|      0|#define HTML_BREAK       15
   62|      0|#define HTML_NOSPACE     16   // don't insert a space for this element, so it doesn't break a word
   63|      0|#define SSML_CLOSE       0x20 // for a closing tag, OR this with the tag type
   64|       |
   65|       |int ProcessSsmlTag(wchar_t *xml_buf,
   66|       |                   char *outbuf,
   67|       |                   int *outix,
   68|       |                   int n_outbuf,
   69|       |                   const char *xmlbase,
   70|       |                   bool *audio_text,
   71|       |                   char *current_voice_id,
   72|       |                   espeak_VOICE *base_voice,
   73|       |                   char *base_voice_variant_name,
   74|       |                   bool *ignore_text,
   75|       |                   bool *clear_skipping_text,
   76|       |                   int *sayas_mode,
   77|       |                   int *sayas_start,
   78|       |                   SSML_STACK *ssml_stack,
   79|       |                   int *n_ssml_stack,
   80|       |                   int *n_param_stack,
   81|       |                   int *speech_parameters);
   82|       |
   83|       |int ParseSsmlReference(char *ref,
   84|       |                       int *c1,
   85|       |                       int *c2);
   86|       |
   87|       |#ifdef __cplusplus
   88|       |}
   89|       |#endif
   90|       |
   91|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/synth_mbrola.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2013 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2016 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <ctype.h>
   23|       |#include <errno.h>
   24|       |#include <math.h>
   25|       |#include <stdbool.h>
   26|       |#include <stdint.h>
   27|       |#include <stdio.h>
   28|       |#include <stdlib.h>
   29|       |#include <string.h>
   30|       |
   31|       |#include <espeak-ng/espeak_ng.h>
   32|       |#include <espeak-ng/speak_lib.h>
   33|       |#include <espeak-ng/encoding.h>
   34|       |
   35|       |#include "dictionary.h"
   36|       |#include "mbrola.h"
   37|       |#include "readclause.h"
   38|       |#include "setlengths.h"
   39|       |#include "synthdata.h"
   40|       |#include "wavegen.h"
   41|       |
   42|       |
   43|       |#include "speech.h"
   44|       |#include "phoneme.h"
   45|       |#include "voice.h"
   46|       |#include "synthesize.h"
   47|       |#include "translate.h"
   48|       |
   49|       |// included here so tests can find these even without OPT_MBROLA set
   50|       |int mbrola_delay;
   51|       |char mbrola_name[20];
   52|       |
   53|       |#ifdef INCLUDE_MBROLA
   54|       |
   55|       |#if defined(_WIN32) || defined(_WIN64)
   56|       |#include <windows.h>
   57|       |#endif
   58|       |
   59|       |#include "mbrowrap.h"
   60|       |
   61|       |static MBROLA_TAB *mbrola_tab = NULL;
   62|       |static int mbrola_control = 0;
   63|       |static int mbr_name_prefix = 0;
   64|       |
   65|       |espeak_ng_STATUS LoadMbrolaTable(const char *mbrola_voice, const char *phtrans, int *srate)
   66|      0|{
   67|      0|	// Load a phoneme name translation table from espeak-ng-data/mbrola
   68|      0|
   69|      0|	int size;
   70|      0|	int ix;
   71|      0|	int *pw;
   72|      0|	FILE *f_in;
   73|      0|	char path[sizeof(path_home)+15];
   74|      0|
   75|      0|	mbrola_name[0] = 0;
   76|      0|	mbrola_delay = 0;
   77|      0|	mbr_name_prefix = 0;
   78|      0|
   79|      0|	if (mbrola_voice == NULL) {
   80|      0|		samplerate = samplerate_native;
   81|      0|		SetParameter(espeakVOICETYPE, 0, 0);
   82|      0|		return ENS_OK;
   83|      0|	}
   84|      0|
   85|      0|	if (!load_MBR())
   86|      0|		return ENS_MBROLA_NOT_FOUND;
   87|      0|
   88|      0|	sprintf(path, "%s/mbrola/%s", path_home, mbrola_voice);
   89|      0|#ifdef PLATFORM_POSIX
   90|      0|	// if not found, then also look in
   91|      0|	//   usr/share/mbrola/xx, /usr/share/mbrola/xx/xx, /usr/share/mbrola/voices/xx
   92|      0|	if (GetFileLength(path) <= 0) {
   93|      0|		sprintf(path, "/usr/share/mbrola/%s", mbrola_voice);
   94|      0|
   95|      0|		if (GetFileLength(path) <= 0) {
   96|      0|			sprintf(path, "/usr/share/mbrola/%s/%s", mbrola_voice, mbrola_voice);
   97|      0|
   98|      0|			if (GetFileLength(path) <= 0)
   99|      0|				sprintf(path, "/usr/share/mbrola/voices/%s", mbrola_voice);
  100|      0|
  101|      0|			// Show error message
  102|      0|			if (GetFileLength(path) <= 0) {
  103|      0|				fprintf(stderr, "Cannot find MBROLA voice file '%s' in neither of paths:\n"
  104|      0|						" - /usr/share/mbrola/%s\n"
  105|      0|						" - /usr/share/mbrola/%s/%s\n"
  106|      0|						" - /usr/share/mbrola/voices/%s\n"
  107|      0|						"Please install necessary MBROLA voice!\n",
  108|      0|						mbrola_voice, mbrola_voice, mbrola_voice, mbrola_voice, mbrola_voice);
  109|      0|				// Set path back to simple name, otherwise it shows misleading error only for
  110|      0|				// last unsuccessfully searched path
  111|      0|				sprintf(path, "%s", mbrola_voice);
  112|      0|			}
  113|      0|		}
  114|      0|	}
  115|      0|	close_MBR();
  116|      0|#endif
  117|      0|
  118|      0|	if (init_MBR(path) != 0) // initialise the required mbrola voice
  119|      0|		return ENS_MBROLA_VOICE_NOT_FOUND;
  120|      0|
  121|      0|	setNoError_MBR(1); // don't stop on phoneme errors
  122|      0|
  123|      0|	// read eSpeak's mbrola phoneme translation data, eg. en1_phtrans
  124|      0|	sprintf(path, "%s/mbrola_ph/%s", path_home, phtrans);
  125|      0|	size = GetFileLength(path);
  126|      0|	if (size < 0) // size == -errno
  127|      0|		return -size;
  128|      0|	if ((f_in = fopen(path, "rb")) == NULL) {
  129|      0|		int error = errno;
  130|      0|		close_MBR();
  131|      0|		return error;
  132|      0|	}
  133|      0|
  134|      0|	MBROLA_TAB *new_mbrola_tab = (MBROLA_TAB *)realloc(mbrola_tab, size);
  135|      0|	if (new_mbrola_tab == NULL) {
  136|      0|		fclose(f_in);
  137|      0|		close_MBR();
  138|      0|		return ENOMEM;
  139|      0|	}
  140|      0|	mbrola_tab = new_mbrola_tab;
  141|      0|
  142|      0|	mbrola_control = Read4Bytes(f_in);
  143|      0|	pw = (int *)mbrola_tab;
  144|      0|	for (ix = 4; ix < size; ix += 4)
  145|      0|		*pw++ = Read4Bytes(f_in);
  146|      0|	fclose(f_in);
  147|      0|
  148|      0|	setVolumeRatio_MBR((float)(mbrola_control & 0xff) /16.0f);
  149|      0|	samplerate = *srate = getFreq_MBR();
  150|      0|	if (*srate == 22050)
  151|      0|		SetParameter(espeakVOICETYPE, 0, 0);
  152|      0|	else
  153|      0|		SetParameter(espeakVOICETYPE, 1, 0);
  154|      0|	strcpy(mbrola_name, mbrola_voice);
  155|      0|	mbrola_delay = 1000; // improve synchronization of events
  156|      0|	return ENS_OK;
  157|      0|}
  158|       |
  159|       |static int GetMbrName(PHONEME_LIST *plist, PHONEME_TAB *ph, PHONEME_TAB *ph_prev, PHONEME_TAB *ph_next, int *name2, int *split, int *control)
  160|      0|{
  161|      0|	// Look up a phoneme in the mbrola phoneme name translation table
  162|      0|	// It may give none, 1, or 2 mbrola phonemes
  163|      0|
  164|      0|	MBROLA_TAB *pr;
  165|      0|	PHONEME_TAB *other_ph;
  166|      0|	bool found = false;
  167|      0|	static int mnem;
  168|      0|
  169|      0|	// control
  170|      0|	// bit 0  skip the next phoneme
  171|      0|	// bit 1  match this and Previous phoneme
  172|      0|	// bit 2  only at the start of a word
  173|      0|	// bit 3  don't match two phonemes across a word boundary
  174|      0|	// bit 4  add this phoneme name as a prefix to the next phoneme name (used for de4 phoneme prefix '?')
  175|      0|	// bit 5  only in stressed syllable
  176|      0|	// bit 6  only at the end of a word
  177|      0|
  178|      0|	*name2 = 0;
  179|      0|	*split = 0;
  180|      0|	*control = 0;
  181|      0|	mnem = ph->mnemonic;
  182|      0|
  183|      0|	pr = mbrola_tab;
  184|      0|	while (pr->name != 0) {
  185|      0|		if (mnem == pr->name) {
  186|      0|			if (pr->next_phoneme == 0)
  187|      0|				found = true;
  188|      0|			else if ((pr->next_phoneme == ':') && (plist->synthflags & SFLAG_LENGTHEN))
  189|      0|				found = true;
  190|      0|			else {
  191|      0|				if (pr->control & 2)
  192|      0|					other_ph = ph_prev;
  193|      0|				else if ((pr->control & 8) && ((plist+1)->newword))
  194|      0|					other_ph = phoneme_tab[phPAUSE]; // don't match the next phoneme over a word boundary
  195|      0|				else
  196|      0|					other_ph = ph_next;
  197|      0|
  198|      0|				if ((pr->next_phoneme == other_ph->mnemonic) ||
  199|      0|				    ((pr->next_phoneme == 2) && (other_ph->type == phVOWEL)) ||
  200|      0|				    ((pr->next_phoneme == '_') && (other_ph->type == phPAUSE)))
  201|      0|					found = true;
  202|      0|			}
  203|      0|
  204|      0|			if ((pr->control & 4) && (plist->newword == 0)) // only at start of word
  205|      0|				found = false;
  206|      0|
  207|      0|			if ((pr->control & 0x40) && (plist[1].newword == 0)) // only at the end of a word
  208|      0|				found = false;
  209|      0|
  210|      0|			if ((pr->control & 0x20) && (plist->stresslevel < plist->wordstress))
  211|      0|				found = false; // only in stressed syllables
  212|      0|
  213|      0|			if (found) {
  214|      0|				*name2 = pr->mbr_name2;
  215|      0|				*split = pr->percent;
  216|      0|				*control = pr->control;
  217|      0|
  218|      0|				if (pr->control & 0x10) {
  219|      0|					mbr_name_prefix = pr->mbr_name;
  220|      0|					return 0;
  221|      0|				}
  222|      0|				mnem = pr->mbr_name;
  223|      0|				break;
  224|      0|			}
  225|      0|		}
  226|      0|
  227|      0|		pr++;
  228|      0|	}
  229|      0|
  230|      0|	if (mbr_name_prefix != 0)
  231|      0|		mnem = (mnem << 8) | (mbr_name_prefix & 0xff);
  232|      0|	mbr_name_prefix = 0;
  233|      0|	return mnem;
  234|      0|}
  235|       |
  236|       |static char *WritePitch(int env, int pitch1, int pitch2, int split, int final)
  237|      0|{
  238|      0|	// final=1:  only give the final pitch value.
  239|      0|	int x;
  240|      0|	int ix;
  241|      0|	int pitch_base;
  242|      0|	int pitch_range;
  243|      0|	int p1, p2, p_end;
  244|      0|	unsigned char *pitch_env;
  245|      0|	int max = -1;
  246|      0|	int min = 999;
  247|      0|	int y_max = 0;
  248|      0|	int y_min = 0;
  249|      0|	int env100 = 80; // apply the pitch change only over this proportion of the mbrola phoneme(s)
  250|      0|	int y2;
  251|      0|	int y[4];
  252|      0|	int env_split;
  253|      0|	char buf[50];
  254|      0|	static char output[50];
  255|      0|
  256|      0|	output[0] = 0;
  257|      0|	pitch_env = envelope_data[env];
  258|      0|
  259|      0|	SetPitch2(voice, pitch1, pitch2, &pitch_base, &pitch_range);
  260|      0|
  261|      0|	env_split = (split * 128)/100;
  262|      0|	if (env_split < 0)
  263|      0|		env_split = 0-env_split;
  264|      0|
  265|      0|	// find max and min in the pitch envelope
  266|      0|	for (x = 0; x < 128; x++) {
  267|      0|		if (pitch_env[x] > max) {
  268|      0|			max = pitch_env[x];
  269|      0|			y_max = x;
  270|      0|		}
  271|      0|		if (pitch_env[x] < min) {
  272|      0|			min = pitch_env[x];
  273|      0|			y_min = x;
  274|      0|		}
  275|      0|	}
  276|      0|	// set an additional pitch point half way through the phoneme.
  277|      0|	// but look for a maximum or a minimum and use that instead
  278|      0|	y[2] = 64;
  279|      0|	if ((y_max > 0) && (y_max < 127))
  280|      0|		y[2] = y_max;
  281|      0|	if ((y_min > 0) && (y_min < 127))
  282|      0|		y[2] = y_min;
  283|      0|	y[1] = y[2] / 2;
  284|      0|	y[3] = y[2] + (127 - y[2])/2;
  285|      0|
  286|      0|	// set initial pitch
  287|      0|	p1 = ((pitch_env[0]*pitch_range)>>8) + pitch_base; // Hz << 12
  288|      0|	p_end = ((pitch_env[127]*pitch_range)>>8) + pitch_base;
  289|      0|
  290|      0|	if (split >= 0) {
  291|      0|		sprintf(buf, " 0 %d", p1/4096);
  292|      0|		strcat(output, buf);
  293|      0|	}
  294|      0|
  295|      0|	// don't use intermediate pitch points for linear rise and fall
  296|      0|	if (env > 1) {
  297|      0|		for (ix = 1; ix < 4; ix++) {
  298|      0|			p2 = ((pitch_env[y[ix]]*pitch_range)>>8) + pitch_base;
  299|      0|
  300|      0|			if (split > 0)
  301|      0|				y2 = (y[ix] * env100)/env_split;
  302|      0|			else if (split < 0)
  303|      0|				y2 = ((y[ix]-env_split) * env100)/env_split;
  304|      0|			else
  305|      0|				y2 = (y[ix] * env100)/128;
  306|      0|			if ((y2 > 0) && (y2 <= env100)) {
  307|      0|				sprintf(buf, " %d %d", y2, p2/4096);
  308|      0|				strcat(output, buf);
  309|      0|			}
  310|      0|		}
  311|      0|	}
  312|      0|
  313|      0|	p_end = p_end/4096;
  314|      0|	if (split <= 0) {
  315|      0|		sprintf(buf, " %d %d", env100, p_end);
  316|      0|		strcat(output, buf);
  317|      0|	}
  318|      0|	if (env100 < 100) {
  319|      0|		sprintf(buf, " %d %d", 100, p_end);
  320|      0|		strcat(output, buf);
  321|      0|	}
  322|      0|	strcat(output, "\n");
  323|      0|
  324|      0|	if (final)
  325|      0|		sprintf(output, "\t100 %d\n", p_end);
  326|      0|	return output;
  327|      0|}
  328|       |
  329|       |int MbrolaTranslate(PHONEME_LIST *plist, int n_phonemes, bool resume, FILE *f_mbrola)
  330|      0|{
  331|      0|	// Generate a mbrola pho file
  332|      0|	unsigned int name;
  333|      0|	int len;
  334|      0|	int len1;
  335|      0|	PHONEME_TAB *ph;
  336|      0|	PHONEME_TAB *ph_next;
  337|      0|	PHONEME_TAB *ph_prev;
  338|      0|	PHONEME_LIST *p;
  339|      0|	PHONEME_LIST *next;
  340|      0|	PHONEME_DATA phdata;
  341|      0|	FMT_PARAMS fmtp;
  342|      0|	int pause = 0;
  343|      0|	bool released;
  344|      0|	int name2;
  345|      0|	int control;
  346|      0|	bool done;
  347|      0|	int len_percent;
  348|      0|	const char *final_pitch;
  349|      0|	char *ptr;
  350|      0|	char mbr_buf[120];
  351|      0|
  352|      0|	static int phix;
  353|      0|	static int embedded_ix;
  354|      0|	static int word_count;
  355|      0|
  356|      0|	if (!resume) {
  357|      0|		phix = 1;
  358|      0|		embedded_ix = 0;
  359|      0|		word_count = 0;
  360|      0|	}
  361|      0|
  362|      0|	while (phix < n_phonemes) {
  363|      0|		if (WcmdqFree() < MIN_WCMDQ)
  364|      0|			return 1;
  365|      0|
  366|      0|		ptr = mbr_buf;
  367|      0|
  368|      0|		p = &plist[phix];
  369|      0|		next = &plist[phix+1];
  370|      0|		ph = p->ph;
  371|      0|		ph_prev = plist[phix-1].ph;
  372|      0|		ph_next = plist[phix+1].ph;
  373|      0|
  374|      0|		if (p->synthflags & SFLAG_EMBEDDED)
  375|      0|			DoEmbedded(&embedded_ix, p->sourceix);
  376|      0|
  377|      0|		if (p->newword & PHLIST_START_OF_SENTENCE)
  378|      0|			DoMarker(espeakEVENT_SENTENCE, (p->sourceix & 0x7ff) + clause_start_char, 0, count_sentences);
  379|      0|		if (p->newword & PHLIST_START_OF_SENTENCE)
  380|      0|			DoMarker(espeakEVENT_WORD, (p->sourceix & 0x7ff) + clause_start_char, p->sourceix >> 11, clause_start_word + word_count++);
  381|      0|
  382|      0|		name = GetMbrName(p, ph, ph_prev, ph_next, &name2, &len_percent, &control);
  383|      0|		if (control & 1)
  384|      0|			phix++;
  385|      0|
  386|      0|		if (name == 0) {
  387|      0|			phix++;
  388|      0|			continue; // ignore this phoneme
  389|      0|		}
  390|      0|
  391|      0|		if ((ph->type == phPAUSE) && (name == ph->mnemonic)) {
  392|      0|			// a pause phoneme, which has not been changed by the translation
  393|      0|			name = '_';
  394|      0|			len = (p->length * speed.pause_factor)/256;
  395|      0|			if (len == 0)
  396|      0|				len = 1;
  397|      0|		} else
  398|      0|			len = (80 * speed.wav_factor)/256;
  399|      0|
  400|      0|		if (ph->code != phonEND_WORD) {
  401|      0|			char phoneme_name[16];
  402|      0|			WritePhMnemonic(phoneme_name, p->ph, p, option_phoneme_events & espeakINITIALIZE_PHONEME_IPA, NULL);
  403|      0|			DoPhonemeMarker(espeakEVENT_PHONEME, (p->sourceix & 0x7ff) + clause_start_char, 0, phoneme_name);
  404|      0|		}
  405|      0|
  406|      0|		ptr += sprintf(ptr, "%s\t", WordToString(name));
  407|      0|
  408|      0|		if (name2 == '_') {
  409|      0|			// add a pause after this phoneme
  410|      0|			pause = len_percent;
  411|      0|			name2 = 0;
  412|      0|		}
  413|      0|
  414|      0|		done = false;
  415|      0|		final_pitch = "";
  416|      0|
  417|      0|		switch (ph->type)
  418|      0|		{
  419|      0|		case phVOWEL:
  420|      0|			len = ph->std_length;
  421|      0|			if (p->synthflags & SFLAG_LENGTHEN)
  422|      0|				len += phoneme_tab[phonLENGTHEN]->std_length; // phoneme was followed by an extra : symbol
  423|      0|
  424|      0|			if (ph_next->type == phPAUSE)
  425|      0|				len += 50; // lengthen vowels before a pause
  426|      0|			len = (len * p->length)/256;
  427|      0|
  428|      0|			if (name2 == 0) {
  429|      0|				char *pitch = WritePitch(p->env, p->pitch1, p->pitch2, 0, 0);
  430|      0|				ptr += sprintf(ptr, "%d\t%s", len, pitch);
  431|      0|			} else {
  432|      0|				char *pitch;
  433|      0|
  434|      0|				pitch = WritePitch(p->env, p->pitch1, p->pitch2, len_percent, 0);
  435|      0|				len1 = (len * len_percent)/100;
  436|      0|				ptr += sprintf(ptr, "%d\t%s", len1, pitch);
  437|      0|
  438|      0|				pitch = WritePitch(p->env, p->pitch1, p->pitch2, -len_percent, 0);
  439|      0|				ptr += sprintf(ptr, "%s\t%d\t%s", WordToString(name2), len-len1, pitch);
  440|      0|			}
  441|      0|			done = true;
  442|      0|			break;
  443|      0|		case phSTOP:
  444|      0|			released = false;
  445|      0|			if (next->type == phVOWEL) released = true;
  446|      0|			if (next->type == phLIQUID && !next->newword) released = true;
  447|      0|
  448|      0|			if (released == false)
  449|      0|				p->synthflags |= SFLAG_NEXT_PAUSE;
  450|      0|			InterpretPhoneme(NULL, 0, p, &phdata, NULL);
  451|      0|			len = DoSample3(&phdata, 0, -1);
  452|      0|
  453|      0|			len = (len * 1000)/samplerate; // convert to mS
  454|      0|			len += PauseLength(p->prepause, 1);
  455|      0|			break;
  456|      0|		case phVSTOP:
  457|      0|			len = (80 * speed.wav_factor)/256;
  458|      0|			break;
  459|      0|		case phFRICATIVE:
  460|      0|			len = 0;
  461|      0|			InterpretPhoneme(NULL, 0, p, &phdata, NULL);
  462|      0|			if (p->synthflags & SFLAG_LENGTHEN)
  463|      0|				len = DoSample3(&phdata, p->length, -1); // play it twice for [s:] etc.
  464|      0|			len += DoSample3(&phdata, p->length, -1);
  465|      0|
  466|      0|			len = (len * 1000)/samplerate; // convert to mS
  467|      0|			break;
  468|      0|		case phNASAL:
  469|      0|			if (next->type != phVOWEL) {
  470|      0|				memset(&fmtp, 0, sizeof(fmtp));
  471|      0|				InterpretPhoneme(NULL, 0, p, &phdata, NULL);
  472|      0|				fmtp.fmt_addr = phdata.sound_addr[pd_FMT];
  473|      0|				len = DoSpect2(p->ph, 0, &fmtp,  p, -1);
  474|      0|				len = (len * 1000)/samplerate;
  475|      0|				if (next->type == phPAUSE)
  476|      0|					len += 50;
  477|      0|				final_pitch = WritePitch(p->env, p->pitch1, p->pitch2, 0, 1);
  478|      0|			}
  479|      0|			break;
  480|      0|		case phLIQUID:
  481|      0|			if (next->type == phPAUSE) {
  482|      0|				len += 50;
  483|      0|				final_pitch = WritePitch(p->env, p->pitch1, p->pitch2, 0, 1);
  484|      0|			}
  485|      0|			break;
  486|      0|		}
  487|      0|
  488|      0|		if (!done) {
  489|      0|			if (name2 != 0) {
  490|      0|				len1 = (len * len_percent)/100;
  491|      0|				ptr += sprintf(ptr, "%d\n%s\t", len1, WordToString(name2));
  492|      0|				len -= len1;
  493|      0|			}
  494|      0|			ptr += sprintf(ptr, "%d%s\n", len, final_pitch);
  495|      0|		}
  496|      0|
  497|      0|		if (pause) {
  498|      0|			len += PauseLength(pause, 0);
  499|      0|			ptr += sprintf(ptr, "_ \t%d\n", PauseLength(pause, 0));
  500|      0|			pause = 0;
  501|      0|		}
  502|      0|
  503|      0|		if (f_mbrola)
  504|      0|			fwrite(mbr_buf, 1, (ptr-mbr_buf), f_mbrola); // write .pho to a file
  505|      0|		else {
  506|      0|			int res = write_MBR(mbr_buf);
  507|      0|			if (res < 0)
  508|      0|				return 0;  // don't get stuck on error
  509|      0|			if (res == 0)
  510|      0|				return 1;
  511|      0|			wcmdq[wcmdq_tail][0] = WCMD_MBROLA_DATA;
  512|      0|			wcmdq[wcmdq_tail][1] = len;
  513|      0|			WcmdqInc();
  514|      0|		}
  515|      0|
  516|      0|		phix++;
  517|      0|	}
  518|      0|
  519|      0|	if (!f_mbrola) {
  520|      0|		flush_MBR();
  521|      0|
  522|      0|		// flush the mbrola output buffer
  523|      0|		wcmdq[wcmdq_tail][0] = WCMD_MBROLA_DATA;
  524|      0|		wcmdq[wcmdq_tail][1] = 500;
  525|      0|		WcmdqInc();
  526|      0|	}
  527|      0|
  528|      0|	return 0;
  529|      0|}
  530|       |
  531|       |int MbrolaGenerate(PHONEME_LIST *phoneme_list, int *n_ph, bool resume)
  532|      0|{
  533|      0|	FILE *f_mbrola = NULL;
  534|      0|
  535|      0|	if (*n_ph == 0)
  536|      0|		return 0;
  537|      0|
  538|      0|	if (option_phonemes & espeakPHONEMES_MBROLA) {
  539|      0|		// send mbrola data to a file, not to the mbrola library
  540|      0|		f_mbrola = f_trans;
  541|      0|	}
  542|      0|
  543|      0|	int  again = MbrolaTranslate(phoneme_list, *n_ph, resume, f_mbrola);
  544|      0|	if (!again)
  545|      0|		*n_ph = 0;
  546|      0|	return again;
  547|      0|}
  548|       |
  549|       |int MbrolaFill(int length, bool resume, int amplitude)
  550|      0|{
  551|      0|	// Read audio data from Mbrola (length is in millisecs)
  552|      0|
  553|      0|	static int n_samples;
  554|      0|	int req_samples, result;
  555|      0|	int ix;
  556|      0|	short value16;
  557|      0|	int value;
  558|      0|
  559|      0|	if (!resume)
  560|      0|		n_samples = samplerate * length / 1000;
  561|      0|
  562|      0|	req_samples = (out_end - out_ptr)/2;
  563|      0|	if (req_samples > n_samples)
  564|      0|		req_samples = n_samples;
  565|      0|	result = read_MBR((short *)out_ptr, req_samples);
  566|      0|	if (result <= 0)
  567|      0|		return 0;
  568|      0|
  569|      0|	for (ix = 0; ix < result; ix++) {
  570|      0|		value16 = out_ptr[0] + (out_ptr[1] << 8);
  571|      0|		value = value16 * amplitude;
  572|      0|		value = value / 40; // adjust this constant to give a suitable amplitude for mbrola voices
  573|      0|		if (value > 0x7fff)
  574|      0|			value = 0x7fff;
  575|      0|		if (value < -0x8000)
  576|      0|			value = 0x8000;
  577|      0|		out_ptr[0] = value;
  578|      0|		out_ptr[1] = value >> 8;
  579|      0|		out_ptr += 2;
  580|      0|	}
  581|      0|	n_samples -= result;
  582|      0|	return n_samples ? 1 : 0;
  583|      0|}
  584|       |
  585|       |void MbrolaReset(void)
  586|      0|{
  587|      0|	// Reset the Mbrola engine and flush the pending audio
  588|      0|
  589|      0|	reset_MBR();
  590|      0|}
  591|       |
  592|       |#else
  593|       |
  594|       |// mbrola interface is not compiled, provide dummy functions.
  595|       |
  596|       |espeak_ng_STATUS LoadMbrolaTable(const char *mbrola_voice, const char *phtrans, int *srate)
  597|       |{
  598|       |	(void)mbrola_voice; // unused parameter
  599|       |	(void)phtrans; // unused parameter
  600|       |	(void)srate; // unused parameter
  601|       |	return ENS_NOT_SUPPORTED;
  602|       |}
  603|       |
  604|       |int MbrolaGenerate(PHONEME_LIST *phoneme_list, int *n_ph, bool resume)
  605|       |{
  606|       |	(void)phoneme_list; // unused parameter
  607|       |	(void)n_ph; // unused parameter
  608|       |	(void)resume; // unused parameter
  609|       |	return 0;
  610|       |}
  611|       |
  612|       |int MbrolaFill(int length, bool resume, int amplitude)
  613|       |{
  614|       |	(void)length; // unused parameter
  615|       |	(void)resume; // unused parameter
  616|       |	(void)amplitude; // unused parameter
  617|       |	return 0;
  618|       |}
  619|       |
  620|       |void MbrolaReset(void)
  621|       |{
  622|       |}
  623|       |
  624|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/synthdata.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2014 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2017 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <ctype.h>
   23|       |#include <errno.h>
   24|       |#include <stdbool.h>
   25|       |#include <stdint.h>
   26|       |#include <stdio.h>
   27|       |#include <stdlib.h>
   28|       |#include <string.h>
   29|       |
   30|       |#include <espeak-ng/espeak_ng.h>
   31|       |#include <espeak-ng/speak_lib.h>
   32|       |#include <espeak-ng/encoding.h>
   33|       |
   34|       |#include "synthdata.h"
   35|       |#include "error.h"                    // for create_file_error_context, crea...
   36|       |#include "phoneme.h"                  // for PHONEME_TAB, PHONEME_TAB_LIST
   37|       |#include "speech.h"                   // for path_home, GetFileLength, PATHSEP
   38|       |#include "mbrola.h"                   // for mbrola_name
   39|       |#include "soundicon.h"               // for soundicon_tab
   40|       |#include "synthesize.h"               // for PHONEME_LIST, frameref_t, PHONE...
   41|       |#include "translate.h"                // for Translator, LANGUAGE_OPTIONS
   42|       |#include "voice.h"                    // for ReadTonePoints, tone_points, voice
   43|       |
   44|       |const int version_phdata  = 0x014801;
   45|       |
   46|       |// copy the current phoneme table into here
   47|       |int n_phoneme_tab;
   48|       |int current_phoneme_table;
   49|       |PHONEME_TAB *phoneme_tab[N_PHONEME_TAB];
   50|       |
   51|       |unsigned short *phoneme_index = NULL;
   52|       |char *phondata_ptr = NULL;
   53|       |unsigned char *wavefile_data = NULL;
   54|       |static unsigned char *phoneme_tab_data = NULL;
   55|       |
   56|       |int n_phoneme_tables;
   57|       |PHONEME_TAB_LIST phoneme_tab_list[N_PHONEME_TABS];
   58|       |int phoneme_tab_number = 0;
   59|       |
   60|       |int seq_len_adjust;
   61|       |
   62|       |static espeak_ng_STATUS ReadPhFile(void **ptr, const char *fname, int *size, espeak_ng_ERROR_CONTEXT *context)
   63|      0|{
   64|      0|	if (!ptr) return EINVAL;
   65|      0|
   66|      0|	FILE *f_in;
   67|      0|	int length;
   68|      0|	char buf[sizeof(path_home)+40];
   69|      0|
   70|      0|	sprintf(buf, "%s%c%s", path_home, PATHSEP, fname);
   71|      0|	length = GetFileLength(buf);
   72|      0|	if (length < 0) // length == -errno
   73|      0|		return create_file_error_context(context, -length, buf);
   74|      0|
   75|      0|	if ((f_in = fopen(buf, "rb")) == NULL)
   76|      0|		return create_file_error_context(context, errno, buf);
   77|      0|
   78|      0|	if (*ptr != NULL)
   79|      0|		free(*ptr);
   80|      0|
   81|      0|	if ((*ptr = malloc(length)) == NULL) {
   82|      0|		fclose(f_in);
   83|      0|		return ENOMEM;
   84|      0|	}
   85|      0|	if (fread(*ptr, 1, length, f_in) != length) {
   86|      0|		int error = errno;
   87|      0|		fclose(f_in);
   88|      0|		free(*ptr);
   89|      0|		return create_file_error_context(context, error, buf);
   90|      0|	}
   91|      0|
   92|      0|	fclose(f_in);
   93|      0|	if (size != NULL)
   94|      0|		*size = length;
   95|      0|	return ENS_OK;
   96|      0|}
   97|       |
   98|       |espeak_ng_STATUS LoadPhData(int *srate, espeak_ng_ERROR_CONTEXT *context)
   99|      0|{
  100|      0|	int ix;
  101|      0|	int n_phonemes;
  102|      0|	int version;
  103|      0|	int length = 0;
  104|      0|	int rate;
  105|      0|	unsigned char *p;
  106|      0|
  107|      0|	espeak_ng_STATUS status;
  108|      0|	if ((status = ReadPhFile((void **)&phoneme_tab_data, "phontab", NULL, context)) != ENS_OK)
  109|      0|		return status;
  110|      0|	if ((status = ReadPhFile((void **)&phoneme_index, "phonindex", NULL, context)) != ENS_OK)
  111|      0|		return status;
  112|      0|	if ((status = ReadPhFile((void **)&phondata_ptr, "phondata", NULL, context)) != ENS_OK)
  113|      0|		return status;
  114|      0|	if ((status = ReadPhFile((void **)&tunes, "intonations", &length, context)) != ENS_OK)
  115|      0|		return status;
  116|      0|	wavefile_data = (unsigned char *)phondata_ptr;
  117|      0|	n_tunes = length / sizeof(TUNE);
  118|      0|
  119|      0|	// read the version number and sample rate from the first 8 bytes of phondata
  120|      0|	version = 0; // bytes 0-3, version number
  121|      0|	rate = 0;    // bytes 4-7, sample rate
  122|      0|	for (ix = 0; ix < 4; ix++) {
  123|      0|		version += (wavefile_data[ix] << (ix*8));
  124|      0|		rate += (wavefile_data[ix+4] << (ix*8));
  125|      0|	}
  126|      0|
  127|      0|	if (version != version_phdata)
  128|      0|		return create_version_mismatch_error_context(context, path_home, version, version_phdata);
  129|      0|
  130|      0|	// set up phoneme tables
  131|      0|	p = phoneme_tab_data;
  132|      0|	n_phoneme_tables = p[0];
  133|      0|	p += 4;
  134|      0|
  135|      0|	for (ix = 0; ix < n_phoneme_tables; ix++) {
  136|      0|		n_phonemes = p[0];
  137|      0|		phoneme_tab_list[ix].n_phonemes = p[0];
  138|      0|		phoneme_tab_list[ix].includes = p[1];
  139|      0|		p += 4;
  140|      0|		memcpy(phoneme_tab_list[ix].name, p, N_PHONEME_TAB_NAME);
  141|      0|		p += N_PHONEME_TAB_NAME;
  142|      0|		phoneme_tab_list[ix].phoneme_tab_ptr = (PHONEME_TAB *)p;
  143|      0|		p += (n_phonemes * sizeof(PHONEME_TAB));
  144|      0|	}
  145|      0|
  146|      0|	if (phoneme_tab_number >= n_phoneme_tables)
  147|      0|		phoneme_tab_number = 0;
  148|      0|
  149|      0|	if (srate != NULL)
  150|      0|		*srate = rate;
  151|      0|	return ENS_OK;
  152|      0|}
  153|       |
  154|       |void FreePhData(void)
  155|      0|{
  156|      0|	free(phoneme_tab_data);
  157|      0|	free(phoneme_index);
  158|      0|	free(phondata_ptr);
  159|      0|	free(tunes);
  160|      0|	phoneme_tab_data = NULL;
  161|      0|	phoneme_index = NULL;
  162|      0|	phondata_ptr = NULL;
  163|      0|	tunes = NULL;
  164|      0|}
  165|       |
  166|       |int PhonemeCode(unsigned int mnem)
  167|      0|{
  168|      0|	int ix;
  169|      0|
  170|      0|	for (ix = 0; ix < n_phoneme_tab; ix++) {
  171|      0|		if (phoneme_tab[ix] == NULL)
  172|      0|			continue;
  173|      0|		if (phoneme_tab[ix]->mnemonic == mnem)
  174|      0|			return phoneme_tab[ix]->code;
  175|      0|	}
  176|      0|	return 0;
  177|      0|}
  178|       |
  179|       |int LookupPhonemeString(const char *string)
  180|      0|{
  181|      0|	int ix;
  182|      0|	unsigned char c;
  183|      0|	unsigned int mnem;
  184|      0|
  185|      0|	// Pack up to 4 characters into a word
  186|      0|	mnem = 0;
  187|      0|	for (ix = 0; ix < 4; ix++) {
  188|      0|		if (string[ix] == 0) break;
  189|      0|		c = string[ix];
  190|      0|		mnem |= (c << (ix*8));
  191|      0|	}
  192|      0|
  193|      0|	return PhonemeCode(mnem);
  194|      0|}
  195|       |
  196|       |frameref_t *LookupSpect(PHONEME_TAB *this_ph, int which, FMT_PARAMS *fmt_params,  int *n_frames, PHONEME_LIST *plist)
  197|      0|{
  198|      0|	int ix;
  199|      0|	int nf;
  200|      0|	int nf1;
  201|      0|	int seq_break;
  202|      0|	frameref_t *frames;
  203|      0|	int length1;
  204|      0|	int length_std;
  205|      0|	int length_factor;
  206|      0|	SPECT_SEQ *seq, *seq2;
  207|      0|	SPECT_SEQK *seqk, *seqk2;
  208|      0|	frame_t *frame;
  209|      0|	static frameref_t frames_buf[N_SEQ_FRAMES];
  210|      0|
  211|      0|	seq = (SPECT_SEQ *)(&phondata_ptr[fmt_params->fmt_addr]);
  212|      0|	seqk = (SPECT_SEQK *)seq;
  213|      0|	nf = seq->n_frames;
  214|      0|
  215|      0|	if (nf >= N_SEQ_FRAMES)
  216|      0|		nf = N_SEQ_FRAMES - 1;
  217|      0|
  218|      0|	seq_len_adjust = fmt_params->fmt2_lenadj + fmt_params->fmt_length;
  219|      0|	seq_break = 0;
  220|      0|
  221|      0|	for (ix = 0; ix < nf; ix++) {
  222|      0|		if (seq->frame[0].frflags & FRFLAG_KLATT)
  223|      0|			frame = &seqk->frame[ix];
  224|      0|		else
  225|      0|			frame = (frame_t *)&seq->frame[ix];
  226|      0|		frames_buf[ix].frame = frame;
  227|      0|		frames_buf[ix].frflags = frame->frflags;
  228|      0|		frames_buf[ix].length = frame->length;
  229|      0|		if (frame->frflags & FRFLAG_VOWEL_CENTRE)
  230|      0|			seq_break = ix;
  231|      0|	}
  232|      0|
  233|      0|	frames = &frames_buf[0];
  234|      0|	if (seq_break > 0) {
  235|      0|		if (which == 1)
  236|      0|			nf = seq_break + 1;
  237|      0|		else {
  238|      0|			frames = &frames_buf[seq_break]; // body of vowel, skip past initial frames
  239|      0|			nf -= seq_break;
  240|      0|		}
  241|      0|	}
  242|      0|
  243|      0|	// do we need to modify a frame for blending with a consonant?
  244|      0|	if ((this_ph->type == phVOWEL) && (fmt_params->fmt2_addr == 0) && (fmt_params->use_vowelin))
  245|      0|		seq_len_adjust += FormantTransition2(frames, &nf, fmt_params->transition0, fmt_params->transition1, NULL, which);
  246|      0|
  247|      0|	length1 = 0;
  248|      0|	nf1 = nf - 1;
  249|      0|	for (ix = 0; ix < nf1; ix++)
  250|      0|		length1 += frames[ix].length;
  251|      0|
  252|      0|	if (fmt_params->fmt2_addr != 0) {
  253|      0|		// a secondary reference has been returned, which is not a wavefile
  254|      0|		// add these spectra to the main sequence
  255|      0|		seq2 = (SPECT_SEQ *)(&phondata_ptr[fmt_params->fmt2_addr]);
  256|      0|		seqk2 = (SPECT_SEQK *)seq2;
  257|      0|
  258|      0|		// first frame of the addition just sets the length of the last frame of the main seq
  259|      0|		nf--;
  260|      0|		for (ix = 0; ix < seq2->n_frames; ix++) {
  261|      0|			if (seq2->frame[0].frflags & FRFLAG_KLATT)
  262|      0|				frame = &seqk2->frame[ix];
  263|      0|			else
  264|      0|				frame = (frame_t *)&seq2->frame[ix];
  265|      0|
  266|      0|			frames[nf].length = frame->length;
  267|      0|			if (ix > 0) {
  268|      0|				frames[nf].frame = frame;
  269|      0|				frames[nf].frflags = frame->frflags;
  270|      0|			}
  271|      0|			nf++;
  272|      0|		}
  273|      0|	}
  274|      0|
  275|      0|	if (length1 > 0) {
  276|      0|		if (which == 2) {
  277|      0|			// adjust the length of the main part to match the standard length specified for the vowel
  278|      0|			// less the front part of the vowel and any added suffix
  279|      0|
  280|      0|			length_std = fmt_params->std_length + seq_len_adjust - 45;
  281|      0|			if (length_std < 10)
  282|      0|				length_std = 10;
  283|      0|			if (plist->synthflags & SFLAG_LENGTHEN)
  284|      0|				length_std += (phoneme_tab[phonLENGTHEN]->std_length * 2); // phoneme was followed by an extra : symbol
  285|      0|
  286|      0|			// can adjust vowel length for stressed syllables here
  287|      0|
  288|      0|			length_factor = (length_std * 256)/ length1;
  289|      0|
  290|      0|			for (ix = 0; ix < nf1; ix++)
  291|      0|				frames[ix].length = (frames[ix].length * length_factor)/256;
  292|      0|		} else {
  293|      0|			if (which == 1) {
  294|      0|				// front of a vowel
  295|      0|				if (fmt_params->fmt_control == 1) {
  296|      0|					// This is the default start of a vowel.
  297|      0|					// Allow very short vowels to have shorter front parts
  298|      0|					if (fmt_params->std_length < 130)
  299|      0|						frames[0].length = (frames[0].length * fmt_params->std_length)/130;
  300|      0|				}
  301|      0|			} else {
  302|      0|				// not a vowel
  303|      0|				if (fmt_params->std_length > 0)
  304|      0|					seq_len_adjust += (fmt_params->std_length - length1);
  305|      0|			}
  306|      0|
  307|      0|			if (seq_len_adjust != 0) {
  308|      0|				length_factor = ((length1 + seq_len_adjust) * 256)/length1;
  309|      0|				for (ix = 0; ix < nf1; ix++)
  310|      0|					frames[ix].length = (frames[ix].length * length_factor)/256;
  311|      0|			}
  312|      0|		}
  313|      0|	}
  314|      0|
  315|      0|	*n_frames = nf;
  316|      0|	return frames;
  317|      0|}
  318|       |
  319|       |unsigned char *GetEnvelope(int index)
  320|      0|{
  321|      0|	if (index == 0) {
  322|      0|		fprintf(stderr, "espeak: No envelope\n");
  323|      0|		return envelope_data[0]; // not found, use a default envelope
  324|      0|	}
  325|      0|	return (unsigned char *)&phondata_ptr[index];
  326|      0|}
  327|       |
  328|       |static void SetUpPhonemeTable(int number)
  329|      0|{
  330|      0|	int ix;
  331|      0|	int includes;
  332|      0|	int ph_code;
  333|      0|	PHONEME_TAB *phtab;
  334|      0|
  335|      0|	if ((includes = phoneme_tab_list[number].includes) > 0) {
  336|      0|		// recursively include base phoneme tables
  337|      0|		SetUpPhonemeTable(includes - 1);
  338|      0|	}
  339|      0|
  340|      0|	// now add the phonemes from this table
  341|      0|	phtab = phoneme_tab_list[number].phoneme_tab_ptr;
  342|      0|	for (ix = 0; ix < phoneme_tab_list[number].n_phonemes; ix++) {
  343|      0|		ph_code = phtab[ix].code;
  344|      0|		phoneme_tab[ph_code] = &phtab[ix];
  345|      0|		if (ph_code > n_phoneme_tab)
  346|      0|			n_phoneme_tab = ph_code;
  347|      0|	}
  348|      0|}
  349|       |
  350|       |void SelectPhonemeTable(int number)
  351|      0|{
  352|      0|	n_phoneme_tab = 0;
  353|      0|	SetUpPhonemeTable(number); // recursively for included phoneme tables
  354|      0|	n_phoneme_tab++;
  355|      0|	current_phoneme_table = number;
  356|      0|}
  357|       |
  358|       |int LookupPhonemeTable(const char *name)
  359|      0|{
  360|      0|	int ix;
  361|      0|
  362|      0|	for (ix = 0; ix < n_phoneme_tables; ix++) {
  363|      0|		if (strcmp(name, phoneme_tab_list[ix].name) == 0) {
  364|      0|			phoneme_tab_number = ix;
  365|      0|			break;
  366|      0|		}
  367|      0|	}
  368|      0|	if (ix == n_phoneme_tables)
  369|      0|		return -1;
  370|      0|
  371|      0|	return ix;
  372|      0|}
  373|       |
  374|       |int SelectPhonemeTableName(const char *name)
  375|      0|{
  376|      0|	// Look up a phoneme set by name, and select it if it exists
  377|      0|	// Returns the phoneme table number
  378|      0|	int ix;
  379|      0|
  380|      0|	if ((ix = LookupPhonemeTable(name)) == -1)
  381|      0|		return -1;
  382|      0|
  383|      0|	SelectPhonemeTable(ix);
  384|      0|	return ix;
  385|      0|}
  386|       |
  387|       |void LoadConfig(void)
  388|      0|{
  389|      0|	// Load configuration file, if one exists
  390|      0|	char buf[sizeof(path_home)+10];
  391|      0|	FILE *f;
  392|      0|	int ix;
  393|      0|	char c1;
  394|      0|	char string[200];
  395|      0|
  396|      0|	sprintf(buf, "%s%c%s", path_home, PATHSEP, "config");
  397|      0|	if ((f = fopen(buf, "r")) == NULL)
  398|      0|		return;
  399|      0|
  400|      0|	while (fgets(buf, sizeof(buf), f) != NULL) {
  401|      0|		if (buf[0] == '/')  continue;
  402|      0|
  403|      0|		if (memcmp(buf, "tone", 4) == 0)
  404|      0|			ReadTonePoints(&buf[5], tone_points);
  405|      0|		else if (memcmp(buf, "soundicon", 9) == 0) {
  406|      0|			ix = sscanf(&buf[10], "_%c %s", &c1, string);
  407|      0|			if (ix == 2) {
  408|      0|				// add sound file information to soundicon array
  409|      0|				// the file will be loaded to memory by LoadSoundFile2()
  410|      0|				soundicon_tab[n_soundicon_tab].name = c1;
  411|      0|				soundicon_tab[n_soundicon_tab].filename = strdup(string);
  412|      0|				soundicon_tab[n_soundicon_tab++].length = 0;
  413|      0|			}
  414|      0|		}
  415|      0|	}
  416|      0|	fclose(f);
  417|      0|}
  418|       |
  419|       |static void InvalidInstn(PHONEME_TAB *ph, int instn)
  420|      0|{
  421|      0|	fprintf(stderr, "Invalid instruction %.4x for phoneme '%s'\n", instn, WordToString(ph->mnemonic));
  422|      0|}
  423|       |
  424|       |static bool StressCondition(Translator *tr, PHONEME_LIST *plist, int condition, int control)
  425|      0|{
  426|      0|	int stress_level;
  427|      0|	PHONEME_LIST *pl;
  428|      0|	static int condition_level[4] = { 1, 2, 4, 15 };
  429|      0|
  430|      0|	if (phoneme_tab[plist[0].phcode]->type == phVOWEL)
  431|      0|		pl = plist;
  432|      0|	else {
  433|      0|		// consonant, get stress from the following vowel
  434|      0|		if (phoneme_tab[plist[1].phcode]->type == phVOWEL)
  435|      0|			pl = &plist[1];
  436|      0|		else
  437|      0|			return false; // no stress elevel for this consonant
  438|      0|	}
  439|      0|
  440|      0|	stress_level = pl->stresslevel & 0xf;
  441|      0|
  442|      0|	if (tr != NULL) {
  443|      0|		if ((control & 1) && (plist->synthflags & SFLAG_DICTIONARY) && ((tr->langopts.param[LOPT_REDUCE] & 1) == 0)) {
  444|      0|			// change phoneme.  Don't change phonemes which are given for the word in the dictionary.
  445|      0|			return false;
  446|      0|		}
  447|      0|
  448|      0|		if ((tr->langopts.param[LOPT_REDUCE] & 0x2) && (stress_level >= pl->wordstress)) {
  449|      0|			// treat the most stressed syllable in an unstressed word as stressed
  450|      0|			stress_level = STRESS_IS_PRIMARY;
  451|      0|		}
  452|      0|	}
  453|      0|
  454|      0|	if (condition == STRESS_IS_PRIMARY)
  455|      0|		return stress_level >= pl->wordstress;
  456|      0|
  457|      0|	if (condition == STRESS_IS_SECONDARY) {
  458|      0|		if (stress_level > STRESS_IS_SECONDARY)
  459|      0|			return true;
  460|      0|	} else {
  461|      0|		if (stress_level < condition_level[condition])
  462|      0|			return true;
  463|      0|	}
  464|      0|	return false;
  465|      0|
  466|      0|}
  467|       |
  468|       |static int CountVowelPosition(PHONEME_LIST *plist)
  469|      0|{
  470|      0|	int count = 0;
  471|      0|
  472|      0|	for (;;) {
  473|      0|		if (plist->ph->type == phVOWEL)
  474|      0|			count++;
  475|      0|		if (plist->sourceix != 0)
  476|      0|			break;
  477|      0|		plist--;
  478|      0|	}
  479|      0|	return count;
  480|      0|}
  481|       |
  482|       |static bool InterpretCondition(Translator *tr, int control, PHONEME_LIST *plist, unsigned short *p_prog, WORD_PH_DATA *worddata)
  483|      0|{
  484|      0|	int which;
  485|      0|	int ix;
  486|      0|	unsigned int data;
  487|      0|	int instn;
  488|      0|	int instn2;
  489|      0|	bool check_endtype = false;
  490|      0|	PHONEME_TAB *ph;
  491|      0|	PHONEME_LIST *plist_this;
  492|      0|
  493|      0|	// instruction: 2xxx, 3xxx
  494|      0|
  495|      0|	// bits 8-10 = 0 to 5,  which phoneme, =6 the 'which' information is in the next instruction.
  496|      0|	// bit 11 = 0, bits 0-7 are a phoneme code
  497|      0|	// bit 11 = 1, bits 5-7 type of data, bits 0-4 data value
  498|      0|
  499|      0|	// bits 8-10 = 7,  other conditions
  500|      0|
  501|      0|	instn = (*p_prog) & 0xfff;
  502|      0|	data = instn & 0xff;
  503|      0|	instn2 = instn >> 8;
  504|      0|
  505|      0|	if (instn2 < 14) {
  506|      0|		plist_this = plist;
  507|      0|		which = (instn2) % 7;
  508|      0|
  509|      0|		if (which == 6) {
  510|      0|			// the 'which' code is in the next instruction
  511|      0|			p_prog++;
  512|      0|			which = (*p_prog);
  513|      0|		}
  514|      0|
  515|      0|		if (which == 4) {
  516|      0|			// nextPhW not word boundary
  517|      0|			if (plist[1].sourceix)
  518|      0|				return false;
  519|      0|		}
  520|      0|		if (which == 5) {
  521|      0|			// prevPhW, not word boundary
  522|      0|			if (plist[0].sourceix)
  523|      0|				return false;
  524|      0|		}
  525|      0|		if (which == 6) {
  526|      0|			// next2PhW, not word boundary
  527|      0|			if (plist[1].sourceix || plist[2].sourceix)
  528|      0|				return false;
  529|      0|		}
  530|      0|
  531|      0|		switch (which)
  532|      0|		{
  533|      0|		case 0: // prevPh
  534|      0|		case 5: // prevPhW
  535|      0|			plist--;
  536|      0|			check_endtype = true;
  537|      0|			break;
  538|      0|		case 1: // thisPh
  539|      0|			break;
  540|      0|		case 2: // nextPh
  541|      0|		case 4: // nextPhW
  542|      0|			plist++;
  543|      0|			break;
  544|      0|		case 3: // next2Ph
  545|      0|		case 6: // next2PhW
  546|      0|			plist += 2;
  547|      0|			break;
  548|      0|		case 7:
  549|      0|			// nextVowel, not word boundary
  550|      0|			for (which = 1;; which++) {
  551|      0|				if (plist[which].sourceix)
  552|      0|					return false;
  553|      0|				if (phoneme_tab[plist[which].phcode]->type == phVOWEL) {
  554|      0|					plist = &plist[which];
  555|      0|					break;
  556|      0|				}
  557|      0|			}
  558|      0|			break;
  559|      0|		case 8: // prevVowel in this word
  560|      0|			if ((worddata == NULL) || (worddata->prev_vowel.ph == NULL))
  561|      0|				return false; // no previous vowel
  562|      0|			plist = &(worddata->prev_vowel);
  563|      0|			check_endtype = true;
  564|      0|			break;
  565|      0|		case 9: // next3PhW
  566|      0|			for (ix = 1; ix <= 3; ix++) {
  567|      0|				if (plist[ix].sourceix)
  568|      0|					return false;
  569|      0|			}
  570|      0|			plist = &plist[3];
  571|      0|			break;
  572|      0|		case 10: // prev2PhW
  573|      0|			if ((plist[0].sourceix) || (plist[-1].sourceix))
  574|      0|				return false;
  575|      0|			plist -= 2;
  576|      0|			check_endtype = true;
  577|      0|			break;
  578|      0|		}
  579|      0|
  580|      0|		if ((which == 0) || (which == 5)) {
  581|      0|			if (plist->phcode == 1) {
  582|      0|				// This is a NULL phoneme, a phoneme has been deleted so look at the previous phoneme
  583|      0|				plist--;
  584|      0|			}
  585|      0|		}
  586|      0|
  587|      0|		if (control & 0x100) {
  588|      0|			// "change phonemes" pass
  589|      0|			plist->ph = phoneme_tab[plist->phcode];
  590|      0|		}
  591|      0|		ph = plist->ph;
  592|      0|
  593|      0|		if (instn2 < 7) {
  594|      0|			// 'data' is a phoneme number
  595|      0|			if ((phoneme_tab[data]->mnemonic == ph->mnemonic) == true)
  596|      0|				return true;
  597|      0|
  598|      0|			//  not an exact match, check for a vowel type (eg. #i )
  599|      0|			if ((check_endtype) && (ph->type == phVOWEL))
  600|      0|				return data == ph->end_type; // prevPh() match on end_type
  601|      0|			return data == ph->start_type; // thisPh() or nextPh(), match on start_type
  602|      0|		}
  603|      0|
  604|      0|		data = instn & 0x1f;
  605|      0|
  606|      0|		switch (instn & 0xe0)
  607|      0|		{
  608|      0|		case CONDITION_IS_PHONEME_TYPE:
  609|      0|			return ph->type == data;
  610|      0|		case CONDITION_IS_PLACE_OF_ARTICULATION:
  611|      0|			return ((ph->phflags >> 16) & 0xf) == data;
  612|      0|		case CONDITION_IS_PHFLAG_SET:
  613|      0|			return (ph->phflags & (1 << data)) != 0;
  614|      0|		case CONDITION_IS_OTHER:
  615|      0|			switch (data)
  616|      0|			{
  617|      0|			case STRESS_IS_DIMINISHED:
  618|      0|			case STRESS_IS_UNSTRESSED:
  619|      0|			case STRESS_IS_NOT_STRESSED:
  620|      0|			case STRESS_IS_SECONDARY:
  621|      0|			case STRESS_IS_PRIMARY:
  622|      0|				return StressCondition(tr, plist, data, 0);
  623|      0|			case isBreak:
  624|      0|				return (ph->type == phPAUSE) || (plist_this->synthflags & SFLAG_NEXT_PAUSE);
  625|      0|			case isWordStart:
  626|      0|				return plist->sourceix != 0;
  627|      0|			case isWordEnd:
  628|      0|				return plist[1].sourceix || (plist[1].ph->type == phPAUSE);
  629|      0|			case isAfterStress:
  630|      0|				if (plist->sourceix != 0)
  631|      0|					return false;
  632|      0|				do {
  633|      0|					plist--;
  634|      0|					if ((plist->stresslevel & 0xf) >= 4)
  635|      0|						return true;
  636|      0|
  637|      0|				} while (plist->sourceix == 0);
  638|      0|				break;
  639|      0|			case isNotVowel:
  640|      0|				return ph->type != phVOWEL;
  641|      0|			case isFinalVowel:
  642|      0|				for (;;) {
  643|      0|					plist++;
  644|      0|					if (plist->sourceix != 0)
  645|      0|						return true; // start of next word, without finding another vowel
  646|      0|					if (plist->ph->type == phVOWEL)
  647|      0|						return false;
  648|      0|				}
  649|      0|			case isVoiced:
  650|      0|				return (ph->type == phVOWEL) || (ph->type == phLIQUID) || (ph->phflags & phVOICED);
  651|      0|			case isFirstVowel:
  652|      0|				return CountVowelPosition(plist) == 1;
  653|      0|			case isSecondVowel:
  654|      0|				return CountVowelPosition(plist) == 2;
  655|      0|			case isTranslationGiven:
  656|      0|				return (plist->synthflags & SFLAG_DICTIONARY) != 0;
  657|      0|			}
  658|      0|			break;
  659|      0|
  660|      0|		}
  661|      0|		return false;
  662|      0|	} else if (instn2 == 0xf) {
  663|      0|		// Other conditions
  664|      0|		switch (data)
  665|      0|		{
  666|      0|		case 1: // PreVoicing
  667|      0|			return control & 1;
  668|      0|		case 2: // KlattSynth
  669|      0|			return voice->klattv[0] != 0;
  670|      0|		case 3: // MbrolaSynth
  671|      0|			return mbrola_name[0] != 0;
  672|      0|		}
  673|      0|	}
  674|      0|	return false;
  675|      0|}
  676|       |
  677|       |static void SwitchOnVowelType(PHONEME_LIST *plist, PHONEME_DATA *phdata, unsigned short **p_prog, int instn_type)
  678|      0|{
  679|      0|	unsigned short *prog;
  680|      0|	int voweltype;
  681|      0|	signed char x;
  682|      0|
  683|      0|	if (instn_type == 2) {
  684|      0|		phdata->pd_control |= pd_FORNEXTPH;
  685|      0|		voweltype = plist[1].ph->start_type; // SwitchNextVowelType
  686|      0|	} else
  687|      0|		voweltype = plist[-1].ph->end_type; // SwitchPrevVowelType
  688|      0|
  689|      0|	voweltype -= phonVOWELTYPES;
  690|      0|	if ((voweltype >= 0) && (voweltype < 6)) {
  691|      0|		prog = *p_prog + voweltype*2;
  692|      0|		phdata->sound_addr[instn_type] = (((prog[1] & 0xf) << 16) + prog[2]) * 4;
  693|      0|		x = (prog[1] >> 4) & 0xff;
  694|      0|		phdata->sound_param[instn_type] = x; // sign extend
  695|      0|	}
  696|      0|
  697|      0|	*p_prog += 12;
  698|      0|}
  699|       |
  700|       |static int NumInstnWords(unsigned short *prog)
  701|      0|{
  702|      0|	int instn;
  703|      0|	int instn2;
  704|      0|	int instn_type;
  705|      0|	int n;
  706|      0|	int type2;
  707|      0|	static const char n_words[16] = { 0, 1, 0, 0, 1, 1, 0, 1, 1, 2, 4, 0, 0, 0, 0, 0 };
  708|      0|
  709|      0|	instn = *prog;
  710|      0|	instn_type = instn >> 12;
  711|      0|	if ((n = n_words[instn_type]) > 0)
  712|      0|		return n;
  713|      0|
  714|      0|	switch (instn_type)
  715|      0|	{
  716|      0|	case 0:
  717|      0|		if (((instn & 0xf00) >> 8) == i_IPA_NAME) {
  718|      0|			n = ((instn & 0xff) + 1) / 2;
  719|      0|			return n+1;
  720|      0|		}
  721|      0|		return 1;
  722|      0|	case 6:
  723|      0|		type2 = (instn & 0xf00) >> 9;
  724|      0|		if ((type2 == 5) || (type2 == 6))
  725|      0|			return 12; // switch on vowel type
  726|      0|		return 1;
  727|      0|	case 2:
  728|      0|	case 3:
  729|      0|		// a condition, check for a 2-word instruction
  730|      0|		if (((n = instn & 0x0f00) == 0x600) || (n == 0x0d00))
  731|      0|			return 2;
  732|      0|		return 1;
  733|      0|	default:
  734|      0|		// instn_type 11 to 15, 2 words
  735|      0|		instn2 = prog[2];
  736|      0|		if ((instn2 >> 12) == 0xf) {
  737|      0|			// This instruction is followed by addWav(), 2 more words
  738|      0|			return 4;
  739|      0|		}
  740|      0|		if (instn2 == INSTN_CONTINUE)
  741|      0|			return 3;
  742|      0|		return 2;
  743|      0|	}
  744|      0|}
  745|       |
  746|       |void InterpretPhoneme(Translator *tr, int control, PHONEME_LIST *plist, PHONEME_DATA *phdata, WORD_PH_DATA *worddata)
  747|      0|{
  748|      0|	// control:
  749|      0|	// bit 0:  PreVoicing
  750|      0|	// bit 8:  change phonemes
  751|      0|
  752|      0|	PHONEME_TAB *ph;
  753|      0|	unsigned short *prog;
  754|      0|	unsigned short instn;
  755|      0|	int instn2;
  756|      0|	int or_flag;
  757|      0|	bool truth;
  758|      0|	bool truth2;
  759|      0|	int data;
  760|      0|	int end_flag;
  761|      0|	int ix;
  762|      0|	signed char param_sc;
  763|      0|
  764|      0|	#define N_RETURN 10
  765|      0|	int n_return = 0;
  766|      0|	unsigned short *return_addr[N_RETURN]; // return address stack
  767|      0|
  768|      0|	ph = plist->ph;
  769|      0|
  770|      0|	if ((worddata != NULL) && (plist->sourceix)) {
  771|      0|		// start of a word, reset word data
  772|      0|		worddata->prev_vowel.ph = NULL;
  773|      0|	}
  774|      0|
  775|      0|	memset(phdata, 0, sizeof(PHONEME_DATA));
  776|      0|	phdata->pd_param[i_SET_LENGTH] = ph->std_length;
  777|      0|	phdata->pd_param[i_LENGTH_MOD] = ph->length_mod;
  778|      0|
  779|      0|	if (ph->program == 0)
  780|      0|		return;
  781|      0|
  782|      0|	end_flag = 0;
  783|      0|
  784|      0|	for (prog = &phoneme_index[ph->program]; end_flag != 1; prog++) {
  785|      0|		instn = *prog;
  786|      0|		instn2 = (instn >> 8) & 0xf;
  787|      0|
  788|      0|		switch (instn >> 12)
  789|      0|		{
  790|      0|		case 0: // 0xxx
  791|      0|			data = instn & 0xff;
  792|      0|
  793|      0|			if (instn2 == 0) {
  794|      0|				// instructions with no operand
  795|      0|				switch (data)
  796|      0|				{
  797|      0|				case INSTN_RETURN:
  798|      0|					end_flag = 1;
  799|      0|					break;
  800|      0|				case INSTN_CONTINUE:
  801|      0|					break;
  802|      0|				default:
  803|      0|					InvalidInstn(ph, instn);
  804|      0|					break;
  805|      0|				}
  806|      0|			} else if (instn2 == i_APPEND_IFNEXTVOWEL) {
  807|      0|				if (phoneme_tab[plist[1].phcode]->type == phVOWEL)
  808|      0|					phdata->pd_param[i_APPEND_PHONEME] = data;
  809|      0|			} else if (instn2 == i_ADD_LENGTH) {
  810|      0|				if (data & 0x80) {
  811|      0|					// a negative value, do sign extension
  812|      0|					data = -(0x100 - data);
  813|      0|				}
  814|      0|				phdata->pd_param[i_SET_LENGTH] += data;
  815|      0|			} else if (instn2 == i_IPA_NAME) {
  816|      0|				// followed by utf-8 characters, 2 per instn word
  817|      0|				for (ix = 0; (ix < data) && (ix < 16); ix += 2) {
  818|      0|					prog++;
  819|      0|					phdata->ipa_string[ix] = prog[0] >> 8;
  820|      0|					phdata->ipa_string[ix+1] = prog[0] & 0xff;
  821|      0|				}
  822|      0|				phdata->ipa_string[ix] = 0;
  823|      0|			} else if (instn2 < N_PHONEME_DATA_PARAM) {
  824|      0|				phdata->pd_param[instn2] = data;
  825|      0|				if ((instn2 == i_CHANGE_PHONEME) && (control & 0x100)) {
  826|      0|					// found ChangePhoneme() in PhonemeList mode, exit
  827|      0|					end_flag = 1;
  828|      0|				}
  829|      0|			} else
  830|      0|				InvalidInstn(ph, instn);
  831|      0|			break;
  832|      0|		case 1:
  833|      0|			if (tr == NULL)
  834|      0|				break; // ignore if in synthesis stage
  835|      0|
  836|      0|			if (instn2 < 8) {
  837|      0|				// ChangeIf
  838|      0|				if (StressCondition(tr, plist, instn2 & 7, 1) == true) {
  839|      0|					phdata->pd_param[i_CHANGE_PHONEME] = instn & 0xff;
  840|      0|					end_flag = 1; // change phoneme, exit
  841|      0|				}
  842|      0|			}
  843|      0|			break;
  844|      0|		case 2:
  845|      0|		case 3:
  846|      0|			// conditions
  847|      0|			or_flag = 0;
  848|      0|			truth = true;
  849|      0|			while ((instn & 0xe000) == 0x2000) {
  850|      0|				// process a sequence of conditions, using  boolean accumulator
  851|      0|				truth2 = InterpretCondition(tr, control, plist, prog, worddata);
  852|      0|				prog += NumInstnWords(prog);
  853|      0|				if (*prog == i_NOT) {
  854|      0|					truth2 = truth2 ^ 1;
  855|      0|					prog++;
  856|      0|				}
  857|      0|
  858|      0|				if (or_flag)
  859|      0|					truth = truth || truth2;
  860|      0|				else
  861|      0|					truth = truth && truth2;
  862|      0|				or_flag = instn & 0x1000;
  863|      0|				instn = *prog;
  864|      0|			}
  865|      0|
  866|      0|			if (truth == false) {
  867|      0|				if ((instn & 0xf800) == i_JUMP_FALSE)
  868|      0|					prog += instn & 0xff;
  869|      0|				else {
  870|      0|					// instruction after a condition is not JUMP_FALSE, so skip the instruction.
  871|      0|					prog += NumInstnWords(prog);
  872|      0|					if ((prog[0] & 0xfe00) == 0x6000)
  873|      0|						prog++; // and skip ELSE jump
  874|      0|				}
  875|      0|			}
  876|      0|			prog--;
  877|      0|			break;
  878|      0|		case 6:
  879|      0|			// JUMP
  880|      0|			switch (instn2 >> 1)
  881|      0|			{
  882|      0|			case 0:
  883|      0|				prog += (instn & 0xff) - 1;
  884|      0|				break;
  885|      0|			case 4:
  886|      0|				// conditional jumps should have been processed in the Condition section
  887|      0|				break;
  888|      0|			case 5: // NexttVowelStarts
  889|      0|				SwitchOnVowelType(plist, phdata, &prog, 2);
  890|      0|				break;
  891|      0|			case 6: // PrevVowelTypeEndings
  892|      0|				SwitchOnVowelType(plist, phdata, &prog, 3);
  893|      0|				break;
  894|      0|			}
  895|      0|			break;
  896|      0|		case 9:
  897|      0|			data = ((instn & 0xf) << 16) + prog[1];
  898|      0|			prog++;
  899|      0|			switch (instn2)
  900|      0|			{
  901|      0|			case 1:
  902|      0|				// call a procedure or another phoneme
  903|      0|				if (n_return < N_RETURN) {
  904|      0|					return_addr[n_return++] = prog;
  905|      0|					prog = &phoneme_index[data] - 1;
  906|      0|				}
  907|      0|				break;
  908|      0|			case 2:
  909|      0|				// pitch envelope
  910|      0|				phdata->pitch_env = data;
  911|      0|				break;
  912|      0|			case 3:
  913|      0|				// amplitude envelope
  914|      0|				phdata->amp_env = data;
  915|      0|				break;
  916|      0|			}
  917|      0|			break;
  918|      0|		case 10: //  Vowelin, Vowelout
  919|      0|			if (instn2 == 1)
  920|      0|				ix = 0;
  921|      0|			else
  922|      0|				ix = 2;
  923|      0|
  924|      0|			phdata->vowel_transition[ix] = ((prog[0] & 0xff) << 16) + prog[1];
  925|      0|			phdata->vowel_transition[ix+1] = (prog[2] << 16) + prog[3];
  926|      0|			prog += 3;
  927|      0|			break;
  928|      0|		case 11: // FMT
  929|      0|		case 12: // WAV
  930|      0|		case 13: // VowelStart
  931|      0|		case 14: // VowelEnd
  932|      0|		case 15: // addWav
  933|      0|			instn2 = (instn >> 12) - 11;
  934|      0|			phdata->sound_addr[instn2] = ((instn & 0xf) << 18) + (prog[1] << 2);
  935|      0|			param_sc = phdata->sound_param[instn2] = (instn >> 4) & 0xff;
  936|      0|			prog++;
  937|      0|
  938|      0|			if (prog[1] != INSTN_CONTINUE) {
  939|      0|				if (instn2 < 2) {
  940|      0|					// FMT() and WAV() imply Return
  941|      0|					end_flag = 1;
  942|      0|					if ((prog[1] >> 12) == 0xf) {
  943|      0|						// Return after the following addWav()
  944|      0|						end_flag = 2;
  945|      0|					}
  946|      0|				} else if (instn2 == pd_ADDWAV) {
  947|      0|					// addWav(), return if previous instruction was FMT() or WAV()
  948|      0|					end_flag--;
  949|      0|				}
  950|      0|
  951|      0|				if ((instn2 == pd_VWLSTART) || (instn2 == pd_VWLEND)) {
  952|      0|					// VowelStart or VowelEnding.
  953|      0|					phdata->sound_param[instn2] = param_sc;   // sign extend
  954|      0|				}
  955|      0|			}
  956|      0|			break;
  957|      0|		default:
  958|      0|			InvalidInstn(ph, instn);
  959|      0|			break;
  960|      0|		}
  961|      0|
  962|      0|		if ((end_flag == 1) && (n_return > 0)) {
  963|      0|			// return from called procedure or phoneme
  964|      0|			end_flag = 0;
  965|      0|			prog = return_addr[--n_return];
  966|      0|		}
  967|      0|	}
  968|      0|
  969|      0|	if ((worddata != NULL) && (plist->type == phVOWEL))
  970|      0|		memcpy(&worddata->prev_vowel, &plist[0], sizeof(PHONEME_LIST));
  971|      0|
  972|      0|	plist->std_length = phdata->pd_param[i_SET_LENGTH];
  973|      0|	if (phdata->sound_addr[0] != 0) {
  974|      0|		plist->phontab_addr = phdata->sound_addr[0]; // FMT address
  975|      0|		plist->sound_param = phdata->sound_param[0];
  976|      0|	} else {
  977|      0|		plist->phontab_addr = phdata->sound_addr[1]; // WAV address
  978|      0|		plist->sound_param = phdata->sound_param[1];
  979|      0|	}
  980|      0|}
  981|       |
  982|       |void InterpretPhoneme2(int phcode, PHONEME_DATA *phdata)
  983|      0|{
  984|      0|	// Examine the program of a single isolated phoneme
  985|      0|	int ix;
  986|      0|	PHONEME_LIST plist[4];
  987|      0|	memset(plist, 0, sizeof(plist));
  988|      0|
  989|      0|	for (ix = 0; ix < 4; ix++) {
  990|      0|		plist[ix].phcode = phonPAUSE;
  991|      0|		plist[ix].ph = phoneme_tab[phonPAUSE];
  992|      0|	}
  993|      0|
  994|      0|	plist[1].phcode = phcode;
  995|      0|	plist[1].ph = phoneme_tab[phcode];
  996|      0|	plist[2].sourceix = 1;
  997|      0|
  998|      0|	InterpretPhoneme(NULL, 0, &plist[1], phdata, NULL);
  999|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/synthesize.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2014 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2017 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <ctype.h>
   23|       |#include <errno.h>
   24|       |#include <math.h>
   25|       |#include <stdbool.h>
   26|       |#include <stdint.h>
   27|       |#include <stdio.h>
   28|       |#include <stdlib.h>
   29|       |#include <string.h>
   30|       |
   31|       |#include <espeak-ng/espeak_ng.h>
   32|       |#include <espeak-ng/speak_lib.h>
   33|       |#include <espeak-ng/encoding.h>
   34|       |
   35|       |#include "synthesize.h"
   36|       |#include "dictionary.h"           // for WritePhMnemonic, GetTranslatedPhone...
   37|       |#include "intonation.h"           // for CalcPitches
   38|       |#include "mbrola.h"               // for MbrolaGenerate, mbrola_name
   39|       |#include "phoneme.h"              // for PHONEME_TAB, phVOWEL, phLIQUID, phN...
   40|       |#include "setlengths.h"           // for CalcLengths
   41|       |#include "soundicon.h"               // for soundicon_tab, n_soundicon
   42|       |#include "synthdata.h"            // for InterpretPhoneme, GetEnvelope, Inte...
   43|       |#include "translate.h"            // for translator, LANGUAGE_OPTIONS, Trans...
   44|       |#include "voice.h"                // for voice_t, voice, LoadVoiceVariant
   45|       |#include "wavegen.h"              // for WcmdqInc, WcmdqFree, WcmdqStop
   46|       |
   47|       |static void SmoothSpect(void);
   48|       |
   49|       |// list of phonemes in a clause
   50|       |int n_phoneme_list = 0;
   51|       |PHONEME_LIST phoneme_list[N_PHONEME_LIST+1];
   52|       |
   53|       |SPEED_FACTORS speed;
   54|       |
   55|       |static int last_pitch_cmd;
   56|       |static int last_amp_cmd;
   57|       |static frame_t  *last_frame;
   58|       |static int last_wcmdq;
   59|       |static int pitch_length;
   60|       |static int amp_length;
   61|       |static int modn_flags;
   62|       |static int fmt_amplitude = 0;
   63|       |
   64|       |static int syllable_start;
   65|       |static int syllable_end;
   66|       |static int syllable_centre;
   67|       |
   68|       |static voice_t *new_voice = NULL;
   69|       |
   70|      0|#define RMS_GLOTTAL1 35   // vowel before glottal stop
   71|      0|#define RMS_START 28  // 28
   72|      0|#define VOWEL_FRONT_LENGTH  50
   73|       |
   74|       |const char *WordToString(unsigned int word)
   75|      0|{
   76|      0|	// Convert a phoneme mnemonic word into a string
   77|      0|	int ix;
   78|      0|	static char buf[5];
   79|      0|
   80|      0|	for (ix = 0; ix < 4; ix++)
   81|      0|		buf[ix] = word >> (ix*8);
   82|      0|	buf[4] = 0;
   83|      0|	return buf;
   84|      0|}
   85|       |
   86|       |void SynthesizeInit()
   87|      0|{
   88|      0|	last_pitch_cmd = 0;
   89|      0|	last_amp_cmd = 0;
   90|      0|	last_frame = NULL;
   91|      0|	syllable_centre = -1;
   92|      0|}
   93|       |
   94|       |static void EndAmplitude(void)
   95|      0|{
   96|      0|	if (amp_length > 0) {
   97|      0|		if (wcmdq[last_amp_cmd][1] == 0)
   98|      0|			wcmdq[last_amp_cmd][1] = amp_length;
   99|      0|		amp_length = 0;
  100|      0|	}
  101|      0|}
  102|       |
  103|       |static void EndPitch(int voice_break)
  104|      0|{
  105|      0|	// possible end of pitch envelope, fill in the length
  106|      0|	if ((pitch_length > 0) && (last_pitch_cmd >= 0)) {
  107|      0|		if (wcmdq[last_pitch_cmd][1] == 0)
  108|      0|			wcmdq[last_pitch_cmd][1] = pitch_length;
  109|      0|		pitch_length = 0;
  110|      0|	}
  111|      0|
  112|      0|	if (voice_break) {
  113|      0|		last_wcmdq = -1;
  114|      0|		last_frame = NULL;
  115|      0|		syllable_end = wcmdq_tail;
  116|      0|		SmoothSpect();
  117|      0|		syllable_centre = -1;
  118|      0|	}
  119|      0|}
  120|       |
  121|       |static void DoAmplitude(int amp, unsigned char *amp_env)
  122|      0|{
  123|      0|	intptr_t *q;
  124|      0|
  125|      0|	last_amp_cmd = wcmdq_tail;
  126|      0|	amp_length = 0; // total length of vowel with this amplitude envelope
  127|      0|
  128|      0|	q = wcmdq[wcmdq_tail];
  129|      0|	q[0] = WCMD_AMPLITUDE;
  130|      0|	q[1] = 0; // fill in later from amp_length
  131|      0|	q[2] = (intptr_t)amp_env;
  132|      0|	q[3] = amp;
  133|      0|	WcmdqInc();
  134|      0|}
  135|       |
  136|       |static void DoPhonemeAlignment(char* pho, int type)
  137|      0|{
  138|      0|	wcmdq[wcmdq_tail][0] = WCMD_PHONEME_ALIGNMENT;
  139|      0|	wcmdq[wcmdq_tail][1] = (intptr_t)pho;
  140|      0|	wcmdq[wcmdq_tail][2] = type;
  141|      0|	WcmdqInc();
  142|      0|}
  143|       |
  144|       |static void DoPitch(unsigned char *env, int pitch1, int pitch2)
  145|      0|{
  146|      0|	intptr_t *q;
  147|      0|
  148|      0|	EndPitch(0);
  149|      0|
  150|      0|	if (pitch1 == 255) {
  151|      0|		// pitch was not set
  152|      0|		pitch1 = 55;
  153|      0|		pitch2 = 76;
  154|      0|		env = envelope_data[PITCHfall];
  155|      0|	}
  156|      0|	last_pitch_cmd = wcmdq_tail;
  157|      0|	pitch_length = 0; // total length of spect with this pitch envelope
  158|      0|
  159|      0|	if (pitch2 < 0)
  160|      0|		pitch2 = 0;
  161|      0|
  162|      0|	q = wcmdq[wcmdq_tail];
  163|      0|	q[0] = WCMD_PITCH;
  164|      0|	q[1] = 0; // length, fill in later from pitch_length
  165|      0|	q[2] = (intptr_t)env;
  166|      0|	q[3] = (pitch1 << 16) + pitch2;
  167|      0|	WcmdqInc();
  168|      0|}
  169|       |
  170|       |int PauseLength(int pause, int control)
  171|      0|{
  172|      0|	unsigned int len;
  173|      0|
  174|      0|	if (control == 0) {
  175|      0|		if (pause >= 200)
  176|      0|			len = (pause * speed.clause_pause_factor)/256;
  177|      0|		else
  178|      0|			len = (pause * speed.pause_factor)/256;
  179|      0|	} else
  180|      0|		len = (pause * speed.wav_factor)/256;
  181|      0|
  182|      0|	if (len < speed.min_pause)
  183|      0|		len = speed.min_pause; // mS, limit the amount to which pauses can be shortened
  184|      0|	return len;
  185|      0|}
  186|       |
  187|       |static void DoPause(int length, int control)
  188|      0|{
  189|      0|	// length in nominal mS
  190|      0|	// control = 1, less shortening at fast speeds
  191|      0|
  192|      0|	unsigned int len;
  193|      0|	int srate2;
  194|      0|
  195|      0|	if (length == 0)
  196|      0|		len = 0;
  197|      0|	else {
  198|      0|		len = PauseLength(length, control);
  199|      0|
  200|      0|		if (len < 90000)
  201|      0|			len = (len * samplerate) / 1000; // convert from mS to number of samples
  202|      0|		else {
  203|      0|			srate2 = samplerate / 25; // avoid overflow
  204|      0|			len = (len * srate2) / 40;
  205|      0|		}
  206|      0|	}
  207|      0|
  208|      0|	EndPitch(1);
  209|      0|	wcmdq[wcmdq_tail][0] = WCMD_PAUSE;
  210|      0|	wcmdq[wcmdq_tail][1] = len;
  211|      0|	WcmdqInc();
  212|      0|	last_frame = NULL;
  213|      0|
  214|      0|	if (fmt_amplitude != 0) {
  215|      0|		wcmdq[wcmdq_tail][0] = WCMD_FMT_AMPLITUDE;
  216|      0|		wcmdq[wcmdq_tail][1] = fmt_amplitude = 0;
  217|      0|		WcmdqInc();
  218|      0|	}
  219|      0|}
  220|       |
  221|       |extern int seq_len_adjust; // temporary fix to advance the start point for playing the wav sample
  222|       |
  223|       |static int DoSample2(int index, int which, int std_length, int control, int length_mod, int amp)
  224|      0|{
  225|      0|	int length;
  226|      0|	int wav_length;
  227|      0|	int wav_scale;
  228|      0|	int min_length;
  229|      0|	int x;
  230|      0|	int len4;
  231|      0|	intptr_t *q;
  232|      0|	unsigned char *p;
  233|      0|
  234|      0|	index = index & 0x7fffff;
  235|      0|	p = &wavefile_data[index];
  236|      0|	wav_scale = p[2];
  237|      0|	wav_length = (p[1] * 256);
  238|      0|	wav_length += p[0]; // length in bytes
  239|      0|
  240|      0|	if (wav_length == 0)
  241|      0|		return 0;
  242|      0|
  243|      0|	min_length = speed.min_sample_len;
  244|      0|
  245|      0|	if (wav_scale == 0)
  246|      0|		min_length *= 2; // 16 bit samples
  247|      0|
  248|      0|	if (std_length > 0) {
  249|      0|		std_length = (std_length * samplerate)/1000;
  250|      0|		if (wav_scale == 0)
  251|      0|			std_length *= 2;
  252|      0|
  253|      0|		x = (min_length * std_length)/wav_length;
  254|      0|		if (x > min_length)
  255|      0|			min_length = x;
  256|      0|	} else {
  257|      0|		// no length specified, use the length of the stored sound
  258|      0|		std_length = wav_length;
  259|      0|	}
  260|      0|
  261|      0|	if (length_mod > 0)
  262|      0|		std_length = (std_length * length_mod)/256;
  263|      0|
  264|      0|	length = (std_length * speed.wav_factor)/256;
  265|      0|
  266|      0|	if (control & pd_DONTLENGTHEN) {
  267|      0|		// this option is used for Stops, with short noise bursts.
  268|      0|		// Don't change their length much.
  269|      0|		if (length > std_length) {
  270|      0|			// don't let length exceed std_length
  271|      0|			length = std_length;
  272|      0|		}
  273|      0|	}
  274|      0|
  275|      0|	if (length < min_length)
  276|      0|		length = min_length;
  277|      0|
  278|      0|
  279|      0|	if (wav_scale == 0) {
  280|      0|		// 16 bit samples
  281|      0|		length /= 2;
  282|      0|		wav_length /= 2;
  283|      0|	}
  284|      0|
  285|      0|	if (amp < 0)
  286|      0|		return length;
  287|      0|
  288|      0|	len4 = wav_length / 4;
  289|      0|
  290|      0|	index += 4;
  291|      0|
  292|      0|	if (which & 0x100) {
  293|      0|		// mix this with synthesised wave
  294|      0|		last_wcmdq = wcmdq_tail;
  295|      0|		q = wcmdq[wcmdq_tail];
  296|      0|		q[0] = WCMD_WAVE2;
  297|      0|		q[1] = length | (wav_length << 16); // length in samples
  298|      0|		q[2] = (intptr_t)(&wavefile_data[index]);
  299|      0|		q[3] = wav_scale + (amp << 8);
  300|      0|		WcmdqInc();
  301|      0|		return length;
  302|      0|	}
  303|      0|
  304|      0|	if (length > wav_length) {
  305|      0|		x = len4*3;
  306|      0|		length -= x;
  307|      0|	} else {
  308|      0|		x = length;
  309|      0|		length = 0;
  310|      0|	}
  311|      0|
  312|      0|	last_wcmdq = wcmdq_tail;
  313|      0|	q = wcmdq[wcmdq_tail];
  314|      0|	q[0] = WCMD_WAVE;
  315|      0|	q[1] = x; // length in samples
  316|      0|	q[2] = (intptr_t)(&wavefile_data[index]);
  317|      0|	q[3] = wav_scale + (amp << 8);
  318|      0|	WcmdqInc();
  319|      0|
  320|      0|	while (length > len4*3) {
  321|      0|		x = len4;
  322|      0|		if (wav_scale == 0)
  323|      0|			x *= 2;
  324|      0|
  325|      0|		last_wcmdq = wcmdq_tail;
  326|      0|		q = wcmdq[wcmdq_tail];
  327|      0|		q[0] = WCMD_WAVE;
  328|      0|		q[1] = len4*2; // length in samples
  329|      0|		q[2] = (intptr_t)(&wavefile_data[index+x]);
  330|      0|		q[3] = wav_scale + (amp << 8);
  331|      0|		WcmdqInc();
  332|      0|
  333|      0|		length -= len4*2;
  334|      0|	}
  335|      0|
  336|      0|	if (length > 0) {
  337|      0|		x = wav_length - length;
  338|      0|		if (wav_scale == 0)
  339|      0|			x *= 2;
  340|      0|		last_wcmdq = wcmdq_tail;
  341|      0|		q = wcmdq[wcmdq_tail];
  342|      0|		q[0] = WCMD_WAVE;
  343|      0|		q[1] = length; // length in samples
  344|      0|		q[2] = (intptr_t)(&wavefile_data[index+x]);
  345|      0|		q[3] = wav_scale + (amp << 8);
  346|      0|		WcmdqInc();
  347|      0|	}
  348|      0|
  349|      0|	return length;
  350|      0|}
  351|       |
  352|       |int DoSample3(PHONEME_DATA *phdata, int length_mod, int amp)
  353|      0|{
  354|      0|	int amp2;
  355|      0|	int len;
  356|      0|	EndPitch(1);
  357|      0|
  358|      0|	if (amp == -1) {
  359|      0|		// just get the length, don't produce sound
  360|      0|		amp2 = amp;
  361|      0|	} else {
  362|      0|		amp2 = phdata->sound_param[pd_WAV];
  363|      0|		if (amp2 == 0)
  364|      0|			amp2 = 100;
  365|      0|		amp2 = (amp2 * 32)/100;
  366|      0|	}
  367|      0|
  368|      0|	seq_len_adjust = 0;
  369|      0|
  370|      0|	if (phdata->sound_addr[pd_WAV] == 0)
  371|      0|		len = 0;
  372|      0|	else
  373|      0|		len = DoSample2(phdata->sound_addr[pd_WAV], 2, phdata->pd_param[pd_LENGTHMOD]*2, phdata->pd_control, length_mod, amp2);
  374|      0|	last_frame = NULL;
  375|      0|	return len;
  376|      0|}
  377|       |
  378|       |static frame_t *AllocFrame()
  379|      0|{
  380|      0|	// Allocate a temporary spectrum frame for the wavegen queue. Use a pool which is big
  381|      0|	// enough to use a round-robin without checks.
  382|      0|	// Only needed for modifying spectra for blending to consonants
  383|      0|
  384|      0|	#define N_FRAME_POOL N_WCMDQ
  385|      0|	static int ix = 0;
  386|      0|	static frame_t frame_pool[N_FRAME_POOL];
  387|      0|
  388|      0|	ix++;
  389|      0|	if (ix >= N_FRAME_POOL)
  390|      0|		ix = 0;
  391|      0|	return &frame_pool[ix];
  392|      0|}
  393|       |
  394|       |static void set_frame_rms(frame_t *fr, int new_rms)
  395|      0|{
  396|      0|	// Each frame includes its RMS amplitude value, so to set a new
  397|      0|	// RMS just adjust the formant amplitudes by the appropriate ratio
  398|      0|
  399|      0|	int x;
  400|      0|	int h;
  401|      0|	int ix;
  402|      0|
  403|      0|	static const short sqrt_tab[200] = {
  404|      0|		  0,  64,  90, 110, 128, 143, 156, 169, 181, 192, 202, 212, 221, 230, 239, 247,
  405|      0|		256, 263, 271, 278, 286, 293, 300, 306, 313, 320, 326, 332, 338, 344, 350, 356,
  406|      0|		362, 367, 373, 378, 384, 389, 394, 399, 404, 409, 414, 419, 424, 429, 434, 438,
  407|      0|		443, 448, 452, 457, 461, 465, 470, 474, 478, 483, 487, 491, 495, 499, 503, 507,
  408|      0|		512, 515, 519, 523, 527, 531, 535, 539, 543, 546, 550, 554, 557, 561, 565, 568,
  409|      0|		572, 576, 579, 583, 586, 590, 593, 596, 600, 603, 607, 610, 613, 617, 620, 623,
  410|      0|		627, 630, 633, 636, 640, 643, 646, 649, 652, 655, 658, 662, 665, 668, 671, 674,
  411|      0|		677, 680, 683, 686, 689, 692, 695, 698, 701, 704, 706, 709, 712, 715, 718, 721,
  412|      0|		724, 726, 729, 732, 735, 738, 740, 743, 746, 749, 751, 754, 757, 759, 762, 765,
  413|      0|		768, 770, 773, 775, 778, 781, 783, 786, 789, 791, 794, 796, 799, 801, 804, 807,
  414|      0|		809, 812, 814, 817, 819, 822, 824, 827, 829, 832, 834, 836, 839, 841, 844, 846,
  415|      0|		849, 851, 853, 856, 858, 861, 863, 865, 868, 870, 872, 875, 877, 879, 882, 884,
  416|      0|		886, 889, 891, 893, 896, 898, 900, 902
  417|      0|	};
  418|      0|
  419|      0|	if (voice->klattv[0]) {
  420|      0|		if (new_rms == -1)
  421|      0|			fr->klattp[KLATT_AV] = 50;
  422|      0|		return;
  423|      0|	}
  424|      0|
  425|      0|	if (fr->rms == 0) return; // check for divide by zero
  426|      0|	x = (new_rms * 64)/fr->rms;
  427|      0|	if (x >= 200) x = 199;
  428|      0|
  429|      0|	x = sqrt_tab[x]; // sqrt(new_rms/fr->rms)*0x200;
  430|      0|
  431|      0|	for (ix = 0; ix < 8; ix++) {
  432|      0|		h = fr->fheight[ix] * x;
  433|      0|		fr->fheight[ix] = h/0x200;
  434|      0|	}
  435|      0|}
  436|       |
  437|       |static void formants_reduce_hf(frame_t *fr, int level)
  438|      0|{
  439|      0|	// change height of peaks 2 to 8, percentage
  440|      0|	int ix;
  441|      0|	int x;
  442|      0|
  443|      0|	if (voice->klattv[0])
  444|      0|		return;
  445|      0|
  446|      0|	for (ix = 2; ix < 8; ix++) {
  447|      0|		x = fr->fheight[ix] * level;
  448|      0|		fr->fheight[ix] = x/100;
  449|      0|	}
  450|      0|}
  451|       |
  452|       |static frame_t *CopyFrame(frame_t *frame1, int copy)
  453|      0|{
  454|      0|	// create a copy of the specified frame in temporary buffer
  455|      0|
  456|      0|	frame_t *frame2;
  457|      0|
  458|      0|	if ((copy == 0) && (frame1->frflags & FRFLAG_COPIED)) {
  459|      0|		// this frame has already been copied in temporary rw memory
  460|      0|		return frame1;
  461|      0|	}
  462|      0|
  463|      0|	frame2 = AllocFrame();
  464|      0|	if (frame2 != NULL) {
  465|      0|		memcpy(frame2, frame1, sizeof(frame_t));
  466|      0|		frame2->length = 0;
  467|      0|		frame2->frflags |= FRFLAG_COPIED;
  468|      0|	}
  469|      0|	return frame2;
  470|      0|}
  471|       |
  472|       |static frame_t *DuplicateLastFrame(frameref_t *seq, int n_frames, int length)
  473|      0|{
  474|      0|	frame_t *fr;
  475|      0|
  476|      0|	seq[n_frames-1].length = length;
  477|      0|	fr = CopyFrame(seq[n_frames-1].frame, 1);
  478|      0|	seq[n_frames].frame = fr;
  479|      0|	seq[n_frames].length = 0;
  480|      0|	return fr;
  481|      0|}
  482|       |
  483|       |static void AdjustFormants(frame_t *fr, int target, int min, int max, int f1_adj, int f3_adj, int hf_reduce, int flags)
  484|      0|{
  485|      0|	int x;
  486|      0|
  487|      0|	target = (target * voice->formant_factor)/256;
  488|      0|
  489|      0|	x = (target - fr->ffreq[2]) / 2;
  490|      0|	if (x > max) x = max;
  491|      0|	if (x < min) x = min;
  492|      0|	fr->ffreq[2] += x;
  493|      0|	fr->ffreq[3] += f3_adj;
  494|      0|
  495|      0|	if (flags & 0x20)
  496|      0|		f3_adj = -f3_adj; // reverse direction for f4,f5 change
  497|      0|	fr->ffreq[4] += f3_adj;
  498|      0|	fr->ffreq[5] += f3_adj;
  499|      0|
  500|      0|	if (f1_adj == 1) {
  501|      0|		x = (235 - fr->ffreq[1]);
  502|      0|		if (x < -100) x = -100;
  503|      0|		if (x > -60) x = -60;
  504|      0|		fr->ffreq[1] += x;
  505|      0|	}
  506|      0|	if (f1_adj == 2) {
  507|      0|		x = (235 - fr->ffreq[1]);
  508|      0|		if (x < -300) x = -300;
  509|      0|		if (x > -150) x = -150;
  510|      0|		fr->ffreq[1] += x;
  511|      0|		fr->ffreq[0] += x;
  512|      0|	}
  513|      0|	if (f1_adj == 3) {
  514|      0|		x = (100 - fr->ffreq[1]);
  515|      0|		if (x < -400) x = -400;
  516|      0|		if (x > -300) x = -400;
  517|      0|		fr->ffreq[1] += x;
  518|      0|		fr->ffreq[0] += x;
  519|      0|	}
  520|      0|	formants_reduce_hf(fr, hf_reduce);
  521|      0|}
  522|       |
  523|       |static int VowelCloseness(frame_t *fr)
  524|      0|{
  525|      0|	// return a value 0-3 depending on the vowel's f1
  526|      0|	int f1;
  527|      0|
  528|      0|	if ((f1 = fr->ffreq[1]) < 300)
  529|      0|		return 3;
  530|      0|	if (f1 < 400)
  531|      0|		return 2;
  532|      0|	if (f1 < 500)
  533|      0|		return 1;
  534|      0|	return 0;
  535|      0|}
  536|       |
  537|       |int FormantTransition2(frameref_t *seq, int *n_frames, unsigned int data1, unsigned int data2, PHONEME_TAB *other_ph, int which)
  538|      0|{
  539|      0|	int ix;
  540|      0|	int formant;
  541|      0|	int next_rms;
  542|      0|
  543|      0|	int len;
  544|      0|	int rms;
  545|      0|	int f1;
  546|      0|	int f2;
  547|      0|	int f2_min;
  548|      0|	int f2_max;
  549|      0|	int f3_adj;
  550|      0|	int f3_amp;
  551|      0|	int flags;
  552|      0|	int vcolour;
  553|      0|
  554|      0|	#define N_VCOLOUR 2
  555|      0|	// percentage change for each formant in 256ths
  556|      0|	static short vcolouring[N_VCOLOUR][5] = {
  557|      0|		{ 243, 272, 256, 256, 256 }, // palatal consonant follows
  558|      0|		{ 256, 256, 240, 240, 240 }, // retroflex
  559|      0|	};
  560|      0|
  561|      0|	frame_t *fr = NULL;
  562|      0|
  563|      0|	if (*n_frames < 2)
  564|      0|		return 0;
  565|      0|
  566|      0|	len = (data1 & 0x3f) * 2;
  567|      0|	rms = (data1 >> 6) & 0x3f;
  568|      0|	flags = (data1 >> 12);
  569|      0|
  570|      0|	f2 = (data2 & 0x3f) * 50;
  571|      0|	f2_min = (((data2 >> 6) & 0x1f) - 15) * 50;
  572|      0|	f2_max = (((data2 >> 11) & 0x1f) - 15) * 50;
  573|      0|	f3_adj = (((data2 >> 16) & 0x1f) - 15) * 50;
  574|      0|	f3_amp = ((data2 >> 21) & 0x1f) * 8;
  575|      0|	f1 = ((data2 >> 26) & 0x7);
  576|      0|	vcolour = (data2 >> 29);
  577|      0|
  578|      0|	if ((other_ph != NULL) && (other_ph->mnemonic == '?'))
  579|      0|		flags |= 8;
  580|      0|
  581|      0|	if (which == 1) {
  582|      0|		// entry to vowel
  583|      0|		fr = CopyFrame(seq[0].frame, 0);
  584|      0|		seq[0].frame = fr;
  585|      0|		seq[0].length = VOWEL_FRONT_LENGTH;
  586|      0|		if (len > 0)
  587|      0|			seq[0].length = len;
  588|      0|		seq[0].frflags |= FRFLAG_LEN_MOD2; // reduce length modification
  589|      0|		fr->frflags |= FRFLAG_LEN_MOD2;
  590|      0|
  591|      0|		next_rms = seq[1].frame->rms;
  592|      0|
  593|      0|		if (voice->klattv[0])
  594|      0|			fr->klattp[KLATT_AV] = seq[1].frame->klattp[KLATT_AV] - 4;
  595|      0|		if (f2 != 0) {
  596|      0|			if (rms & 0x20)
  597|      0|				set_frame_rms(fr, (next_rms * (rms & 0x1f))/30);
  598|      0|			AdjustFormants(fr, f2, f2_min, f2_max, f1, f3_adj, f3_amp, flags);
  599|      0|
  600|      0|			if ((rms & 0x20) == 0)
  601|      0|				set_frame_rms(fr, rms*2);
  602|      0|		} else {
  603|      0|			if (flags & 8)
  604|      0|				set_frame_rms(fr, (next_rms*24)/32);
  605|      0|			else
  606|      0|				set_frame_rms(fr, RMS_START);
  607|      0|		}
  608|      0|
  609|      0|		if (flags & 8)
  610|      0|			modn_flags = 0x800 + (VowelCloseness(fr) << 8);
  611|      0|	} else {
  612|      0|		// exit from vowel
  613|      0|		rms = rms*2;
  614|      0|		if ((f2 != 0) || (flags != 0)) {
  615|      0|
  616|      0|			if (flags & 8) {
  617|      0|				fr = CopyFrame(seq[*n_frames-1].frame, 0);
  618|      0|				seq[*n_frames-1].frame = fr;
  619|      0|				rms = RMS_GLOTTAL1;
  620|      0|
  621|      0|				// degree of glottal-stop effect depends on closeness of vowel (indicated by f1 freq)
  622|      0|				modn_flags = 0x400 + (VowelCloseness(fr) << 8);
  623|      0|			} else {
  624|      0|				fr = DuplicateLastFrame(seq, (*n_frames)++, len);
  625|      0|				if (len > 36)
  626|      0|					seq_len_adjust += (len - 36);
  627|      0|
  628|      0|				if (f2 != 0)
  629|      0|					AdjustFormants(fr, f2, f2_min, f2_max, f1, f3_adj, f3_amp, flags);
  630|      0|			}
  631|      0|
  632|      0|			set_frame_rms(fr, rms);
  633|      0|
  634|      0|			if ((vcolour > 0) && (vcolour <= N_VCOLOUR)) {
  635|      0|				for (ix = 0; ix < *n_frames; ix++) {
  636|      0|					fr = CopyFrame(seq[ix].frame, 0);
  637|      0|					seq[ix].frame = fr;
  638|      0|
  639|      0|					for (formant = 1; formant <= 5; formant++) {
  640|      0|						int x;
  641|      0|						x = fr->ffreq[formant] * vcolouring[vcolour-1][formant-1];
  642|      0|						fr->ffreq[formant] = x / 256;
  643|      0|					}
  644|      0|				}
  645|      0|			}
  646|      0|		}
  647|      0|	}
  648|      0|
  649|      0|	if (fr != NULL) {
  650|      0|		if (flags & 4)
  651|      0|			fr->frflags |= FRFLAG_FORMANT_RATE;
  652|      0|		if (flags & 2)
  653|      0|			fr->frflags |= FRFLAG_BREAK; // don't merge with next frame
  654|      0|	}
  655|      0|
  656|      0|	if (flags & 0x40)
  657|      0|		DoPause(20, 0); // add a short pause after the consonant
  658|      0|
  659|      0|	if (flags & 16)
  660|      0|		return len;
  661|      0|	return 0;
  662|      0|}
  663|       |
  664|       |static void SmoothSpect(void)
  665|      0|{
  666|      0|	// Limit the rate of frequence change of formants, to reduce chirping
  667|      0|
  668|      0|	intptr_t *q;
  669|      0|	frame_t *frame;
  670|      0|	frame_t *frame2;
  671|      0|	frame_t *frame1;
  672|      0|	frame_t *frame_centre;
  673|      0|	int ix;
  674|      0|	int len;
  675|      0|	int pk;
  676|      0|	bool modified;
  677|      0|	int allowed;
  678|      0|	int diff;
  679|      0|
  680|      0|	if (syllable_start == syllable_end)
  681|      0|		return;
  682|      0|
  683|      0|	if ((syllable_centre < 0) || (syllable_centre == syllable_start)) {
  684|      0|		syllable_start = syllable_end;
  685|      0|		return;
  686|      0|	}
  687|      0|
  688|      0|	q = wcmdq[syllable_centre];
  689|      0|	frame_centre = (frame_t *)q[2];
  690|      0|
  691|      0|	// backwards
  692|      0|	ix = syllable_centre -1;
  693|      0|	frame = frame2 = frame_centre;
  694|      0|	for (;;) {
  695|      0|		if (ix < 0) ix = N_WCMDQ-1;
  696|      0|		q = wcmdq[ix];
  697|      0|
  698|      0|		if (q[0] == WCMD_PAUSE || q[0] == WCMD_WAVE)
  699|      0|			break;
  700|      0|
  701|      0|		if (q[0] <= WCMD_SPECT2) {
  702|      0|			len = q[1] & 0xffff;
  703|      0|
  704|      0|			frame1 = (frame_t *)q[3];
  705|      0|			if (frame1 == frame) {
  706|      0|				q[3] = (intptr_t)frame2;
  707|      0|				frame1 = frame2;
  708|      0|			} else
  709|      0|				break; // doesn't follow on from previous frame
  710|      0|
  711|      0|			frame = frame2 = (frame_t *)q[2];
  712|      0|			modified = false;
  713|      0|
  714|      0|			if (frame->frflags & FRFLAG_BREAK)
  715|      0|				break;
  716|      0|
  717|      0|			if (frame->frflags & FRFLAG_FORMANT_RATE)
  718|      0|				len = (len * 12)/10; // allow slightly greater rate of change for this frame (was 12/10)
  719|      0|
  720|      0|			for (pk = 0; pk < 6; pk++) {
  721|      0|				int f1, f2;
  722|      0|
  723|      0|				if ((frame->frflags & FRFLAG_BREAK_LF) && (pk < 3))
  724|      0|					continue;
  725|      0|
  726|      0|				f1 = frame1->ffreq[pk];
  727|      0|				f2 = frame->ffreq[pk];
  728|      0|
  729|      0|				// backwards
  730|      0|				if ((diff = f2 - f1) > 0)
  731|      0|					allowed = f1*2 + f2;
  732|      0|				else
  733|      0|					allowed = f1 + f2*2;
  734|      0|
  735|      0|				// the allowed change is specified as percentage (%*10) of the frequency
  736|      0|				// take "frequency" as 1/3 from the lower freq
  737|      0|				allowed = (allowed * formant_rate[pk])/3000;
  738|      0|				allowed = (allowed * len)/256;
  739|      0|
  740|      0|				if (diff > allowed) {
  741|      0|					if (modified == false) {
  742|      0|						frame2 = CopyFrame(frame, 0);
  743|      0|						modified = true;
  744|      0|					}
  745|      0|					frame2->ffreq[pk] = frame1->ffreq[pk] + allowed;
  746|      0|					q[2] = (intptr_t)frame2;
  747|      0|				} else if (diff < -allowed) {
  748|      0|					if (modified == false) {
  749|      0|						frame2 = CopyFrame(frame, 0);
  750|      0|						modified = true;
  751|      0|					}
  752|      0|					frame2->ffreq[pk] = frame1->ffreq[pk] - allowed;
  753|      0|					q[2] = (intptr_t)frame2;
  754|      0|				}
  755|      0|			}
  756|      0|		}
  757|      0|
  758|      0|		if (ix == syllable_start)
  759|      0|			break;
  760|      0|		ix--;
  761|      0|	}
  762|      0|
  763|      0|	// forwards
  764|      0|	ix = syllable_centre;
  765|      0|
  766|      0|	frame = NULL;
  767|      0|	for (;;) {
  768|      0|		q = wcmdq[ix];
  769|      0|
  770|      0|		if (q[0] == WCMD_PAUSE || q[0] == WCMD_WAVE)
  771|      0|			break;
  772|      0|
  773|      0|		if (q[0] <= WCMD_SPECT2) {
  774|      0|			len = q[1] & 0xffff;
  775|      0|
  776|      0|			frame1 = (frame_t *)q[2];
  777|      0|			if (frame != NULL) {
  778|      0|				if (frame1 == frame) {
  779|      0|					q[2] = (intptr_t)frame2;
  780|      0|					frame1 = frame2;
  781|      0|				} else
  782|      0|					break; // doesn't follow on from previous frame
  783|      0|			}
  784|      0|
  785|      0|			frame = frame2 = (frame_t *)q[3];
  786|      0|			modified = false;
  787|      0|
  788|      0|			if (frame1->frflags & FRFLAG_BREAK)
  789|      0|				break;
  790|      0|
  791|      0|			if (frame1->frflags & FRFLAG_FORMANT_RATE)
  792|      0|				len = (len *6)/5; // allow slightly greater rate of change for this frame
  793|      0|
  794|      0|			for (pk = 0; pk < 6; pk++) {
  795|      0|				int f1, f2;
  796|      0|				f1 = frame1->ffreq[pk];
  797|      0|				f2 = frame->ffreq[pk];
  798|      0|
  799|      0|				// forwards
  800|      0|				if ((diff = f2 - f1) > 0)
  801|      0|					allowed = f1*2 + f2;
  802|      0|				else
  803|      0|					allowed = f1 + f2*2;
  804|      0|				allowed = (allowed * formant_rate[pk])/3000;
  805|      0|				allowed = (allowed * len)/256;
  806|      0|
  807|      0|				if (diff > allowed) {
  808|      0|					if (modified == false) {
  809|      0|						frame2 = CopyFrame(frame, 0);
  810|      0|						modified = true;
  811|      0|					}
  812|      0|					frame2->ffreq[pk] = frame1->ffreq[pk] + allowed;
  813|      0|					q[3] = (intptr_t)frame2;
  814|      0|				} else if (diff < -allowed) {
  815|      0|					if (modified == false) {
  816|      0|						frame2 = CopyFrame(frame, 0);
  817|      0|						modified = true;
  818|      0|					}
  819|      0|					frame2->ffreq[pk] = frame1->ffreq[pk] - allowed;
  820|      0|					q[3] = (intptr_t)frame2;
  821|      0|				}
  822|      0|			}
  823|      0|		}
  824|      0|
  825|      0|		ix++;
  826|      0|		if (ix >= N_WCMDQ) ix = 0;
  827|      0|		if (ix == syllable_end)
  828|      0|			break;
  829|      0|	}
  830|      0|
  831|      0|	syllable_start = syllable_end;
  832|      0|}
  833|       |
  834|       |static void StartSyllable(void)
  835|      0|{
  836|      0|	// start of syllable, if not already started
  837|      0|	if (syllable_end == syllable_start)
  838|      0|		syllable_end = wcmdq_tail;
  839|      0|}
  840|       |
  841|       |int DoSpect2(PHONEME_TAB *this_ph, int which, FMT_PARAMS *fmt_params,  PHONEME_LIST *plist, int modulation)
  842|      0|{
  843|      0|	// which:  0 not a vowel, 1  start of vowel,   2 body and end of vowel
  844|      0|	// length_mod: 256 = 100%
  845|      0|	// modulation: -1 = don't write to wcmdq
  846|      0|
  847|      0|	int n_frames;
  848|      0|	frameref_t *frames;
  849|      0|	int frameix;
  850|      0|	frame_t *frame1;
  851|      0|	frame_t *frame2;
  852|      0|	frame_t *fr;
  853|      0|	int ix;
  854|      0|	intptr_t *q;
  855|      0|	int len;
  856|      0|	int frame_length;
  857|      0|	int length_factor;
  858|      0|	int length_mod;
  859|      0|	int length_sum;
  860|      0|	int length_min;
  861|      0|	int total_len = 0;
  862|      0|	static int wave_flag = 0;
  863|      0|	int wcmd_spect = WCMD_SPECT;
  864|      0|	int frame_lengths[N_SEQ_FRAMES];
  865|      0|
  866|      0|	if (fmt_params->fmt_addr == 0)
  867|      0|		return 0;
  868|      0|
  869|      0|	length_mod = plist->length;
  870|      0|	if (length_mod == 0) length_mod = 256;
  871|      0|
  872|      0|	length_min = (samplerate/70); // greater than one cycle at low pitch (Hz)
  873|      0|	if (which == 2) {
  874|      0|		if ((translator->langopts.param[LOPT_LONG_VOWEL_THRESHOLD] > 0) && ((this_ph->std_length >= translator->langopts.param[LOPT_LONG_VOWEL_THRESHOLD]) || (plist->synthflags & SFLAG_LENGTHEN) || (this_ph->phflags & phLONG)))
  875|      0|			length_min *= 2; // ensure long vowels are longer
  876|      0|	}
  877|      0|
  878|      0|	if (which == 1) {
  879|      0|		// limit the shortening of sonorants before shortened (eg. unstressed vowels)
  880|      0|		if ((this_ph->type == phLIQUID) || (plist[-1].type == phLIQUID) || (plist[-1].type == phNASAL)) {
  881|      0|			if (length_mod < (len = translator->langopts.param[LOPT_SONORANT_MIN]))
  882|      0|				length_mod = len;
  883|      0|		}
  884|      0|	}
  885|      0|
  886|      0|	modn_flags = 0;
  887|      0|	frames = LookupSpect(this_ph, which, fmt_params, &n_frames, plist);
  888|      0|	if (frames == NULL)
  889|      0|		return 0; // not found
  890|      0|
  891|      0|	if (fmt_params->fmt_amp != fmt_amplitude) {
  892|      0|		// an amplitude adjustment is specified for this sequence
  893|      0|		q = wcmdq[wcmdq_tail];
  894|      0|		q[0] = WCMD_FMT_AMPLITUDE;
  895|      0|		q[1] = fmt_amplitude = fmt_params->fmt_amp;
  896|      0|		WcmdqInc();
  897|      0|	}
  898|      0|
  899|      0|	frame1 = frames[0].frame;
  900|      0|	if (voice->klattv[0])
  901|      0|		wcmd_spect = WCMD_KLATT;
  902|      0|
  903|      0|	if (fmt_params->wav_addr == 0) {
  904|      0|		if (wave_flag) {
  905|      0|			// cancel any wavefile that was playing previously
  906|      0|			wcmd_spect = WCMD_SPECT2;
  907|      0|			if (voice->klattv[0])
  908|      0|				wcmd_spect = WCMD_KLATT2;
  909|      0|			wave_flag = 0;
  910|      0|		} else {
  911|      0|			wcmd_spect = WCMD_SPECT;
  912|      0|			if (voice->klattv[0])
  913|      0|				wcmd_spect = WCMD_KLATT;
  914|      0|		}
  915|      0|	}
  916|      0|
  917|      0|	if (last_frame != NULL) {
  918|      0|		if (((last_frame->length < 2) || (last_frame->frflags & FRFLAG_VOWEL_CENTRE))
  919|      0|		    && !(last_frame->frflags & FRFLAG_BREAK)) {
  920|      0|			// last frame of previous sequence was zero-length, replace with first of this sequence
  921|      0|			wcmdq[last_wcmdq][3] = (intptr_t)frame1;
  922|      0|
  923|      0|			if (last_frame->frflags & FRFLAG_BREAK_LF) {
  924|      0|				// but flag indicates keep HF peaks in last segment
  925|      0|				fr = CopyFrame(frame1, 1);
  926|      0|				for (ix = 3; ix < 8; ix++) {
  927|      0|					if (ix < 7)
  928|      0|						fr->ffreq[ix] = last_frame->ffreq[ix];
  929|      0|					fr->fheight[ix] = last_frame->fheight[ix];
  930|      0|				}
  931|      0|				wcmdq[last_wcmdq][3] = (intptr_t)fr;
  932|      0|			}
  933|      0|		}
  934|      0|	}
  935|      0|
  936|      0|	if ((this_ph->type == phVOWEL) && (which == 2)) {
  937|      0|		SmoothSpect(); // process previous syllable
  938|      0|
  939|      0|		// remember the point in the output queue of the centre of the vowel
  940|      0|		syllable_centre = wcmdq_tail;
  941|      0|	}
  942|      0|
  943|      0|	length_sum = 0;
  944|      0|	for (frameix = 1; frameix < n_frames; frameix++) {
  945|      0|		length_factor = length_mod;
  946|      0|		if (frames[frameix-1].frflags & FRFLAG_LEN_MOD) // reduce effect of length mod
  947|      0|			length_factor = (length_mod*(256-speed.lenmod_factor) + 256*speed.lenmod_factor)/256;
  948|      0|		else if (frames[frameix-1].frflags & FRFLAG_LEN_MOD2) // reduce effect of length mod, used for the start of a vowel
  949|      0|			length_factor = (length_mod*(256-speed.lenmod2_factor) + 256*speed.lenmod2_factor)/256;
  950|      0|
  951|      0|		frame_length = frames[frameix-1].length;
  952|      0|		len = (frame_length * samplerate)/1000;
  953|      0|		len = (len * length_factor)/256;
  954|      0|		length_sum += len;
  955|      0|		frame_lengths[frameix] = len;
  956|      0|	}
  957|      0|
  958|      0|	if ((length_sum > 0) && (length_sum < length_min)) {
  959|      0|		// lengthen, so that the sequence is greater than one cycle at low pitch
  960|      0|		for (frameix = 1; frameix < n_frames; frameix++)
  961|      0|			frame_lengths[frameix] = (frame_lengths[frameix] * length_min) / length_sum;
  962|      0|	}
  963|      0|
  964|      0|	for (frameix = 1; frameix < n_frames; frameix++) {
  965|      0|		frame2 = frames[frameix].frame;
  966|      0|
  967|      0|		if ((fmt_params->wav_addr != 0) && ((frame1->frflags & FRFLAG_DEFER_WAV) == 0)) {
  968|      0|			// there is a wave file to play along with this synthesis
  969|      0|			seq_len_adjust = 0;
  970|      0|	
  971|      0|			int wavefile_amp;
  972|      0|			if (fmt_params->wav_amp == 0)
  973|      0|				wavefile_amp = 32;
  974|      0|			else
  975|      0|				wavefile_amp = (fmt_params->wav_amp * 32)/100;
  976|      0|
  977|      0|			DoSample2(fmt_params->wav_addr, which+0x100, 0, fmt_params->fmt_control, 0, wavefile_amp);
  978|      0|			wave_flag = 1;
  979|      0|			fmt_params->wav_addr = 0;
  980|      0|		}
  981|      0|
  982|      0|		if (modulation >= 0) {
  983|      0|			if (frame1->frflags & FRFLAG_MODULATE)
  984|      0|				modulation = 6;
  985|      0|			if ((frameix == n_frames-1) && (modn_flags & 0xf00))
  986|      0|				modulation |= modn_flags; // before or after a glottal stop
  987|      0|		}
  988|      0|
  989|      0|		len = frame_lengths[frameix];
  990|      0|		pitch_length += len;
  991|      0|		amp_length += len;
  992|      0|
  993|      0|		if (len == 0) {
  994|      0|			last_frame = NULL;
  995|      0|			frame1 = frame2;
  996|      0|		} else {
  997|      0|			last_wcmdq = wcmdq_tail;
  998|      0|
  999|      0|			if (modulation >= 0) {
 1000|      0|				q = wcmdq[wcmdq_tail];
 1001|      0|				q[0] = wcmd_spect;
 1002|      0|				q[1] = len + (modulation << 16);
 1003|      0|				q[2] = (intptr_t)frame1;
 1004|      0|				q[3] = (intptr_t)frame2;
 1005|      0|
 1006|      0|				WcmdqInc();
 1007|      0|			}
 1008|      0|			last_frame = frame1 = frame2;
 1009|      0|			total_len += len;
 1010|      0|		}
 1011|      0|	}
 1012|      0|
 1013|      0|	if ((which != 1) && (fmt_amplitude != 0)) {
 1014|      0|		q = wcmdq[wcmdq_tail];
 1015|      0|		q[0] = WCMD_FMT_AMPLITUDE;
 1016|      0|		q[1] = fmt_amplitude = 0;
 1017|      0|		WcmdqInc();
 1018|      0|	}
 1019|      0|
 1020|      0|	return total_len;
 1021|      0|}
 1022|       |
 1023|       |void DoMarker(int type, int char_posn, int length, int value)
 1024|      0|{
 1025|      0|	// This could be used to return an index to the word currently being spoken
 1026|      0|	// Type 1=word, 2=sentence, 3=named marker, 4=play audio, 5=end
 1027|      0|
 1028|      0|	if (WcmdqFree() > 5) {
 1029|      0|		wcmdq[wcmdq_tail][0] = WCMD_MARKER + (type << 8);
 1030|      0|		wcmdq[wcmdq_tail][1] = (char_posn & 0xffffff) | (length << 24);
 1031|      0|		wcmdq[wcmdq_tail][2] = value;
 1032|      0|		WcmdqInc();
 1033|      0|	}
 1034|      0|}
 1035|       |
 1036|       |void DoPhonemeMarker(int type, int char_posn, int length, char *name)
 1037|      0|{
 1038|      0|	// This could be used to return an index to the word currently being spoken
 1039|      0|	// Type 7=phoneme
 1040|      0|
 1041|      0|	int *p;
 1042|      0|
 1043|      0|	if (WcmdqFree() > 5) {
 1044|      0|		wcmdq[wcmdq_tail][0] = WCMD_MARKER + (type << 8);
 1045|      0|		wcmdq[wcmdq_tail][1] = (char_posn & 0xffffff) | (length << 24);
 1046|      0|		p = (int *)name;
 1047|      0|		wcmdq[wcmdq_tail][2] = p[0]; // up to 8 bytes of UTF8 characters
 1048|      0|		wcmdq[wcmdq_tail][3] = p[1];
 1049|      0|		WcmdqInc();
 1050|      0|	}
 1051|      0|}
 1052|       |
 1053|       |#if HAVE_SONIC_H
 1054|       |void DoSonicSpeed(int value)
 1055|       |{
 1056|       |	// value, multiplier * 1024
 1057|       |	wcmdq[wcmdq_tail][0] = WCMD_SONIC_SPEED;
 1058|       |	wcmdq[wcmdq_tail][1] = value;
 1059|       |	WcmdqInc();
 1060|       |}
 1061|       |#endif
 1062|       |
 1063|       |espeak_ng_STATUS DoVoiceChange(voice_t *v)
 1064|      0|{
 1065|      0|	// allocate memory for a copy of the voice data, and free it in wavegenfill()
 1066|      0|	voice_t *v2;
 1067|      0|	if ((v2 = (voice_t *)malloc(sizeof(voice_t))) == NULL)
 1068|      0|		return ENOMEM;
 1069|      0|	memcpy(v2, v, sizeof(voice_t));
 1070|      0|	wcmdq[wcmdq_tail][0] = WCMD_VOICE;
 1071|      0|	wcmdq[wcmdq_tail][2] = (intptr_t)v2;
 1072|      0|	WcmdqInc();
 1073|      0|	return ENS_OK;
 1074|      0|}
 1075|       |
 1076|       |void DoEmbedded(int *embix, int sourceix)
 1077|      0|{
 1078|      0|	// There were embedded commands in the text at this point
 1079|      0|	unsigned int word; // bit 7=last command for this word, bits 5,6 sign, bits 0-4 command
 1080|      0|	unsigned int value;
 1081|      0|	int command;
 1082|      0|
 1083|      0|	do {
 1084|      0|		word = embedded_list[*embix];
 1085|      0|		value = word >> 8;
 1086|      0|		command = word & 0x7f;
 1087|      0|
 1088|      0|		if (command == 0)
 1089|      0|			return; // error
 1090|      0|
 1091|      0|		(*embix)++;
 1092|      0|
 1093|      0|		switch (command & 0x1f)
 1094|      0|		{
 1095|      0|		case EMBED_S: // speed
 1096|      0|			SetEmbedded((command & 0x60) + EMBED_S2, value); // adjusts embedded_value[EMBED_S2]
 1097|      0|			SetSpeed(2);
 1098|      0|			break;
 1099|      0|		case EMBED_I: // play dynamically loaded wav data (sound icon)
 1100|      0|			if ((int)value < n_soundicon_tab) {
 1101|      0|				if (soundicon_tab[value].length != 0) {
 1102|      0|					DoPause(10, 0); // ensure a break in the speech
 1103|      0|					wcmdq[wcmdq_tail][0] = WCMD_WAVE;
 1104|      0|					wcmdq[wcmdq_tail][1] = soundicon_tab[value].length;
 1105|      0|					wcmdq[wcmdq_tail][2] = (intptr_t)soundicon_tab[value].data + 44; // skip WAV header
 1106|      0|					wcmdq[wcmdq_tail][3] = 0x1500; // 16 bit data, amp=21
 1107|      0|					WcmdqInc();
 1108|      0|				}
 1109|      0|			}
 1110|      0|			break;
 1111|      0|		case EMBED_M: // named marker
 1112|      0|			DoMarker(espeakEVENT_MARK, (sourceix & 0x7ff) + clause_start_char, 0, value);
 1113|      0|			break;
 1114|      0|		case EMBED_U: // play sound
 1115|      0|			DoMarker(espeakEVENT_PLAY, count_characters+1, 0, value); // always occurs at end of clause
 1116|      0|			break;
 1117|      0|		default:
 1118|      0|			DoPause(10, 0); // ensure a break in the speech
 1119|      0|			wcmdq[wcmdq_tail][0] = WCMD_EMBEDDED;
 1120|      0|			wcmdq[wcmdq_tail][1] = command;
 1121|      0|			wcmdq[wcmdq_tail][2] = value;
 1122|      0|			WcmdqInc();
 1123|      0|			break;
 1124|      0|		}
 1125|      0|	} while ((word & 0x80) == 0);
 1126|      0|}
 1127|       |
 1128|       |extern espeak_ng_OUTPUT_HOOKS* output_hooks;
 1129|       |
 1130|       |int Generate(PHONEME_LIST *phoneme_list, int *n_ph, bool resume)
 1131|      0|{
 1132|      0|	static int ix;
 1133|      0|	static int embedded_ix;
 1134|      0|	static int word_count;
 1135|      0|	PHONEME_LIST *prev;
 1136|      0|	PHONEME_LIST *next;
 1137|      0|	PHONEME_LIST *next2;
 1138|      0|	PHONEME_LIST *p;
 1139|      0|	bool released;
 1140|      0|	int stress;
 1141|      0|	int modulation;
 1142|      0|	bool  pre_voiced;
 1143|      0|	int free_min;
 1144|      0|	int value;
 1145|      0|	unsigned char *pitch_env = NULL;
 1146|      0|	unsigned char *amp_env;
 1147|      0|	PHONEME_TAB *ph;
 1148|      0|	int use_ipa = 0;
 1149|      0|	bool done_phoneme_marker;
 1150|      0|	int vowelstart_prev;
 1151|      0|	char phoneme_name[16];
 1152|      0|	static int sourceix = 0;
 1153|      0|
 1154|      0|	PHONEME_DATA phdata;
 1155|      0|	PHONEME_DATA phdata_prev;
 1156|      0|	PHONEME_DATA phdata_next;
 1157|      0|	PHONEME_DATA phdata_tone;
 1158|      0|	FMT_PARAMS fmtp;
 1159|      0|	static WORD_PH_DATA worddata;
 1160|      0|
 1161|      0|	if (option_phoneme_events & espeakINITIALIZE_PHONEME_IPA)
 1162|      0|		use_ipa = 1;
 1163|      0|
 1164|      0|	if (mbrola_name[0] != 0)
 1165|      0|		return MbrolaGenerate(phoneme_list, n_ph, resume);
 1166|      0|
 1167|      0|	if (resume == false) {
 1168|      0|		ix = 1;
 1169|      0|		embedded_ix = 0;
 1170|      0|		word_count = 0;
 1171|      0|		pitch_length = 0;
 1172|      0|		amp_length = 0;
 1173|      0|		last_frame = NULL;
 1174|      0|		last_wcmdq = -1;
 1175|      0|		syllable_start = wcmdq_tail;
 1176|      0|		syllable_end = wcmdq_tail;
 1177|      0|		syllable_centre = -1;
 1178|      0|		last_pitch_cmd = -1;
 1179|      0|		memset(&worddata, 0, sizeof(worddata));
 1180|      0|		DoPause(0, 0); // isolate from the previous clause
 1181|      0|	}
 1182|      0|
 1183|      0|	while ((ix < (*n_ph)) && (ix < N_PHONEME_LIST-2)) {
 1184|      0|		p = &phoneme_list[ix];
 1185|      0|		
 1186|      0|		if(output_hooks && output_hooks->outputPhoSymbol)
 1187|      0|		{
 1188|      0|			char buf[30];
 1189|      0|			int dummy=0;
 1190|      0|			WritePhMnemonic(buf, p->ph, p, 0, &dummy);
 1191|      0|			DoPhonemeAlignment(strdup(buf),p->type);
 1192|      0|		}
 1193|      0|
 1194|      0|		if (p->type == phPAUSE)
 1195|      0|			free_min = 10;
 1196|      0|		else if (p->type != phVOWEL)
 1197|      0|			free_min = 15; // we need less Q space for non-vowels, and we need to generate phonemes after a vowel so that the pitch_length is filled in
 1198|      0|		else
 1199|      0|			free_min = MIN_WCMDQ;
 1200|      0|
 1201|      0|		if (WcmdqFree() <= free_min)
 1202|      0|			return 1; // wait
 1203|      0|
 1204|      0|		prev = &phoneme_list[ix-1];
 1205|      0|		next = &phoneme_list[ix+1];
 1206|      0|		next2 = &phoneme_list[ix+2];
 1207|      0|
 1208|      0|		if (p->synthflags & SFLAG_EMBEDDED)
 1209|      0|			DoEmbedded(&embedded_ix, p->sourceix);
 1210|      0|
 1211|      0|		if (p->newword) {
 1212|      0|			if (((p->type == phVOWEL) && (translator->langopts.param[LOPT_WORD_MERGE] & 1)) ||
 1213|      0|			    (p->ph->phflags & phNOPAUSE)) {
 1214|      0|			} else
 1215|      0|				last_frame = NULL;
 1216|      0|
 1217|      0|			sourceix = (p->sourceix & 0x7ff) + clause_start_char;
 1218|      0|
 1219|      0|			if (p->newword & PHLIST_START_OF_SENTENCE)
 1220|      0|				DoMarker(espeakEVENT_SENTENCE, sourceix, 0, count_sentences); // start of sentence
 1221|      0|
 1222|      0|			if (p->newword & PHLIST_START_OF_WORD)
 1223|      0|				DoMarker(espeakEVENT_WORD, sourceix, p->sourceix >> 11, clause_start_word + word_count++); // NOTE, this count doesn't include multiple-word pronunciations in *_list. eg (of a)
 1224|      0|		}
 1225|      0|
 1226|      0|		EndAmplitude();
 1227|      0|
 1228|      0|		if ((p->prepause > 0) && !(p->ph->phflags & phPREVOICE))
 1229|      0|			DoPause(p->prepause, 1);
 1230|      0|
 1231|      0|		done_phoneme_marker = false;
 1232|      0|		if (option_phoneme_events && (p->ph->code != phonEND_WORD)) {
 1233|      0|			if ((p->type == phVOWEL) && (prev->type == phLIQUID || prev->type == phNASAL)) {
 1234|      0|				// For vowels following a liquid or nasal, do the phoneme event after the vowel-start
 1235|      0|			} else {
 1236|      0|				WritePhMnemonic(phoneme_name, p->ph, p, use_ipa, NULL);
 1237|      0|				DoPhonemeMarker(espeakEVENT_PHONEME, sourceix, 0, phoneme_name);
 1238|      0|				done_phoneme_marker = true;
 1239|      0|			}
 1240|      0|		}
 1241|      0|
 1242|      0|		switch (p->type)
 1243|      0|		{
 1244|      0|		case phPAUSE:
 1245|      0|			DoPause(p->length, 0);
 1246|      0|			p->std_length = p->ph->std_length;
 1247|      0|			break;
 1248|      0|		case phSTOP:
 1249|      0|			released = false;
 1250|      0|			ph = p->ph;
 1251|      0|			if (next->type == phVOWEL)
 1252|      0|				released = true;
 1253|      0|			else if (!next->newword) {
 1254|      0|				if (next->type == phLIQUID) released = true;
 1255|      0|			}
 1256|      0|			if (released == false)
 1257|      0|				p->synthflags |= SFLAG_NEXT_PAUSE;
 1258|      0|
 1259|      0|			if (ph->phflags & phPREVOICE) {
 1260|      0|				// a period of voicing before the release
 1261|      0|				memset(&fmtp, 0, sizeof(fmtp));
 1262|      0|				InterpretPhoneme(NULL, 0x01, p, &phdata, &worddata);
 1263|      0|				fmtp.fmt_addr = phdata.sound_addr[pd_FMT];
 1264|      0|				fmtp.fmt_amp = phdata.sound_param[pd_FMT];
 1265|      0|
 1266|      0|				if (last_pitch_cmd < 0) {
 1267|      0|					DoAmplitude(next->amp, NULL);
 1268|      0|					DoPitch(envelope_data[p->env], next->pitch1, next->pitch2);
 1269|      0|				}
 1270|      0|
 1271|      0|				DoSpect2(ph, 0, &fmtp, p, 0);
 1272|      0|			}
 1273|      0|
 1274|      0|			InterpretPhoneme(NULL, 0, p, &phdata, &worddata);
 1275|      0|			phdata.pd_control |= pd_DONTLENGTHEN;
 1276|      0|			DoSample3(&phdata, 0, 0);
 1277|      0|			break;
 1278|      0|		case phFRICATIVE:
 1279|      0|			InterpretPhoneme(NULL, 0, p, &phdata, &worddata);
 1280|      0|
 1281|      0|			if (p->synthflags & SFLAG_LENGTHEN)
 1282|      0|				DoSample3(&phdata, p->length, 0); // play it twice for [s:] etc.
 1283|      0|			DoSample3(&phdata, p->length, 0);
 1284|      0|			break;
 1285|      0|		case phVSTOP:
 1286|      0|			ph = p->ph;
 1287|      0|			memset(&fmtp, 0, sizeof(fmtp));
 1288|      0|			fmtp.fmt_control = pd_DONTLENGTHEN;
 1289|      0|
 1290|      0|			pre_voiced = false;
 1291|      0|			if (next->type == phVOWEL) {
 1292|      0|				DoAmplitude(p->amp, NULL);
 1293|      0|				DoPitch(envelope_data[p->env], p->pitch1, p->pitch2);
 1294|      0|				pre_voiced = true;
 1295|      0|			} else if ((next->type == phLIQUID) && !next->newword) {
 1296|      0|				DoAmplitude(next->amp, NULL);
 1297|      0|				DoPitch(envelope_data[next->env], next->pitch1, next->pitch2);
 1298|      0|				pre_voiced = true;
 1299|      0|			} else {
 1300|      0|				if (last_pitch_cmd < 0) {
 1301|      0|					DoAmplitude(next->amp, NULL);
 1302|      0|					DoPitch(envelope_data[p->env], p->pitch1, p->pitch2);
 1303|      0|				}
 1304|      0|			}
 1305|      0|
 1306|      0|			if ((prev->type == phVOWEL) || (ph->phflags & phPREVOICE)) {
 1307|      0|				// a period of voicing before the release
 1308|      0|				InterpretPhoneme(NULL, 0x01, p, &phdata, &worddata);
 1309|      0|				fmtp.fmt_addr = phdata.sound_addr[pd_FMT];
 1310|      0|				fmtp.fmt_amp = phdata.sound_param[pd_FMT];
 1311|      0|
 1312|      0|				DoSpect2(ph, 0, &fmtp, p, 0);
 1313|      0|				if (p->synthflags & SFLAG_LENGTHEN) {
 1314|      0|					DoPause(25, 1);
 1315|      0|					DoSpect2(ph, 0, &fmtp, p, 0);
 1316|      0|				}
 1317|      0|			} else {
 1318|      0|				if (p->synthflags & SFLAG_LENGTHEN)
 1319|      0|					DoPause(50, 0);
 1320|      0|			}
 1321|      0|
 1322|      0|			if (pre_voiced) {
 1323|      0|				// followed by a vowel, or liquid + vowel
 1324|      0|				StartSyllable();
 1325|      0|			} else
 1326|      0|				p->synthflags |= SFLAG_NEXT_PAUSE;
 1327|      0|			InterpretPhoneme(NULL, 0, p, &phdata, &worddata);
 1328|      0|			fmtp.fmt_addr = phdata.sound_addr[pd_FMT];
 1329|      0|			fmtp.fmt_amp = phdata.sound_param[pd_FMT];
 1330|      0|			fmtp.wav_addr = phdata.sound_addr[pd_ADDWAV];
 1331|      0|			fmtp.wav_amp = phdata.sound_param[pd_ADDWAV];
 1332|      0|			DoSpect2(ph, 0, &fmtp, p, 0);
 1333|      0|
 1334|      0|			if ((p->newword == 0) && (next2->newword == 0)) {
 1335|      0|				if (next->type == phVFRICATIVE)
 1336|      0|					DoPause(20, 0);
 1337|      0|				if (next->type == phFRICATIVE)
 1338|      0|					DoPause(12, 0);
 1339|      0|			}
 1340|      0|			break;
 1341|      0|		case phVFRICATIVE:
 1342|      0|			if (next->type == phVOWEL) {
 1343|      0|				DoAmplitude(p->amp, NULL);
 1344|      0|				DoPitch(envelope_data[p->env], p->pitch1, p->pitch2);
 1345|      0|			} else if (next->type == phLIQUID) {
 1346|      0|				DoAmplitude(next->amp, NULL);
 1347|      0|				DoPitch(envelope_data[next->env], next->pitch1, next->pitch2);
 1348|      0|			} else {
 1349|      0|				if (last_pitch_cmd < 0) {
 1350|      0|					DoAmplitude(p->amp, NULL);
 1351|      0|					DoPitch(envelope_data[p->env], p->pitch1, p->pitch2);
 1352|      0|				}
 1353|      0|			}
 1354|      0|
 1355|      0|			if ((next->type == phVOWEL) || ((next->type == phLIQUID) && (next->newword == 0))) // ?? test 14.Aug.2007
 1356|      0|				StartSyllable();
 1357|      0|			else
 1358|      0|				p->synthflags |= SFLAG_NEXT_PAUSE;
 1359|      0|			InterpretPhoneme(NULL, 0, p, &phdata, &worddata);
 1360|      0|			memset(&fmtp, 0, sizeof(fmtp));
 1361|      0|			fmtp.std_length = phdata.pd_param[i_SET_LENGTH]*2;
 1362|      0|			fmtp.fmt_addr = phdata.sound_addr[pd_FMT];
 1363|      0|			fmtp.fmt_amp = phdata.sound_param[pd_FMT];
 1364|      0|			fmtp.wav_addr = phdata.sound_addr[pd_ADDWAV];
 1365|      0|			fmtp.wav_amp = phdata.sound_param[pd_ADDWAV];
 1366|      0|
 1367|      0|			if (p->synthflags & SFLAG_LENGTHEN)
 1368|      0|				DoSpect2(p->ph, 0, &fmtp, p, 0);
 1369|      0|			DoSpect2(p->ph, 0, &fmtp, p, 0);
 1370|      0|			break;
 1371|      0|		case phNASAL:
 1372|      0|			memset(&fmtp, 0, sizeof(fmtp));
 1373|      0|			if (!(p->synthflags & SFLAG_SEQCONTINUE)) {
 1374|      0|				DoAmplitude(p->amp, NULL);
 1375|      0|				DoPitch(envelope_data[p->env], p->pitch1, p->pitch2);
 1376|      0|			}
 1377|      0|
 1378|      0|			if (prev->type == phNASAL)
 1379|      0|				last_frame = NULL;
 1380|      0|
 1381|      0|			InterpretPhoneme(NULL, 0, p, &phdata, &worddata);
 1382|      0|			fmtp.std_length = phdata.pd_param[i_SET_LENGTH]*2;
 1383|      0|			fmtp.fmt_addr = phdata.sound_addr[pd_FMT];
 1384|      0|			fmtp.fmt_amp = phdata.sound_param[pd_FMT];
 1385|      0|
 1386|      0|			if (next->type == phVOWEL) {
 1387|      0|				StartSyllable();
 1388|      0|				DoSpect2(p->ph, 0, &fmtp, p, 0);
 1389|      0|			} else if (prev->type == phVOWEL && (p->synthflags & SFLAG_SEQCONTINUE))
 1390|      0|				DoSpect2(p->ph, 0, &fmtp, p, 0);
 1391|      0|			else {
 1392|      0|				last_frame = NULL; // only for nasal ?
 1393|      0|				DoSpect2(p->ph, 0, &fmtp, p, 0);
 1394|      0|				last_frame = NULL;
 1395|      0|			}
 1396|      0|
 1397|      0|			break;
 1398|      0|		case phLIQUID:
 1399|      0|			memset(&fmtp, 0, sizeof(fmtp));
 1400|      0|			modulation = 0;
 1401|      0|			if (p->ph->phflags & phTRILL)
 1402|      0|				modulation = 5;
 1403|      0|
 1404|      0|			if (!(p->synthflags & SFLAG_SEQCONTINUE)) {
 1405|      0|				DoAmplitude(p->amp, NULL);
 1406|      0|				DoPitch(envelope_data[p->env], p->pitch1, p->pitch2);
 1407|      0|			}
 1408|      0|
 1409|      0|			if (prev->type == phNASAL)
 1410|      0|				last_frame = NULL;
 1411|      0|
 1412|      0|			if (next->type == phVOWEL)
 1413|      0|				StartSyllable();
 1414|      0|			InterpretPhoneme(NULL, 0, p, &phdata, &worddata);
 1415|      0|
 1416|      0|			if ((value = (phdata.pd_param[i_PAUSE_BEFORE] - p->prepause)) > 0)
 1417|      0|				DoPause(value, 1);
 1418|      0|			fmtp.std_length = phdata.pd_param[i_SET_LENGTH]*2;
 1419|      0|			fmtp.fmt_addr = phdata.sound_addr[pd_FMT];
 1420|      0|			fmtp.fmt_amp = phdata.sound_param[pd_FMT];
 1421|      0|			fmtp.wav_addr = phdata.sound_addr[pd_ADDWAV];
 1422|      0|			fmtp.wav_amp = phdata.sound_param[pd_ADDWAV];
 1423|      0|			DoSpect2(p->ph, 0, &fmtp, p, modulation);
 1424|      0|			break;
 1425|      0|		case phVOWEL:
 1426|      0|			ph = p->ph;
 1427|      0|			stress = p->stresslevel & 0xf;
 1428|      0|
 1429|      0|			memset(&fmtp, 0, sizeof(fmtp));
 1430|      0|
 1431|      0|			InterpretPhoneme(NULL, 0, p, &phdata, &worddata);
 1432|      0|			fmtp.std_length = phdata.pd_param[i_SET_LENGTH] * 2;
 1433|      0|			vowelstart_prev = 0;
 1434|      0|
 1435|      0|			if (((fmtp.fmt_addr = phdata.sound_addr[pd_VWLSTART]) != 0) && ((phdata.pd_control & pd_FORNEXTPH) == 0)) {
 1436|      0|				// a vowel start has been specified by the Vowel program
 1437|      0|				fmtp.fmt_length = phdata.sound_param[pd_VWLSTART];
 1438|      0|			} else if (prev->type != phPAUSE) {
 1439|      0|				// check the previous phoneme
 1440|      0|				InterpretPhoneme(NULL, 0, prev, &phdata_prev, NULL);
 1441|      0|				if (((fmtp.fmt_addr = phdata_prev.sound_addr[pd_VWLSTART]) != 0) && (phdata_prev.pd_control & pd_FORNEXTPH)) {
 1442|      0|					// a vowel start has been specified by the previous phoneme
 1443|      0|					vowelstart_prev = 1;
 1444|      0|					fmtp.fmt2_lenadj = phdata_prev.sound_param[pd_VWLSTART];
 1445|      0|				}
 1446|      0|				fmtp.transition0 = phdata_prev.vowel_transition[0];
 1447|      0|				fmtp.transition1 = phdata_prev.vowel_transition[1];
 1448|      0|			}
 1449|      0|
 1450|      0|			if (fmtp.fmt_addr == 0) {
 1451|      0|				// use the default start for this vowel
 1452|      0|				fmtp.use_vowelin = 1;
 1453|      0|				fmtp.fmt_control = 1;
 1454|      0|				fmtp.fmt_addr = phdata.sound_addr[pd_FMT];
 1455|      0|			}
 1456|      0|
 1457|      0|			fmtp.fmt_amp = phdata.sound_param[pd_FMT];
 1458|      0|
 1459|      0|			pitch_env = envelope_data[p->env];
 1460|      0|			amp_env = NULL;
 1461|      0|			if (p->tone_ph != 0) {
 1462|      0|				InterpretPhoneme2(p->tone_ph, &phdata_tone);
 1463|      0|				pitch_env = GetEnvelope(phdata_tone.pitch_env);
 1464|      0|				if (phdata_tone.amp_env > 0)
 1465|      0|					amp_env = GetEnvelope(phdata_tone.amp_env);
 1466|      0|			}
 1467|      0|
 1468|      0|			StartSyllable();
 1469|      0|
 1470|      0|			modulation = 2;
 1471|      0|			if (stress <= 1)
 1472|      0|				modulation = 1; // 16ths
 1473|      0|			else if (stress >= 7)
 1474|      0|				modulation = 3;
 1475|      0|
 1476|      0|			if (prev->type == phVSTOP || prev->type == phVFRICATIVE) {
 1477|      0|				DoAmplitude(p->amp, amp_env);
 1478|      0|				DoPitch(pitch_env, p->pitch1, p->pitch2); // don't use prevocalic rising tone
 1479|      0|				DoSpect2(ph, 1, &fmtp, p, modulation);
 1480|      0|			} else if (prev->type == phLIQUID || prev->type == phNASAL) {
 1481|      0|				DoAmplitude(p->amp, amp_env);
 1482|      0|				DoSpect2(ph, 1, &fmtp, p, modulation); // continue with pre-vocalic rising tone
 1483|      0|				DoPitch(pitch_env, p->pitch1, p->pitch2);
 1484|      0|			} else if (vowelstart_prev) {
 1485|      0|				// VowelStart from the previous phoneme, but not phLIQUID or phNASAL
 1486|      0|				DoPitch(envelope_data[PITCHrise], p->pitch2 - 15, p->pitch2);
 1487|      0|				DoAmplitude(p->amp-1, amp_env);
 1488|      0|				DoSpect2(ph, 1, &fmtp, p, modulation); // continue with pre-vocalic rising tone
 1489|      0|				DoPitch(pitch_env, p->pitch1, p->pitch2);
 1490|      0|			} else {
 1491|      0|				if (!(p->synthflags & SFLAG_SEQCONTINUE)) {
 1492|      0|					DoAmplitude(p->amp, amp_env);
 1493|      0|					DoPitch(pitch_env, p->pitch1, p->pitch2);
 1494|      0|				}
 1495|      0|
 1496|      0|				DoSpect2(ph, 1, &fmtp, p, modulation);
 1497|      0|			}
 1498|      0|
 1499|      0|			if ((option_phoneme_events) && (done_phoneme_marker == false)) {
 1500|      0|				WritePhMnemonic(phoneme_name, p->ph, p, use_ipa, NULL);
 1501|      0|				DoPhonemeMarker(espeakEVENT_PHONEME, sourceix, 0, phoneme_name);
 1502|      0|			}
 1503|      0|
 1504|      0|			fmtp.fmt_addr = phdata.sound_addr[pd_FMT];
 1505|      0|			fmtp.fmt_amp = phdata.sound_param[pd_FMT];
 1506|      0|			fmtp.transition0 = 0;
 1507|      0|			fmtp.transition1 = 0;
 1508|      0|
 1509|      0|			if ((fmtp.fmt2_addr = phdata.sound_addr[pd_VWLEND]) != 0)
 1510|      0|				fmtp.fmt2_lenadj = phdata.sound_param[pd_VWLEND];
 1511|      0|			else if (next->type != phPAUSE) {
 1512|      0|				fmtp.fmt2_lenadj = 0;
 1513|      0|				InterpretPhoneme(NULL, 0, next, &phdata_next, NULL);
 1514|      0|
 1515|      0|				fmtp.use_vowelin = 1;
 1516|      0|				fmtp.transition0 = phdata_next.vowel_transition[2]; // always do vowel_transition, even if ph_VWLEND ??  consider [N]
 1517|      0|				fmtp.transition1 = phdata_next.vowel_transition[3];
 1518|      0|
 1519|      0|				if ((fmtp.fmt2_addr = phdata_next.sound_addr[pd_VWLEND]) != 0)
 1520|      0|					fmtp.fmt2_lenadj = phdata_next.sound_param[pd_VWLEND];
 1521|      0|			}
 1522|      0|
 1523|      0|			DoSpect2(ph, 2, &fmtp, p, modulation);
 1524|      0|			break;
 1525|      0|		}
 1526|      0|		ix++;
 1527|      0|	}
 1528|      0|	EndPitch(1);
 1529|      0|	if (*n_ph > 0) {
 1530|      0|		DoMarker(espeakEVENT_END, count_characters, 0, count_sentences); // end of clause
 1531|      0|		*n_ph = 0;
 1532|      0|	}
 1533|      0|
 1534|      0|	return 0; // finished the phoneme list
 1535|      0|}
 1536|       |
 1537|       |int SpeakNextClause(int control)
 1538|      0|{
 1539|      0|	// Speak text from memory (text_in)
 1540|      0|	// control 0: start
 1541|      0|	//    text_in is set
 1542|      0|
 1543|      0|	// The other calls have text_in = NULL
 1544|      0|	// control 1: speak next text
 1545|      0|	//         2: stop
 1546|      0|
 1547|      0|	int clause_tone;
 1548|      0|	char *voice_change;
 1549|      0|	const char *phon_out;
 1550|      0|
 1551|      0|	if (control == 2) {
 1552|      0|		// stop speaking
 1553|      0|		n_phoneme_list = 0;
 1554|      0|		WcmdqStop();
 1555|      0|
 1556|      0|		return 0;
 1557|      0|	}
 1558|      0|
 1559|      0|	if (text_decoder_eof(p_decoder)) {
 1560|      0|		skipping_text = false;
 1561|      0|		return 0;
 1562|      0|	}
 1563|      0|
 1564|      0|	if (current_phoneme_table != voice->phoneme_tab_ix)
 1565|      0|		SelectPhonemeTable(voice->phoneme_tab_ix);
 1566|      0|
 1567|      0|	// read the next clause from the input text file, translate it, and generate
 1568|      0|	// entries in the wavegen command queue
 1569|      0|	TranslateClause(translator, &clause_tone, &voice_change);
 1570|      0|
 1571|      0|	CalcPitches(translator, clause_tone);
 1572|      0|	CalcLengths(translator);
 1573|      0|
 1574|      0|	if ((option_phonemes & 0xf) || (phoneme_callback != NULL)) {
 1575|      0|		phon_out = GetTranslatedPhonemeString(option_phonemes);
 1576|      0|		if (option_phonemes & 0xf)
 1577|      0|			fprintf(f_trans, "%s\n", phon_out);
 1578|      0|		if (phoneme_callback != NULL)
 1579|      0|			phoneme_callback(phon_out);
 1580|      0|	}
 1581|      0|
 1582|      0|	if (skipping_text) {
 1583|      0|		n_phoneme_list = 0;
 1584|      0|		return 1;
 1585|      0|	}
 1586|      0|
 1587|      0|	Generate(phoneme_list, &n_phoneme_list, 0);
 1588|      0|
 1589|      0|	if (voice_change != NULL) {
 1590|      0|		// voice change at the end of the clause (i.e. clause was terminated by a voice change)
 1591|      0|		new_voice = LoadVoiceVariant(voice_change, 0); // add a Voice instruction to wavegen at the end of the clause
 1592|      0|	}
 1593|      0|
 1594|      0|	if (new_voice) {
 1595|      0|		// finished the current clause, now change the voice if there was an embedded
 1596|      0|		// change voice command at the end of it (i.e. clause was broken at the change voice command)
 1597|      0|		DoVoiceChange(voice);
 1598|      0|		new_voice = NULL;
 1599|      0|	}
 1600|      0|
 1601|      0|	return 1;
 1602|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/synthesize.h:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2014 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2017 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#ifndef ESPEAK_NG_SYNTHESIZE_H
   21|       |#define ESPEAK_NG_SYNTHESIZE_H
   22|       |
   23|       |#ifdef __cplusplus
   24|       |extern "C"
   25|       |{
   26|       |#endif
   27|       |
   28|       |#include <stdint.h>
   29|       |#include <stdbool.h>
   30|       |#include <espeak-ng/espeak_ng.h>
   31|       |#include "phoneme.h"              // for PHONEME_TAB, N_PHONEME_TAB
   32|       |
   33|      0|#define espeakINITIALIZE_PHONEME_IPA 0x0002 // move this to speak_lib.h, after eSpeak version 1.46.02
   34|       |
   35|      0|#define N_PHONEME_LIST 1000 // enough for source[N_TR_SOURCE] full of text, else it will truncate
   36|       |
   37|      0|#define N_SEQ_FRAMES  25 // max frames in a spectrum sequence (real max is ablut 8)
   38|      0|#define STEPSIZE      64 // 2.9mS at 22 kHz sample rate
   39|       |
   40|       |// flags set for frames within a spectrum sequence
   41|      0|#define FRFLAG_KLATT           0x01 // this frame includes extra data for Klatt synthesizer
   42|      0|#define FRFLAG_VOWEL_CENTRE    0x02 // centre point of vowel
   43|      0|#define FRFLAG_LEN_MOD         0x04 // reduce effect of length adjustment
   44|      0|#define FRFLAG_BREAK_LF        0x08 // but keep f3 upwards
   45|      0|#define FRFLAG_BREAK           0x10 // don't merge with next frame
   46|      0|#define FRFLAG_FORMANT_RATE    0x20 // Flag5 allow increased rate of change of formant freq
   47|      0|#define FRFLAG_MODULATE        0x40 // Flag6 modulate amplitude of some cycles to give trill
   48|      0|#define FRFLAG_DEFER_WAV       0x80 // Flag7 defer mixing WAV until the next frame
   49|      0|#define FRFLAG_LEN_MOD2      0x4000 // reduce effect of length adjustment, used for the start of a vowel
   50|      0|#define FRFLAG_COPIED        0x8000 // This frame has been copied into temporary rw memory
   51|       |
   52|      0|#define SFLAG_SEQCONTINUE      0x01 // a liquid or nasal after a vowel, but not followed by a vowel
   53|      0|#define SFLAG_EMBEDDED         0x02 // there are embedded commands before this phoneme
   54|      0|#define SFLAG_SYLLABLE         0x04 // vowel or syllabic consonant
   55|      0|#define SFLAG_LENGTHEN         0x08 // lengthen symbol : included after this phoneme
   56|      0|#define SFLAG_DICTIONARY       0x10 // the pronunciation of this word was listed in the xx_list dictionary
   57|      0|#define SFLAG_SWITCHED_LANG    0x20 // this word uses phonemes from a different language
   58|      0|#define SFLAG_PROMOTE_STRESS   0x40 // this unstressed word can be promoted to stressed
   59|       |
   60|      0|#define SFLAG_NEXT_PAUSE     0x2000 // consider next phoneme as pause
   61|       |
   62|       |// embedded command numbers
   63|      0|#define EMBED_P     1 // pitch
   64|      0|#define EMBED_S     2 // speed (used in setlengths)
   65|      0|#define EMBED_A     3 // amplitude/volume
   66|      0|#define EMBED_R     4 // pitch range/expression
   67|      0|#define EMBED_H     5 // echo/reverberation
   68|      0|#define EMBED_T     6 // different tone for announcing punctuation (not used)
   69|      0|#define EMBED_I     7 // sound icon
   70|      0|#define EMBED_S2    8 // speed (used in synthesize)
   71|      0|#define EMBED_Y     9 // say-as commands
   72|      0|#define EMBED_M    10 // mark name
   73|      0|#define EMBED_U    11 // audio uri
   74|      0|#define EMBED_B    12 // break
   75|      0|#define EMBED_F    13 // emphasis
   76|       |
   77|      0|#define N_EMBEDDED_VALUES    15
   78|       |extern int embedded_value[N_EMBEDDED_VALUES];
   79|       |extern int embedded_default[N_EMBEDDED_VALUES];
   80|       |
   81|      0|#define N_KLATTP   10 // this affects the phoneme data file format
   82|       |#define N_KLATTP2  14 // used in vowel files, with extra parameters for future extensions
   83|       |
   84|      0|#define KLATT_AV      0
   85|      0|#define KLATT_FNZ     1 // nasal zero freq
   86|      0|#define KLATT_Tilt    2
   87|      0|#define KLATT_Aspr    3
   88|      0|#define KLATT_Skew    4
   89|       |
   90|      0|#define KLATT_Kopen   5
   91|      0|#define KLATT_AVp     6
   92|      0|#define KLATT_Fric    7
   93|      0|#define KLATT_FricBP  8
   94|      0|#define KLATT_Turb    9
   95|       |
   96|       |typedef struct { // 64 bytes
   97|       |	short frflags;
   98|       |	short ffreq[7];
   99|       |	unsigned char length;
  100|       |	unsigned char rms;
  101|       |	unsigned char fheight[8];
  102|       |	unsigned char fwidth[6];   // width/4  f0-5
  103|       |	unsigned char fright[3];   // width/4  f0-2
  104|       |	unsigned char bw[4];       // Klatt bandwidth BNZ /2, f1,f2,f3
  105|       |	unsigned char klattp[5];   // AV, FNZ, Tilt, Aspr, Skew
  106|       |	unsigned char klattp2[5];  // continuation of klattp[],  Avp, Fric, FricBP, Turb
  107|       |	unsigned char klatt_ap[7]; // Klatt parallel amplitude
  108|       |	unsigned char klatt_bp[7]; // Klatt parallel bandwidth  /2
  109|       |	unsigned char spare;       // pad to multiple of 4 bytes
  110|       |} frame_t; // with extra Klatt parameters for parallel resonators
  111|       |
  112|       |typedef struct { // 44 bytes
  113|       |	short frflags;
  114|       |	short ffreq[7];
  115|       |	unsigned char length;
  116|       |	unsigned char rms;
  117|       |	unsigned char fheight[8];
  118|       |	unsigned char fwidth[6];  // width/4  f0-5
  119|       |	unsigned char fright[3];  // width/4  f0-2
  120|       |	unsigned char bw[4];      // Klatt bandwidth BNZ /2, f1,f2,f3
  121|       |	unsigned char klattp[5];  // AV, FNZ, Tilt, Aspr, Skew
  122|       |} frame_t2; // without the extra Klatt parameters
  123|       |
  124|       |typedef struct {
  125|       |	unsigned char *pitch_env;
  126|       |	int pitch;      // pitch Hz*256
  127|       |	int pitch_ix;   // index into pitch envelope (*256)
  128|       |	int pitch_inc;  // increment to pitch_ix
  129|       |	int pitch_base; // Hz*256 low, before modified by envelope
  130|       |	int pitch_range; // Hz*256 range of envelope
  131|       |
  132|       |	unsigned char *mix_wavefile; // wave file to be added to synthesis
  133|       |	int n_mix_wavefile; // length in bytes
  134|       |	int mix_wave_scale; // 0=2 byte samples
  135|       |	int mix_wave_amp;
  136|       |	int mix_wavefile_ix;
  137|       |	int mix_wavefile_max; // length of available WAV data (in bytes)
  138|       |	int mix_wavefile_offset;
  139|       |
  140|       |	int amplitude;
  141|       |	int amplitude_v;
  142|       |	int amplitude_fmt; // percentage amplitude adjustment for formant synthesis
  143|       |} WGEN_DATA;
  144|       |
  145|       |typedef struct {
  146|       |	double a;
  147|       |	double b;
  148|       |	double c;
  149|       |	double x1;
  150|       |	double x2;
  151|       |} RESONATOR;
  152|       |
  153|       |typedef struct {
  154|       |	short length_total; // not used
  155|       |	unsigned char n_frames;
  156|       |	unsigned char sqflags;
  157|       |	frame_t2 frame[N_SEQ_FRAMES]; // max. frames in a spectrum sequence
  158|       |} SPECT_SEQ; // sequence of espeak formant frames
  159|       |
  160|       |typedef struct {
  161|       |	short length_total; // not used
  162|       |	unsigned char n_frames;
  163|       |	unsigned char sqflags;
  164|       |	frame_t frame[N_SEQ_FRAMES]; // max. frames in a spectrum sequence
  165|       |} SPECT_SEQK; // sequence of klatt formants frames
  166|       |
  167|       |typedef struct {
  168|       |	short length;
  169|       |	short frflags;
  170|       |	frame_t *frame;
  171|       |} frameref_t;
  172|       |
  173|       |// a clause translated into phoneme codes (first stage)
  174|       |typedef struct {
  175|       |	unsigned short synthflags; // NOTE Put shorts on 32bit boundaries, because of RISC OS compiler bug?
  176|       |	unsigned char phcode;
  177|       |	unsigned char stresslevel;
  178|       |	unsigned short sourceix;  // ix into the original source text string, only set at the start of a word
  179|       |	unsigned char wordstress; // the highest level stress in this word
  180|       |	unsigned char tone_ph;    // tone phoneme to use with this vowel
  181|       |} PHONEME_LIST2;
  182|       |
  183|      0|#define PHLIST_START_OF_WORD     1
  184|      0|#define PHLIST_END_OF_CLAUSE     2
  185|      0|#define PHLIST_START_OF_SENTENCE 4
  186|      0|#define PHLIST_START_OF_CLAUSE   8
  187|       |
  188|       |typedef struct {
  189|       |	// The first section is a copy of PHONEME_LIST2
  190|       |	unsigned short synthflags;
  191|       |	unsigned char phcode;
  192|       |	unsigned char stresslevel;
  193|       |	unsigned short sourceix;  // ix into the original source text string, only set at the start of a word
  194|       |	unsigned char wordstress; // the highest level stress in this word
  195|       |	unsigned char tone_ph;    // tone phoneme to use with this vowel
  196|       |
  197|       |	PHONEME_TAB *ph;
  198|       |	unsigned int length;  // length_mod
  199|       |	unsigned char env;    // pitch envelope number
  200|       |	unsigned char type;
  201|       |	unsigned char prepause;
  202|       |	unsigned char amp;
  203|       |	unsigned char newword;   // bit flags, see PHLIST_(START|END)_OF_*
  204|       |	unsigned char pitch1;
  205|       |	unsigned char pitch2;
  206|       |	unsigned char std_length;
  207|       |	unsigned int phontab_addr;
  208|       |	int sound_param;
  209|       |} PHONEME_LIST;
  210|       |
  211|      0|#define pd_FMT    0
  212|      0|#define pd_WAV    1
  213|      0|#define pd_VWLSTART 2
  214|      0|#define pd_VWLEND 3
  215|      0|#define pd_ADDWAV 4
  216|       |
  217|      0|#define N_PHONEME_DATA_PARAM 16
  218|      0|#define pd_INSERTPHONEME   i_INSERT_PHONEME
  219|      0|#define pd_APPENDPHONEME   i_APPEND_PHONEME
  220|      0|#define pd_CHANGEPHONEME   i_CHANGE_PHONEME
  221|      0|#define pd_CHANGE_NEXTPHONEME  i_REPLACE_NEXT_PHONEME
  222|      0|#define pd_LENGTHMOD       i_SET_LENGTH
  223|       |
  224|      0|#define pd_FORNEXTPH     0x2
  225|      0|#define pd_DONTLENGTHEN  0x4
  226|       |
  227|       |typedef struct {
  228|       |	int pd_control;
  229|       |	int pd_param[N_PHONEME_DATA_PARAM];  // set from group 0 instructions
  230|       |	int sound_addr[5];
  231|       |	int sound_param[5];
  232|       |	int vowel_transition[4];
  233|       |	int pitch_env;
  234|       |	int amp_env;
  235|       |	char ipa_string[18];
  236|       |} PHONEME_DATA;
  237|       |
  238|       |typedef struct {
  239|       |	int fmt_control;
  240|       |	int use_vowelin;
  241|       |	int fmt_addr;
  242|       |	int fmt_length;
  243|       |	int fmt_amp;
  244|       |	int fmt2_addr;
  245|       |	int fmt2_lenadj;
  246|       |	int wav_addr;
  247|       |	int wav_amp;
  248|       |	int transition0;
  249|       |	int transition1;
  250|       |	int std_length;
  251|       |} FMT_PARAMS;
  252|       |
  253|       |typedef struct {
  254|       |	PHONEME_LIST prev_vowel;
  255|       |} WORD_PH_DATA;
  256|       |
  257|       |// instructions
  258|       |
  259|      0|#define INSTN_RETURN         0x0001
  260|      0|#define INSTN_CONTINUE       0x0002
  261|       |
  262|       |// Group 0 instructions with 8 bit operand.  These values go into bits 8-15 of the instruction
  263|      0|#define i_CHANGE_PHONEME 0x01
  264|      0|#define i_REPLACE_NEXT_PHONEME 0x02
  265|      0|#define i_INSERT_PHONEME 0x03
  266|      0|#define i_APPEND_PHONEME 0x04
  267|      0|#define i_APPEND_IFNEXTVOWEL 0x05
  268|       |#define i_VOICING_SWITCH 0x06
  269|      0|#define i_PAUSE_BEFORE   0x07
  270|       |#define i_PAUSE_AFTER    0x08
  271|      0|#define i_LENGTH_MOD     0x09
  272|      0|#define i_SET_LENGTH     0x0a
  273|       |#define i_LONG_LENGTH    0x0b
  274|      0|#define i_ADD_LENGTH     0x0c
  275|      0|#define i_IPA_NAME       0x0d
  276|       |
  277|       |#define i_CHANGE_IF      0x10  // 0x10 to 0x14
  278|       |
  279|       |// conditions and jumps
  280|       |#define i_CONDITION  0x2000
  281|       |#define i_OR         0x1000  // added to i_CONDITION
  282|      0|#define i_NOT        0x0003
  283|       |
  284|       |#define i_JUMP       0x6000
  285|      0|#define i_JUMP_FALSE 0x6800
  286|       |#define i_SWITCH_NEXTVOWEL 0x6a00
  287|       |#define i_SWITCH_PREVVOWEL 0x6c00
  288|       |#define MAX_JUMP     255  // max jump distance
  289|       |
  290|       |// multi-word instructions
  291|       |#define i_CALLPH     0x9100
  292|       |#define i_PITCHENV   0x9200
  293|       |#define i_AMPENV     0x9300
  294|       |#define i_VOWELIN    0xa100
  295|       |#define i_VOWELOUT   0xa200
  296|       |#define i_FMT        0xb000
  297|       |#define i_WAV        0xc000
  298|       |#define i_VWLSTART   0xd000
  299|       |#define i_VWLENDING  0xe000
  300|       |#define i_WAVADD     0xf000
  301|       |
  302|       |// conditions
  303|      0|#define CONDITION_IS_PHONEME_TYPE 0x00
  304|      0|#define CONDITION_IS_PLACE_OF_ARTICULATION 0x20
  305|      0|#define CONDITION_IS_PHFLAG_SET 0x40
  306|      0|#define CONDITION_IS_OTHER 0x80
  307|       |
  308|       |// other conditions (stress)
  309|      0|#define STRESS_IS_DIMINISHED    0       // diminished, unstressed within a word
  310|      0|#define STRESS_IS_UNSTRESSED    1       // unstressed, weak
  311|      0|#define STRESS_IS_NOT_STRESSED  2       // default, not stressed
  312|      0|#define STRESS_IS_SECONDARY     3       // secondary stress
  313|      0|#define STRESS_IS_PRIMARY       4       // primary (main) stress
  314|      0|#define STRESS_IS_PRIORITY      5       // replaces primary markers
  315|       |
  316|       |// other conditions
  317|      0|#define isAfterStress  9
  318|      0|#define isNotVowel    10
  319|      0|#define isFinalVowel  11
  320|      0|#define isVoiced      12 // voiced consonant, or vowel
  321|      0|#define isFirstVowel  13
  322|      0|#define isSecondVowel 14
  323|      0|#define isTranslationGiven 16 // phoneme translation given in **_list or as [[...]]
  324|      0|#define isBreak        17 // pause phoneme or (stop/vstop/vfric not followed by vowel or (liquid in same word))
  325|      0|#define isWordStart    18
  326|      0|#define isWordEnd      19
  327|       |
  328|       |#define i_StressLevel  0x800
  329|       |
  330|       |typedef struct {
  331|       |	int pause_factor;
  332|       |	int clause_pause_factor;
  333|       |	unsigned int min_pause;
  334|       |	int wav_factor;
  335|       |	int lenmod_factor;
  336|       |	int lenmod2_factor;
  337|       |	int min_sample_len;
  338|       |	int fast_settings;	// TODO: rename this variable to better explain the purpose, or delete if there is none
  339|       |} SPEED_FACTORS;
  340|       |
  341|       |typedef struct {
  342|       |	char name[12];
  343|       |	unsigned char flags[4];
  344|       |	signed char head_extend[8];
  345|       |
  346|       |	unsigned char prehead_start;
  347|       |	unsigned char prehead_end;
  348|       |	unsigned char stressed_env;
  349|       |	unsigned char stressed_drop;
  350|       |	unsigned char secondary_drop;
  351|       |	unsigned char unstressed_shape;
  352|       |
  353|       |	unsigned char onset;
  354|       |	unsigned char head_start;
  355|       |	unsigned char head_end;
  356|       |	unsigned char head_last;
  357|       |
  358|       |	unsigned char head_max_steps;
  359|       |	unsigned char n_head_extend;
  360|       |
  361|       |	signed char unstr_start[3]; // for: onset, head, last
  362|       |	signed char unstr_end[3];
  363|       |
  364|       |	unsigned char nucleus0_env; // pitch envelope, tonic syllable is at end, no tail
  365|       |	unsigned char nucleus0_max;
  366|       |	unsigned char nucleus0_min;
  367|       |
  368|       |	unsigned char nucleus1_env; // when followed by a tail
  369|       |	unsigned char nucleus1_max;
  370|       |	unsigned char nucleus1_min;
  371|       |	unsigned char tail_start;
  372|       |	unsigned char tail_end;
  373|       |
  374|       |	unsigned char split_nucleus_env;
  375|       |	unsigned char split_nucleus_max;
  376|       |	unsigned char split_nucleus_min;
  377|       |	unsigned char split_tail_start;
  378|       |	unsigned char split_tail_end;
  379|       |	unsigned char split_tune;
  380|       |
  381|       |	unsigned char spare[8];
  382|       |	int spare2; // the struct length should be a multiple of 4 bytes
  383|       |} TUNE;
  384|       |
  385|       |extern int n_tunes;
  386|       |extern TUNE *tunes;
  387|       |
  388|       |// phoneme table
  389|       |extern PHONEME_TAB *phoneme_tab[N_PHONEME_TAB];
  390|       |
  391|       |// list of phonemes in a clause
  392|       |extern int n_phoneme_list;
  393|       |extern PHONEME_LIST phoneme_list[N_PHONEME_LIST+1];
  394|       |extern unsigned int embedded_list[];
  395|       |
  396|       |extern unsigned char env_fall[128];
  397|       |extern unsigned char env_rise[128];
  398|       |extern unsigned char env_frise[128];
  399|       |
  400|      0|#define MAX_PITCH_VALUE  101
  401|       |extern unsigned char pitch_adjust_tab[MAX_PITCH_VALUE+1];
  402|       |
  403|       |// queue of commands for wavegen
  404|      0|#define WCMD_KLATT  1
  405|      0|#define WCMD_KLATT2 2
  406|      0|#define WCMD_SPECT  3
  407|      0|#define WCMD_SPECT2 4
  408|      0|#define WCMD_PAUSE  5
  409|      0|#define WCMD_WAVE    6
  410|      0|#define WCMD_WAVE2   7
  411|      0|#define WCMD_AMPLITUDE 8
  412|      0|#define WCMD_PITCH  9
  413|      0|#define WCMD_MARKER 10
  414|      0|#define WCMD_VOICE   11
  415|      0|#define WCMD_EMBEDDED 12
  416|      0|#define WCMD_MBROLA_DATA 13
  417|      0|#define WCMD_FMT_AMPLITUDE 14
  418|       |#define WCMD_SONIC_SPEED 15
  419|      0|#define WCMD_PHONEME_ALIGNMENT 16
  420|       |
  421|      0|#define N_WCMDQ   170
  422|      0|#define MIN_WCMDQ  25   // need this many free entries before adding new phoneme
  423|       |
  424|       |extern intptr_t wcmdq[N_WCMDQ][4];
  425|       |extern int wcmdq_head;
  426|       |extern int wcmdq_tail;
  427|       |
  428|       |void MarkerEvent(int type, unsigned int char_position, int value, int value2, unsigned char *out_ptr);
  429|       |
  430|       |extern unsigned char *wavefile_data;
  431|       |extern int samplerate;
  432|       |extern int samplerate_native;
  433|       |
  434|      0|#define N_ECHO_BUF 5500   // max of 250mS at 22050 Hz
  435|       |extern int echo_head;
  436|       |extern int echo_tail;
  437|       |extern int echo_amp;
  438|       |extern short echo_buf[N_ECHO_BUF];
  439|       |
  440|       |void SynthesizeInit(void);
  441|       |int  Generate(PHONEME_LIST *phoneme_list, int *n_ph, bool resume);
  442|       |int  SpeakNextClause(int control);
  443|       |void SetSpeed(int control);
  444|       |void SetEmbedded(int control, int value);
  445|       |int FormantTransition2(frameref_t *seq, int *n_frames, unsigned int data1, unsigned int data2, PHONEME_TAB *other_ph, int which);
  446|       |
  447|       |void Write4Bytes(FILE *f, int value);
  448|       |
  449|       |#if HAVE_SONIC_H
  450|       |void DoSonicSpeed(int value);
  451|       |#endif
  452|       |
  453|      0|#define ENV_LEN  128    // length of pitch envelopes
  454|      0|#define PITCHfall   0  // standard pitch envelopes
  455|      0|#define PITCHrise   2
  456|      0|#define N_ENVELOPE_DATA   20
  457|       |extern unsigned char *envelope_data[N_ENVELOPE_DATA];
  458|       |
  459|       |extern int formant_rate[];         // max rate of change of each formant
  460|       |extern SPEED_FACTORS speed;
  461|       |
  462|       |extern unsigned char *out_ptr;
  463|       |extern unsigned char *out_end;
  464|       |extern espeak_EVENT *event_list;
  465|       |extern t_espeak_callback *synth_callback;
  466|       |extern const int version_phdata;
  467|       |
  468|       |void DoEmbedded(int *embix, int sourceix);
  469|       |void DoMarker(int type, int char_posn, int length, int value);
  470|       |void DoPhonemeMarker(int type, int char_posn, int length, char *name);
  471|       |int DoSample3(PHONEME_DATA *phdata, int length_mod, int amp);
  472|       |int DoSpect2(PHONEME_TAB *this_ph, int which, FMT_PARAMS *fmt_params,  PHONEME_LIST *plist, int modulation);
  473|       |int PauseLength(int pause, int control);
  474|       |const char *WordToString(unsigned int word);
  475|       |
  476|       |#ifdef __cplusplus
  477|       |}
  478|       |#endif
  479|       |
  480|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/tr_languages.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2015 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2016, 2020 Reece H. Dunn
    5|       | * Copyright (C) 2021 Juho Hiltunen
    6|       | *
    7|       | * This program is free software; you can redistribute it and/or modify
    8|       | * it under the terms of the GNU General Public License as published by
    9|       | * the Free Software Foundation; either version 3 of the License, or
   10|       | * (at your option) any later version.
   11|       | *
   12|       | * This program is distributed in the hope that it will be useful,
   13|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   14|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   15|       | * GNU General Public License for more details.
   16|       | *
   17|       | * You should have received a copy of the GNU General Public License
   18|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   19|       | */
   20|       |
   21|       |#include "config.h"
   22|       |
   23|       |#include <ctype.h>
   24|       |#include <locale.h>
   25|       |#include <stdint.h>
   26|       |#include <stdio.h>
   27|       |#include <stdlib.h>
   28|       |#include <string.h>
   29|       |
   30|       |#include <espeak-ng/espeak_ng.h>
   31|       |#include <espeak-ng/speak_lib.h>
   32|       |#include <espeak-ng/encoding.h>
   33|       |
   34|       |#include "setlengths.h"          // for SetLengthMods
   35|       |#include "translate.h"           // for Translator, LANGUAGE_OPTIONS, L, NUM...
   36|       |
   37|       |// start of unicode pages for character sets
   38|      0|#define OFFSET_GREEK    0x380
   39|      0|#define OFFSET_CYRILLIC 0x420
   40|      0|#define OFFSET_ARMENIAN 0x530
   41|       |#define OFFSET_HEBREW   0x590
   42|      0|#define OFFSET_ARABIC   0x600
   43|       |#define OFFSET_SYRIAC   0x700
   44|      0|#define OFFSET_DEVANAGARI  0x900
   45|      0|#define OFFSET_BENGALI  0x980
   46|      0|#define OFFSET_GURMUKHI 0xa00
   47|      0|#define OFFSET_GUJARATI 0xa80
   48|      0|#define OFFSET_ORIYA    0xb00
   49|      0|#define OFFSET_TAMIL    0xb80
   50|      0|#define OFFSET_TELUGU   0xc00
   51|      0|#define OFFSET_KANNADA  0xc80
   52|      0|#define OFFSET_MALAYALAM 0xd00
   53|      0|#define OFFSET_SINHALA  0x0d80
   54|       |#define OFFSET_THAI     0x0e00
   55|       |#define OFFSET_LAO      0x0e80
   56|      0|#define OFFSET_TIBET    0x0f00
   57|       |#define OFFSET_MYANMAR  0x1000
   58|      0|#define OFFSET_GEORGIAN 0x10a0
   59|      0|#define OFFSET_KOREAN   0x1100
   60|      0|#define OFFSET_ETHIOPIC 0x1200
   61|       |
   62|       |// character ranges must be listed in ascending unicode order
   63|       |ALPHABET alphabets[] = {
   64|       |	{ "_el",    OFFSET_GREEK,    0x380, 0x3ff,  L('e', 'l'), AL_DONT_NAME | AL_NOT_LETTERS | AL_WORDS },
   65|       |	{ "_cyr",   OFFSET_CYRILLIC, 0x400, 0x52f,  0, 0 },
   66|       |	{ "_hy",    OFFSET_ARMENIAN, 0x530, 0x58f,  L('h', 'y'), AL_WORDS },
   67|       |	{ "_he",    OFFSET_HEBREW,   0x590, 0x5ff,  0, 0 },
   68|       |	{ "_ar",    OFFSET_ARABIC,   0x600, 0x6ff,  0, 0 },
   69|       |	{ "_syc",   OFFSET_SYRIAC,   0x700, 0x74f,  0, 0 },
   70|       |	{ "_hi",    OFFSET_DEVANAGARI, 0x900, 0x97f, L('h', 'i'), AL_WORDS },
   71|       |	{ "_bn",    OFFSET_BENGALI,  0x0980, 0x9ff, L('b', 'n'), AL_WORDS },
   72|       |	{ "_gur",   OFFSET_GURMUKHI, 0xa00, 0xa7f,  L('p', 'a'), AL_WORDS },
   73|       |	{ "_gu",    OFFSET_GUJARATI, 0xa80, 0xaff,  L('g', 'u'), AL_WORDS },
   74|       |	{ "_or",    OFFSET_ORIYA,    0xb00, 0xb7f,  0, 0 },
   75|       |	{ "_ta",    OFFSET_TAMIL,    0xb80, 0xbff,  L('t', 'a'), AL_WORDS },
   76|       |	{ "_te",    OFFSET_TELUGU,   0xc00, 0xc7f,  L('t', 'e'), 0 },
   77|       |	{ "_kn",    OFFSET_KANNADA,  0xc80, 0xcff,  L('k', 'n'), AL_WORDS },
   78|       |	{ "_ml",    OFFSET_MALAYALAM, 0xd00, 0xd7f,  L('m', 'l'), AL_WORDS },
   79|       |	{ "_si",    OFFSET_SINHALA,  0xd80, 0xdff,  L('s', 'i'), AL_WORDS },
   80|       |	{ "_th",    OFFSET_THAI,     0xe00, 0xe7f,  0, 0 },
   81|       |	{ "_lo",    OFFSET_LAO,      0xe80, 0xeff,  0, 0 },
   82|       |	{ "_ti",    OFFSET_TIBET,    0xf00, 0xfff,  0, 0 },
   83|       |	{ "_my",    OFFSET_MYANMAR,  0x1000, 0x109f, 0, 0 },
   84|       |	{ "_ka",    OFFSET_GEORGIAN, 0x10a0, 0x10ff, L('k', 'a'), AL_WORDS },
   85|       |	{ "_ko",    OFFSET_KOREAN,   0x1100, 0x11ff, L('k', 'o'), AL_WORDS },
   86|       |	{ "_eth",   OFFSET_ETHIOPIC, 0x1200, 0x139f, 0, 0 },
   87|       |	{ "_braille", 0x2800,        0x2800, 0x28ff, 0, AL_NO_SYMBOL },
   88|       |	{ "_ja",    0x3040,          0x3040, 0x30ff, 0, AL_NOT_CODE },
   89|       |	{ "_zh",    0x3100,          0x3100, 0x9fff, 0, AL_NOT_CODE },
   90|       |	{ "_ko",    0xa700,          0xa700, 0xd7ff, L('k', 'o'), AL_NOT_CODE | AL_WORDS },
   91|       |	{ NULL, 0, 0, 0, 0, 0 }
   92|       |};
   93|       |
   94|       |ALPHABET *AlphabetFromChar(int c)
   95|      0|{
   96|      0|	// Find the alphabet from a character.
   97|      0|	ALPHABET *alphabet = alphabets;
   98|      0|
   99|      0|	while (alphabet->name != NULL) {
  100|      0|		if (c <= alphabet->range_max) {
  101|      0|			if (c >= alphabet->range_min)
  102|      0|				return alphabet;
  103|      0|			else
  104|      0|				break;
  105|      0|		}
  106|      0|		alphabet++;
  107|      0|	}
  108|      0|	return NULL;
  109|      0|}
  110|       |
  111|       |static void Translator_Russian(Translator *tr);
  112|       |
  113|       |static void SetLetterVowel(Translator *tr, int c)
  114|      0|{
  115|      0|	tr->letter_bits[c] = (tr->letter_bits[c] & 0x40) | 0x81; // keep value for group 6 (front vowels e,i,y)
  116|      0|}
  117|       |
  118|       |static void ResetLetterBits(Translator *tr, int groups)
  119|      0|{
  120|      0|	// Clear all the specified groups
  121|      0|	unsigned int ix;
  122|      0|	unsigned int mask;
  123|      0|
  124|      0|	mask = ~groups;
  125|      0|
  126|      0|	for (ix = 0; ix < sizeof(tr->letter_bits); ix++)
  127|      0|		tr->letter_bits[ix] &= mask;
  128|      0|}
  129|       |
  130|       |static void SetLetterBits(Translator *tr, int group, const char *string)
  131|      0|{
  132|      0|	int bits;
  133|      0|	unsigned char c;
  134|      0|
  135|      0|	bits = (1L << group);
  136|      0|	while ((c = *string++) != 0)
  137|      0|		tr->letter_bits[c] |= bits;
  138|      0|}
  139|       |
  140|       |static void SetLetterBitsRange(Translator *tr, int group, int first, int last)
  141|      0|{
  142|      0|	int bits;
  143|      0|	int ix;
  144|      0|
  145|      0|	bits = (1L << group);
  146|      0|	for (ix = first; ix <= last; ix++)
  147|      0|		tr->letter_bits[ix] |= bits;
  148|      0|}
  149|       |
  150|       |static void SetLetterBitsUTF8(Translator *tr, int group, const char *letters, int offset)
  151|      0|{
  152|      0|	// Add the letters to the specified letter group.
  153|      0|	const char *p = letters;
  154|      0|	int code = -1;
  155|      0|	while (code != 0) {
  156|      0|		int bytes = utf8_in(&code, p);
  157|      0|		if (code > 0x20)
  158|      0|			tr->letter_bits[code - offset] |= (1L << group);
  159|      0|		p += bytes;
  160|      0|	}
  161|      0|}
  162|       |
  163|       |// ignore these characters
  164|       |static const unsigned short chars_ignore_default[] = {
  165|       |	// U+00AD SOFT HYPHEN
  166|       |	//     Used to mark hyphenation points in words for where to split a
  167|       |	//     word at the end of a line to provide readable justified text.
  168|       |	0xad,   1,
  169|       |	// U+200C ZERO WIDTH NON-JOINER
  170|       |	//     Used to prevent combined ligatures being displayed in their
  171|       |	//     combined form.
  172|       |	0x200c, 1,
  173|       |	// U+200D ZERO WIDTH JOINER
  174|       |	//     Used to indicate an alternative connected form made up of the
  175|       |	//     characters surrounding the ZWJ in Devanagari, Kannada, Malayalam
  176|       |	//     and Emoji.
  177|       |//	0x200d, 1, // Not ignored.
  178|       |	// End of the ignored character list.
  179|       |	0,      0
  180|       |};
  181|       |
  182|       |// alternatively, ignore characters but allow zero-width-non-joiner (lang-fa)
  183|       |static const unsigned short chars_ignore_zwnj_hyphen[] = {
  184|       |	// U+00AD SOFT HYPHEN
  185|       |	//     Used to mark hyphenation points in words for where to split a
  186|       |	//     word at the end of a line to provide readable justified text.
  187|       |	0xad,   1,
  188|       |	// U+0640 TATWEEL (KASHIDA)
  189|       |	//     Used in Arabic scripts to stretch characters for justifying
  190|       |	//     the text.
  191|       |	0x640,  1,
  192|       |	// U+200C ZERO WIDTH NON-JOINER
  193|       |	//     Used to prevent combined ligatures being displayed in their
  194|       |	//     combined form.
  195|       |	0x200c, '-',
  196|       |	// U+200D ZERO WIDTH JOINER
  197|       |	//     Used to indicate an alternative connected form made up of the
  198|       |	//     characters surrounding the ZWJ in Devanagari, Kannada, Malayalam
  199|       |	//     and Emoji.
  200|       |//	0x200d, 1, // Not ignored.
  201|       |	// End of the ignored character list.
  202|       |	0,      0
  203|       |};
  204|       |
  205|       |const unsigned char utf8_ordinal[] = { 0xc2, 0xba, 0 }; // masculine ordinal character, UTF-8
  206|       |const unsigned char utf8_null[] = { 0 }; // null string, UTF-8
  207|       |
  208|       |static Translator *NewTranslator(void)
  209|      0|{
  210|      0|	Translator *tr;
  211|      0|	int ix;
  212|      0|	static const unsigned char stress_amps2[] = { 18, 18, 20, 20, 20, 22, 22, 20 };
  213|      0|	static const short stress_lengths2[8] = { 182, 140, 220, 220, 220, 240, 260, 280 };
  214|      0|	static const wchar_t empty_wstring[1] = { 0 };
  215|      0|	static const wchar_t punct_in_word[2] = { '\'', 0 };  // allow hyphen within words
  216|      0|	static const unsigned char default_tunes[6] = { 0, 1, 2, 3, 0, 0 };
  217|      0|
  218|      0|	// Translates character codes in the range transpose_min to transpose_max to
  219|      0|	// a number in the range 1 to 63.  0 indicates there is no translation.
  220|      0|	// Used up to 57 (max of 63)
  221|      0|	static const char transpose_map_latin[] = {
  222|      0|		 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, // 0x60
  223|      0|		16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,  0,  0,  0,  0,  0, // 0x70
  224|      0|		 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0x80
  225|      0|		 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0x90
  226|      0|		 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0xa0
  227|      0|		 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0xb0
  228|      0|		 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0xc0
  229|      0|		 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0xd0
  230|      0|		27, 28, 29,  0,  0, 30, 31, 32, 33, 34, 35, 36,  0, 37, 38,  0, // 0xe0
  231|      0|		 0,  0,  0, 39,  0,  0, 40,  0, 41,  0, 42,  0, 43,  0,  0,  0, // 0xf0
  232|      0|		 0,  0,  0, 44,  0, 45,  0, 46,  0,  0,  0,  0,  0, 47,  0,  0, // 0x100
  233|      0|		 0, 48,  0,  0,  0,  0,  0,  0,  0, 49,  0,  0,  0,  0,  0,  0, // 0x110
  234|      0|		 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0x120
  235|      0|		 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0x130
  236|      0|		 0,  0, 50,  0, 51,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0x140
  237|      0|		 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 52,  0,  0,  0,  0, // 0x150
  238|      0|		 0, 53,  0, 54,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0x160
  239|      0|		 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 55,  0, 56,  0, 57,  0, // 0x170
  240|      0|	};
  241|      0|
  242|      0|	if ((tr = (Translator *)malloc(sizeof(Translator))) == NULL)
  243|      0|		return NULL;
  244|      0|
  245|      0|	tr->encoding = ESPEAKNG_ENCODING_ISO_8859_1;
  246|      0|	dictionary_name[0] = 0;
  247|      0|	tr->dictionary_name[0] = 0;
  248|      0|	tr->dict_condition = 0;
  249|      0|	tr->dict_min_size = 0;
  250|      0|	tr->data_dictrules = NULL; // language_1   translation rules file
  251|      0|	tr->data_dictlist = NULL;  // language_2   dictionary lookup file
  252|      0|
  253|      0|	tr->transpose_min = 0x60;
  254|      0|	tr->transpose_max = 0x17f;
  255|      0|	tr->transpose_map = transpose_map_latin;
  256|      0|	tr->frequent_pairs = NULL;
  257|      0|
  258|      0|	// only need lower case
  259|      0|	tr->letter_bits_offset = 0;
  260|      0|	memset(tr->letter_bits, 0, sizeof(tr->letter_bits));
  261|      0|	memset(tr->letter_groups, 0, sizeof(tr->letter_groups));
  262|      0|
  263|      0|	// 0-6 sets of characters matched by A B C H F G Y  in pronunciation rules
  264|      0|	// these may be set differently for different languages
  265|      0|	SetLetterBits(tr, 0, "aeiou"); // A  vowels, except y
  266|      0|	SetLetterBits(tr, 1, "bcdfgjklmnpqstvxz"); // B  hard consonants, excluding h,r,w
  267|      0|	SetLetterBits(tr, 2, "bcdfghjklmnpqrstvwxz"); // C  all consonants
  268|      0|	SetLetterBits(tr, 3, "hlmnr"); // H  'soft' consonants
  269|      0|	SetLetterBits(tr, 4, "cfhkpqstx"); // F  voiceless consonants
  270|      0|	SetLetterBits(tr, 5, "bdgjlmnrvwyz"); // G voiced
  271|      0|	SetLetterBits(tr, 6, "eiy"); // Letter group Y, front vowels
  272|      0|	SetLetterBits(tr, 7, "aeiouy"); // vowels, including y
  273|      0|
  274|      0|	tr->char_plus_apostrophe = empty_wstring;
  275|      0|	tr->punct_within_word = punct_in_word;
  276|      0|	tr->chars_ignore = chars_ignore_default;
  277|      0|
  278|      0|	for (ix = 0; ix < 8; ix++) {
  279|      0|		tr->stress_amps[ix] = stress_amps2[ix];
  280|      0|		tr->stress_lengths[ix] = stress_lengths2[ix];
  281|      0|	}
  282|      0|	memset(&(tr->langopts), 0, sizeof(tr->langopts));
  283|      0|	tr->langopts.max_lengthmod = 500;
  284|      0|	tr->langopts.lengthen_tonic = 20;
  285|      0|
  286|      0|	tr->langopts.stress_rule = STRESSPOSN_2R;
  287|      0|	tr->langopts.unstressed_wd1 = 1;
  288|      0|	tr->langopts.unstressed_wd2 = 3;
  289|      0|	tr->langopts.param[LOPT_SONORANT_MIN] = 95;
  290|      0|	tr->langopts.param[LOPT_LONG_VOWEL_THRESHOLD] = 190/2;
  291|      0|	tr->langopts.param[LOPT_MAXAMP_EOC] = 19;
  292|      0|	tr->langopts.param[LOPT_UNPRONOUNCABLE] = 's'; // don't count this character at start of word
  293|      0|	tr->langopts.param[LOPT_BRACKET_PAUSE] = 4; // pause at bracket
  294|      0|	tr->langopts.param[LOPT_BRACKET_PAUSE_ANNOUNCED] = 2; // pauses when announcing bracket names
  295|      0|	tr->langopts.max_initial_consonants = 3;
  296|      0|	tr->langopts.replace_chars = NULL;
  297|      0|	tr->langopts.alt_alphabet_lang = L('e', 'n');
  298|      0|	tr->langopts.roman_suffix = utf8_null;
  299|      0|	tr->langopts.lowercase_sentence = false;
  300|      0|
  301|      0|	SetLengthMods(tr, 201);
  302|      0|
  303|      0|	tr->langopts.long_stop = 100;
  304|      0|
  305|      0|	tr->langopts.max_roman = 49;
  306|      0|	tr->langopts.min_roman = 2;
  307|      0|	tr->langopts.thousands_sep = ',';
  308|      0|	tr->langopts.decimal_sep = '.';
  309|      0|	tr->langopts.numbers = NUM_DEFAULT;
  310|      0|	tr->langopts.break_numbers = BREAK_THOUSANDS;
  311|      0|	tr->langopts.max_digits = 14;
  312|      0|
  313|      0|	// index by 0=. 1=, 2=?, 3=! 4=none, 5=emphasized
  314|      0|	unsigned char punctuation_to_tone[INTONATION_TYPES][PUNCT_INTONATIONS] = {
  315|      0|		{  0,  1,  2,  3, 0, 4 },
  316|      0|		{  0,  1,  2,  3, 0, 4 },
  317|      0|		{  5,  6,  2,  3, 0, 4 },
  318|      0|		{  5,  7,  1,  3, 0, 4 },
  319|      0|		{  8,  9, 10,  3, 0, 0 },
  320|      0|		{  8,  8, 10,  3, 0, 0 },
  321|      0|		{ 11, 11, 11, 11, 0, 0 }, // 6 test
  322|      0|		{ 12, 12, 12, 12, 0, 0 }
  323|      0|	};
  324|      0|
  325|      0|	memcpy(tr->punct_to_tone, punctuation_to_tone, sizeof(tr->punct_to_tone));
  326|      0|
  327|      0|	memcpy(tr->langopts.tunes, default_tunes, sizeof(tr->langopts.tunes));
  328|      0|
  329|      0|	return tr;
  330|      0|}
  331|       |
  332|       |// common letter pairs, encode these as a single byte
  333|       |//  2 bytes, using the transposed character codes
  334|       |static const short pairs_ru[] = {
  335|       |	0x010c, //  ла   21052  0x23
  336|       |	0x010e, //  на   18400
  337|       |	0x0113, //  та   14254
  338|       |	0x0301, //  ав   31083
  339|       |	0x030f, //  ов   13420
  340|       |	0x060e, //  не   21798
  341|       |	0x0611, //  ре   19458
  342|       |	0x0903, //  ви   16226
  343|       |	0x0b01, //  ак   14456
  344|       |	0x0b0f, //  ок   17836
  345|       |	0x0c01, //  ал   13324
  346|       |	0x0c09, //  ил   16877
  347|       |	0x0e01, //  ан   15359
  348|       |	0x0e06, //  ен   13543  0x30
  349|       |	0x0e09, //  ин   17168
  350|       |	0x0e0e, //  нн   15973
  351|       |	0x0e0f, //  он   22373
  352|       |	0x0e1c, //  ын   15052
  353|       |	0x0f03, //  во   24947
  354|       |	0x0f11, //  ро   13552
  355|       |	0x0f12, //  со   16368
  356|       |	0x100f, //  оп   19054
  357|       |	0x1011, //  рп   17067
  358|       |	0x1101, //  ар   23967
  359|       |	0x1106, //  ер   18795
  360|       |	0x1109, //  ир   13797
  361|       |	0x110f, //  ор   21737
  362|       |	0x1213, //  тс   25076
  363|       |	0x1220, //  яс   14310
  364|       |	0x7fff
  365|       |};
  366|       |
  367|       |static const unsigned char ru_vowels[] = { // (also kazakh) offset by 0x420 -- а е ё и о у ы э ю я ә ө ұ ү і
  368|       |	0x10, 0x15, 0x31, 0x18, 0x1e, 0x23, 0x2b, 0x2d, 0x2e, 0x2f,  0xb9, 0xc9, 0x91, 0x8f, 0x36, 0
  369|       |};
  370|       |static const unsigned char ru_consonants[] = { // б в г д ж з й к л м н п р с т ф х ц ч ш щ ъ ь қ ң һ
  371|       |	0x11, 0x12, 0x13, 0x14, 0x16, 0x17, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1f, 0x20, 0x21, 0x22, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2c, 0x73, 0x7b, 0x83, 0x9b, 0
  372|       |};
  373|       |
  374|       |static void SetArabicLetters(Translator *tr)
  375|      0|{
  376|      0|	const char *arab_vowel_letters = "َ  ُ  ِ";
  377|      0|	const char *arab_consonant_vowel_letters = "ا و ي";
  378|      0|	const char *arab_consonant_letters = "ب پ ت ة ث ج ح خ د ذ ر ز س ش ص ض ط ظ ع غ ف ق ك ل م ن ئ ؤ ء أ آ إ ه";
  379|      0|	const char *arab_thick_letters = "ص ض ط ظ";
  380|      0|	const char *arab_shadda_letter = " ّ ";
  381|      0|	const char *arab_hamza_letter = " ّ ";
  382|      0|	const char *arab_sukun_letter = " ّ ";
  383|      0|
  384|      0|	SetLetterBitsUTF8(tr, LETTERGP_A, arab_vowel_letters, OFFSET_ARABIC);
  385|      0|	SetLetterBitsUTF8(tr, LETTERGP_B, arab_consonant_vowel_letters, OFFSET_ARABIC);
  386|      0|	SetLetterBitsUTF8(tr, LETTERGP_C, arab_consonant_letters, OFFSET_ARABIC);
  387|      0|	SetLetterBitsUTF8(tr, LETTERGP_F, arab_thick_letters, OFFSET_ARABIC);
  388|      0|	SetLetterBitsUTF8(tr, LETTERGP_G, arab_shadda_letter, OFFSET_ARABIC);
  389|      0|	SetLetterBitsUTF8(tr, LETTERGP_H, arab_hamza_letter, OFFSET_ARABIC);
  390|      0|	SetLetterBitsUTF8(tr, LETTERGP_Y, arab_sukun_letter, OFFSET_ARABIC);
  391|      0|}
  392|       |
  393|       |static void SetCyrillicLetters(Translator *tr)
  394|      0|{
  395|      0|	// Set letter types for Cyrillic script languages: bg (Bulgarian), ru (Russian), tt (Tatar), uk (Ukrainian).
  396|      0|
  397|      0|	// character codes offset by 0x420
  398|      0|	static const char cyrl_soft[] = { 0x2c, 0x19, 0x27, 0x29, 0 }; // letter group B  [k ts; s;] -- ь й ч щ
  399|      0|	static const char cyrl_hard[] = { 0x2a, 0x16, 0x26, 0x28, 0 }; // letter group H  [S Z ts] -- ъ ж ц ш
  400|      0|	static const char cyrl_nothard[] = { 0x11, 0x12, 0x13, 0x14, 0x17, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1f, 0x20, 0x21, 0x22, 0x24, 0x25, 0x27, 0x29, 0x2c, 0 }; // б в г д з й к л м н п р с т ф х ч щ ь
  401|      0|	static const char cyrl_voiced[] = { 0x11, 0x12, 0x13, 0x14, 0x16, 0x17, 0 };    // letter group G  (voiced obstruents) -- б в г д ж з
  402|      0|	static const char cyrl_ivowels[] = { 0x2c, 0x2e, 0x2f, 0x31, 0 };   // letter group Y  (iotated vowels & soft-sign) -- ь ю я ё
  403|      0|	tr->encoding = ESPEAKNG_ENCODING_KOI8_R;
  404|      0|	tr->transpose_min = 0x430;  // convert cyrillic from unicode into range 0x01 to 0x22
  405|      0|	tr->transpose_max = 0x451;
  406|      0|	tr->transpose_map = NULL;
  407|      0|	tr->frequent_pairs = pairs_ru;
  408|      0|
  409|      0|	tr->letter_bits_offset = OFFSET_CYRILLIC;
  410|      0|	memset(tr->letter_bits, 0, sizeof(tr->letter_bits));
  411|      0|	SetLetterBits(tr, LETTERGP_A, (char *)ru_vowels);
  412|      0|	SetLetterBits(tr, LETTERGP_B, cyrl_soft);
  413|      0|	SetLetterBits(tr, LETTERGP_C, (char *)ru_consonants);
  414|      0|	SetLetterBits(tr, LETTERGP_H, cyrl_hard);
  415|      0|	SetLetterBits(tr, LETTERGP_F, cyrl_nothard);
  416|      0|	SetLetterBits(tr, LETTERGP_G, cyrl_voiced);
  417|      0|	SetLetterBits(tr, LETTERGP_Y, cyrl_ivowels);
  418|      0|	SetLetterBits(tr, LETTERGP_VOWEL2, (char *)ru_vowels);
  419|      0|}
  420|       |
  421|       |static void SetIndicLetters(Translator *tr)
  422|      0|{
  423|      0|	// Set letter types for Devanagari (Indic) script languages: Devanagari, Tamill, etc.
  424|      0|
  425|      0|	static const char deva_consonants2[] = { 0x02, 0x03, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x7b, 0x7c, 0x7e, 0x7f, 0 };
  426|      0|	static const char deva_vowels2[] = { 0x60, 0x61, 0x55, 0x56, 0x57, 0x62, 0x63, 0 };  // non-consecutive vowels and vowel-signs
  427|      0|
  428|      0|	memset(tr->letter_bits, 0, sizeof(tr->letter_bits));
  429|      0|	SetLetterBitsRange(tr, LETTERGP_A, 0x04, 0x14); // vowel letters
  430|      0|	SetLetterBitsRange(tr, LETTERGP_A, 0x3e, 0x4d); // + vowel signs, and virama
  431|      0|	SetLetterBits(tr, LETTERGP_A, deva_vowels2);     // + extra vowels and vowel signs
  432|      0|
  433|      0|	SetLetterBitsRange(tr, LETTERGP_B, 0x3e, 0x4d); // vowel signs, and virama
  434|      0|	SetLetterBits(tr, LETTERGP_B, deva_vowels2);     // + extra vowels and vowel signs
  435|      0|
  436|      0|	SetLetterBitsRange(tr, LETTERGP_C, 0x15, 0x39); // the main consonant range
  437|      0|	SetLetterBits(tr, LETTERGP_C, deva_consonants2); // + additional consonants
  438|      0|
  439|      0|	SetLetterBitsRange(tr, LETTERGP_Y, 0x04, 0x14); // vowel letters
  440|      0|	SetLetterBitsRange(tr, LETTERGP_Y, 0x3e, 0x4c); // + vowel signs
  441|      0|	SetLetterBits(tr, LETTERGP_Y, deva_vowels2);     // + extra vowels and vowel signs
  442|      0|
  443|      0|	tr->langopts.param[LOPT_UNPRONOUNCABLE] = 1;    // disable check for unpronouncable words
  444|      0|	tr->langopts.suffix_add_e = tr->letter_bits_offset + 0x4d; // virama
  445|      0|}
  446|       |
  447|       |static void SetupTranslator(Translator *tr, const short *lengths, const unsigned char *amps)
  448|      0|{
  449|      0|	if (lengths != NULL)
  450|      0|		memcpy(tr->stress_lengths, lengths, sizeof(tr->stress_lengths));
  451|      0|	if (amps != NULL)
  452|      0|		memcpy(tr->stress_amps, amps, sizeof(tr->stress_amps));
  453|      0|}
  454|       |
  455|       |Translator *SelectTranslator(const char *name)
  456|      0|{
  457|      0|	int name2 = 0;
  458|      0|	Translator *tr;
  459|      0|
  460|      0|	static const short stress_lengths_equal[8] = { 230, 230,  230, 230,  0, 0,  230, 230 };
  461|      0|	static const unsigned char stress_amps_equal[8] = { 19, 19, 19, 19, 19, 19, 19, 19 };
  462|      0|
  463|      0|	static const short stress_lengths_fr[8] = { 190, 170,  190, 200,  0, 0,  190, 240 };
  464|      0|	static const unsigned char stress_amps_fr[8] = { 18, 16, 18, 18, 18, 18, 18, 18 };
  465|      0|
  466|      0|	static const unsigned char stress_amps_sk[8] = { 17, 16, 20, 20, 20, 22, 22, 21 };
  467|      0|	static const short stress_lengths_sk[8] = { 190, 190, 210, 210, 0, 0, 210, 210 };
  468|      0|
  469|      0|	static const short stress_lengths_ta[8] = { 200, 200,  210, 210,  0, 0,  230, 230 };
  470|      0|	static const short stress_lengths_ta2[8] = { 230, 230,  240, 240,  0, 0,  260, 260 };
  471|      0|	static const unsigned char stress_amps_ta[8] = { 18, 18, 18, 18, 20, 20, 22, 22 };
  472|      0|
  473|      0|	tr = NewTranslator();
  474|      0|	strcpy(tr->dictionary_name, name);
  475|      0|
  476|      0|	// convert name string into a word of up to 4 characters, for the switch()
  477|      0|	while (*name != 0)
  478|      0|		name2 = (name2 << 8) + *name++;
  479|      0|
  480|      0|	switch (name2)
  481|      0|	{
  482|      0|	case L('m', 'i'):
  483|      0|	case L('m', 'y'):
  484|      0|	case L4('p', 'i', 'q', 'd'): // piqd
  485|      0|	case L('p', 'y'):
  486|      0|	case L('q', 'u'):
  487|      0|	case L3('q', 'u', 'c'):
  488|      0|	case L('t', 'h'):
  489|      0|	case L('u', 'z'):
  490|      0|	{
  491|      0|		tr->langopts.numbers = 0; // disable numbers until the definition are complete in _list file
  492|      0|	}
  493|      0|		break;
  494|      0|	case L('a', 'f'):
  495|      0|	{
  496|      0|		static const short stress_lengths_af[8] = { 170, 140, 220, 220,  0, 0, 250, 270 };
  497|      0|		SetupTranslator(tr, stress_lengths_af, NULL);
  498|      0|
  499|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
  500|      0|		tr->langopts.vowel_pause = 0x30;
  501|      0|		tr->langopts.param[LOPT_DIERESES] = 1;
  502|      0|		tr->langopts.param[LOPT_PREFIXES] = 1;
  503|      0|		SetLetterVowel(tr, 'y'); // add 'y' to vowels
  504|      0|
  505|      0|		tr->langopts.numbers = NUM_SWAP_TENS | NUM_HUNDRED_AND | NUM_SINGLE_AND | NUM_ROMAN | NUM_1900;
  506|      0|		tr->langopts.accents = 1;
  507|      0|	}
  508|      0|		break;
  509|      0|	case L('a', 'm'): // Amharic, Ethiopia
  510|      0|	{
  511|      0|		SetupTranslator(tr, stress_lengths_fr, stress_amps_fr);
  512|      0|		tr->letter_bits_offset = OFFSET_ETHIOPIC;
  513|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
  514|      0|		tr->langopts.stress_flags = S_NO_AUTO_2 | S_FINAL_DIM; // don't use secondary stress
  515|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods;  // don't lengthen vowels in the last syllable
  516|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 1;           // disable check for unpronouncable words
  517|      0|		tr->langopts.numbers = NUM_OMIT_1_HUNDRED;
  518|      0|	}
  519|      0|		break;
  520|      0|	case L('a', 'r'): // Arabic
  521|      0|		tr->transpose_min = OFFSET_ARABIC; // for ar_list, use 6-bit character codes
  522|      0|		tr->transpose_max = 0x65f;
  523|      0|		tr->transpose_map = NULL;
  524|      0|		tr->letter_bits_offset = OFFSET_ARABIC;
  525|      0|		tr->langopts.numbers = NUM_SWAP_TENS | NUM_AND_UNITS | NUM_HUNDRED_AND | NUM_OMIT_1_HUNDRED | NUM_AND_HUNDRED | NUM_THOUSAND_AND | NUM_OMIT_1_THOUSAND;
  526|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 1; // disable check for unpronouncable words
  527|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_6;
  528|      0|		SetArabicLetters(tr);
  529|      0|		break;
  530|      0|	case L('b', 'g'): // Bulgarian
  531|      0|	{
  532|      0|		SetCyrillicLetters(tr);
  533|      0|		SetLetterVowel(tr, 0x2a);
  534|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_5;
  535|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 0x432; // [v]  don't count this character at start of word
  536|      0|		tr->langopts.param[LOPT_REGRESSIVE_VOICING] = 0x107; // devoice at end of word, and change voicing to match a following consonant (except v)
  537|      0|		tr->langopts.param[LOPT_REDUCE] = 2;
  538|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
  539|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_ALLOW_SPACE | NUM_OMIT_1_HUNDRED | NUM_HUNDRED_AND | NUM_AND_UNITS | NUM_SINGLE_AND | NUM_ROMAN | NUM_ROMAN_ORDINAL | NUM_ROMAN_CAPITALS;
  540|      0|		tr->langopts.thousands_sep = ' '; // don't allow dot as thousands separator
  541|      0|	}
  542|      0|		break;
  543|      0|	case L('b', 'n'): // Bengali
  544|      0|	case L('a', 's'): // Assamese
  545|      0|	case L3('b', 'p', 'y'): // Manipuri  (temporary placement - it's not indo-european)
  546|      0|	{
  547|      0|		static const short stress_lengths_bn[8] = { 180, 180,  210, 210,  0, 0,  230, 240 };
  548|      0|		static const unsigned char stress_amps_bn[8] = { 18, 18, 18, 18, 20, 20, 22, 22 };
  549|      0|		static const char bn_consonants2[3] = { 0x70, 0x71, 0 };
  550|      0|
  551|      0|		SetupTranslator(tr, stress_lengths_bn, stress_amps_bn);
  552|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
  553|      0|
  554|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
  555|      0|		tr->langopts.stress_flags =  S_MID_DIM | S_FINAL_DIM; // use 'diminished' for unstressed final syllable
  556|      0|		tr->letter_bits_offset = OFFSET_BENGALI;
  557|      0|		SetIndicLetters(tr); // call this after setting OFFSET_BENGALI
  558|      0|		SetLetterBitsRange(tr, LETTERGP_B, 0x01, 0x01); // candranindu
  559|      0|		SetLetterBitsRange(tr, LETTERGP_F, 0x3e, 0x4c); // vowel signs, but not virama
  560|      0|		SetLetterBits(tr, LETTERGP_C, bn_consonants2);
  561|      0|
  562|      0|		tr->langopts.numbers = NUM_SWAP_TENS;
  563|      0|		tr->langopts.break_numbers = BREAK_LAKH_BN;
  564|      0|
  565|      0|		if (name2 == L3('b', 'p', 'y')) {
  566|      0|			tr->langopts.numbers = NUM_DEFAULT;
  567|      0|			tr->langopts.numbers2 = NUM2_SWAP_THOUSANDS;
  568|      0|		}
  569|      0|
  570|      0|	}
  571|      0|		break;
  572|      0|	case L('b', 'o'): // Tibet
  573|      0|	{
  574|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
  575|      0|		tr->letter_bits_offset = OFFSET_TIBET;
  576|      0|		SetLetterBitsRange(tr, LETTERGP_A, 0x71, 0x7d); // vowel signs
  577|      0|		SetLetterBitsRange(tr, LETTERGP_B, 0x71, 0x81); // vowel signs and subjoined letters
  578|      0|		SetLetterBitsRange(tr, LETTERGP_B, 0x90, 0xbc);
  579|      0|		SetLetterBitsRange(tr, LETTERGP_C, 0x40, 0x6c); // consonant letters (not subjoined)
  580|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 1;    // disable check for unpronouncable words
  581|      0|		tr->langopts.numbers = NUM_DEFAULT;
  582|      0|	}
  583|      0|		break;
  584|      0|	case L3('c', 'h', 'r'): // Cherokee
  585|      0|	{
  586|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 1; // disable check for unpronouncable words
  587|      0|		tr->langopts.stress_flags = S_NO_AUTO_2 | S_FINAL_DIM | S_FINAL_DIM_ONLY | S_EO_CLAUSE1;
  588|      0|	}
  589|      0|		break;
  590|      0|	case L('c', 'y'): // Welsh
  591|      0|	{
  592|      0|		static const short stress_lengths_cy[8] = { 170, 220, 180, 180, 0, 0, 250, 270 };
  593|      0|		static const unsigned char stress_amps_cy[8] = { 17, 15, 18, 18, 0, 0, 22, 20 }; // 'diminished' is used to mark a quieter, final unstressed syllable
  594|      0|
  595|      0|		SetupTranslator(tr, stress_lengths_cy, stress_amps_cy);
  596|      0|
  597|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_14;
  598|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
  599|      0|
  600|      0|		// 'diminished' is an unstressed final syllable
  601|      0|		tr->langopts.stress_flags =  S_FINAL_DIM_ONLY | S_FINAL_NO_2;
  602|      0|		tr->langopts.unstressed_wd1 = 0;
  603|      0|		tr->langopts.unstressed_wd2 = 2;
  604|      0|		tr->langopts.param[LOPT_SONORANT_MIN] = 120; // limit the shortening of sonorants before short vowels
  605|      0|
  606|      0|		tr->langopts.numbers = NUM_OMIT_1_HUNDRED;
  607|      0|
  608|      0|		SetLetterVowel(tr, 'w'); // add letter to vowels and remove from consonants
  609|      0|		SetLetterVowel(tr, 'y');
  610|      0|	}
  611|      0|		break;
  612|      0|	case L('d', 'a'): // Danish
  613|      0|	{
  614|      0|		static const short stress_lengths_da[8] = { 160, 140, 200, 200, 0, 0, 220, 230 };
  615|      0|		SetupTranslator(tr, stress_lengths_da, NULL);
  616|      0|
  617|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
  618|      0|		tr->langopts.param[LOPT_PREFIXES] = 1;
  619|      0|		SetLetterVowel(tr, 'y');
  620|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_SWAP_TENS | NUM_HUNDRED_AND | NUM_OMIT_1_HUNDRED | NUM_ORDINAL_DOT | NUM_1900 | NUM_ROMAN | NUM_ROMAN_CAPITALS | NUM_ROMAN_ORDINAL;
  621|      0|	}
  622|      0|		break;
  623|      0|	case L('d', 'e'):
  624|      0|	{
  625|      0|		static const short stress_lengths_de[8] = { 150, 130, 200, 200,  0, 0, 270, 270 };
  626|      0|		static const unsigned char stress_amps_de[] = { 20, 20, 20, 20, 20, 22, 22, 20 };
  627|      0|		SetupTranslator(tr, stress_lengths_de, stress_amps_de);
  628|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
  629|      0|		tr->langopts.word_gap = 0x8; // don't use linking phonemes
  630|      0|		tr->langopts.vowel_pause = 0x30;
  631|      0|		tr->langopts.param[LOPT_PREFIXES] = 1;
  632|      0|		tr->langopts.param[LOPT_REGRESSIVE_VOICING] = 0x100; // devoice at end of word
  633|      0|		tr->langopts.param[LOPT_LONG_VOWEL_THRESHOLD] = 175/2;
  634|      0|
  635|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_SWAP_TENS | NUM_ALLOW_SPACE | NUM_ORDINAL_DOT | NUM_ROMAN;
  636|      0|		SetLetterVowel(tr, 'y');
  637|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 2; // use de_rules for unpronouncable rules
  638|      0|	}
  639|      0|		break;
  640|      0|	case L('e', 'n'):
  641|      0|	{
  642|      0|		static const short stress_lengths_en[8] = { 182, 140, 220, 220, 0, 0, 248, 275 };
  643|      0|		SetupTranslator(tr, stress_lengths_en, NULL);
  644|      0|
  645|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
  646|      0|		tr->langopts.stress_flags = 0x08;
  647|      0|		tr->langopts.numbers = NUM_HUNDRED_AND | NUM_ROMAN | NUM_1900;
  648|      0|		tr->langopts.max_digits = 33;
  649|      0|		tr->langopts.param[LOPT_COMBINE_WORDS] = 2; // allow "mc" to cmbine with the following word
  650|      0|		tr->langopts.suffix_add_e = 'e';
  651|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 2; // use en_rules for unpronouncable rules
  652|      0|		SetLetterBits(tr, 6, "aeiouy"); // Group Y: vowels, including y
  653|      0|	}
  654|      0|		break;
  655|      0|	case L('e', 'l'): // Greek
  656|      0|	case L3('g', 'r', 'c'): // Ancient Greek
  657|      0|	{
  658|      0|		static const short stress_lengths_el[8] = { 155, 180,  210, 210,  0, 0,  270, 300 };
  659|      0|		static const unsigned char stress_amps_el[8] = { 15, 12, 20, 20, 20, 22, 22, 21 }; // 'diminished' is used to mark a quieter, final unstressed syllable
  660|      0|
  661|      0|		// character codes offset by 0x380
  662|      0|		static const char el_vowels[] = { 0x10, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x35, 0x37, 0x39, 0x3f, 0x45, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0 };
  663|      0|		static const char el_fvowels[] = { 0x2d, 0x2e, 0x2f, 0x35, 0x37, 0x39, 0x45, 0x4d, 0 }; // ε η ι υ  έ ή ί ύ _
  664|      0|		static const char el_voiceless[] = { 0x38, 0x3a, 0x3e, 0x40, 0x42, 0x43, 0x44, 0x46, 0x47, 0 }; // θ κ ξ π ς σ τ φ χ _
  665|      0|		static const char el_consonants[] = { 0x32, 0x33, 0x34, 0x36, 0x38, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x40, 0x41, 0x42, 0x43, 0x44, 0x46, 0x47, 0x48, 0 };
  666|      0|		static const wchar_t el_char_apostrophe[] = { 0x3c3, 0 }; // σ _
  667|      0|
  668|      0|		SetupTranslator(tr, stress_lengths_el, stress_amps_el);
  669|      0|
  670|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_7;
  671|      0|		tr->char_plus_apostrophe = el_char_apostrophe;
  672|      0|
  673|      0|		tr->letter_bits_offset = OFFSET_GREEK;
  674|      0|		memset(tr->letter_bits, 0, sizeof(tr->letter_bits));
  675|      0|		SetLetterBits(tr, LETTERGP_A, el_vowels);
  676|      0|		SetLetterBits(tr, LETTERGP_VOWEL2, el_vowels);
  677|      0|		SetLetterBits(tr, LETTERGP_B, el_voiceless);
  678|      0|		SetLetterBits(tr, LETTERGP_C, el_consonants);
  679|      0|		SetLetterBits(tr, LETTERGP_Y, el_fvowels); // front vowels: ε η ι υ _
  680|      0|
  681|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
  682|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
  683|      0|		tr->langopts.stress_flags = S_FINAL_DIM_ONLY; // mark unstressed final syllables as diminished
  684|      0|		tr->langopts.unstressed_wd1 = 0;
  685|      0|		tr->langopts.unstressed_wd2 = 2;
  686|      0|		tr->langopts.param[LOPT_SONORANT_MIN] = 130; // limit the shortening of sonorants before short vowels
  687|      0|
  688|      0|		tr->langopts.numbers = NUM_SINGLE_STRESS | NUM_DECIMAL_COMMA;
  689|      0|		tr->langopts.numbers2 = NUM2_THOUSANDPLEX_VAR_THOUSANDS | NUM2_MULTIPLE_ORDINAL | NUM2_ORDINAL_NO_AND;
  690|      0|
  691|      0|		if (name2 == L3('g', 'r', 'c')) {
  692|      0|			// ancient greek
  693|      0|			tr->langopts.param[LOPT_UNPRONOUNCABLE] = 1;
  694|      0|		}
  695|      0|	}
  696|      0|		break;
  697|      0|	case L('e', 'o'):
  698|      0|	{
  699|      0|		static const short stress_lengths_eo[8] = { 150, 140,  180, 180,    0,   0,  200, 200 };
  700|      0|		static const unsigned char stress_amps_eo[] = { 16, 14, 20, 20, 20, 22, 22, 21 };
  701|      0|		static const wchar_t eo_char_apostrophe[2] = { 'l', 0 };
  702|      0|
  703|      0|		SetupTranslator(tr, stress_lengths_eo, stress_amps_eo);
  704|      0|
  705|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_3;
  706|      0|		tr->char_plus_apostrophe = eo_char_apostrophe;
  707|      0|
  708|      0|		tr->langopts.vowel_pause = 2;
  709|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
  710|      0|		tr->langopts.stress_flags =  S_FINAL_DIM_ONLY | S_FINAL_NO_2;
  711|      0|		tr->langopts.unstressed_wd2 = 2;
  712|      0|
  713|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_OMIT_1_HUNDRED | NUM_ALLOW_SPACE | NUM_ROMAN;
  714|      0|	}
  715|      0|		break;
  716|      0|	case L('e', 's'): // Spanish
  717|      0|	case L('a', 'n'): // Aragonese
  718|      0|	case L('c', 'a'): // Catalan
  719|      0|	case L('i', 'a'): // Interlingua
  720|      0|	case L3('p', 'a', 'p'): // Papiamento
  721|      0|	{
  722|      0|		static const short stress_lengths_es[8] = { 160, 145,  155, 150,  0, 0,  200, 245 };
  723|      0|		static const unsigned char stress_amps_es[8] = { 16, 14, 15, 16, 20, 20, 22, 22 }; // 'diminished' is used to mark a quieter, final unstressed syllable
  724|      0|		static const wchar_t ca_punct_within_word[] = { '\'', 0xb7, 0 }; // ca: allow middle-dot within word
  725|      0|
  726|      0|		SetupTranslator(tr, stress_lengths_es, stress_amps_es);
  727|      0|
  728|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
  729|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
  730|      0|
  731|      0|		// stress last syllable if it doesn't end in vowel or "s" or "n"
  732|      0|		// 'diminished' is an unstressed final syllable
  733|      0|		tr->langopts.stress_flags = S_FINAL_SPANISH | S_FINAL_DIM_ONLY | S_FINAL_NO_2;
  734|      0|		tr->langopts.unstressed_wd1 = 0;
  735|      0|		tr->langopts.unstressed_wd2 = 2;
  736|      0|		tr->langopts.param[LOPT_SONORANT_MIN] = 120; // limit the shortening of sonorants before short vowels
  737|      0|
  738|      0|		tr->langopts.numbers = NUM_SINGLE_STRESS | NUM_DECIMAL_COMMA | NUM_AND_UNITS | NUM_OMIT_1_HUNDRED | NUM_OMIT_1_THOUSAND | NUM_ROMAN | NUM_ROMAN_AFTER | NUM_DFRACTION_4;
  739|      0|		tr->langopts.numbers2 = NUM2_MULTIPLE_ORDINAL | NUM2_ORDINAL_NO_AND;
  740|      0|
  741|      0|		if (name2 == L('c', 'a')) {
  742|      0|			// stress last syllable unless word ends with a vowel
  743|      0|			tr->punct_within_word = ca_punct_within_word;
  744|      0|			tr->langopts.stress_flags = S_FINAL_SPANISH | S_FINAL_DIM_ONLY | S_FINAL_NO_2 | S_NO_AUTO_2;
  745|      0|		} else if (name2 == L('i', 'a')) {
  746|      0|			tr->langopts.stress_flags = S_FINAL_SPANISH | S_FINAL_DIM_ONLY | S_FINAL_NO_2;
  747|      0|			tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_OMIT_1_HUNDRED | NUM_OMIT_1_THOUSAND | NUM_ROMAN | NUM_ROMAN_AFTER;
  748|      0|		} else if (name2 == L('a', 'n')) {
  749|      0|			tr->langopts.stress_flags = S_FINAL_SPANISH | S_FINAL_DIM_ONLY | S_FINAL_NO_2;
  750|      0|			tr->langopts.numbers = NUM_SINGLE_STRESS | NUM_DECIMAL_COMMA | NUM_AND_UNITS | NUM_OMIT_1_HUNDRED | NUM_OMIT_1_THOUSAND | NUM_ROMAN | NUM_ROMAN_ORDINAL;
  751|      0|			tr->langopts.numbers2 = NUM2_ORDINAL_NO_AND;
  752|      0|			tr->langopts.roman_suffix = utf8_ordinal;
  753|      0|		} else if (name2 == L3('p', 'a', 'p')) {
  754|      0|			// stress last syllable unless word ends with a vowel
  755|      0|			tr->langopts.stress_rule = STRESSPOSN_1R;
  756|      0|			tr->langopts.stress_flags = S_FINAL_VOWEL_UNSTRESSED | S_FINAL_DIM_ONLY | S_FINAL_NO_2 | S_NO_AUTO_2;
  757|      0|		} else
  758|      0|			tr->langopts.param[LOPT_UNPRONOUNCABLE] = 2; // use es_rules for unpronouncable rules
  759|      0|	}
  760|      0|		break;
  761|      0|	case L('e', 'u'): // basque
  762|      0|	{
  763|      0|		static const short stress_lengths_eu[8] = { 200, 200,  200, 200,  0, 0,  210, 230 }; // very weak stress
  764|      0|		static const unsigned char stress_amps_eu[8] = { 16, 16, 18, 18, 18, 18, 18, 18 };
  765|      0|		SetupTranslator(tr, stress_lengths_eu, stress_amps_eu);
  766|      0|		tr->langopts.stress_flags = S_FINAL_VOWEL_UNSTRESSED | S_MID_DIM;
  767|      0|		tr->langopts.param[LOPT_SUFFIX] = 1;
  768|      0|		tr->langopts.numbers = NUM_SINGLE_STRESS | NUM_DECIMAL_COMMA | NUM_HUNDRED_AND | NUM_OMIT_1_HUNDRED | NUM_OMIT_1_THOUSAND | NUM_VIGESIMAL;
  769|      0|	}
  770|      0|		break;
  771|      0|	case L('f', 'a'): // Farsi
  772|      0|	{
  773|      0|		// Convert characters in the range 0x620 to 0x6cc to the range 1 to 63.
  774|      0|		// 0 indicates no translation for this character
  775|      0|		static const char transpose_map_fa[] = {
  776|      0|			 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, // 0x620
  777|      0|			16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,  0,  0,  0,  0,  0, // 0x630
  778|      0|			 0, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, // 0x640
  779|      0|			42, 43,  0,  0, 44,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0x650
  780|      0|			 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0x660
  781|      0|			 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 45,  0, // 0x670
  782|      0|			 0,  0,  0,  0,  0,  0, 46,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0x680
  783|      0|			 0,  0,  0,  0,  0,  0,  0,  0, 47,  0,  0,  0,  0,  0,  0,  0, // 0x690
  784|      0|			 0,  0,  0,  0,  0,  0,  0,  0,  0, 48,  0,  0,  0,  0,  0, 49, // 0x6a0
  785|      0|			 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 0x6b0
  786|      0|			50,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 51              // 0x6c0
  787|      0|		};
  788|      0|		tr->transpose_min = 0x620;
  789|      0|		tr->transpose_max = 0x6cc;
  790|      0|		tr->transpose_map = transpose_map_fa;
  791|      0|		tr->letter_bits_offset = OFFSET_ARABIC;
  792|      0|
  793|      0|		tr->langopts.numbers = NUM_AND_UNITS | NUM_HUNDRED_AND;
  794|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 1; // disable check for unpronouncable words
  795|      0|
  796|      0|		tr->chars_ignore = chars_ignore_zwnj_hyphen; // replace ZWNJ by hyphen
  797|      0|	}
  798|      0|		break;
  799|      0|	case L('e', 't'): // Estonian
  800|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_4;
  801|      0|		// fallthrough:
  802|      0|	case L('f', 'i'): // Finnish
  803|      0|	{
  804|      0|		static const unsigned char stress_amps_fi[8] = { 18, 16, 22, 22, 20, 22, 22, 22 };
  805|      0|		static const short stress_lengths_fi[8] = { 150, 180, 200, 200, 0, 0, 210, 250 };
  806|      0|
  807|      0|		SetupTranslator(tr, stress_lengths_fi, stress_amps_fi);
  808|      0|
  809|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
  810|      0|		tr->langopts.param[LOPT_IT_DOUBLING] = 1;
  811|      0|		tr->langopts.long_stop = 130;
  812|      0|
  813|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_ALLOW_SPACE | NUM_DFRACTION_2 | NUM_ORDINAL_DOT;
  814|      0|		SetLetterVowel(tr, 'y');
  815|      0|		tr->langopts.spelling_stress = 1;
  816|      0|		tr->langopts.intonation_group = 3; // less intonation, don't raise pitch at comma
  817|      0|	}
  818|      0|		break;
  819|      0|	case L('f', 'r'): // french
  820|      0|	{
  821|      0|		SetupTranslator(tr, stress_lengths_fr, stress_amps_fr);
  822|      0|		tr->langopts.stress_rule = STRESSPOSN_1R; // stress on final syllable
  823|      0|		tr->langopts.stress_flags = S_NO_AUTO_2 | S_FINAL_DIM; // don't use secondary stress
  824|      0|		tr->langopts.param[LOPT_IT_LENGTHEN] = 1; // remove lengthen indicator from unstressed syllables
  825|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
  826|      0|		tr->langopts.accents = 2; // Say "Capital" after the letter.
  827|      0|
  828|      0|		tr->langopts.numbers = NUM_SINGLE_STRESS | NUM_DECIMAL_COMMA | NUM_ALLOW_SPACE | NUM_OMIT_1_HUNDRED | NUM_NOPAUSE | NUM_ROMAN | NUM_ROMAN_CAPITALS | NUM_ROMAN_AFTER | NUM_VIGESIMAL | NUM_DFRACTION_4;
  829|      0|		SetLetterVowel(tr, 'y');
  830|      0|	}
  831|      0|		break;
  832|      0|    case L3('h','a', 'k'): // Hakka Chinese
  833|      0|    {
  834|      0|        tr->langopts.stress_flags = S_NO_DIM; // don't automatically set diminished stress (may be set in the intonation module)
  835|      0|        tr->langopts.tone_language = 1; // Tone language, use  CalcPitches_Tone() rather than CalcPitches()
  836|      0|        tr->langopts.tone_numbers = 1; // a number after letters indicates a tone number (eg. pinyin or jyutping)
  837|      0|        tr->langopts.ideographs = 1;
  838|      0|    }
  839|      0|        break;
  840|      0|	case L('g', 'a'): // irish
  841|      0|	case L('g', 'd'): // scots gaelic
  842|      0|	{
  843|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
  844|      0|		tr->langopts.stress_flags = S_NO_AUTO_2; // don't use secondary stress
  845|      0|		tr->langopts.numbers = NUM_OMIT_1_HUNDRED | NUM_OMIT_1_THOUSAND;
  846|      0|		tr->langopts.accents = 2; // 'capital' after letter name
  847|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 3; // don't count apostrophe
  848|      0|		tr->langopts.param[LOPT_IT_LENGTHEN] = 1; // remove [:] phoneme from non-stressed syllables (Lang=gd)
  849|      0|	}
  850|      0|		break;
  851|      0|	case L('g','n'):   // guarani
  852|      0|		{
  853|      0|			tr->langopts.stress_rule = STRESSPOSN_1R;      // stress on final syllable
  854|      0|			tr->langopts.length_mods0 = tr->langopts.length_mods;  // don't lengthen vowels in the last syllable
  855|      0|		}
  856|      0|		break;
  857|      0|	case L('h', 'i'): // Hindi
  858|      0|	case L('n', 'e'): // Nepali
  859|      0|	case L('o', 'r'): // Oriya
  860|      0|	case L('p', 'a'): // Punjabi
  861|      0|	case L('g', 'u'): // Gujarati
  862|      0|	case L('m', 'r'): // Marathi
  863|      0|	{
  864|      0|		static const short stress_lengths_hi[8] = { 190, 190,  210, 210,  0, 0,  230, 250 };
  865|      0|		static const unsigned char stress_amps_hi[8] = { 17, 14, 20, 19, 20, 22, 22, 21 };
  866|      0|
  867|      0|		SetupTranslator(tr, stress_lengths_hi, stress_amps_hi);
  868|      0|		tr->encoding = ESPEAKNG_ENCODING_ISCII;
  869|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
  870|      0|
  871|      0|		tr->langopts.stress_rule = STRESSPOSN_1RH; // stress on last heaviest syllable, excluding final syllable
  872|      0|		tr->langopts.stress_flags =  S_MID_DIM | S_FINAL_DIM; // use 'diminished' for unstressed final syllable
  873|      0|		tr->langopts.numbers = NUM_SWAP_TENS;
  874|      0|		tr->langopts.break_numbers = BREAK_LAKH_HI;
  875|      0|		tr->letter_bits_offset = OFFSET_DEVANAGARI;
  876|      0|
  877|      0|		if (name2 == L('p', 'a'))
  878|      0|			tr->letter_bits_offset = OFFSET_GURMUKHI;
  879|      0|		else if (name2 == L('g', 'u')) {
  880|      0|			SetupTranslator(tr, stress_lengths_equal, stress_amps_equal);
  881|      0|			tr->letter_bits_offset = OFFSET_GUJARATI;
  882|      0|			tr->langopts.stress_rule = STRESSPOSN_2R;
  883|      0|		} else if (name2 == L('n', 'e')) {
  884|      0|			SetupTranslator(tr, stress_lengths_equal, stress_amps_equal);
  885|      0|			tr->langopts.break_numbers = BREAK_LAKH;
  886|      0|			tr->langopts.max_digits = 22;
  887|      0|			tr->langopts.numbers2 |= NUM2_ENGLISH_NUMERALS;
  888|      0|		} else if (name2 == L('o', 'r'))
  889|      0|			tr->letter_bits_offset = OFFSET_ORIYA;
  890|      0|		SetIndicLetters(tr);
  891|      0|	}
  892|      0|		break;
  893|      0|	case L('h', 'r'): // Croatian
  894|      0|	case L('b', 's'): // Bosnian
  895|      0|	case L('s', 'r'): // Serbian
  896|      0|	{
  897|      0|		static const unsigned char stress_amps_hr[8] = { 17, 17, 20, 20, 20, 22, 22, 21 };
  898|      0|		static const short stress_lengths_hr[8] = { 180, 160, 200, 200, 0, 0, 220, 230 };
  899|      0|		static const short stress_lengths_sr[8] = { 160, 150, 200, 200, 0, 0, 250, 260 };
  900|      0|
  901|      0|		strcpy(tr->dictionary_name, "hbs");
  902|      0|
  903|      0|		if (name2 == L('s', 'r'))
  904|      0|			SetupTranslator(tr, stress_lengths_sr, stress_amps_hr);
  905|      0|		else
  906|      0|			SetupTranslator(tr, stress_lengths_hr, stress_amps_hr);
  907|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_2;
  908|      0|
  909|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
  910|      0|		tr->langopts.stress_flags = S_FINAL_NO_2;
  911|      0|		tr->langopts.param[LOPT_REGRESSIVE_VOICING] = 0x3;
  912|      0|		tr->langopts.max_initial_consonants = 5;
  913|      0|		tr->langopts.spelling_stress = 1;
  914|      0|		tr->langopts.accents = 1;
  915|      0|
  916|      0|		tr->langopts.numbers = NUM_SINGLE_STRESS | NUM_HUNDRED_AND | NUM_OMIT_1_HUNDRED | NUM_DECIMAL_COMMA | NUM_THOUS_SPACE | NUM_DFRACTION_2 | NUM_ROMAN_CAPITALS;
  917|      0|		tr->langopts.numbers2 = NUM2_THOUSANDPLEX_VAR_THOUSANDS | NUM2_THOUSANDPLEX_VAR_MILLIARDS | NUM2_THOUSANDS_VAR5;
  918|      0|		tr->langopts.our_alphabet = OFFSET_CYRILLIC; // don't say "cyrillic" before letter names
  919|      0|
  920|      0|		SetLetterVowel(tr, 'y');
  921|      0|		SetLetterVowel(tr, 'r');
  922|      0|	}
  923|      0|		break;
  924|      0|	case L('h', 't'): // Haitian Creole
  925|      0|		tr->langopts.stress_rule = STRESSPOSN_1R; // stress on final syllable
  926|      0|		tr->langopts.stress_flags = S_NO_AUTO_2 | S_FINAL_DIM; // don't use secondary stress
  927|      0|		tr->langopts.numbers = NUM_SINGLE_STRESS | NUM_OMIT_1_HUNDRED | NUM_NOPAUSE | NUM_ROMAN | NUM_VIGESIMAL | NUM_DFRACTION_4;
  928|      0|		break;
  929|      0|	case L('h', 'u'): // Hungarian
  930|      0|	{
  931|      0|		static const unsigned char stress_amps_hu[8] = { 17, 17, 19, 19, 20, 22, 22, 21 };
  932|      0|		static const short stress_lengths_hu[8] = { 185, 195, 195, 190, 0, 0, 210, 220 };
  933|      0|
  934|      0|		SetupTranslator(tr, stress_lengths_hu, stress_amps_hu);
  935|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_2;
  936|      0|
  937|      0|		tr->langopts.vowel_pause = 0x20;
  938|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
  939|      0|		tr->langopts.stress_flags = S_FINAL_DIM_ONLY | S_FINAL_NO_2 | S_NO_AUTO_2 | 0x8000 | S_HYPEN_UNSTRESS;
  940|      0|		tr->langopts.unstressed_wd1 = 2;
  941|      0|		tr->langopts.param[LOPT_IT_DOUBLING] = 1;
  942|      0|		tr->langopts.param[LOPT_ANNOUNCE_PUNCT] = 2; // don't break clause before announcing . ? !
  943|      0|
  944|      0|		tr->langopts.numbers = NUM_DFRACTION_5 | NUM_ALLOW_SPACE | NUM_ROMAN | NUM_ROMAN_ORDINAL | NUM_ROMAN_CAPITALS | NUM_ORDINAL_DOT | NUM_OMIT_1_HUNDRED | NUM_OMIT_1_THOUSAND;
  945|      0|		tr->langopts.thousands_sep = ' '; // don't allow dot as thousands separator
  946|      0|		tr->langopts.decimal_sep = ',';
  947|      0|		tr->langopts.max_roman = 899;
  948|      0|		tr->langopts.min_roman = 1;
  949|      0|		SetLetterVowel(tr, 'y');
  950|      0|		tr->langopts.spelling_stress = 1;
  951|      0|		SetLengthMods(tr, 3); // all equal
  952|      0|	}
  953|      0|		break;
  954|      0|	case L('h', 'y'): // Armenian
  955|      0|	{
  956|      0|		static const short stress_lengths_hy[8] = { 250, 200,  250, 250,  0, 0,  250, 250 };
  957|      0|		static const char hy_vowels[] = { 0x31, 0x35, 0x37, 0x38, 0x3b, 0x48, 0x55, 0 };
  958|      0|		static const char hy_consonants[] = {
  959|      0|			0x32, 0x33, 0x34, 0x36, 0x39, 0x3a, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44,
  960|      0|			0x46, 0x47, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x56, 0
  961|      0|		};
  962|      0|		static const char hy_consonants2[] = { 0x45, 0 };
  963|      0|
  964|      0|		SetupTranslator(tr, stress_lengths_hy, NULL);
  965|      0|		tr->langopts.stress_rule = STRESSPOSN_1R; // default stress on final syllable
  966|      0|
  967|      0|		tr->letter_bits_offset = OFFSET_ARMENIAN;
  968|      0|		memset(tr->letter_bits, 0, sizeof(tr->letter_bits));
  969|      0|		SetLetterBits(tr, LETTERGP_A, hy_vowels);
  970|      0|		SetLetterBits(tr, LETTERGP_VOWEL2, hy_vowels);
  971|      0|		SetLetterBits(tr, LETTERGP_B, hy_consonants); // not including 'j'
  972|      0|		SetLetterBits(tr, LETTERGP_C, hy_consonants);
  973|      0|		SetLetterBits(tr, LETTERGP_C, hy_consonants2); // add 'j'
  974|      0|		tr->langopts.max_initial_consonants = 6;
  975|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_ALLOW_SPACE | NUM_OMIT_1_HUNDRED;
  976|      0|	}
  977|      0|		break;
  978|      0|			
  979|      0|	case L('i', 'o'): // Ido International Auxiliary Language 
  980|      0|	{
  981|      0|		static const short stress_lengths_eo[8] = { 150, 140,  180, 180,    0,   0,  200, 200 };
  982|      0|		static const unsigned char stress_amps_eo[] = { 16, 14, 20, 20, 20, 22, 22, 21 };
  983|      0|		static const wchar_t eo_char_apostrophe[2] = { 'l', 0 };
  984|      0|
  985|      0|		SetupTranslator(tr, stress_lengths_eo, stress_amps_eo);
  986|      0|
  987|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_3;
  988|      0|		tr->char_plus_apostrophe = eo_char_apostrophe;
  989|      0|
  990|      0|		tr->langopts.vowel_pause = 2;
  991|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
  992|      0|		tr->langopts.stress_flags = S_FINAL_DIM_ONLY | S_FINAL_NO_2;
  993|      0|		tr->langopts.unstressed_wd2 = 2;
  994|      0|
  995|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_OMIT_1_HUNDRED | NUM_ALLOW_SPACE | NUM_AND_UNITS| NUM_HUNDRED_AND | NUM_ROMAN;
  996|      0|	}
  997|      0|	break;
  998|      0|			
  999|      0|	case L('i', 'd'): // Indonesian
 1000|      0|	case L('m', 's'): // Malay
 1001|      0|	{
 1002|      0|		static const short stress_lengths_id[8] = { 160, 200,  180, 180,  0, 0,  220, 240 };
 1003|      0|		static const unsigned char stress_amps_id[8] = { 16, 18, 18, 18, 20, 22, 22, 21 };
 1004|      0|
 1005|      0|		SetupTranslator(tr, stress_lengths_id, stress_amps_id);
 1006|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
 1007|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_ALLOW_SPACE | NUM_ROMAN;
 1008|      0|		tr->langopts.stress_flags =  S_FINAL_DIM_ONLY | S_FINAL_NO_2;
 1009|      0|		tr->langopts.accents = 2; // "capital" after letter name
 1010|      0|	}
 1011|      0|		break;
 1012|      0|	case L('i', 's'): // Icelandic
 1013|      0|	{
 1014|      0|		static const short stress_lengths_is[8] = { 180, 160, 200, 200, 0, 0, 240, 250 };
 1015|      0|		static const wchar_t is_lettergroup_B[] = { 'c', 'f', 'h', 'k', 'p', 't', 'x', 0xfe, 0 }; // voiceless conants, including 'þ'  ?? 's'
 1016|      0|
 1017|      0|		SetupTranslator(tr, stress_lengths_is, NULL);
 1018|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
 1019|      0|		tr->langopts.stress_flags = S_FINAL_NO_2;
 1020|      0|		tr->langopts.param[LOPT_IT_LENGTHEN] = 0x11; // remove lengthen indicator from unstressed vowels
 1021|      0|		tr->langopts.param[LOPT_REDUCE] = 2;
 1022|      0|
 1023|      0|		ResetLetterBits(tr, 0x18);
 1024|      0|		SetLetterBits(tr, 4, "kpst"); // Letter group F
 1025|      0|		SetLetterBits(tr, 3, "jvr"); // Letter group H
 1026|      0|		tr->letter_groups[1] = is_lettergroup_B;
 1027|      0|		SetLetterVowel(tr, 'y');
 1028|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_SINGLE_AND | NUM_HUNDRED_AND | NUM_AND_UNITS | NUM_1900;
 1029|      0|		tr->langopts.numbers2 = NUM2_THOUSANDPLEX_VAR_THOUSANDS;
 1030|      0|	}
 1031|      0|		break;
 1032|      0|	case L('i', 't'): // Italian
 1033|      0|	{
 1034|      0|		static const short stress_lengths_it[8] = { 160, 140, 150, 165, 0, 0, 218, 305 };
 1035|      0|		static const unsigned char stress_amps_it[8] = { 17, 15, 18, 16, 20, 22, 22, 22 };
 1036|      0|		SetupTranslator(tr, stress_lengths_it, stress_amps_it);
 1037|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
 1038|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
 1039|      0|		tr->langopts.stress_flags = S_NO_AUTO_2 | S_FINAL_DIM_ONLY | S_PRIORITY_STRESS;
 1040|      0|		tr->langopts.vowel_pause = 1;
 1041|      0|		tr->langopts.unstressed_wd1 = 0;
 1042|      0|		tr->langopts.unstressed_wd2 = 2;
 1043|      0|		tr->langopts.param[LOPT_IT_LENGTHEN] = 2; // remove lengthen indicator from unstressed or non-penultimate syllables
 1044|      0|		tr->langopts.param[LOPT_IT_DOUBLING] = 1; // double the first consonant if the previous word ends in a stressed vowel (changed to =1, 23.01.2014 - only use if prev.word has $double)
 1045|      0|		tr->langopts.param[LOPT_SONORANT_MIN] = 130; // limit the shortening of sonorants before short vowels
 1046|      0|		tr->langopts.param[LOPT_REDUCE] = 1; // reduce vowels even if phonemes are specified in it_list
 1047|      0|		tr->langopts.param[LOPT_ALT] = 2; // call ApplySpecialAttributes2() if a word has $alt or $alt2
 1048|      0|		tr->langopts.numbers = NUM_SINGLE_VOWEL | NUM_OMIT_1_HUNDRED |NUM_DECIMAL_COMMA | NUM_DFRACTION_1 | NUM_ROMAN | NUM_ROMAN_CAPITALS | NUM_ROMAN_ORDINAL;
 1049|      0|		tr->langopts.numbers2 = NUM2_NO_TEEN_ORDINALS;
 1050|      0|		tr->langopts.roman_suffix = utf8_ordinal;
 1051|      0|		tr->langopts.accents = 2; // Say "Capital" after the letter.
 1052|      0|		SetLetterVowel(tr, 'y');
 1053|      0|	}
 1054|      0|		break;
 1055|      0|	case L3('j', 'b', 'o'): // Lojban
 1056|      0|	{
 1057|      0|		static const short stress_lengths_jbo[8] = { 145, 145, 170, 160, 0, 0, 330, 350 };
 1058|      0|		static const wchar_t jbo_punct_within_word[] = { '.', ',', '\'', 0x2c8, 0 }; // allow period and comma within a word, also stress marker (from LOPT_CAPS_IN_WORD)
 1059|      0|
 1060|      0|		SetupTranslator(tr, stress_lengths_jbo, NULL);
 1061|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
 1062|      0|		tr->langopts.vowel_pause = 0x20c; // pause before a word which starts with a vowel, or after a word which ends in a consonant
 1063|      0|		tr->punct_within_word = jbo_punct_within_word;
 1064|      0|		tr->langopts.param[LOPT_CAPS_IN_WORD] = 1; // capitals indicate stressed syllables
 1065|      0|		SetLetterVowel(tr, 'y');
 1066|      0|		tr->langopts.max_lengthmod = 368;
 1067|      0|		tr->langopts.numbers = 0; // disable numbers until the definition are complete in _list file
 1068|      0|	}
 1069|      0|		break;
 1070|      0|	case L('k', 'a'): // Georgian
 1071|      0|	{
 1072|      0|		// character codes offset by 0x1080
 1073|      0|		static const char ka_vowels[] = { 0x30, 0x34, 0x38, 0x3d, 0x43, 0x55, 0x57, 0 };
 1074|      0|		static const char ka_consonants[] =
 1075|      0|		{ 0x31, 0x32, 0x33, 0x35, 0x36, 0x37, 0x39, 0x3a, 0x3b, 0x3c, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x44,
 1076|      0|		  0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x56, 0 };
 1077|      0|		SetupTranslator(tr, stress_lengths_ta, stress_amps_ta);
 1078|      0|		memset(tr->letter_bits, 0, sizeof(tr->letter_bits));
 1079|      0|		SetLetterBits(tr, LETTERGP_A, ka_vowels);
 1080|      0|		SetLetterBits(tr, LETTERGP_C, ka_consonants);
 1081|      0|		SetLetterBits(tr, LETTERGP_VOWEL2, ka_vowels);
 1082|      0|
 1083|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
 1084|      0|		tr->langopts.stress_flags = S_FINAL_NO_2;
 1085|      0|		tr->letter_bits_offset = OFFSET_GEORGIAN;
 1086|      0|		tr->langopts.max_initial_consonants = 7;
 1087|      0|		tr->langopts.numbers = NUM_VIGESIMAL | NUM_AND_UNITS | NUM_OMIT_1_HUNDRED |NUM_OMIT_1_THOUSAND | NUM_DFRACTION_5 | NUM_ROMAN;
 1088|      0|
 1089|      0|		tr->langopts.alt_alphabet = OFFSET_CYRILLIC;
 1090|      0|		tr->langopts.alt_alphabet_lang = L('r', 'u');
 1091|      0|	}
 1092|      0|		break;
 1093|      0|	case L('k', 'k'): // Kazakh
 1094|      0|	{
 1095|      0|		static const unsigned char stress_amps_tr[8] = { 18, 16, 20, 21, 20, 21, 21, 20 };
 1096|      0|		static const short stress_lengths_tr[8] = { 190, 180, 230, 230, 0, 0, 250, 250 };
 1097|      0|
 1098|      0|		tr->letter_bits_offset = OFFSET_CYRILLIC;
 1099|      0|		memset(tr->letter_bits, 0, sizeof(tr->letter_bits));
 1100|      0|		SetLetterBits(tr, LETTERGP_A, (char *)ru_vowels);
 1101|      0|		SetLetterBits(tr, LETTERGP_C, (char *)ru_consonants);
 1102|      0|		SetLetterBits(tr, LETTERGP_VOWEL2, (char *)ru_vowels);
 1103|      0|
 1104|      0|		SetupTranslator(tr, stress_lengths_tr, stress_amps_tr);
 1105|      0|
 1106|      0|		tr->langopts.stress_rule = STRESSPOSN_1RU; // stress on the last syllable, before any explicitly unstressed syllable
 1107|      0|		tr->langopts.stress_flags = S_NO_AUTO_2 + S_NO_EOC_LENGTHEN; // no automatic secondary stress, don't lengthen at end-of-clause
 1108|      0|		tr->langopts.lengthen_tonic = 0;
 1109|      0|		tr->langopts.param[LOPT_SUFFIX] = 1;
 1110|      0|
 1111|      0|		tr->langopts.numbers =  NUM_OMIT_1_HUNDRED | NUM_DFRACTION_6;
 1112|      0|		tr->langopts.max_initial_consonants = 2;
 1113|      0|		SetLengthMods(tr, 3); // all equal
 1114|      0|	}
 1115|      0|		break;
 1116|      0|	case L('k', 'l'): // Greenlandic
 1117|      0|	{
 1118|      0|		SetupTranslator(tr, stress_lengths_equal, stress_amps_equal);
 1119|      0|		tr->langopts.stress_rule = STRESSPOSN_GREENLANDIC;
 1120|      0|		tr->langopts.stress_flags = S_NO_AUTO_2;
 1121|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_SWAP_TENS | NUM_HUNDRED_AND | NUM_OMIT_1_HUNDRED | NUM_ORDINAL_DOT | NUM_1900 | NUM_ROMAN | NUM_ROMAN_CAPITALS | NUM_ROMAN_ORDINAL;
 1122|      0|	}
 1123|      0|		break;
 1124|      0|	case L('k', 'o'): // Korean, TEST
 1125|      0|	{
 1126|      0|		static const char ko_ivowels[] = { 0x63, 0x64, 0x67, 0x68, 0x6d, 0x72, 0x74, 0x75, 0 }; // y and i vowels
 1127|      0|		static const unsigned char ko_voiced[] = { 0x02, 0x05, 0x06, 0xab, 0xaf, 0xb7, 0xbc, 0 }; // voiced consonants, l,m,n,N
 1128|      0|
 1129|      0|		tr->letter_bits_offset = OFFSET_KOREAN;
 1130|      0|		tr->langopts.our_alphabet = 0xa700;
 1131|      0|		memset(tr->letter_bits, 0, sizeof(tr->letter_bits));
 1132|      0|		SetLetterBitsRange(tr, LETTERGP_A, 0x61, 0x75);
 1133|      0|		SetLetterBits(tr, LETTERGP_Y, ko_ivowels);
 1134|      0|		SetLetterBits(tr, LETTERGP_G, (const char *)ko_voiced);
 1135|      0|
 1136|      0|		tr->langopts.stress_rule = STRESSPOSN_2LLH; // ?? 1st syllable if it is heavy, else 2nd syllable
 1137|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 1; // disable check for unpronouncable words
 1138|      0|		tr->langopts.numbers = NUM_OMIT_1_HUNDRED;
 1139|      0|		tr->langopts.numbers2 = NUM2_MYRIADS;
 1140|      0|		tr->langopts.break_numbers = BREAK_MYRIADS;
 1141|      0|		tr->langopts.max_digits = 20;
 1142|      0|	}
 1143|      0|		break;
 1144|      0|	case L('k', 'u'): // Kurdish
 1145|      0|	{
 1146|      0|		static const unsigned char stress_amps_ku[8] = { 18, 18, 20, 20, 20, 22, 22, 21 };
 1147|      0|		static const short stress_lengths_ku[8] = { 180, 180, 190, 180, 0, 0, 230, 240 };
 1148|      0|
 1149|      0|		SetupTranslator(tr, stress_lengths_ku, stress_amps_ku);
 1150|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_9;
 1151|      0|
 1152|      0|		tr->langopts.stress_rule = STRESSPOSN_1RU; // stress on the last syllable, before any explicitly unstressed syllable
 1153|      0|
 1154|      0|		tr->langopts.numbers = NUM_HUNDRED_AND | NUM_AND_UNITS | NUM_OMIT_1_HUNDRED | NUM_AND_HUNDRED;
 1155|      0|		tr->langopts.max_initial_consonants = 2;
 1156|      0|	}
 1157|      0|		break;
 1158|      0|	case L('k', 'y'): // Kyrgyx
 1159|      0|		tr->langopts.numbers = NUM_DEFAULT;
 1160|      0|		break;
 1161|      0|	case L('l', 'a'): // Latin
 1162|      0|	{
 1163|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_4; // includes a,e,i,o,u-macron
 1164|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
 1165|      0|		tr->langopts.stress_flags = S_NO_AUTO_2;
 1166|      0|		tr->langopts.unstressed_wd1 = 0;
 1167|      0|		tr->langopts.unstressed_wd2 = 2;
 1168|      0|		tr->langopts.param[LOPT_DIERESES] = 1;
 1169|      0|		tr->langopts.numbers = NUM_ROMAN;
 1170|      0|		tr->langopts.max_roman = 5000;
 1171|      0|	}
 1172|      0|		break;
 1173|      0|	case L('l', 't'): // Lithuanian
 1174|      0|	{
 1175|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_4;
 1176|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
 1177|      0|		tr->langopts.stress_flags = S_NO_AUTO_2;
 1178|      0|		tr->langopts.unstressed_wd1 = 0;
 1179|      0|		tr->langopts.unstressed_wd2 = 2;
 1180|      0|		tr->langopts.param[LOPT_DIERESES] = 1;
 1181|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_OMIT_1_HUNDRED | NUM_DFRACTION_4 | NUM_ORDINAL_DOT;
 1182|      0|		tr->langopts.numbers2 = NUM2_THOUSANDS_VAR4;
 1183|      0|		tr->langopts.max_roman = 5000;
 1184|      0|	}
 1185|      0|		break;
 1186|      0|	case L('l', 'v'): // latvian
 1187|      0|	case L3('l', 't', 'g'): // latgalian
 1188|      0|	{
 1189|      0|		static const unsigned char stress_amps_lv[8] = { 14, 10, 10, 8, 0, 0, 20, 15 };
 1190|      0|		static const short stress_lengths_lv[8] = { 180, 180, 180, 160, 0, 0, 230, 180 };
 1191|      0|
 1192|      0|		SetupTranslator(tr, stress_lengths_lv, stress_amps_lv);
 1193|      0|
 1194|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
 1195|      0|		tr->langopts.spelling_stress = 1;
 1196|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_4;
 1197|      0|		tr->langopts.max_digits = 33;
 1198|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_OMIT_1_HUNDRED | NUM_DFRACTION_4 | NUM_ORDINAL_DOT;
 1199|      0|		tr->langopts.stress_flags = S_NO_AUTO_2 | S_FINAL_DIM | S_FINAL_DIM_ONLY | S_EO_CLAUSE1;
 1200|      0|	}
 1201|      0|		break;
 1202|      0|	case L('m', 'k'): // Macedonian
 1203|      0|	{
 1204|      0|		static wchar_t vowels_cyrillic[] = {
 1205|      0|			// also include 'р' [R]
 1206|      0|			0x440, 0x430, 0x435, 0x438, 0x439, 0x43e, 0x443, 0x44b, 0x44d,
 1207|      0|			0x44e, 0x44f, 0x450, 0x451, 0x456, 0x457, 0x45d, 0x45e, 0
 1208|      0|		};
 1209|      0|		static const unsigned char stress_amps_mk[8] = { 17, 17, 20, 20, 20, 22, 22, 21 };
 1210|      0|		static const short stress_lengths_mk[8] = { 180, 160, 200, 200, 0, 0, 220, 230 };
 1211|      0|
 1212|      0|		SetupTranslator(tr, stress_lengths_mk, stress_amps_mk);
 1213|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_5;
 1214|      0|		tr->letter_groups[0] = tr->letter_groups[7] = vowels_cyrillic;
 1215|      0|		tr->letter_bits_offset = OFFSET_CYRILLIC;
 1216|      0|
 1217|      0|		tr->langopts.stress_rule = STRESSPOSN_3R; // antipenultimate
 1218|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_AND_UNITS | NUM_OMIT_1_HUNDRED | NUM_OMIT_1_THOUSAND | NUM_DFRACTION_2;
 1219|      0|		tr->langopts.numbers2 = NUM2_THOUSANDPLEX_VAR_THOUSANDS | NUM2_THOUSANDPLEX_VAR_MILLIARDS | NUM2_THOUSANDS_VAR2;
 1220|      0|	}
 1221|      0|		break;
 1222|      0|	case L('m', 't'): // Maltese
 1223|      0|	{
 1224|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_3;
 1225|      0|		tr->langopts.param[LOPT_REGRESSIVE_VOICING] = 0x100; // devoice at end of word
 1226|      0|		tr->langopts.stress_rule = STRESSPOSN_2R; // penultimate
 1227|      0|		tr->langopts.numbers = NUM_DEFAULT;
 1228|      0|	}
 1229|      0|		break;
 1230|      0|	case L('n', 'l'): // Dutch
 1231|      0|	{
 1232|      0|		static const short stress_lengths_nl[8] = { 160, 135, 210, 210,  0, 0, 260, 280 };
 1233|      0|
 1234|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
 1235|      0|		tr->langopts.vowel_pause = 0x30; // ??
 1236|      0|		tr->langopts.param[LOPT_DIERESES] = 1;
 1237|      0|		tr->langopts.param[LOPT_PREFIXES] = 1;
 1238|      0|		tr->langopts.param[LOPT_REGRESSIVE_VOICING] = 0x100; // devoice at end of word
 1239|      0|		SetLetterVowel(tr, 'y');
 1240|      0|
 1241|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_SWAP_TENS | NUM_OMIT_1_HUNDRED | NUM_OMIT_1_THOUSAND | NUM_ALLOW_SPACE | NUM_1900 | NUM_ORDINAL_DOT;
 1242|      0|		tr->langopts.ordinal_indicator = "e";
 1243|      0|		tr->langopts.stress_flags = S_FIRST_PRIMARY;
 1244|      0|		memcpy(tr->stress_lengths, stress_lengths_nl, sizeof(tr->stress_lengths));
 1245|      0|	}
 1246|      0|		break;
 1247|      0|	case L('n', 'b'): // Norwegian
 1248|      0|	{
 1249|      0|		static const short stress_lengths_no[8] = { 160, 140, 200, 200, 0, 0, 220, 230 };
 1250|      0|
 1251|      0|		SetupTranslator(tr, stress_lengths_no, NULL);
 1252|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
 1253|      0|		SetLetterVowel(tr, 'y');
 1254|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_HUNDRED_AND | NUM_ALLOW_SPACE | NUM_1900 | NUM_ORDINAL_DOT;
 1255|      0|	}
 1256|      0|		break;
 1257|      0|	case L('o', 'm'): // Oromo
 1258|      0|	{
 1259|      0|		static const unsigned char stress_amps_om[] = { 18, 15, 20, 20, 20, 22, 22, 22 };
 1260|      0|		static const short stress_lengths_om[8] = { 200, 200, 200, 200, 0, 0, 200, 200 };
 1261|      0|
 1262|      0|		SetupTranslator(tr, stress_lengths_om, stress_amps_om);
 1263|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
 1264|      0|		tr->langopts.stress_flags = S_FINAL_DIM_ONLY | S_FINAL_NO_2 | 0x80000;
 1265|      0|		tr->langopts.numbers = NUM_OMIT_1_HUNDRED | NUM_HUNDRED_AND;
 1266|      0|		tr->langopts.numbers2 = NUM2_SWAP_THOUSANDS;
 1267|      0|	}
 1268|      0|		break;
 1269|      0|	case L('p', 'l'): // Polish
 1270|      0|	{
 1271|      0|		static const short stress_lengths_pl[8] = { 160, 190,  175, 175,  0, 0,  200, 210 };
 1272|      0|		static const unsigned char stress_amps_pl[8] = { 17, 13, 19, 19, 20, 22, 22, 21 }; // 'diminished' is used to mark a quieter, final unstressed syllable
 1273|      0|
 1274|      0|		SetupTranslator(tr, stress_lengths_pl, stress_amps_pl);
 1275|      0|
 1276|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_2;
 1277|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
 1278|      0|		tr->langopts.stress_flags = S_FINAL_DIM_ONLY; // mark unstressed final syllables as diminished
 1279|      0|		tr->langopts.param[LOPT_REGRESSIVE_VOICING] = 0x9;
 1280|      0|		tr->langopts.max_initial_consonants = 7; // for example: wchrzczony :)
 1281|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_ALLOW_SPACE | NUM_DFRACTION_2;
 1282|      0|		tr->langopts.numbers2 = NUM2_THOUSANDS_VAR3;
 1283|      0|		tr->langopts.param[LOPT_COMBINE_WORDS] = 4 + 0x100; // combine 'nie' (marked with $alt2) with some 1-syllable (and 2-syllable) words (marked with $alt)
 1284|      0|		SetLetterVowel(tr, 'y');
 1285|      0|	}
 1286|      0|		break;
 1287|      0|	case L('p', 't'): // Portuguese
 1288|      0|	{
 1289|      0|		static const short stress_lengths_pt[8] = { 170, 115,  210, 240,  0, 0,  260, 280 };
 1290|      0|		static const unsigned char stress_amps_pt[8] = { 16, 11, 19, 21, 20, 22, 22, 21 }; // 'diminished' is used to mark a quieter, final unstressed syllable
 1291|      0|
 1292|      0|		SetupTranslator(tr, stress_lengths_pt, stress_amps_pt);
 1293|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
 1294|      0|
 1295|      0|		tr->langopts.stress_rule = STRESSPOSN_1R; // stress on final syllable
 1296|      0|		tr->langopts.stress_flags =  S_FINAL_DIM_ONLY | S_FINAL_NO_2 | S_INITIAL_2 | S_PRIORITY_STRESS;
 1297|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_DFRACTION_2 | NUM_HUNDRED_AND | NUM_AND_UNITS | NUM_ROMAN_CAPITALS;
 1298|      0|		tr->langopts.numbers2 = NUM2_MULTIPLE_ORDINAL | NUM2_NO_TEEN_ORDINALS | NUM2_ORDINAL_NO_AND;
 1299|      0|		tr->langopts.max_roman = 5000;
 1300|      0|		SetLetterVowel(tr, 'y');
 1301|      0|		ResetLetterBits(tr, 0x2);
 1302|      0|		SetLetterBits(tr, 1, "bcdfgjkmnpqstvxz"); // B  hard consonants, excluding h,l,r,w,y
 1303|      0|		tr->langopts.param[LOPT_ALT] = 2; // call ApplySpecialAttributes2() if a word has $alt or $alt2
 1304|      0|		tr->langopts.accents = 2; // 'capital' after letter name
 1305|      0|	}
 1306|      0|		break;
 1307|      0|	case L('r', 'o'): // Romanian
 1308|      0|	{
 1309|      0|		static const short stress_lengths_ro[8] = { 170, 170,  180, 180,  0, 0,  240, 260 };
 1310|      0|		static const unsigned char stress_amps_ro[8] = { 15, 13, 18, 18, 20, 22, 22, 21 };
 1311|      0|
 1312|      0|		SetupTranslator(tr, stress_lengths_ro, stress_amps_ro);
 1313|      0|
 1314|      0|		tr->langopts.stress_rule = STRESSPOSN_1R;
 1315|      0|		tr->langopts.stress_flags = S_FINAL_VOWEL_UNSTRESSED | S_FINAL_DIM_ONLY;
 1316|      0|
 1317|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_2;
 1318|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_ALLOW_SPACE | NUM_DFRACTION_3 | NUM_AND_UNITS | NUM_ROMAN;
 1319|      0|		tr->langopts.numbers2 = NUM2_THOUSANDPLEX_VAR_ALL;
 1320|      0|	}
 1321|      0|		break;
 1322|      0|	case L('r', 'u'): // Russian
 1323|      0|		Translator_Russian(tr);
 1324|      0|		break;
 1325|      0|	case L('r', 'w'): // Kiryarwanda
 1326|      0|	{
 1327|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
 1328|      0|		tr->langopts.stress_flags = S_FINAL_DIM_ONLY | S_FINAL_NO_2;
 1329|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
 1330|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 1; // disable check for unpronouncable words.  Need to allow "bw'" prefix
 1331|      0|		tr->langopts.numbers = NUM_HUNDRED_AND | NUM_AND_UNITS | NUM_DFRACTION_2 | NUM_AND_HUNDRED;
 1332|      0|		tr->langopts.numbers2 = NUM2_SWAP_THOUSANDS;
 1333|      0|	}
 1334|      0|		break;
 1335|      0|	case L('s', 'k'): // Slovak
 1336|      0|	case L('c', 's'): // Czech
 1337|      0|	{
 1338|      0|		static const char *sk_voiced = "bdgjlmnrvwzaeiouy";
 1339|      0|
 1340|      0|		SetupTranslator(tr, stress_lengths_sk, stress_amps_sk);
 1341|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_2;
 1342|      0|
 1343|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
 1344|      0|		tr->langopts.stress_flags = S_FINAL_DIM_ONLY | S_FINAL_NO_2;
 1345|      0|		tr->langopts.param[LOPT_REGRESSIVE_VOICING] = 0x3;
 1346|      0|		tr->langopts.max_initial_consonants = 5;
 1347|      0|		tr->langopts.spelling_stress = 1;
 1348|      0|		tr->langopts.param[LOPT_COMBINE_WORDS] = 4; // combine some prepositions with the following word
 1349|      0|
 1350|      0|		tr->langopts.numbers = NUM_OMIT_1_HUNDRED | NUM_DFRACTION_2 | NUM_ROMAN;
 1351|      0|		tr->langopts.numbers2 = NUM2_THOUSANDS_VAR2;
 1352|      0|		tr->langopts.thousands_sep = 0; // no thousands separator
 1353|      0|		tr->langopts.decimal_sep = ',';
 1354|      0|
 1355|      0|		if (name2 == L('c', 's'))
 1356|      0|			tr->langopts.numbers2 = NUM2_THOUSANDPLEX_VAR_MILLIARDS | NUM2_THOUSANDS_VAR4;
 1357|      0|
 1358|      0|		SetLetterVowel(tr, 'y');
 1359|      0|		SetLetterVowel(tr, 'r');
 1360|      0|		ResetLetterBits(tr, 0x20);
 1361|      0|		SetLetterBits(tr, 5, sk_voiced);
 1362|      0|	}
 1363|      0|		break;
 1364|      0|	case L('s', 'i'): // Sinhala
 1365|      0|	{
 1366|      0|		SetupTranslator(tr, stress_lengths_ta, stress_amps_ta);
 1367|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
 1368|      0|
 1369|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
 1370|      0|		tr->langopts.stress_flags =  S_FINAL_DIM_ONLY | S_FINAL_NO_2;
 1371|      0|		tr->langopts.spelling_stress = 1;
 1372|      0|
 1373|      0|		tr->letter_bits_offset = OFFSET_SINHALA;
 1374|      0|		memset(tr->letter_bits, 0, sizeof(tr->letter_bits));
 1375|      0|		SetLetterBitsRange(tr, LETTERGP_A, 0x05, 0x16); // vowel letters
 1376|      0|		SetLetterBitsRange(tr, LETTERGP_A, 0x4a, 0x73); // + vowel signs, and virama
 1377|      0|
 1378|      0|		SetLetterBitsRange(tr, LETTERGP_B, 0x4a, 0x73); // vowel signs, and virama
 1379|      0|
 1380|      0|		SetLetterBitsRange(tr, LETTERGP_C, 0x1a, 0x46); // the main consonant range
 1381|      0|
 1382|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 1; // disable check for unpronouncable words
 1383|      0|		tr->langopts.suffix_add_e = tr->letter_bits_offset + 0x4a; // virama
 1384|      0|		tr->langopts.numbers =  NUM_OMIT_1_THOUSAND | NUM_SINGLE_STRESS_L | NUM_DFRACTION_7;
 1385|      0|		tr->langopts.numbers2 =  NUM2_PERCENT_BEFORE;
 1386|      0|		tr->langopts.break_numbers = BREAK_LAKH_HI;
 1387|      0|	}
 1388|      0|		break;
 1389|      0|	case L('s', 'l'): // Slovenian
 1390|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_2;
 1391|      0|		tr->langopts.stress_rule = STRESSPOSN_2R; // Temporary
 1392|      0|		tr->langopts.stress_flags = S_NO_AUTO_2;
 1393|      0|		tr->langopts.param[LOPT_REGRESSIVE_VOICING] = 0x103;
 1394|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 0x76; // [v]  don't count this character at start of word
 1395|      0|		tr->langopts.param[LOPT_ALT] = 2; // call ApplySpecialAttributes2() if a word has $alt or $alt2
 1396|      0|		tr->langopts.param[LOPT_IT_LENGTHEN] = 1; // remove lengthen indicator from unstressed syllables
 1397|      0|		tr->letter_bits[(int)'r'] |= 0x80; // add 'r' to letter group 7, vowels for Unpronouncable test
 1398|      0|		tr->langopts.numbers =  NUM_DECIMAL_COMMA | NUM_ALLOW_SPACE | NUM_SWAP_TENS | NUM_OMIT_1_HUNDRED | NUM_DFRACTION_2 | NUM_ORDINAL_DOT | NUM_ROMAN;
 1399|      0|		tr->langopts.numbers2 = NUM2_THOUSANDS_VAR4;
 1400|      0|		tr->langopts.thousands_sep = ' '; // don't allow dot as thousands separator
 1401|      0|		break;
 1402|      0|		
 1403|      0|	case L3('s', 'm', 'j'): // Lule Saami
 1404|      0|	{
 1405|      0|		static const unsigned char stress_amps_fi[8] = { 18, 16, 22, 22, 20, 22, 22, 22 };
 1406|      0|		static const short stress_lengths_fi[8] = { 150, 180, 200, 200, 0, 0, 210, 250 };
 1407|      0|
 1408|      0|		SetupTranslator(tr, stress_lengths_fi, stress_amps_fi);
 1409|      0|
 1410|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
 1411|      0|		tr->langopts.stress_flags = S_FINAL_DIM_ONLY | S_FINAL_NO_2 | S_2_TO_HEAVY; // move secondary stress from light to a following heavy syllable
 1412|      0|		tr->langopts.param[LOPT_IT_DOUBLING] = 1;
 1413|      0|		tr->langopts.long_stop = 130;
 1414|      0|
 1415|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_ALLOW_SPACE | NUM_SWAP_TENS | NUM_OMIT_1_HUNDRED | NUM_DFRACTION_2 | NUM_ORDINAL_DOT;
 1416|      0|		SetLetterVowel(tr, 'y');
 1417|      0|		tr->langopts.spelling_stress = 1;
 1418|      0|		tr->langopts.intonation_group = 3; // less intonation, don't raise pitch at comma
 1419|      0|	}
 1420|      0|		break;
 1421|      0|		
 1422|      0|	case L('s', 'q'): // Albanian
 1423|      0|	{
 1424|      0|		static const short stress_lengths_sq[8] = { 150, 150,  180, 180,  0, 0,  300, 300 };
 1425|      0|		static const unsigned char stress_amps_sq[8] = { 16, 12, 16, 16, 20, 20, 21, 19 };
 1426|      0|
 1427|      0|		SetupTranslator(tr, stress_lengths_sq, stress_amps_sq);
 1428|      0|
 1429|      0|		tr->langopts.stress_rule = STRESSPOSN_1R;
 1430|      0|		tr->langopts.stress_flags =  S_FINAL_DIM_ONLY | S_FINAL_NO_2 | S_FINAL_VOWEL_UNSTRESSED;
 1431|      0|		SetLetterVowel(tr, 'y');
 1432|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_HUNDRED_AND | NUM_AND_UNITS | NUM_DFRACTION_4;
 1433|      0|		tr->langopts.accents = 2; // "capital" after letter name
 1434|      0|	}
 1435|      0|		break;
 1436|      0|	case L('s', 'v'): // Swedish
 1437|      0|	{
 1438|      0|		static const unsigned char stress_amps_sv[] = { 16, 16, 20, 20, 20, 22, 22, 21 };
 1439|      0|		static const short stress_lengths_sv[8] = { 160, 135, 220, 220, 0, 0, 250, 280 };
 1440|      0|		SetupTranslator(tr, stress_lengths_sv, stress_amps_sv);
 1441|      0|
 1442|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
 1443|      0|		SetLetterVowel(tr, 'y');
 1444|      0|		tr->langopts.numbers = NUM_SINGLE_STRESS | NUM_DECIMAL_COMMA | NUM_ALLOW_SPACE | NUM_1900;
 1445|      0|		tr->langopts.accents = 1;
 1446|      0|	}
 1447|      0|		break;
 1448|      0|	case L('s', 'w'): // Swahili
 1449|      0|	case L('t', 'n'): // Setswana
 1450|      0|	{
 1451|      0|		static const short stress_lengths_sw[8] = { 160, 170,  200, 200,    0,   0,  320, 340 };
 1452|      0|		static const unsigned char stress_amps_sw[] = { 16, 12, 19, 19, 20, 22, 22, 21 };
 1453|      0|
 1454|      0|		SetupTranslator(tr, stress_lengths_sw, stress_amps_sw);
 1455|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
 1456|      0|
 1457|      0|		tr->langopts.vowel_pause = 1;
 1458|      0|		tr->langopts.stress_rule = STRESSPOSN_2R;
 1459|      0|		tr->langopts.stress_flags =  S_FINAL_DIM_ONLY | S_FINAL_NO_2;
 1460|      0|		tr->langopts.max_initial_consonants = 4; // for example: mwngi
 1461|      0|
 1462|      0|
 1463|      0|		tr->langopts.numbers = NUM_AND_UNITS | NUM_HUNDRED_AND | NUM_SINGLE_AND | NUM_OMIT_1_HUNDRED;
 1464|      0|	}
 1465|      0|		break;
 1466|      0|	case L('t', 'a'): // Tamil
 1467|      0|	case L('k', 'n'): // Kannada
 1468|      0|	case L('m', 'l'): // Malayalam
 1469|      0|	case L('t', 'e'): // Telugu
 1470|      0|	{
 1471|      0|		SetupTranslator(tr, stress_lengths_ta2, stress_amps_ta);
 1472|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
 1473|      0|
 1474|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
 1475|      0|		tr->langopts.stress_flags =  S_FINAL_DIM_ONLY | S_FINAL_NO_2; // use 'diminished' for unstressed final syllable
 1476|      0|		tr->langopts.spelling_stress = 1;
 1477|      0|		tr->langopts.break_numbers = BREAK_LAKH_DV;
 1478|      0|
 1479|      0|		if (name2 == L('t', 'a')) {
 1480|      0|			SetupTranslator(tr, stress_lengths_ta, NULL);
 1481|      0|			tr->letter_bits_offset = OFFSET_TAMIL;
 1482|      0|			tr->langopts.numbers =  NUM_OMIT_1_THOUSAND;
 1483|      0|			tr->langopts.numbers2 = NUM2_ORDINAL_AND_THOUSANDS;
 1484|      0|			tr->langopts.param[LOPT_WORD_MERGE] = 1; // don't break vowels between words
 1485|      0|		} else if (name2 == L('m', 'l')) {
 1486|      0|			static const short stress_lengths_ml[8] = { 180, 160,  240, 240,  0, 0,  260, 260 };
 1487|      0|			SetupTranslator(tr, stress_lengths_ml, stress_amps_equal);
 1488|      0|			tr->letter_bits_offset = OFFSET_MALAYALAM;
 1489|      0|			tr->langopts.numbers = NUM_OMIT_1_THOUSAND | NUM_OMIT_1_HUNDRED;
 1490|      0|			tr->langopts.numbers2 = NUM2_OMIT_1_HUNDRED_ONLY;
 1491|      0|			tr->langopts.stress_rule = STRESSPOSN_1SL; // 1st syllable, unless 1st vowel is short and 2nd is long
 1492|      0|		} else if (name2 == L('k', 'n')) {
 1493|      0|			tr->letter_bits_offset = OFFSET_KANNADA;
 1494|      0|			tr->langopts.numbers = NUM_DEFAULT;
 1495|      0|		} else if (name2 == L('t', 'e')) {
 1496|      0|			tr->letter_bits_offset = OFFSET_TELUGU;
 1497|      0|			tr->langopts.numbers = NUM_DEFAULT;
 1498|      0|			tr->langopts.numbers2 = NUM2_ORDINAL_DROP_VOWEL;
 1499|      0|		}
 1500|      0|		SetIndicLetters(tr); // call this after setting OFFSET_
 1501|      0|		SetLetterBitsRange(tr, LETTERGP_B, 0x4e, 0x4e); // chillu-virama (unofficial)
 1502|      0|	}
 1503|      0|		break;
 1504|      0|	case L('t', 'r'): // Turkish
 1505|      0|	case L('a', 'z'): // Azerbaijan
 1506|      0|	{
 1507|      0|		static const unsigned char stress_amps_tr[8] = { 18, 16, 20, 21, 20, 21, 21, 20 };
 1508|      0|		static const short stress_lengths_tr[8] = { 190, 180, 200, 230, 0, 0, 240, 250 };
 1509|      0|
 1510|      0|		SetupTranslator(tr, stress_lengths_tr, stress_amps_tr);
 1511|      0|		tr->encoding = ESPEAKNG_ENCODING_ISO_8859_9;
 1512|      0|
 1513|      0|		tr->langopts.stress_rule = STRESSPOSN_1RU; // stress on the last syllable, before any explicitly unstressed syllable
 1514|      0|		tr->langopts.stress_flags = S_NO_AUTO_2; // no automatic secondary stress
 1515|      0|		tr->langopts.dotless_i = 1;
 1516|      0|		tr->langopts.param[LOPT_SUFFIX] = 1;
 1517|      0|
 1518|      0|		if (name2 == L('a', 'z'))
 1519|      0|			tr->langopts.numbers = NUM_SINGLE_STRESS | NUM_DECIMAL_COMMA  | NUM_ALLOW_SPACE | NUM_OMIT_1_HUNDRED | NUM_OMIT_1_THOUSAND | NUM_DFRACTION_2;
 1520|      0|		else
 1521|      0|			tr->langopts.numbers = NUM_SINGLE_STRESS | NUM_DECIMAL_COMMA | NUM_OMIT_1_HUNDRED | NUM_OMIT_1_THOUSAND | NUM_DFRACTION_2;
 1522|      0|		tr->langopts.max_initial_consonants = 2;
 1523|      0|	}
 1524|      0|		break;
 1525|      0|	case L('t', 't'): // Tatar
 1526|      0|	{
 1527|      0|		SetCyrillicLetters(tr);
 1528|      0|		SetupTranslator(tr, stress_lengths_fr, stress_amps_fr);
 1529|      0|		tr->langopts.stress_rule = STRESSPOSN_1R; // stress on final syllable
 1530|      0|		tr->langopts.stress_flags = S_NO_AUTO_2; // no automatic secondary stress
 1531|      0|		tr->langopts.numbers = NUM_SINGLE_STRESS | NUM_DECIMAL_COMMA | NUM_OMIT_1_HUNDRED | NUM_OMIT_1_THOUSAND | NUM_DFRACTION_4;
 1532|      0|	}
 1533|      0|		break;
 1534|      0|	case L('u', 'k'): // Ukrainian
 1535|      0|	{
 1536|      0|		Translator_Russian(tr);
 1537|      0|	}
 1538|      0|		break;
 1539|      0|	case L('u', 'r'): // Urdu
 1540|      0|	case L('s', 'd'): // Sindhi
 1541|      0|	{
 1542|      0|		tr->letter_bits_offset = OFFSET_ARABIC;
 1543|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 1; // disable check for unpronouncable words
 1544|      0|		tr->langopts.numbers = NUM_SWAP_TENS;
 1545|      0|		tr->langopts.break_numbers = BREAK_LAKH_UR;
 1546|      0|	}
 1547|      0|		break;
 1548|      0|	case L('v', 'i'): // Vietnamese
 1549|      0|	{
 1550|      0|		static const short stress_lengths_vi[8] = { 150, 150,  180, 180,  210, 230,  230, 240 };
 1551|      0|		static const unsigned char stress_amps_vi[] = { 16, 16, 16, 16, 22, 22, 22, 22 };
 1552|      0|		static wchar_t vowels_vi[] = {
 1553|      0|			 0x61,   0xe0,   0xe1, 0x1ea3,   0xe3, 0x1ea1, // a
 1554|      0|			0x103, 0x1eb1, 0x1eaf, 0x1eb3, 0x1eb5, 0x1eb7, // ă
 1555|      0|			 0xe2, 0x1ea7, 0x1ea5, 0x1ea9, 0x1eab, 0x1ead, // â
 1556|      0|			 0x65,   0xe8,   0xe9, 0x1ebb, 0x1ebd, 0x1eb9, // e
 1557|      0|			 0xea, 0x1ec1, 0x1ebf, 0x1ec3, 0x1ec5, 0x1ec7, // i
 1558|      0|			 0x69,   0xec,   0xed, 0x1ec9,  0x129, 0x1ecb, // i
 1559|      0|			 0x6f,   0xf2,   0xf3, 0x1ecf,   0xf5, 0x1ecd, // o
 1560|      0|			 0xf4, 0x1ed3, 0x1ed1, 0x1ed5, 0x1ed7, 0x1ed9, // ô
 1561|      0|			0x1a1, 0x1edd, 0x1edb, 0x1edf, 0x1ee1, 0x1ee3, // ơ
 1562|      0|			 0x75,   0xf9,   0xfa, 0x1ee7,  0x169, 0x1ee5, // u
 1563|      0|			0x1b0, 0x1eeb, 0x1ee9, 0x1eed, 0x1eef, 0x1ef1, // ư
 1564|      0|			 0x79, 0x1ef3,   0xfd, 0x1ef7, 0x1ef9, 0x1ef5, // y
 1565|      0|			0
 1566|      0|		};
 1567|      0|
 1568|      0|		SetupTranslator(tr, stress_lengths_vi, stress_amps_vi);
 1569|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
 1570|      0|
 1571|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
 1572|      0|		tr->langopts.word_gap = 0x21; // length of a final vowel is less dependent on the next consonant, don't merge consonant with next word
 1573|      0|		tr->letter_groups[0] = tr->letter_groups[7] = vowels_vi;
 1574|      0|		tr->langopts.tone_language = 1; // Tone language, use  CalcPitches_Tone() rather than CalcPitches()
 1575|      0|		tr->langopts.unstressed_wd1 = 2;
 1576|      0|		tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_HUNDRED_AND_DIGIT | NUM_DFRACTION_4 | NUM_ZERO_HUNDRED;
 1577|      0|
 1578|      0|	}
 1579|      0|		break;
 1580|      0|	case L('w', 'o'):
 1581|      0|		tr->langopts.stress_rule = STRESSPOSN_1L;
 1582|      0|		tr->langopts.numbers = NUM_AND_UNITS | NUM_HUNDRED_AND | NUM_OMIT_1_HUNDRED | NUM_OMIT_1_THOUSAND | NUM_SINGLE_STRESS;
 1583|      0|		break;
 1584|      0|	case L3('s', 'h', 'n'):
 1585|      0|		tr->langopts.tone_language = 1; // Tone language, use  CalcPitches_Tone() rather than CalcPitches()
 1586|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
 1587|      0|		tr->langopts.numbers = NUM_DEFAULT;
 1588|      0|		tr->langopts.break_numbers = BREAK_INDIVIDUAL;
 1589|      0|		break;
 1590|      0|	case L3('c', 'm', 'n'): // no break, just go to 'zh' case
 1591|      0|	case L3('y', 'u', 'e'):
 1592|      0|	case L('z','h'):	// zh is used for backwards compatibility. Prefer cmn or yue.
 1593|      0|	{
 1594|      0|		static const short stress_lengths_zh[8] = { 230, 150, 230, 230, 230, 0, 240, 250 }; // 1=tone5. end-of-sentence, 6=tone 1&4, 7=tone 2&3
 1595|      0|		static const unsigned char stress_amps_zh[] = { 22, 16, 22, 22, 22, 22, 22, 22 };
 1596|      0|
 1597|      0|		SetupTranslator(tr, stress_lengths_zh, stress_amps_zh);
 1598|      0|
 1599|      0|		tr->langopts.stress_rule = STRESSPOSN_1R; // stress on final syllable of a "word"
 1600|      0|		tr->langopts.stress_flags = S_NO_DIM; // don't automatically set diminished stress (may be set in the intonation module)
 1601|      0|		tr->langopts.vowel_pause = 0;
 1602|      0|		tr->langopts.tone_language = 1; // Tone language, use  CalcPitches_Tone() rather than CalcPitches()
 1603|      0|		tr->langopts.length_mods0 = tr->langopts.length_mods; // don't lengthen vowels in the last syllable
 1604|      0|		tr->langopts.tone_numbers = 1; // a number after letters indicates a tone number (eg. pinyin or jyutping)
 1605|      0|		tr->langopts.ideographs = 1;
 1606|      0|		tr->langopts.our_alphabet = 0x3100;
 1607|      0|		tr->langopts.word_gap = 0x21; // length of a final vowel is less dependent on the next consonant, don't merge consonant with next word
 1608|      0|		if (name2 == L3('y', 'u', 'e')) {
 1609|      0|			tr->langopts.textmode = true;
 1610|      0|			tr->langopts.listx = 1; // compile zh_listx after zh_list
 1611|      0|			tr->langopts.numbers = NUM_DEFAULT;
 1612|      0|			tr->langopts.numbers2 = NUM2_ZERO_TENS;
 1613|      0|			tr->langopts.break_numbers = BREAK_INDIVIDUAL;
 1614|      0|		}
 1615|      0|		break;
 1616|      0|	}
 1617|      0|	default:
 1618|      0|		tr->langopts.param[LOPT_UNPRONOUNCABLE] = 1; // disable check for unpronouncable words
 1619|      0|		break;
 1620|      0|	}
 1621|      0|
 1622|      0|	tr->translator_name = name2;
 1623|      0|
 1624|      0|	ProcessLanguageOptions(&tr->langopts);
 1625|      0|	return tr;
 1626|      0|}
 1627|       |
 1628|       |void ProcessLanguageOptions(LANGUAGE_OPTIONS *langopts)
 1629|      0|{
 1630|      0|	if (langopts->numbers & NUM_DECIMAL_COMMA) {
 1631|      0|		// use . and ; for thousands and decimal separators
 1632|      0|		langopts->thousands_sep = '.';
 1633|      0|		langopts->decimal_sep = ',';
 1634|      0|	}
 1635|      0|	if (langopts->numbers & NUM_THOUS_SPACE)
 1636|      0|		langopts->thousands_sep = 0; // don't allow thousands separator, except space
 1637|      0|}
 1638|       |
 1639|       |static void Translator_Russian(Translator *tr)
 1640|      0|{
 1641|      0|	static const unsigned char stress_amps_ru[] = { 16, 16, 18, 18, 20, 24, 24, 22 };
 1642|      0|	static const short stress_lengths_ru[8] = { 150, 140, 220, 220, 0, 0, 260, 280 };
 1643|      0|	static const char ru_ivowels[] = { 0x15, 0x18, 0x34, 0x37, 0 }; // add "е и є ї" to Y lettergroup (iotated vowels & soft-sign)
 1644|      0|
 1645|      0|	SetupTranslator(tr, stress_lengths_ru, stress_amps_ru);
 1646|      0|	SetCyrillicLetters(tr);
 1647|      0|	SetLetterBits(tr, LETTERGP_Y, ru_ivowels);
 1648|      0|
 1649|      0|	tr->langopts.param[LOPT_UNPRONOUNCABLE] = 0x432; // [v]  don't count this character at start of word
 1650|      0|	tr->langopts.param[LOPT_REGRESSIVE_VOICING] = 1;
 1651|      0|	tr->langopts.param[LOPT_REDUCE] = 2;
 1652|      0|	tr->langopts.stress_rule = STRESSPOSN_SYLCOUNT;
 1653|      0|	tr->langopts.stress_flags = S_NO_AUTO_2;
 1654|      0|
 1655|      0|	tr->langopts.numbers = NUM_DECIMAL_COMMA | NUM_OMIT_1_HUNDRED;
 1656|      0|	tr->langopts.numbers2 = NUM2_THOUSANDPLEX_VAR_THOUSANDS | NUM2_THOUSANDS_VAR1; // variant numbers before thousands
 1657|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/translate.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2014 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2017 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <ctype.h>
   23|       |#include <stdbool.h>
   24|       |#include <stdint.h>
   25|       |#include <stdio.h>
   26|       |#include <stdlib.h>
   27|       |#include <string.h>
   28|       |#include <wchar.h>
   29|       |#include <wctype.h>
   30|       |
   31|       |#include <espeak-ng/espeak_ng.h>
   32|       |#include <espeak-ng/speak_lib.h>
   33|       |#include <espeak-ng/encoding.h>
   34|       |
   35|       |#include "translate.h"
   36|       |#include "dictionary.h"           // for TranslateRules, LookupDictList, Cha...
   37|       |#include "numbers.h"              // for SetSpellingStress, TranslateLetter
   38|       |#include "phoneme.h"              // for phonSWITCH, PHONEME_TAB, phonPAUSE_...
   39|       |#include "phonemelist.h"          // for MakePhonemeList
   40|       |#include "readclause.h"           // for towlower2, Eof, ReadClause, is_str_...
   41|       |#include "synthdata.h"            // for SelectPhonemeTable, LookupPhonemeTable
   42|       |#include "synthesize.h"           // for PHONEME_LIST2, N_PHONEME_LIST, PHON...
   43|       |#include "ucd/ucd.h"              // for ucd_toupper
   44|       |#include "voice.h"                // for voice, voice_t
   45|       |
   46|       |Translator *translator = NULL; // the main translator
   47|       |Translator *translator2 = NULL; // secondary translator for certain words
   48|       |static char translator2_language[20] = { 0 };
   49|       |
   50|       |FILE *f_trans = NULL; // phoneme output text
   51|       |int option_tone_flags = 0; // bit 8=emphasize allcaps, bit 9=emphasize penultimate stress
   52|       |int option_phonemes = 0;
   53|       |int option_phoneme_events = 0;
   54|       |int option_endpause = 0; // suppress pause after end of text
   55|       |int option_capitals = 0;
   56|       |int option_punctuation = 0;
   57|       |int option_sayas = 0;
   58|       |static int option_sayas2 = 0; // used in translate_clause()
   59|       |static int option_emphasis = 0; // 0=normal, 1=normal, 2=weak, 3=moderate, 4=strong
   60|       |int option_ssml = 0;
   61|       |int option_phoneme_input = 0; // allow [[phonemes]] in input
   62|       |int option_wordgap = 0;
   63|       |
   64|       |static int count_sayas_digits;
   65|       |int skip_sentences;
   66|       |int skip_words;
   67|       |int skip_characters;
   68|       |char skip_marker[N_MARKER_LENGTH];
   69|       |bool skipping_text; // waiting until word count, sentence count, or named marker is reached
   70|       |int end_character_position;
   71|       |int count_sentences;
   72|       |int count_words;
   73|       |int clause_start_char;
   74|       |int clause_start_word;
   75|       |bool new_sentence;
   76|       |static int word_emphasis = 0; // set if emphasis level 3 or 4
   77|       |static int embedded_flag = 0; // there are embedded commands to be applied to the next phoneme, used in TranslateWord2()
   78|       |
   79|       |static int prev_clause_pause = 0;
   80|       |static int max_clause_pause = 0;
   81|       |static bool any_stressed_words;
   82|       |int pre_pause;
   83|       |ALPHABET *current_alphabet;
   84|       |
   85|       |// these were previously in translator class
   86|       |char word_phonemes[N_WORD_PHONEMES]; // a word translated into phoneme codes
   87|       |int n_ph_list2;
   88|       |PHONEME_LIST2 ph_list2[N_PHONEME_LIST]; // first stage of text->phonemes
   89|       |
   90|       |wchar_t option_punctlist[N_PUNCTLIST] = { 0 };
   91|       |
   92|       |// these are overridden by defaults set in the "speak" file
   93|       |int option_linelength = 0;
   94|       |
   95|      0|#define N_EMBEDDED_LIST  250
   96|       |static int embedded_ix;
   97|       |static int embedded_read;
   98|       |unsigned int embedded_list[N_EMBEDDED_LIST];
   99|       |
  100|       |// the source text of a single clause (UTF8 bytes)
  101|       |static char source[N_TR_SOURCE+40]; // extra space for embedded command & voice change info at end
  102|       |
  103|       |int n_replace_phonemes;
  104|       |REPLACE_PHONEMES replace_phonemes[N_REPLACE_PHONEMES];
  105|       |
  106|       |// brackets, also 0x2014 to 0x021f which don't need to be in this list
  107|       |static const unsigned short brackets[] = {
  108|       |	'(', ')', '[', ']', '{', '}', '<', '>', '"', '\'', '`',
  109|       |	0xab,   0xbb,   // double angle brackets
  110|       |	0x300a, 0x300b, // double angle brackets (ideograph)
  111|       |	0xe000+'<',     // private usage area
  112|       |	0
  113|       |};
  114|       |
  115|       |// other characters which break a word, but don't produce a pause
  116|       |static const unsigned short breaks[] = { '_', 0 };
  117|       |
  118|       |int IsAlpha(unsigned int c)
  119|      0|{
  120|      0|	// Replacement for iswalph() which also checks for some in-word symbols
  121|      0|
  122|      0|	static const unsigned short extra_indic_alphas[] = {
  123|      0|		0xa70, 0xa71, // Gurmukhi: tippi, addak
  124|      0|		0
  125|      0|	};
  126|      0|
  127|      0|	if (iswalpha(c))
  128|      0|		return 1;
  129|      0|
  130|      0|	if (c < 0x300)
  131|      0|		return 0;
  132|      0|
  133|      0|	if ((c >= 0x901) && (c <= 0xdf7)) {
  134|      0|		// Indic scripts: Devanagari, Tamil, etc
  135|      0|		if ((c & 0x7f) < 0x64)
  136|      0|			return 1;
  137|      0|		if (lookupwchar(extra_indic_alphas, c) != 0)
  138|      0|			return 1;
  139|      0|		if ((c >= 0xd7a) && (c <= 0xd7f))
  140|      0|			return 1; // malaytalam chillu characters
  141|      0|
  142|      0|		return 0;
  143|      0|	}
  144|      0|
  145|      0|	if ((c >= 0x5b0) && (c <= 0x5c2))
  146|      0|		return 1; // Hebrew vowel marks
  147|      0|
  148|      0|	if (c == 0x0605)
  149|      0|		return 1;
  150|      0|
  151|      0|	if ((c == 0x670) || ((c >= 0x64b) && (c <= 0x65e)))
  152|      0|		return 1; // arabic vowel marks
  153|      0|
  154|      0|	if ((c >= 0x300) && (c <= 0x36f))
  155|      0|		return 1; // combining accents
  156|      0|
  157|      0|	if ((c >= 0xf40) && (c <= 0xfbc))
  158|      0|		return 1; // tibetan
  159|      0|
  160|      0|	if ((c >= 0x1100) && (c <= 0x11ff))
  161|      0|		return 1; // Korean jamo
  162|      0|
  163|      0|	if ((c >= 0x2800) && (c <= 0x28ff))
  164|      0|		return 1; // braille
  165|      0|
  166|      0|	if ((c > 0x3040) && (c <= 0xa700))
  167|      0|		return 1; // Chinese/Japanese.  Should never get here, but Mac OS 10.4's iswalpha seems to be broken, so just make sure
  168|      0|
  169|      0|	return 0;
  170|      0|}
  171|       |
  172|       |int IsDigit09(unsigned int c)
  173|      0|{
  174|      0|	if ((c >= '0') && (c <= '9'))
  175|      0|		return 1;
  176|      0|	return 0;
  177|      0|}
  178|       |
  179|       |int IsDigit(unsigned int c)
  180|      0|{
  181|      0|	if (iswdigit(c))
  182|      0|		return 1;
  183|      0|
  184|      0|	if ((c >= 0x966) && (c <= 0x96f))
  185|      0|		return 1;
  186|      0|
  187|      0|	return 0;
  188|      0|}
  189|       |
  190|       |static int IsSpace(unsigned int c)
  191|      0|{
  192|      0|	if (c == 0)
  193|      0|		return 0;
  194|      0|	if ((c >= 0x2500) && (c < 0x25a0))
  195|      0|		return 1; // box drawing characters
  196|      0|	if ((c >= 0xfff9) && (c <= 0xffff))
  197|      0|		return 1; // unicode specials
  198|      0|	return iswspace(c);
  199|      0|}
  200|       |
  201|       |int isspace2(unsigned int c)
  202|      0|{
  203|      0|	// can't use isspace() because on Windows, isspace(0xe1) gives TRUE !
  204|      0|	int c2;
  205|      0|
  206|      0|	if (((c2 = (c & 0xff)) == 0) || (c > ' '))
  207|      0|		return 0;
  208|      0|	return 1;
  209|      0|}
  210|       |
  211|       |void DeleteTranslator(Translator *tr)
  212|      0|{
  213|      0|	if (!tr) return;
  214|      0|
  215|      0|	if (tr->data_dictlist != NULL)
  216|      0|		free(tr->data_dictlist);
  217|      0|	free(tr);
  218|      0|}
  219|       |
  220|       |int lookupwchar(const unsigned short *list, int c)
  221|      0|{
  222|      0|	// Is the character c in the list ?
  223|      0|	int ix;
  224|      0|
  225|      0|	for (ix = 0; list[ix] != 0; ix++) {
  226|      0|		if (list[ix] == c)
  227|      0|			return ix+1;
  228|      0|	}
  229|      0|	return 0;
  230|      0|}
  231|       |
  232|       |int lookupwchar2(const unsigned short *list, int c)
  233|      0|{
  234|      0|	// Replace character c by another character.
  235|      0|	// Returns 0 = not found, 1 = delete character
  236|      0|
  237|      0|	int ix;
  238|      0|
  239|      0|	for (ix = 0; list[ix] != 0; ix += 2) {
  240|      0|		if (list[ix] == c)
  241|      0|			return list[ix+1];
  242|      0|	}
  243|      0|	return 0;
  244|      0|}
  245|       |
  246|       |int IsBracket(int c)
  247|      0|{
  248|      0|	if ((c >= 0x2014) && (c <= 0x201f))
  249|      0|		return 1;
  250|      0|	return lookupwchar(brackets, c);
  251|      0|}
  252|       |
  253|       |int utf8_nbytes(const char *buf)
  254|      0|{
  255|      0|	// Returns the number of bytes for the first UTF-8 character in buf
  256|      0|
  257|      0|	unsigned char c = (unsigned char)buf[0];
  258|      0|	if (c < 0x80)
  259|      0|		return 1;
  260|      0|	if (c < 0xe0)
  261|      0|		return 2;
  262|      0|	if (c < 0xf0)
  263|      0|		return 3;
  264|      0|	return 4;
  265|      0|}
  266|       |
  267|       |int utf8_in2(int *c, const char *buf, int backwards)
  268|      0|{
  269|      0|	// Reads a unicode characater from a UTF8 string
  270|      0|	// Returns the number of UTF8 bytes used.
  271|      0|	// c: holds integer representation of multibyte character
  272|      0|	// buf: position of buffer is moved, if character is read
  273|      0|	// backwards: set if we are moving backwards through the UTF8 string
  274|      0|
  275|      0|	int c1;
  276|      0|	int n_bytes;
  277|      0|	int ix;
  278|      0|	static const unsigned char mask[4] = { 0xff, 0x1f, 0x0f, 0x07 };
  279|      0|
  280|      0|	// find the start of the next/previous character
  281|      0|	while ((*buf & 0xc0) == 0x80) {
  282|      0|		// skip over non-initial bytes of a multi-byte utf8 character
  283|      0|		if (backwards)
  284|      0|			buf--;
  285|      0|		else
  286|      0|			buf++;
  287|      0|	}
  288|      0|
  289|      0|	n_bytes = 0;
  290|      0|
  291|      0|	if ((c1 = *buf++) & 0x80) {
  292|      0|		if ((c1 & 0xe0) == 0xc0)
  293|      0|			n_bytes = 1;
  294|      0|		else if ((c1 & 0xf0) == 0xe0)
  295|      0|			n_bytes = 2;
  296|      0|		else if ((c1 & 0xf8) == 0xf0)
  297|      0|			n_bytes = 3;
  298|      0|
  299|      0|		c1 &= mask[n_bytes];
  300|      0|		for (ix = 0; ix < n_bytes; ix++)
  301|      0|			c1 = (c1 << 6) + (*buf++ & 0x3f);
  302|      0|	}
  303|      0|	*c = c1;
  304|      0|	return n_bytes+1;
  305|      0|}
  306|       |
  307|       |#pragma GCC visibility push(default)
  308|       |int utf8_in(int *c, const char *buf)
  309|      0|{
  310|      0|	/* Read a unicode characater from a UTF8 string
  311|      0|	 * Returns the number of UTF8 bytes used.
  312|      0|	 * buf: position of buffer is moved, if character is read
  313|      0|	 * c: holds UTF-16 representation of multibyte character by
  314|      0|	 * skipping UTF-8 header bits of bytes in following way:
  315|      0|	 * 2-byte character "ā":
  316|      0|	 * hex            binary
  317|      0|	 * c481           1100010010000001
  318|      0|	 *    |           11000100  000001
  319|      0|	 *    V              \    \ |    |
  320|      0|	 * 0101           0000000100000001
  321|      0|	 * 3-byte character "ꙅ":
  322|      0|	 * ea9985 111010101001100110000101
  323|      0|	 *            1010  011001  000101
  324|      0|	 *    |       +  +--.\   \  |    |
  325|      0|	 *    V        `--.  \`.  `.|    |
  326|      0|	 *   A645         1010011001000101
  327|      0|	 * 4-byte character "𠜎":
  328|      0|	 * f0a09c8e 11110000101000001001110010001110
  329|      0|	 *    V          000  100000  011100  001110
  330|      0|	 *   02070e         000000100000011100001110
  331|      0|	 */
  332|      0|	return utf8_in2(c, buf, 0);
  333|      0|}
  334|       |#pragma GCC visibility pop
  335|       |
  336|       |int utf8_out(unsigned int c, char *buf)
  337|      0|{
  338|      0|	// write a UTF-16 character into a buffer as UTF-8
  339|      0|	// returns the number of bytes written
  340|      0|
  341|      0|	int n_bytes;
  342|      0|	int j;
  343|      0|	int shift;
  344|      0|	static char unsigned code[4] = { 0, 0xc0, 0xe0, 0xf0 };
  345|      0|
  346|      0|	if (c < 0x80) {
  347|      0|		buf[0] = c;
  348|      0|		return 1;
  349|      0|	}
  350|      0|	if (c >= 0x110000) {
  351|      0|		buf[0] = ' '; // out of range character code
  352|      0|		return 1;
  353|      0|	}
  354|      0|	if (c < 0x0800)
  355|      0|		n_bytes = 1;
  356|      0|	else if (c < 0x10000)
  357|      0|		n_bytes = 2;
  358|      0|	else
  359|      0|		n_bytes = 3;
  360|      0|
  361|      0|	shift = 6*n_bytes;
  362|      0|	buf[0] = code[n_bytes] | (c >> shift);
  363|      0|	for (j = 0; j < n_bytes; j++) {
  364|      0|		shift -= 6;
  365|      0|		buf[j+1] = 0x80 + ((c >> shift) & 0x3f);
  366|      0|	}
  367|      0|	return n_bytes+1;
  368|      0|}
  369|       |
  370|       |char *strchr_w(const char *s, int c)
  371|      0|{
  372|      0|	// return NULL for any non-ascii character
  373|      0|	if (c >= 0x80)
  374|      0|		return NULL;
  375|      0|	return strchr((char *)s, c); // (char *) is needed for Borland compiler
  376|      0|}
  377|       |
  378|       |// append plural suffixes depending on preceding letter
  379|       |static void addPluralSuffixes(int flags, Translator *tr, char last_char, char *word_phonemes)
  380|      0|{
  381|      0|	char word_zz[4] = { 0, 'z', 'z', 0 };
  382|      0|	char word_iz[4] = { 0, 'i', 'z', 0 };
  383|      0|	char word_ss[4] = { 0, 's', 's', 0 };
  384|      0|	if (flags & FLAG_HAS_PLURAL) {
  385|      0|		// s or 's suffix, append [s], [z] or [Iz] depending on previous letter
  386|      0|		if (last_char == 'f')
  387|      0|			TranslateRules(tr, &word_ss[1], word_phonemes, N_WORD_PHONEMES,
  388|      0|			NULL, 0, NULL);
  389|      0|		else if ((last_char == 0) || (strchr_w("hsx", last_char) == NULL))
  390|      0|			TranslateRules(tr, &word_zz[1], word_phonemes, N_WORD_PHONEMES,
  391|      0|			NULL, 0, NULL);
  392|      0|		else
  393|      0|			TranslateRules(tr, &word_iz[1], word_phonemes, N_WORD_PHONEMES,
  394|      0|			NULL, 0, NULL);
  395|      0|	}
  396|      0|}
  397|       |
  398|       |static char *SpeakIndividualLetters(Translator *tr, char *word, char *phonemes, int spell_word)
  399|      0|{
  400|      0|	int posn = 0;
  401|      0|	int capitals = 0;
  402|      0|	bool non_initial = false;
  403|      0|
  404|      0|	if (spell_word > 2)
  405|      0|		capitals = 2; // speak 'capital'
  406|      0|	if (spell_word > 1)
  407|      0|		capitals |= 4; // speak character code for unknown letters
  408|      0|
  409|      0|	while ((*word != ' ') && (*word != 0)) {
  410|      0|		word += TranslateLetter(tr, word, phonemes, capitals | non_initial, current_alphabet);
  411|      0|		posn++;
  412|      0|		non_initial = true;
  413|      0|		if (phonemes[0] == phonSWITCH) {
  414|      0|			// change to another language in order to translate this word
  415|      0|			strcpy(word_phonemes, phonemes);
  416|      0|			return NULL;
  417|      0|		}
  418|      0|	}
  419|      0|	SetSpellingStress(tr, phonemes, spell_word, posn);
  420|      0|	return word;
  421|      0|}
  422|       |
  423|       |static int CheckDottedAbbrev(char *word1)
  424|      0|{
  425|      0|	int wc;
  426|      0|	int count = 0;
  427|      0|	int nbytes;
  428|      0|	int ok;
  429|      0|	int ix;
  430|      0|	char *word;
  431|      0|	char *wbuf;
  432|      0|	char word_buf[80];
  433|      0|
  434|      0|	word = word1;
  435|      0|	wbuf = word_buf;
  436|      0|
  437|      0|	for (;;) {
  438|      0|		ok = 0;
  439|      0|		nbytes = utf8_in(&wc, word);
  440|      0|		if ((word[nbytes] == ' ') && IsAlpha(wc)) {
  441|      0|			if (word[nbytes+1] == '.') {
  442|      0|				if (word[nbytes+2] == ' ')
  443|      0|					ok = 1;
  444|      0|				else if (word[nbytes+2] == '\'' && word[nbytes+3] == 's') {
  445|      0|					nbytes += 2; // delete the final dot (eg. u.s.a.'s)
  446|      0|					ok = 2;
  447|      0|				}
  448|      0|			} else if ((count > 0) && (word[nbytes] == ' '))
  449|      0|				ok = 2;
  450|      0|		}
  451|      0|
  452|      0|		if (ok == 0)
  453|      0|			break;
  454|      0|
  455|      0|		for (ix = 0; ix < nbytes; ix++)
  456|      0|			*wbuf++ = word[ix];
  457|      0|
  458|      0|		count++;
  459|      0|
  460|      0|		if (ok == 2) {
  461|      0|			word += nbytes;
  462|      0|			break;
  463|      0|		}
  464|      0|
  465|      0|		word += (nbytes + 3);
  466|      0|	}
  467|      0|
  468|      0|	if (count > 1) {
  469|      0|		ix = wbuf - word_buf;
  470|      0|		memcpy(word1, word_buf, ix);
  471|      0|		while (&word1[ix] < word)
  472|      0|			word1[ix++] = ' ';
  473|      0|		dictionary_skipwords = (count - 1)*2;
  474|      0|	}
  475|      0|	return count;
  476|      0|}
  477|       |
  478|       |static int TranslateWord3(Translator *tr, char *word_start, WORD_TAB *wtab, char *word_out)
  479|      0|{
  480|      0|	// word1 is terminated by space (0x20) character
  481|      0|
  482|      0|	char *word1;
  483|      0|	int word_length;
  484|      0|	int ix;
  485|      0|	char *p;
  486|      0|	int pfix;
  487|      0|	int n_chars;
  488|      0|	unsigned int dictionary_flags[2];
  489|      0|	unsigned int dictionary_flags2[2];
  490|      0|	int end_type = 0;
  491|      0|	int end_type1 = 0;
  492|      0|	int prefix_type = 0;
  493|      0|	int prefix_stress;
  494|      0|	char *wordx;
  495|      0|	char phonemes[N_WORD_PHONEMES];
  496|      0|	char phonemes2[N_WORD_PHONEMES];
  497|      0|	char prefix_phonemes[N_WORD_PHONEMES];
  498|      0|	char unpron_phonemes[N_WORD_PHONEMES];
  499|      0|	char end_phonemes[N_WORD_PHONEMES];
  500|      0|	char end_phonemes2[N_WORD_PHONEMES];
  501|      0|	char word_copy[N_WORD_BYTES];
  502|      0|	char word_copy2[N_WORD_BYTES];
  503|      0|	int word_copy_length;
  504|      0|	char prefix_chars[0x3f + 2];
  505|      0|	bool found = false;
  506|      0|	int end_flags;
  507|      0|	int c_temp; // save a character byte while we temporarily replace it with space
  508|      0|	int first_char;
  509|      0|	int last_char = 0;
  510|      0|	int prefix_flags = 0;
  511|      0|	bool more_suffixes;
  512|      0|	bool confirm_prefix;
  513|      0|	int spell_word;
  514|      0|	int emphasize_allcaps = 0;
  515|      0|	int wflags;
  516|      0|	int was_unpronouncable = 0;
  517|      0|	int loopcount;
  518|      0|	int add_suffix_phonemes = 0;
  519|      0|	WORD_TAB wtab_null[8];
  520|      0|
  521|      0|	if (wtab == NULL) {
  522|      0|		memset(wtab_null, 0, sizeof(wtab_null));
  523|      0|		wtab = wtab_null;
  524|      0|	}
  525|      0|	wflags = wtab->flags;
  526|      0|
  527|      0|	dictionary_flags[0] = 0;
  528|      0|	dictionary_flags[1] = 0;
  529|      0|	dictionary_flags2[0] = 0;
  530|      0|	dictionary_flags2[1] = 0;
  531|      0|	dictionary_skipwords = 0;
  532|      0|
  533|      0|	phonemes[0] = 0;
  534|      0|	unpron_phonemes[0] = 0;
  535|      0|	prefix_phonemes[0] = 0;
  536|      0|	end_phonemes[0] = 0;
  537|      0|
  538|      0|	if (tr->data_dictlist == NULL) {
  539|      0|		// dictionary is not loaded
  540|      0|		word_phonemes[0] = 0;
  541|      0|		return 0;
  542|      0|	}
  543|      0|
  544|      0|	// count the length of the word
  545|      0|	word1 = word_start;
  546|      0|	if (*word1 == ' ') word1++; // possibly a dot was replaced by space:  $dot
  547|      0|	wordx = word1;
  548|      0|
  549|      0|	utf8_in(&first_char, wordx);
  550|      0|	word_length = 0;
  551|      0|	while ((*wordx != 0) && (*wordx != ' ')) {
  552|      0|		wordx += utf8_in(&last_char, wordx);
  553|      0|		word_length++;
  554|      0|	}
  555|      0|
  556|      0|	word_copy_length = wordx - word_start;
  557|      0|	if (word_copy_length >= N_WORD_BYTES)
  558|      0|		word_copy_length = N_WORD_BYTES-1;
  559|      0|	memcpy(word_copy2, word_start, word_copy_length);
  560|      0|
  561|      0|	spell_word = 0;
  562|      0|
  563|      0|	if ((word_length == 1) && (wflags & FLAG_TRANSLATOR2)) {
  564|      0|		// retranslating a 1-character word using a different language, say its name
  565|      0|		utf8_in(&c_temp, wordx+1); // the next character
  566|      0|		if (!IsAlpha(c_temp) || (AlphabetFromChar(last_char) != AlphabetFromChar(c_temp)))
  567|      0|			spell_word = 1;
  568|      0|	}
  569|      0|
  570|      0|	if (option_sayas == SAYAS_KEY) {
  571|      0|		if (word_length == 1)
  572|      0|			spell_word = 4;
  573|      0|		else {
  574|      0|			// is there a translation for this keyname ?
  575|      0|			word1--;
  576|      0|			*word1 = '_'; // prefix keyname with '_'
  577|      0|			found = LookupDictList(tr, &word1, phonemes, dictionary_flags, 0, wtab);
  578|      0|		}
  579|      0|	}
  580|      0|
  581|      0|	// try an initial lookup in the dictionary list, we may find a pronunciation specified, or
  582|      0|	// we may just find some flags
  583|      0|	if (option_sayas & 0x10) {
  584|      0|		// SAYAS_CHAR, SAYAS_GYLPH, or SAYAS_SINGLE_CHAR
  585|      0|		spell_word = option_sayas & 0xf; // 2,3,4
  586|      0|	} else {
  587|      0|		if (!found)
  588|      0|			found = LookupDictList(tr, &word1, phonemes, dictionary_flags, FLAG_ALLOW_TEXTMODE, wtab);   // the original word
  589|      0|
  590|      0|		if ((dictionary_flags[0] & (FLAG_ALLOW_DOT | FLAG_NEEDS_DOT)) && (wordx[1] == '.'))
  591|      0|			wordx[1] = ' '; // remove a Dot after this word
  592|      0|
  593|      0|		if (dictionary_flags[0] & FLAG_TEXTMODE) {
  594|      0|			if (word_out != NULL)
  595|      0|				strcpy(word_out, word1);
  596|      0|
  597|      0|			return dictionary_flags[0];
  598|      0|		} else if ((found == false) && (dictionary_flags[0] & FLAG_SKIPWORDS) && !(dictionary_flags[0] & FLAG_ABBREV)) {
  599|      0|			// grouped words, but no translation.  Join the words with hyphens.
  600|      0|			wordx = word1;
  601|      0|			ix = 0;
  602|      0|			while (ix < dictionary_skipwords) {
  603|      0|				if (*wordx == ' ') {
  604|      0|					*wordx = '-';
  605|      0|					ix++;
  606|      0|				}
  607|      0|				wordx++;
  608|      0|			}
  609|      0|		}
  610|      0|
  611|      0|		if ((word_length == 1) && (dictionary_skipwords == 0)) {
  612|      0|			// is this a series of single letters separated by dots?
  613|      0|			if (CheckDottedAbbrev(word1)) {
  614|      0|				dictionary_flags[0] = 0;
  615|      0|				dictionary_flags[1] = 0;
  616|      0|				spell_word = 1;
  617|      0|				if (dictionary_skipwords)
  618|      0|					dictionary_flags[0] = FLAG_SKIPWORDS;
  619|      0|			}
  620|      0|		}
  621|      0|
  622|      0|		if (phonemes[0] == phonSWITCH) {
  623|      0|			// change to another language in order to translate this word
  624|      0|			strcpy(word_phonemes, phonemes);
  625|      0|			return 0;
  626|      0|		}
  627|      0|
  628|      0|		if (!found && (dictionary_flags[0] & FLAG_ABBREV)) {
  629|      0|			// the word has $abbrev flag, but no pronunciation specified.  Speak as individual letters
  630|      0|			spell_word = 1;
  631|      0|		}
  632|      0|
  633|      0|		if (!found && iswdigit(first_char)) {
  634|      0|			Lookup(tr, "_0lang", word_phonemes);
  635|      0|			if (word_phonemes[0] == phonSWITCH)
  636|      0|				return 0;
  637|      0|
  638|      0|			if ((tr->langopts.numbers2 & NUM2_ENGLISH_NUMERALS) && !(wtab->flags & FLAG_CHAR_REPLACED)) {
  639|      0|				// for this language, speak English numerals (0-9) with the English voice
  640|      0|				sprintf(word_phonemes, "%c", phonSWITCH);
  641|      0|				return 0;
  642|      0|			}
  643|      0|
  644|      0|			found = TranslateNumber(tr, word1, phonemes, dictionary_flags, wtab, 0);
  645|      0|		}
  646|      0|
  647|      0|		if (!found && ((wflags & FLAG_UPPERS) != FLAG_FIRST_UPPER)) {
  648|      0|			// either all upper or all lower case
  649|      0|
  650|      0|			if ((tr->langopts.numbers & NUM_ROMAN) || ((tr->langopts.numbers & NUM_ROMAN_CAPITALS) && (wflags & FLAG_ALL_UPPER))) {
  651|      0|				if ((wflags & FLAG_LAST_WORD) || !(wtab[1].flags & FLAG_NOSPACE)) {
  652|      0|					// don't use Roman number if this word is not separated from the next word (eg. "XLTest")
  653|      0|					if ((found = TranslateRoman(tr, word1, phonemes, wtab)) != 0)
  654|      0|						dictionary_flags[0] |= FLAG_ABBREV; // prevent emphasis if capitals
  655|      0|				}
  656|      0|			}
  657|      0|		}
  658|      0|
  659|      0|		if ((wflags & FLAG_ALL_UPPER) && (word_length > 1) && iswalpha(first_char)) {
  660|      0|			if ((option_tone_flags & OPTION_EMPHASIZE_ALLCAPS) && !(dictionary_flags[0] & FLAG_ABBREV)) {
  661|      0|				// emphasize words which are in capitals
  662|      0|				emphasize_allcaps = FLAG_EMPHASIZED;
  663|      0|			} else if (!found && !(dictionary_flags[0] &  FLAG_SKIPWORDS) && (word_length < 4) && (tr->clause_lower_count > 3)
  664|      0|			           && (tr->clause_upper_count <= tr->clause_lower_count)) {
  665|      0|				// An upper case word in a lower case clause. This could be an abbreviation.
  666|      0|				spell_word = 1;
  667|      0|			}
  668|      0|		}
  669|      0|	}
  670|      0|
  671|      0|	if (spell_word > 0) {
  672|      0|		// Speak as individual letters
  673|      0|		phonemes[0] = 0;
  674|      0|
  675|      0|		if (SpeakIndividualLetters(tr, word1, phonemes, spell_word) == NULL) {
  676|      0|			if (word_length > 1)
  677|      0|				return FLAG_SPELLWORD; // a mixture of languages, retranslate as individual letters, separated by spaces
  678|      0|			return 0;
  679|      0|		}
  680|      0|		strcpy(word_phonemes, phonemes);
  681|      0|		if (wflags & FLAG_TRANSLATOR2)
  682|      0|			return 0;
  683|      0|
  684|      0|		addPluralSuffixes(wflags, tr, last_char, word_phonemes);
  685|      0|		return dictionary_flags[0] & FLAG_SKIPWORDS; // for "b.c.d"
  686|      0|	} else if (found == false) {
  687|      0|		// word's pronunciation is not given in the dictionary list, although
  688|      0|		// dictionary_flags may have ben set there
  689|      0|
  690|      0|		int posn;
  691|      0|		bool non_initial = false;
  692|      0|		int length;
  693|      0|
  694|      0|		posn = 0;
  695|      0|		length = 999;
  696|      0|		wordx = word1;
  697|      0|
  698|      0|		while (((length < 3) && (length > 0)) || (word_length > 1 && Unpronouncable(tr, wordx, posn))) {
  699|      0|			// This word looks "unpronouncable", so speak letters individually until we
  700|      0|			// find a remainder that we can pronounce.
  701|      0|			was_unpronouncable = FLAG_WAS_UNPRONOUNCABLE;
  702|      0|			emphasize_allcaps = 0;
  703|      0|
  704|      0|			if (wordx[0] == '\'')
  705|      0|				break;
  706|      0|
  707|      0|			if (posn > 0)
  708|      0|				non_initial = true;
  709|      0|
  710|      0|			wordx += TranslateLetter(tr, wordx, unpron_phonemes, non_initial, current_alphabet);
  711|      0|			posn++;
  712|      0|			if (unpron_phonemes[0] == phonSWITCH) {
  713|      0|				// change to another language in order to translate this word
  714|      0|				strcpy(word_phonemes, unpron_phonemes);
  715|      0|				if (strcmp(&unpron_phonemes[1], ESPEAKNG_DEFAULT_VOICE) == 0)
  716|      0|					return FLAG_SPELLWORD; // _^_en must have been set in TranslateLetter(), not *_rules which uses only _^_
  717|      0|				return 0;
  718|      0|			}
  719|      0|
  720|      0|			length = 0;
  721|      0|			while (wordx[length] != ' ') length++;
  722|      0|		}
  723|      0|		SetSpellingStress(tr, unpron_phonemes, 0, posn);
  724|      0|
  725|      0|		// anything left ?
  726|      0|		if (*wordx != ' ') {
  727|      0|			if ((unpron_phonemes[0] != 0) && (wordx[0] != '\'')) {
  728|      0|				// letters which have been spoken individually from affecting the pronunciation of the pronuncable part
  729|      0|				wordx[-1] = ' ';
  730|      0|			}
  731|      0|
  732|      0|			// Translate the stem
  733|      0|			end_type = TranslateRules(tr, wordx, phonemes, N_WORD_PHONEMES, end_phonemes, wflags, dictionary_flags);
  734|      0|
  735|      0|			if (phonemes[0] == phonSWITCH) {
  736|      0|				// change to another language in order to translate this word
  737|      0|				strcpy(word_phonemes, phonemes);
  738|      0|				return 0;
  739|      0|			}
  740|      0|
  741|      0|			if ((phonemes[0] == 0) && (end_phonemes[0] == 0)) {
  742|      0|				int wc;
  743|      0|				// characters not recognised, speak them individually
  744|      0|				// ?? should we say super/sub-script numbers and letters here?
  745|      0|				utf8_in(&wc, wordx);
  746|      0|				if ((word_length == 1) && (IsAlpha(wc) || IsSuperscript(wc))) {
  747|      0|					if ((wordx = SpeakIndividualLetters(tr, wordx, phonemes, spell_word)) == NULL)
  748|      0|						return 0;
  749|      0|					strcpy(word_phonemes, phonemes);
  750|      0|					return 0;
  751|      0|				}
  752|      0|			}
  753|      0|
  754|      0|			c_temp = wordx[-1];
  755|      0|
  756|      0|			found = false;
  757|      0|			confirm_prefix = true;
  758|      0|			for (loopcount = 0; (loopcount < 50) && (end_type & SUFX_P); loopcount++) {
  759|      0|				// Found a standard prefix, remove it and retranslate
  760|      0|				// loopcount guards against an endless loop
  761|      0|				if (confirm_prefix && !(end_type & SUFX_B)) {
  762|      0|					int end2;
  763|      0|					char end_phonemes2[N_WORD_PHONEMES];
  764|      0|
  765|      0|					// remove any standard suffix and confirm that the prefix is still recognised
  766|      0|					phonemes2[0] = 0;
  767|      0|					end2 = TranslateRules(tr, wordx, phonemes2, N_WORD_PHONEMES, end_phonemes2, wflags|FLAG_NO_PREFIX|FLAG_NO_TRACE, dictionary_flags);
  768|      0|					if (end2) {
  769|      0|						RemoveEnding(tr, wordx, end2, word_copy);
  770|      0|						end_type = TranslateRules(tr, wordx, phonemes, N_WORD_PHONEMES, end_phonemes, wflags|FLAG_NO_TRACE, dictionary_flags);
  771|      0|						memcpy(wordx, word_copy, strlen(word_copy));
  772|      0|						if ((end_type & SUFX_P) == 0) {
  773|      0|							// after removing the suffix, the prefix is no longer recognised.
  774|      0|							// Keep the suffix, but don't use the prefix
  775|      0|							end_type = end2;
  776|      0|							strcpy(phonemes, phonemes2);
  777|      0|							strcpy(end_phonemes, end_phonemes2);
  778|      0|							if (option_phonemes & espeakPHONEMES_TRACE) {
  779|      0|								DecodePhonemes(end_phonemes, end_phonemes2);
  780|      0|								fprintf(f_trans, "  suffix [%s]\n\n", end_phonemes2);
  781|      0|							}
  782|      0|						}
  783|      0|						confirm_prefix = false;
  784|      0|						continue;
  785|      0|					}
  786|      0|				}
  787|      0|
  788|      0|				prefix_type = end_type;
  789|      0|
  790|      0|				if (prefix_type & SUFX_V)
  791|      0|					tr->expect_verb = 1; // use the verb form of the word
  792|      0|
  793|      0|				wordx[-1] = c_temp;
  794|      0|
  795|      0|				if ((prefix_type & SUFX_B) == 0) {
  796|      0|					for (ix = (prefix_type & 0xf); ix > 0; ix--) { // num. of characters to remove
  797|      0|						wordx++;
  798|      0|						while ((*wordx & 0xc0) == 0x80) wordx++; // for multibyte characters
  799|      0|					}
  800|      0|				} else {
  801|      0|					pfix = 1;
  802|      0|					prefix_chars[0] = 0;
  803|      0|					n_chars = prefix_type & 0x3f;
  804|      0|
  805|      0|					for (ix = 0; ix < n_chars; ix++) { // num. of bytes to remove
  806|      0|						prefix_chars[pfix++] = *wordx++;
  807|      0|
  808|      0|						if ((prefix_type & SUFX_B) && (ix == (n_chars-1)))
  809|      0|							prefix_chars[pfix-1] = 0; // discard the last character of the prefix, this is the separator character
  810|      0|					}
  811|      0|					prefix_chars[pfix] = 0;
  812|      0|				}
  813|      0|				c_temp = wordx[-1];
  814|      0|				wordx[-1] = ' ';
  815|      0|				confirm_prefix = true;
  816|      0|				wflags |= FLAG_PREFIX_REMOVED;
  817|      0|
  818|      0|				if (prefix_type & SUFX_B) {
  819|      0|					// SUFX_B is used for Turkish, tr_rules contains " ' (Pb"
  820|      0|					// examine the prefix part
  821|      0|					char *wordpf;
  822|      0|					char prefix_phonemes2[12];
  823|      0|
  824|      0|					strncpy0(prefix_phonemes2, end_phonemes, sizeof(prefix_phonemes2));
  825|      0|					wordpf = &prefix_chars[1];
  826|      0|					strcpy(prefix_phonemes, phonemes);
  827|      0|
  828|      0|					// look for stress marker or $abbrev
  829|      0|					found = LookupDictList(tr, &wordpf, phonemes, dictionary_flags, 0, wtab);
  830|      0|					if (found)
  831|      0|						strcpy(prefix_phonemes, phonemes);
  832|      0|					if (dictionary_flags[0] & FLAG_ABBREV) {
  833|      0|						prefix_phonemes[0] = 0;
  834|      0|						SpeakIndividualLetters(tr, wordpf, prefix_phonemes, 1);
  835|      0|					}
  836|      0|				} else
  837|      0|					strcat(prefix_phonemes, end_phonemes);
  838|      0|				end_phonemes[0] = 0;
  839|      0|
  840|      0|				end_type = 0;
  841|      0|				found = LookupDictList(tr, &wordx, phonemes, dictionary_flags2, SUFX_P, wtab); // without prefix
  842|      0|				if (dictionary_flags[0] == 0) {
  843|      0|					dictionary_flags[0] = dictionary_flags2[0];
  844|      0|					dictionary_flags[1] = dictionary_flags2[1];
  845|      0|				} else
  846|      0|					prefix_flags = 1;
  847|      0|				if (found == false) {
  848|      0|					end_type = TranslateRules(tr, wordx, phonemes, N_WORD_PHONEMES, end_phonemes, wflags & (FLAG_HYPHEN_AFTER | FLAG_PREFIX_REMOVED), dictionary_flags);
  849|      0|
  850|      0|					if (phonemes[0] == phonSWITCH) {
  851|      0|						// change to another language in order to translate this word
  852|      0|						wordx[-1] = c_temp;
  853|      0|						strcpy(word_phonemes, phonemes);
  854|      0|						return 0;
  855|      0|					}
  856|      0|				}
  857|      0|			}
  858|      0|
  859|      0|			if ((end_type != 0) && !(end_type & SUFX_P)) {
  860|      0|				end_type1 = end_type;
  861|      0|				strcpy(phonemes2, phonemes);
  862|      0|
  863|      0|				// The word has a standard ending, re-translate without this ending
  864|      0|				end_flags = RemoveEnding(tr, wordx, end_type, word_copy);
  865|      0|				more_suffixes = true;
  866|      0|
  867|      0|				while (more_suffixes) {
  868|      0|					more_suffixes = false;
  869|      0|					phonemes[0] = 0;
  870|      0|
  871|      0|					if (prefix_phonemes[0] != 0) {
  872|      0|						// lookup the stem without the prefix removed
  873|      0|						wordx[-1] = c_temp;
  874|      0|						found = LookupDictList(tr, &word1, phonemes, dictionary_flags2, end_flags, wtab);  // include prefix, but not suffix
  875|      0|						wordx[-1] = ' ';
  876|      0|						if (phonemes[0] == phonSWITCH) {
  877|      0|							// change to another language in order to translate this word
  878|      0|							memcpy(wordx, word_copy, strlen(word_copy));
  879|      0|							strcpy(word_phonemes, phonemes);
  880|      0|							return 0;
  881|      0|						}
  882|      0|						if (dictionary_flags[0] == 0) {
  883|      0|							dictionary_flags[0] = dictionary_flags2[0];
  884|      0|							dictionary_flags[1] = dictionary_flags2[1];
  885|      0|						}
  886|      0|						if (found)
  887|      0|							prefix_phonemes[0] = 0; // matched whole word, don't need prefix now
  888|      0|
  889|      0|						if ((found == false) && (dictionary_flags2[0] != 0))
  890|      0|							prefix_flags = 1;
  891|      0|					}
  892|      0|					if (found == false) {
  893|      0|						found = LookupDictList(tr, &wordx, phonemes, dictionary_flags2, end_flags, wtab);  // without prefix and suffix
  894|      0|						if (phonemes[0] == phonSWITCH) {
  895|      0|							// change to another language in order to translate this word
  896|      0|							memcpy(wordx, word_copy, strlen(word_copy));
  897|      0|							strcpy(word_phonemes, phonemes);
  898|      0|							return 0;
  899|      0|						}
  900|      0|
  901|      0|						if (dictionary_flags[0] == 0) {
  902|      0|							dictionary_flags[0] = dictionary_flags2[0];
  903|      0|							dictionary_flags[1] = dictionary_flags2[1];
  904|      0|						}
  905|      0|					}
  906|      0|					if (found == false) {
  907|      0|						if (end_type & SUFX_Q) {
  908|      0|							// don't retranslate, use the original lookup result
  909|      0|							strcpy(phonemes, phonemes2);
  910|      0|						} else {
  911|      0|							if (end_flags & FLAG_SUFX)
  912|      0|								wflags |= FLAG_SUFFIX_REMOVED;
  913|      0|							if (end_type & SUFX_A)
  914|      0|								wflags |= FLAG_SUFFIX_VOWEL;
  915|      0|
  916|      0|							if (end_type & SUFX_M) {
  917|      0|								// allow more suffixes before this suffix
  918|      0|								strcpy(end_phonemes2, end_phonemes);
  919|      0|								end_type = TranslateRules(tr, wordx, phonemes, N_WORD_PHONEMES, end_phonemes, wflags, dictionary_flags);
  920|      0|								strcat(end_phonemes, end_phonemes2); // add the phonemes for the previous suffixes after this one
  921|      0|
  922|      0|								if ((end_type != 0) && !(end_type & SUFX_P)) {
  923|      0|									// there is another suffix
  924|      0|									end_flags = RemoveEnding(tr, wordx, end_type, NULL);
  925|      0|									more_suffixes = true;
  926|      0|								}
  927|      0|							} else {
  928|      0|								// don't remove any previous suffix
  929|      0|								TranslateRules(tr, wordx, phonemes, N_WORD_PHONEMES, NULL, wflags, dictionary_flags);
  930|      0|								end_type = 0;
  931|      0|							}
  932|      0|
  933|      0|							if (phonemes[0] == phonSWITCH) {
  934|      0|								// change to another language in order to translate this word
  935|      0|								strcpy(word_phonemes, phonemes);
  936|      0|								memcpy(wordx, word_copy, strlen(word_copy));
  937|      0|								wordx[-1] = c_temp;
  938|      0|								return 0;
  939|      0|							}
  940|      0|						}
  941|      0|					}
  942|      0|				}
  943|      0|
  944|      0|
  945|      0|				if ((end_type1 & SUFX_T) == 0) {
  946|      0|					// the default is to add the suffix and then determine the word's stress pattern
  947|      0|					AppendPhonemes(tr, phonemes, N_WORD_PHONEMES, end_phonemes);
  948|      0|					end_phonemes[0] = 0;
  949|      0|				}
  950|      0|				memcpy(wordx, word_copy, strlen(word_copy));
  951|      0|			}
  952|      0|
  953|      0|			wordx[-1] = c_temp;
  954|      0|		}
  955|      0|	}
  956|      0|
  957|      0|	addPluralSuffixes(wflags, tr, last_char, word_phonemes);
  958|      0|	wflags |= emphasize_allcaps;
  959|      0|
  960|      0|	// determine stress pattern for this word
  961|      0|
  962|      0|	add_suffix_phonemes = 0;
  963|      0|	if (end_phonemes[0] != 0)
  964|      0|		add_suffix_phonemes = 2;
  965|      0|
  966|      0|	prefix_stress = 0;
  967|      0|	for (p = prefix_phonemes; *p != 0; p++) {
  968|      0|		if ((*p == phonSTRESS_P) || (*p == phonSTRESS_P2))
  969|      0|			prefix_stress = *p;
  970|      0|	}
  971|      0|	if (prefix_flags || (prefix_stress != 0)) {
  972|      0|		if ((tr->langopts.param[LOPT_PREFIXES]) || (prefix_type & SUFX_T)) {
  973|      0|			char *p;
  974|      0|			// German, keep a secondary stress on the stem
  975|      0|			SetWordStress(tr, phonemes, dictionary_flags, 3, 0);
  976|      0|
  977|      0|			// reduce all but the first primary stress
  978|      0|			ix = 0;
  979|      0|			for (p = prefix_phonemes; *p != 0; p++) {
  980|      0|				if (*p == phonSTRESS_P) {
  981|      0|					if (ix == 0)
  982|      0|						ix = 1;
  983|      0|					else
  984|      0|						*p = phonSTRESS_3;
  985|      0|				}
  986|      0|			}
  987|      0|			snprintf(word_phonemes, sizeof(word_phonemes), "%s%s%s", unpron_phonemes, prefix_phonemes, phonemes);
  988|      0|			word_phonemes[N_WORD_PHONEMES-1] = 0;
  989|      0|			SetWordStress(tr, word_phonemes, dictionary_flags, -1, 0);
  990|      0|		} else {
  991|      0|			// stress position affects the whole word, including prefix
  992|      0|			snprintf(word_phonemes, sizeof(word_phonemes), "%s%s%s", unpron_phonemes, prefix_phonemes, phonemes);
  993|      0|			word_phonemes[N_WORD_PHONEMES-1] = 0;
  994|      0|			SetWordStress(tr, word_phonemes, dictionary_flags, -1, 0);
  995|      0|		}
  996|      0|	} else {
  997|      0|		SetWordStress(tr, phonemes, dictionary_flags, -1, add_suffix_phonemes);
  998|      0|		snprintf(word_phonemes, sizeof(word_phonemes), "%s%s%s", unpron_phonemes, prefix_phonemes, phonemes);
  999|      0|		word_phonemes[N_WORD_PHONEMES-1] = 0;
 1000|      0|	}
 1001|      0|
 1002|      0|	if (end_phonemes[0] != 0) {
 1003|      0|		// a suffix had the SUFX_T option set, add the suffix after the stress pattern has been determined
 1004|      0|		ix = strlen(word_phonemes);
 1005|      0|		end_phonemes[N_WORD_PHONEMES-1-ix] = 0; // ensure no buffer overflow
 1006|      0|		strcpy(&word_phonemes[ix], end_phonemes);
 1007|      0|	}
 1008|      0|
 1009|      0|	if (wflags & FLAG_LAST_WORD) {
 1010|      0|		// don't use $brk pause before the last word of a sentence
 1011|      0|		// (but allow it for emphasis, see below
 1012|      0|		dictionary_flags[0] &= ~FLAG_PAUSE1;
 1013|      0|	}
 1014|      0|
 1015|      0|	if ((wflags & FLAG_HYPHEN) && (tr->langopts.stress_flags & S_HYPEN_UNSTRESS))
 1016|      0|		ChangeWordStress(tr, word_phonemes, 3);
 1017|      0|	else if (wflags & FLAG_EMPHASIZED2) {
 1018|      0|		// A word is indicated in the source text as stressed
 1019|      0|		// Give it stress level 6 (for the intonation module)
 1020|      0|		ChangeWordStress(tr, word_phonemes, 6);
 1021|      0|
 1022|      0|		if (wflags & FLAG_EMPHASIZED)
 1023|      0|			dictionary_flags[0] |= FLAG_PAUSE1; // precede by short pause
 1024|      0|	} else if (wtab[dictionary_skipwords].flags & FLAG_LAST_WORD) {
 1025|      0|		// the word has attribute to stress or unstress when at end of clause
 1026|      0|		if (dictionary_flags[0] & (FLAG_STRESS_END | FLAG_STRESS_END2))
 1027|      0|			ChangeWordStress(tr, word_phonemes, 4);
 1028|      0|		else if ((dictionary_flags[0] & FLAG_UNSTRESS_END) && (any_stressed_words))
 1029|      0|			ChangeWordStress(tr, word_phonemes, 3);
 1030|      0|	}
 1031|      0|
 1032|      0|	// dictionary flags for this word give a clue about which alternative pronunciations of
 1033|      0|	// following words to use.
 1034|      0|	if (end_type1 & SUFX_F) {
 1035|      0|		// expect a verb form, with or without -s suffix
 1036|      0|		tr->expect_verb = 2;
 1037|      0|		tr->expect_verb_s = 2;
 1038|      0|	}
 1039|      0|
 1040|      0|	if (dictionary_flags[1] & FLAG_PASTF) {
 1041|      0|		// expect perfect tense in next two words
 1042|      0|		tr->expect_past = 3;
 1043|      0|		tr->expect_verb = 0;
 1044|      0|		tr->expect_noun = 0;
 1045|      0|	} else if (dictionary_flags[1] & FLAG_VERBF) {
 1046|      0|		// expect a verb in the next word
 1047|      0|		tr->expect_verb = 2;
 1048|      0|		tr->expect_verb_s = 0; // verb won't have -s suffix
 1049|      0|		tr->expect_noun = 0;
 1050|      0|	} else if (dictionary_flags[1] & FLAG_VERBSF) {
 1051|      0|		// expect a verb, must have a -s suffix
 1052|      0|		tr->expect_verb = 0;
 1053|      0|		tr->expect_verb_s = 2;
 1054|      0|		tr->expect_past = 0;
 1055|      0|		tr->expect_noun = 0;
 1056|      0|	} else if (dictionary_flags[1] & FLAG_NOUNF) {
 1057|      0|		// not expecting a verb next
 1058|      0|		tr->expect_noun = 2;
 1059|      0|		tr->expect_verb = 0;
 1060|      0|		tr->expect_verb_s = 0;
 1061|      0|		tr->expect_past = 0;
 1062|      0|	}
 1063|      0|
 1064|      0|	if ((wordx[0] != 0) && (!(dictionary_flags[1] & FLAG_VERB_EXT))) {
 1065|      0|		if (tr->expect_verb > 0)
 1066|      0|			tr->expect_verb--;
 1067|      0|
 1068|      0|		if (tr->expect_verb_s > 0)
 1069|      0|			tr->expect_verb_s--;
 1070|      0|
 1071|      0|		if (tr->expect_noun > 0)
 1072|      0|			tr->expect_noun--;
 1073|      0|
 1074|      0|		if (tr->expect_past > 0)
 1075|      0|			tr->expect_past--;
 1076|      0|	}
 1077|      0|
 1078|      0|	if ((word_length == 1) && (tr->translator_name == L('e', 'n')) && iswalpha(first_char) && (first_char != 'i')) {
 1079|      0|		// English Specific !!!!
 1080|      0|		// any single letter before a dot is an abbreviation, except 'I'
 1081|      0|		dictionary_flags[0] |= FLAG_ALLOW_DOT;
 1082|      0|	}
 1083|      0|
 1084|      0|	if ((tr->langopts.param[LOPT_ALT] & 2) && ((dictionary_flags[0] & (FLAG_ALT_TRANS | FLAG_ALT2_TRANS)) != 0))
 1085|      0|		ApplySpecialAttribute2(tr, word_phonemes, dictionary_flags[0]);
 1086|      0|
 1087|      0|	dictionary_flags[0] |= was_unpronouncable;
 1088|      0|	memcpy(word_start, word_copy2, word_copy_length);
 1089|      0|	return dictionary_flags[0];
 1090|      0|}
 1091|       |
 1092|       |
 1093|       |int TranslateWord(Translator *tr, char *word_start, WORD_TAB *wtab, char *word_out)
 1094|      0|{
 1095|      0|	char words_phonemes[N_WORD_PHONEMES]; // a word translated into phoneme codes
 1096|      0|	char *phonemes = words_phonemes;
 1097|      0|	int available = N_WORD_PHONEMES;
 1098|      0|	bool first_word = true;
 1099|      0|
 1100|      0|	int flags = TranslateWord3(tr, word_start, wtab, word_out);
 1101|      0|	if (flags & FLAG_TEXTMODE && word_out) {
 1102|      0|		// Ensure that start of word rules match with the replaced text,
 1103|      0|		// so that emoji and other characters are pronounced correctly.
 1104|      0|		char word[N_WORD_BYTES+1];
 1105|      0|		word[0] = 0;
 1106|      0|		word[1] = ' ';
 1107|      0|		strcpy(word+2, word_out);
 1108|      0|		word_out = word+2;
 1109|      0|
 1110|      0|		while (*word_out && available > 1) {
 1111|      0|			int c;
 1112|      0|			utf8_in(&c, word_out);
 1113|      0|			if (iswupper(c)) {
 1114|      0|				wtab->flags |= FLAG_FIRST_UPPER;
 1115|      0|				utf8_out(tolower(c), word_out);
 1116|      0|			} else {
 1117|      0|				wtab->flags &= ~FLAG_FIRST_UPPER;
 1118|      0|			}
 1119|      0|
 1120|      0|			TranslateWord3(tr, word_out, wtab, NULL);
 1121|      0|
 1122|      0|			int n;
 1123|      0|			if (first_word) {
 1124|      0|				n = snprintf(phonemes, available, "%s", word_phonemes);
 1125|      0|				first_word = false;
 1126|      0|			} else {
 1127|      0|				n = snprintf(phonemes, available, "%c%s", phonEND_WORD, word_phonemes);
 1128|      0|			}
 1129|      0|
 1130|      0|			available -= n;
 1131|      0|			phonemes += n;
 1132|      0|
 1133|      0|			// skip to the next word in a multi-word replacement. Always skip at least one word.
 1134|      0|			for (dictionary_skipwords++; dictionary_skipwords > 0; dictionary_skipwords--) {
 1135|      0|				while (!isspace(*word_out)) ++word_out;
 1136|      0|				while (isspace(*word_out))  ++word_out;
 1137|      0|			}
 1138|      0|		}
 1139|      0|
 1140|      0|		// If the list file contains a text replacement to another
 1141|      0|		// entry in the list file, e.g.:
 1142|      0|		//     ripost     riposte $text
 1143|      0|		//     riposte    rI#p0st
 1144|      0|		// calling it from a prefix or suffix rule such as 'riposted'
 1145|      0|		// causes word_out[0] to be NULL, as TranslateWord3 has the
 1146|      0|		// information needed to perform the mapping. In this case,
 1147|      0|		// no phonemes have been written in this loop and the phonemes
 1148|      0|		// have been calculated, so don't override them.
 1149|      0|		if (phonemes != words_phonemes) {
 1150|      0|			snprintf(word_phonemes, sizeof(word_phonemes), "%s", words_phonemes);
 1151|      0|		}
 1152|      0|	}
 1153|      0|	return flags;
 1154|      0|}
 1155|       |
 1156|       |static void SetPlist2(PHONEME_LIST2 *p, unsigned char phcode)
 1157|      0|{
 1158|      0|	p->phcode = phcode;
 1159|      0|	p->stresslevel = 0;
 1160|      0|	p->tone_ph = 0;
 1161|      0|	p->synthflags = embedded_flag;
 1162|      0|	p->sourceix = 0;
 1163|      0|	embedded_flag = 0;
 1164|      0|}
 1165|       |
 1166|       |static int CountSyllables(unsigned char *phonemes)
 1167|      0|{
 1168|      0|	int count = 0;
 1169|      0|	int phon;
 1170|      0|	while ((phon = *phonemes++) != 0) {
 1171|      0|		if (phoneme_tab[phon]->type == phVOWEL)
 1172|      0|			count++;
 1173|      0|	}
 1174|      0|	return count;
 1175|      0|}
 1176|       |
 1177|       |static void Word_EmbeddedCmd()
 1178|      0|{
 1179|      0|	// Process embedded commands for emphasis, sayas, and break
 1180|      0|	int embedded_cmd;
 1181|      0|	int value;
 1182|      0|
 1183|      0|	do {
 1184|      0|		embedded_cmd = embedded_list[embedded_read++];
 1185|      0|		value = embedded_cmd >> 8;
 1186|      0|
 1187|      0|		switch (embedded_cmd & 0x1f)
 1188|      0|		{
 1189|      0|		case EMBED_Y:
 1190|      0|			option_sayas = value;
 1191|      0|			break;
 1192|      0|
 1193|      0|		case EMBED_F:
 1194|      0|			option_emphasis = value;
 1195|      0|			break;
 1196|      0|
 1197|      0|		case EMBED_B:
 1198|      0|			// break command
 1199|      0|			if (value == 0)
 1200|      0|				pre_pause = 0; // break=none
 1201|      0|			else
 1202|      0|				pre_pause += value;
 1203|      0|			break;
 1204|      0|		}
 1205|      0|	} while (((embedded_cmd & 0x80) == 0) && (embedded_read < embedded_ix));
 1206|      0|}
 1207|       |
 1208|       |int SetTranslator2(const char *new_language)
 1209|      0|{
 1210|      0|	// Set translator2 to a second language
 1211|      0|	int new_phoneme_tab;
 1212|      0|
 1213|      0|	if ((new_phoneme_tab = SelectPhonemeTableName(new_language)) >= 0) {
 1214|      0|		if ((translator2 != NULL) && (strcmp(new_language, translator2_language) != 0)) {
 1215|      0|			// we already have an alternative translator, but not for the required language, delete it
 1216|      0|			DeleteTranslator(translator2);
 1217|      0|			translator2 = NULL;
 1218|      0|		}
 1219|      0|
 1220|      0|		if (translator2 == NULL) {
 1221|      0|			translator2 = SelectTranslator(new_language);
 1222|      0|			strcpy(translator2_language, new_language);
 1223|      0|
 1224|      0|			if (LoadDictionary(translator2, translator2->dictionary_name, 0) != 0) {
 1225|      0|				SelectPhonemeTable(voice->phoneme_tab_ix); // revert to original phoneme table
 1226|      0|				new_phoneme_tab = -1;
 1227|      0|				translator2_language[0] = 0;
 1228|      0|			}
 1229|      0|			translator2->phoneme_tab_ix = new_phoneme_tab;
 1230|      0|		}
 1231|      0|	}
 1232|      0|	if (translator2 != NULL)
 1233|      0|		translator2->phonemes_repeat[0] = 0;
 1234|      0|	return new_phoneme_tab;
 1235|      0|}
 1236|       |
 1237|       |static int TranslateWord2(Translator *tr, char *word, WORD_TAB *wtab, int pre_pause)
 1238|      0|{
 1239|      0|	int flags = 0;
 1240|      0|	int stress;
 1241|      0|	int next_stress;
 1242|      0|	int next_tone = 0;
 1243|      0|	unsigned char *p;
 1244|      0|	int srcix;
 1245|      0|	int found_dict_flag;
 1246|      0|	unsigned char ph_code;
 1247|      0|	PHONEME_LIST2 *plist2;
 1248|      0|	PHONEME_TAB *ph;
 1249|      0|	int max_stress;
 1250|      0|	int max_stress_ix = 0;
 1251|      0|	int prev_vowel = -1;
 1252|      0|	int pitch_raised = 0;
 1253|      0|	int switch_phonemes = -1;
 1254|      0|	bool first_phoneme = true;
 1255|      0|	int source_ix;
 1256|      0|	int len;
 1257|      0|	int ix;
 1258|      0|	int sylimit; // max. number of syllables in a word to be combined with a preceding preposition
 1259|      0|	const char *new_language;
 1260|      0|	int bad_phoneme;
 1261|      0|	int word_flags;
 1262|      0|	int word_copy_len;
 1263|      0|	char word_copy[N_WORD_BYTES+1];
 1264|      0|	char word_replaced[N_WORD_BYTES+1];
 1265|      0|	char old_dictionary_name[40];
 1266|      0|
 1267|      0|	len = wtab->length;
 1268|      0|	if (len > 31) len = 31;
 1269|      0|	source_ix = (wtab->sourceix & 0x7ff) | (len << 11); // bits 0-10 sourceix, bits 11-15 word length
 1270|      0|
 1271|      0|	word_flags = wtab[0].flags;
 1272|      0|	if (word_flags & FLAG_EMBEDDED) {
 1273|      0|		wtab[0].flags &= ~FLAG_EMBEDDED; // clear it in case we call TranslateWord2() again for the same word
 1274|      0|		embedded_flag = SFLAG_EMBEDDED;
 1275|      0|
 1276|      0|		Word_EmbeddedCmd();
 1277|      0|	}
 1278|      0|
 1279|      0|	if ((word[0] == 0) || (word_flags & FLAG_DELETE_WORD)) {
 1280|      0|		// nothing to translate.  Add a dummy phoneme to carry any embedded commands
 1281|      0|		if (embedded_flag) {
 1282|      0|			ph_list2[n_ph_list2].phcode = phonEND_WORD;
 1283|      0|			ph_list2[n_ph_list2].stresslevel = 0;
 1284|      0|			ph_list2[n_ph_list2].wordstress = 0;
 1285|      0|			ph_list2[n_ph_list2].tone_ph = 0;
 1286|      0|			ph_list2[n_ph_list2].synthflags = embedded_flag;
 1287|      0|			ph_list2[n_ph_list2].sourceix = 0;
 1288|      0|			n_ph_list2++;
 1289|      0|			embedded_flag = 0;
 1290|      0|		}
 1291|      0|		word_phonemes[0] = 0;
 1292|      0|		return 0;
 1293|      0|	}
 1294|      0|
 1295|      0|	// after a $pause word attribute, ignore a $pause attribute on the next two words
 1296|      0|	if (tr->prepause_timeout > 0)
 1297|      0|		tr->prepause_timeout--;
 1298|      0|
 1299|      0|	if ((option_sayas & 0xf0) == 0x10) {
 1300|      0|		if (!(word_flags & FLAG_FIRST_WORD)) {
 1301|      0|			// SAYAS_CHARS, SAYAS_GLYPHS, or SAYAS_SINGLECHARS.  Pause between each word.
 1302|      0|			pre_pause += 4;
 1303|      0|		}
 1304|      0|	}
 1305|      0|
 1306|      0|	if (word_flags & FLAG_FIRST_UPPER) {
 1307|      0|		if ((option_capitals > 2) && (embedded_ix < N_EMBEDDED_LIST-6)) {
 1308|      0|			// indicate capital letter by raising pitch
 1309|      0|			if (embedded_flag)
 1310|      0|				embedded_list[embedded_ix-1] &= ~0x80; // already embedded command before this word, remove terminator
 1311|      0|			if ((pitch_raised = option_capitals) == 3)
 1312|      0|				pitch_raised = 20; // default pitch raise for capitals
 1313|      0|			embedded_list[embedded_ix++] = EMBED_P+0x40+0x80 + (pitch_raised << 8); // raise pitch
 1314|      0|			embedded_flag = SFLAG_EMBEDDED;
 1315|      0|		}
 1316|      0|	}
 1317|      0|
 1318|      0|	p = (unsigned char *)word_phonemes;
 1319|      0|	if (word_flags & FLAG_PHONEMES) {
 1320|      0|		// The input is in phoneme mnemonics, not language text
 1321|      0|		int c1;
 1322|      0|		char lang_name[12];
 1323|      0|
 1324|      0|		if (memcmp(word, "_^_", 3) == 0) {
 1325|      0|			// switch languages
 1326|      0|			word += 3;
 1327|      0|			for (ix = 0;;) {
 1328|      0|				c1 = *word++;
 1329|      0|				if ((c1 == ' ') || (c1 == 0))
 1330|      0|					break;
 1331|      0|				lang_name[ix++] = tolower(c1);
 1332|      0|			}
 1333|      0|			lang_name[ix] = 0;
 1334|      0|
 1335|      0|			if ((ix = LookupPhonemeTable(lang_name)) > 0) {
 1336|      0|				SelectPhonemeTable(ix);
 1337|      0|				word_phonemes[0] = phonSWITCH;
 1338|      0|				word_phonemes[1] = ix;
 1339|      0|				word_phonemes[2] = 0;
 1340|      0|			}
 1341|      0|		} else
 1342|      0|			EncodePhonemes(word, word_phonemes, &bad_phoneme);
 1343|      0|		flags = FLAG_FOUND;
 1344|      0|	} else {
 1345|      0|		int c2;
 1346|      0|		ix = 0;
 1347|      0|		while (((c2 = word_copy[ix] = word[ix]) != ' ') && (c2 != 0) && (ix < N_WORD_BYTES)) ix++;
 1348|      0|		word_copy_len = ix;
 1349|      0|
 1350|      0|		word_replaced[2] = 0;
 1351|      0|		flags = TranslateWord(translator, word, wtab, &word_replaced[2]);
 1352|      0|
 1353|      0|		if (flags & FLAG_SPELLWORD) {
 1354|      0|			// re-translate the word as individual letters, separated by spaces
 1355|      0|			memcpy(word, word_copy, word_copy_len);
 1356|      0|			return flags;
 1357|      0|		}
 1358|      0|
 1359|      0|		if ((flags & FLAG_COMBINE) && !(wtab[1].flags & FLAG_PHONEMES)) {
 1360|      0|			char *p2;
 1361|      0|			bool ok = true;
 1362|      0|			unsigned int flags2[2];
 1363|      0|			int c_word2;
 1364|      0|			char ph_buf[N_WORD_PHONEMES];
 1365|      0|
 1366|      0|			flags2[0] = 0;
 1367|      0|			sylimit = tr->langopts.param[LOPT_COMBINE_WORDS];
 1368|      0|
 1369|      0|			// LANG=cs,sk
 1370|      0|			// combine a preposition with the following word
 1371|      0|			p2 = word;
 1372|      0|			while (*p2 != ' ') p2++;
 1373|      0|
 1374|      0|			utf8_in(&c_word2, p2+1); // first character of the next word;
 1375|      0|			if (!iswalpha(c_word2))
 1376|      0|				ok = false;
 1377|      0|
 1378|      0|			if (ok == true) {
 1379|      0|				strcpy(ph_buf, word_phonemes);
 1380|      0|
 1381|      0|				flags2[0] = TranslateWord(translator, p2+1, wtab+1, NULL);
 1382|      0|				if ((flags2[0] & FLAG_WAS_UNPRONOUNCABLE) || (word_phonemes[0] == phonSWITCH))
 1383|      0|					ok = false;
 1384|      0|
 1385|      0|				if (sylimit & 0x100) {
 1386|      0|					// only if the second word has $alt attribute
 1387|      0|					if ((flags2[0] & FLAG_ALT_TRANS) == 0)
 1388|      0|						ok = false;
 1389|      0|				}
 1390|      0|
 1391|      0|				if ((sylimit & 0x200) && ((wtab+1)->flags & FLAG_LAST_WORD)) {
 1392|      0|					// not if the next word is end-of-sentence
 1393|      0|					ok = false;
 1394|      0|				}
 1395|      0|
 1396|      0|				if (ok == false)
 1397|      0|					strcpy(word_phonemes, ph_buf);
 1398|      0|			}
 1399|      0|
 1400|      0|			if (ok) {
 1401|      0|				*p2 = '-'; // replace next space by hyphen
 1402|      0|				wtab[0].flags &= ~FLAG_ALL_UPPER; // prevent it being considered an abbreviation
 1403|      0|				flags = TranslateWord(translator, word, wtab, NULL); // translate the combined word
 1404|      0|				if ((sylimit > 0) && (CountSyllables(p) > (sylimit & 0x1f))) {
 1405|      0|					// revert to separate words
 1406|      0|					*p2 = ' ';
 1407|      0|					flags = TranslateWord(translator, word, wtab, NULL);
 1408|      0|				} else {
 1409|      0|					if (flags == 0)
 1410|      0|						flags = flags2[0]; // no flags for the combined word, so use flags from the second word eg. lang-hu "nem december 7-e"
 1411|      0|					flags |= FLAG_SKIPWORDS;
 1412|      0|					dictionary_skipwords = 1;
 1413|      0|				}
 1414|      0|			}
 1415|      0|		}
 1416|      0|
 1417|      0|		if (p[0] == phonSWITCH) {
 1418|      0|			int switch_attempt;
 1419|      0|			strcpy(old_dictionary_name, dictionary_name);
 1420|      0|			for (switch_attempt = 0; switch_attempt < 2; switch_attempt++) {
 1421|      0|				// this word uses a different language
 1422|      0|				memcpy(word, word_copy, word_copy_len);
 1423|      0|
 1424|      0|				new_language = (char *)(&p[1]);
 1425|      0|				if (new_language[0] == 0)
 1426|      0|					new_language = ESPEAKNG_DEFAULT_VOICE;
 1427|      0|
 1428|      0|				switch_phonemes = SetTranslator2(new_language);
 1429|      0|
 1430|      0|				if (switch_phonemes >= 0) {
 1431|      0|					// re-translate the word using the new translator
 1432|      0|					wtab[0].flags |= FLAG_TRANSLATOR2;
 1433|      0|					if (word_replaced[2] != 0) {
 1434|      0|						word_replaced[0] = 0; // byte before the start of the word
 1435|      0|						word_replaced[1] = ' ';
 1436|      0|						flags = TranslateWord(translator2, &word_replaced[1], wtab, NULL);
 1437|      0|					} else
 1438|      0|						flags = TranslateWord(translator2, word, wtab, &word_replaced[2]);
 1439|      0|				}
 1440|      0|
 1441|      0|				if (p[0] != phonSWITCH)
 1442|      0|					break;
 1443|      0|			}
 1444|      0|
 1445|      0|			if (p[0] == phonSWITCH)
 1446|      0|				return FLAG_SPELLWORD;
 1447|      0|
 1448|      0|			if (switch_phonemes < 0) {
 1449|      0|				// language code is not recognised or 2nd translator won't translate it
 1450|      0|				p[0] = phonSCHWA; // just say something
 1451|      0|				p[1] = phonSCHWA;
 1452|      0|				p[2] = 0;
 1453|      0|			}
 1454|      0|
 1455|      0|			if (switch_phonemes == -1) {
 1456|      0|				strcpy(dictionary_name, old_dictionary_name);
 1457|      0|				SelectPhonemeTable(voice->phoneme_tab_ix);
 1458|      0|
 1459|      0|				// leave switch_phonemes set, but use the original phoneme table number.
 1460|      0|				// This will suppress LOPT_REGRESSIVE_VOICING
 1461|      0|				switch_phonemes = voice->phoneme_tab_ix; // original phoneme table
 1462|      0|			}
 1463|      0|		}
 1464|      0|
 1465|      0|		if (!(word_flags & FLAG_HYPHEN)) {
 1466|      0|			if (flags & FLAG_PAUSE1) {
 1467|      0|				if (pre_pause < 1)
 1468|      0|					pre_pause = 1;
 1469|      0|			}
 1470|      0|			if ((flags & FLAG_PREPAUSE) && !(word_flags & (FLAG_LAST_WORD | FLAG_FIRST_WORD)) && !(wtab[-1].flags & FLAG_FIRST_WORD) && (tr->prepause_timeout == 0)) {
 1471|      0|				// the word is marked in the dictionary list with $pause
 1472|      0|				if (pre_pause < 4) pre_pause = 4;
 1473|      0|				tr->prepause_timeout = 3;
 1474|      0|			}
 1475|      0|		}
 1476|      0|
 1477|      0|		if ((option_emphasis >= 3) && (pre_pause < 1))
 1478|      0|			pre_pause = 1;
 1479|      0|	}
 1480|      0|
 1481|      0|	stress = 0;
 1482|      0|	next_stress = 1;
 1483|      0|	srcix = 0;
 1484|      0|	max_stress = -1;
 1485|      0|
 1486|      0|	found_dict_flag = 0;
 1487|      0|	if ((flags & FLAG_FOUND) && !(flags & FLAG_TEXTMODE))
 1488|      0|		found_dict_flag = SFLAG_DICTIONARY;
 1489|      0|
 1490|      0|	while ((pre_pause > 0) && (n_ph_list2 < N_PHONEME_LIST-4)) {
 1491|      0|		// add pause phonemes here. Either because of punctuation (brackets or quotes) in the
 1492|      0|		// text, or because the word is marked in the dictionary lookup as a conjunction
 1493|      0|		if (pre_pause > 1) {
 1494|      0|			SetPlist2(&ph_list2[n_ph_list2++], phonPAUSE);
 1495|      0|			pre_pause -= 2;
 1496|      0|		} else {
 1497|      0|			SetPlist2(&ph_list2[n_ph_list2++], phonPAUSE_NOLINK);
 1498|      0|			pre_pause--;
 1499|      0|		}
 1500|      0|		tr->end_stressed_vowel = 0; // forget about the previous word
 1501|      0|		tr->prev_dict_flags[0] = 0;
 1502|      0|		tr->prev_dict_flags[1] = 0;
 1503|      0|	}
 1504|      0|	plist2 = &ph_list2[n_ph_list2];
 1505|      0|
 1506|      0|	if ((option_capitals == 1) && (word_flags & FLAG_FIRST_UPPER)) {
 1507|      0|		SetPlist2(&ph_list2[n_ph_list2++], phonPAUSE_SHORT);
 1508|      0|		SetPlist2(&ph_list2[n_ph_list2++], phonCAPITAL);
 1509|      0|		if ((word_flags & FLAG_ALL_UPPER) && IsAlpha(word[1])) {
 1510|      0|			// word > 1 letter and all capitals
 1511|      0|			SetPlist2(&ph_list2[n_ph_list2++], phonPAUSE_SHORT);
 1512|      0|			SetPlist2(&ph_list2[n_ph_list2++], phonCAPITAL);
 1513|      0|		}
 1514|      0|	}
 1515|      0|
 1516|      0|	if (switch_phonemes >= 0) {
 1517|      0|		if ((p[0] == phonPAUSE) && (p[1] == phonSWITCH)) {
 1518|      0|			// the new word starts with a phoneme table switch, so there's no need to switch before it.
 1519|      0|			if (ph_list2[n_ph_list2-1].phcode == phonSWITCH) {
 1520|      0|				// previous phoneme is also a phonSWITCH, delete it
 1521|      0|				n_ph_list2--;
 1522|      0|			}
 1523|      0|		} else {
 1524|      0|			// this word uses a different phoneme table
 1525|      0|			if (ph_list2[n_ph_list2-1].phcode == phonSWITCH) {
 1526|      0|				// previous phoneme is also a phonSWITCH, just change its phoneme table number
 1527|      0|				n_ph_list2--;
 1528|      0|			} else
 1529|      0|				SetPlist2(&ph_list2[n_ph_list2], phonSWITCH);
 1530|      0|			ph_list2[n_ph_list2++].tone_ph = switch_phonemes; // temporary phoneme table number
 1531|      0|		}
 1532|      0|	}
 1533|      0|
 1534|      0|	// remove initial pause from a word if it follows a hyphen
 1535|      0|	if ((word_flags & FLAG_HYPHEN) && (phoneme_tab[*p]->type == phPAUSE))
 1536|      0|		p++;
 1537|      0|
 1538|      0|	if ((p[0] == 0) && (embedded_flag)) {
 1539|      0|		// no phonemes.  Insert a very short pause to carry an embedded command
 1540|      0|		p[0] = phonPAUSE_VSHORT;
 1541|      0|		p[1] = 0;
 1542|      0|	}
 1543|      0|
 1544|      0|	while (((ph_code = *p++) != 0) && (n_ph_list2 < N_PHONEME_LIST-4)) {
 1545|      0|		if (ph_code == 255)
 1546|      0|			continue; // unknown phoneme
 1547|      0|
 1548|      0|		// Add the phonemes to the first stage phoneme list (ph_list2)
 1549|      0|		ph = phoneme_tab[ph_code];
 1550|      0|		if (ph == NULL) {
 1551|      0|			printf("Invalid phoneme code %d\n", ph_code);
 1552|      0|			continue;
 1553|      0|		}
 1554|      0|
 1555|      0|		if (ph_code == phonSWITCH) {
 1556|      0|			ph_list2[n_ph_list2].phcode = ph_code;
 1557|      0|			ph_list2[n_ph_list2].sourceix = 0;
 1558|      0|			ph_list2[n_ph_list2].synthflags = 0;
 1559|      0|			ph_list2[n_ph_list2++].tone_ph = *p;
 1560|      0|			SelectPhonemeTable(*p);
 1561|      0|			p++;
 1562|      0|		} else if (ph->type == phSTRESS) {
 1563|      0|			// don't add stress phonemes codes to the list, but give their stress
 1564|      0|			// value to the next vowel phoneme
 1565|      0|			// std_length is used to hold stress number or (if >10) a tone number for a tone language
 1566|      0|			if (ph->program == 0)
 1567|      0|				next_stress = ph->std_length;
 1568|      0|			else {
 1569|      0|				// for tone languages, the tone number for a syllable follows the vowel
 1570|      0|				if (prev_vowel >= 0)
 1571|      0|					ph_list2[prev_vowel].tone_ph = ph_code;
 1572|      0|				else
 1573|      0|					next_tone = ph_code; // no previous vowel, apply to the next vowel
 1574|      0|			}
 1575|      0|		} else if (ph_code == phonSYLLABIC) {
 1576|      0|			// mark the previous phoneme as a syllabic consonant
 1577|      0|			prev_vowel = n_ph_list2-1;
 1578|      0|			ph_list2[prev_vowel].synthflags |= SFLAG_SYLLABLE;
 1579|      0|			ph_list2[prev_vowel].stresslevel = next_stress;
 1580|      0|		} else if (ph_code == phonLENGTHEN)
 1581|      0|			ph_list2[n_ph_list2-1].synthflags |= SFLAG_LENGTHEN;
 1582|      0|		else if (ph_code == phonEND_WORD) {
 1583|      0|			// a || symbol in a phoneme string was used to indicate a word boundary
 1584|      0|			// Don't add this phoneme to the list, but make sure the next phoneme has
 1585|      0|			// a newword indication
 1586|      0|			srcix = source_ix+1;
 1587|      0|		} else if (ph_code == phonX1) {
 1588|      0|			// a language specific action
 1589|      0|			if (tr->langopts.param[LOPT_IT_DOUBLING])
 1590|      0|				flags |= FLAG_DOUBLING;
 1591|      0|		} else {
 1592|      0|			ph_list2[n_ph_list2].phcode = ph_code;
 1593|      0|			ph_list2[n_ph_list2].tone_ph = 0;
 1594|      0|			ph_list2[n_ph_list2].synthflags = embedded_flag | found_dict_flag;
 1595|      0|			embedded_flag = 0;
 1596|      0|			ph_list2[n_ph_list2].sourceix = srcix;
 1597|      0|			srcix = 0;
 1598|      0|
 1599|      0|			if (ph->type == phVOWEL) {
 1600|      0|				stress = next_stress;
 1601|      0|				next_stress = 1; // default is 'unstressed'
 1602|      0|
 1603|      0|				if (stress >= 4)
 1604|      0|					any_stressed_words = true;
 1605|      0|
 1606|      0|				if ((prev_vowel >= 0) && (n_ph_list2-1) != prev_vowel)
 1607|      0|					ph_list2[n_ph_list2-1].stresslevel = stress; // set stress for previous consonant
 1608|      0|
 1609|      0|				ph_list2[n_ph_list2].synthflags |= SFLAG_SYLLABLE;
 1610|      0|				prev_vowel = n_ph_list2;
 1611|      0|
 1612|      0|				if (stress > max_stress) {
 1613|      0|					max_stress = stress;
 1614|      0|					max_stress_ix = n_ph_list2;
 1615|      0|				}
 1616|      0|				if (next_tone != 0) {
 1617|      0|					ph_list2[n_ph_list2].tone_ph = next_tone;
 1618|      0|					next_tone = 0;
 1619|      0|				}
 1620|      0|			} else {
 1621|      0|				if (first_phoneme && tr->langopts.param[LOPT_IT_DOUBLING]) {
 1622|      0|					if (((tr->prev_dict_flags[0] & FLAG_DOUBLING) && (tr->langopts.param[LOPT_IT_DOUBLING] & 1)) ||
 1623|      0|					    (tr->end_stressed_vowel && (tr->langopts.param[LOPT_IT_DOUBLING] & 2))) {
 1624|      0|						// italian, double the initial consonant if the previous word ends with a
 1625|      0|						// stressed vowel, or is marked with a flag
 1626|      0|						ph_list2[n_ph_list2].synthflags |= SFLAG_LENGTHEN;
 1627|      0|					}
 1628|      0|				}
 1629|      0|			}
 1630|      0|
 1631|      0|			ph_list2[n_ph_list2].stresslevel = stress;
 1632|      0|			n_ph_list2++;
 1633|      0|			first_phoneme = false;
 1634|      0|		}
 1635|      0|	}
 1636|      0|
 1637|      0|	if (word_flags & FLAG_COMMA_AFTER)
 1638|      0|		SetPlist2(&ph_list2[n_ph_list2++], phonPAUSE_CLAUSE);
 1639|      0|
 1640|      0|	// don't set new-word if there is a hyphen before it
 1641|      0|	if ((word_flags & FLAG_HYPHEN) == 0)
 1642|      0|		plist2->sourceix = source_ix;
 1643|      0|
 1644|      0|	tr->end_stressed_vowel = 0;
 1645|      0|	if ((stress >= 4) && (phoneme_tab[ph_list2[n_ph_list2-1].phcode]->type == phVOWEL))
 1646|      0|		tr->end_stressed_vowel = 1; // word ends with a stressed vowel
 1647|      0|
 1648|      0|	if (switch_phonemes >= 0) {
 1649|      0|		// this word uses a different phoneme table, now switch back
 1650|      0|		strcpy(dictionary_name, old_dictionary_name);
 1651|      0|		SelectPhonemeTable(voice->phoneme_tab_ix);
 1652|      0|		SetPlist2(&ph_list2[n_ph_list2], phonSWITCH);
 1653|      0|		ph_list2[n_ph_list2++].tone_ph = voice->phoneme_tab_ix; // original phoneme table number
 1654|      0|	}
 1655|      0|
 1656|      0|
 1657|      0|	if (pitch_raised > 0) {
 1658|      0|		embedded_list[embedded_ix++] = EMBED_P+0x60+0x80 + (pitch_raised << 8); // lower pitch
 1659|      0|		SetPlist2(&ph_list2[n_ph_list2], phonPAUSE_SHORT);
 1660|      0|		ph_list2[n_ph_list2++].synthflags = SFLAG_EMBEDDED;
 1661|      0|	}
 1662|      0|
 1663|      0|	if (flags & FLAG_STRESS_END2) {
 1664|      0|		// this's word's stress could be increased later
 1665|      0|		ph_list2[max_stress_ix].synthflags |= SFLAG_PROMOTE_STRESS;
 1666|      0|	}
 1667|      0|
 1668|      0|	tr->prev_dict_flags[0] = flags;
 1669|      0|	return flags;
 1670|      0|}
 1671|       |
 1672|       |static int EmbeddedCommand(unsigned int *source_index_out)
 1673|      0|{
 1674|      0|	// An embedded command to change the pitch, volume, etc.
 1675|      0|	// returns number of commands added to embedded_list
 1676|      0|
 1677|      0|	// pitch,speed,amplitude,expression,reverb,tone,voice,sayas
 1678|      0|	const char *commands = "PSARHTIVYMUBF";
 1679|      0|	int value = -1;
 1680|      0|	int sign = 0;
 1681|      0|	unsigned char c;
 1682|      0|	char *p;
 1683|      0|	int cmd;
 1684|      0|	int source_index = *source_index_out;
 1685|      0|
 1686|      0|	c = source[source_index];
 1687|      0|	if (c == '+') {
 1688|      0|		sign = 0x40;
 1689|      0|		source_index++;
 1690|      0|	} else if (c == '-') {
 1691|      0|		sign = 0x60;
 1692|      0|		source_index++;
 1693|      0|	}
 1694|      0|
 1695|      0|	if (IsDigit09(source[source_index])) {
 1696|      0|		value = atoi(&source[source_index]);
 1697|      0|		while (IsDigit09(source[source_index]))
 1698|      0|			source_index++;
 1699|      0|	}
 1700|      0|
 1701|      0|	c = source[source_index++];
 1702|      0|	if (embedded_ix >= (N_EMBEDDED_LIST - 2))
 1703|      0|		return 0; // list is full
 1704|      0|
 1705|      0|	if ((p = strchr_w(commands, c)) == NULL)
 1706|      0|		return 0;
 1707|      0|	cmd = (p - commands)+1;
 1708|      0|	if (value == -1) {
 1709|      0|		value = embedded_default[cmd];
 1710|      0|		sign = 0;
 1711|      0|	}
 1712|      0|
 1713|      0|	if (cmd == EMBED_Y) {
 1714|      0|		option_sayas2 = value;
 1715|      0|		count_sayas_digits = 0;
 1716|      0|	}
 1717|      0|	if (cmd == EMBED_F) {
 1718|      0|		if (value >= 3)
 1719|      0|			word_emphasis = FLAG_EMPHASIZED;
 1720|      0|		else
 1721|      0|			word_emphasis = 0;
 1722|      0|	}
 1723|      0|
 1724|      0|	embedded_list[embedded_ix++] = cmd + sign + (value << 8);
 1725|      0|	*source_index_out = source_index;
 1726|      0|	return 1;
 1727|      0|}
 1728|       |
 1729|       |static const char *FindReplacementChars(Translator *tr, const char **pfrom, unsigned int c, const char *next, int *ignore_next_n)
 1730|      0|{
 1731|      0|	const char *from = *pfrom;
 1732|      0|	while ( !is_str_totally_null(from, 4) ) {
 1733|      0|		unsigned int fc = 0; // from character
 1734|      0|		unsigned int nc = c; // next character
 1735|      0|		const char *match_next = next;
 1736|      0|
 1737|      0|		*pfrom = from;
 1738|      0|
 1739|      0|		from += utf8_in((int *)&fc, from);
 1740|      0|		if (nc == fc) {
 1741|      0|			if (*from == 0) return from + 1;
 1742|      0|
 1743|      0|			bool matched = true;
 1744|      0|			int nmatched = 0;
 1745|      0|			while (*from != 0) {
 1746|      0|				from += utf8_in((int *)&fc, from);
 1747|      0|
 1748|      0|				match_next += utf8_in((int *)&nc, match_next);
 1749|      0|				nc = towlower2(nc, tr);
 1750|      0|
 1751|      0|				if (nc != fc)
 1752|      0|					matched = false;
 1753|      0|				else
 1754|      0|					nmatched++;
 1755|      0|			}
 1756|      0|
 1757|      0|			if (*from == 0 && matched) {
 1758|      0|				*ignore_next_n = nmatched;
 1759|      0|				return from + 1;
 1760|      0|			}
 1761|      0|		}
 1762|      0|
 1763|      0|		// replacement 'from' string (skip the remaining part, if any)
 1764|      0|		while (*from != '\0') from++;
 1765|      0|		from++;
 1766|      0|
 1767|      0|		// replacement 'to' string
 1768|      0|		while (*from != '\0') from++;
 1769|      0|		from++;
 1770|      0|	}
 1771|      0|	return NULL;
 1772|      0|}
 1773|       |
 1774|       |// handle .replace rule in xx_rules file
 1775|       |static int SubstituteChar(Translator *tr, unsigned int c, unsigned int next_in, const char *next, int *insert, int *wordflags)
 1776|      0|{
 1777|      0|	unsigned int new_c, c2 = ' ', c_lower;
 1778|      0|	int upper_case = 0;
 1779|      0|
 1780|      0|	static int ignore_next_n = 0;
 1781|      0|	if (ignore_next_n > 0) {
 1782|      0|		ignore_next_n--;
 1783|      0|		return 8;
 1784|      0|	}
 1785|      0|
 1786|      0|	if (c == 0) return 0;
 1787|      0|
 1788|      0|	const char *from = (const char *)tr->langopts.replace_chars;
 1789|      0|	if (from == NULL)
 1790|      0|		return c;
 1791|      0|
 1792|      0|	// there is a list of character codes to be substituted with alternative codes
 1793|      0|
 1794|      0|	if (iswupper(c_lower = c)) {
 1795|      0|		c_lower = towlower2(c, tr);
 1796|      0|		upper_case = 1;
 1797|      0|	}
 1798|      0|
 1799|      0|	const char *to = FindReplacementChars(tr, &from, c_lower, next, &ignore_next_n);
 1800|      0|	if (to == NULL)
 1801|      0|		return c; // no substitution
 1802|      0|
 1803|      0|	if (option_phonemes & espeakPHONEMES_TRACE)
 1804|      0|		fprintf(f_trans, "Replace: %s > %s\n", from, to);
 1805|      0|
 1806|      0|	to += utf8_in((int *)&new_c, to);
 1807|      0|	if (*to != 0) {
 1808|      0|		// there is a second character to be inserted
 1809|      0|		// don't convert the case of the second character unless the next letter is also upper case
 1810|      0|		to += utf8_in((int *)&c2, to);
 1811|      0|		if (upper_case && iswupper(next_in))
 1812|      0|			c2 = ucd_toupper(c2);
 1813|      0|		*insert = c2;
 1814|      0|	}
 1815|      0|
 1816|      0|	if (upper_case)
 1817|      0|		new_c = ucd_toupper(new_c);
 1818|      0|
 1819|      0|	*wordflags |= FLAG_CHAR_REPLACED;
 1820|      0|	return new_c;
 1821|      0|}
 1822|       |
 1823|       |static int TranslateChar(Translator *tr, char *ptr, int prev_in, unsigned int c, unsigned int next_in, int *insert, int *wordflags)
 1824|      0|{
 1825|      0|	// To allow language specific examination and replacement of characters
 1826|      0|
 1827|      0|	int code;
 1828|      0|	int initial;
 1829|      0|	int medial;
 1830|      0|	int final;
 1831|      0|	int next2;
 1832|      0|
 1833|      0|	static const unsigned char hangul_compatibility[0x34] = {
 1834|      0|		0,  0x00, 0x01, 0xaa, 0x02, 0xac, 0xad, 0x03,
 1835|      0|		0x04, 0x05, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb4,
 1836|      0|		0xb6, 0x06, 0x07, 0x08, 0xb9, 0x09, 0x0a, 0xbc,
 1837|      0|		0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x61,
 1838|      0|		0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
 1839|      0|		0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71,
 1840|      0|		0x72, 0x73, 0x74, 0x75
 1841|      0|	};
 1842|      0|
 1843|      0|	// check for Korean Hangul letters
 1844|      0|	if (((code = c - 0xac00) >= 0) && (c <= 0xd7af)) {
 1845|      0|		// break a syllable hangul into 2 or 3 individual jamo
 1846|      0|		initial = (code/28)/21;
 1847|      0|		medial = (code/28) % 21;
 1848|      0|		final = code % 28;
 1849|      0|
 1850|      0|		if (initial == 11) {
 1851|      0|			// null initial
 1852|      0|			c = medial + 0x1161;
 1853|      0|			if (final > 0)
 1854|      0|				*insert = final + 0x11a7;
 1855|      0|		} else {
 1856|      0|			// extract the initial and insert the remainder with a null initial
 1857|      0|			c = initial + 0x1100;
 1858|      0|			*insert = (11*28*21) + (medial*28) + final + 0xac00;
 1859|      0|		}
 1860|      0|		return c;
 1861|      0|	} else if (((code = c - 0x3130) >= 0) && (code < 0x34)) {
 1862|      0|		// Hangul compatibility jamo
 1863|      0|		return hangul_compatibility[code] + 0x1100;
 1864|      0|	}
 1865|      0|
 1866|      0|	switch (tr->translator_name)
 1867|      0|	{
 1868|      0|	case L('a', 'f'):
 1869|      0|	case L('n', 'l'):
 1870|      0|		// look for 'n  and replace by a special character (unicode: schwa)
 1871|      0|
 1872|      0|		if (!iswalpha(prev_in)) {
 1873|      0|			utf8_in(&next2, &ptr[1]);
 1874|      0|
 1875|      0|			if ((c == '\'') && IsSpace(next2)) {
 1876|      0|				if ((next_in == 'n') && (tr->translator_name == L('a', 'f'))) {
 1877|      0|					// n preceded by either apostrophe or U2019 "right single quotation mark"
 1878|      0|					ptr[0] = ' '; // delete the n
 1879|      0|					return 0x0259; // replace  '  by  unicode schwa character
 1880|      0|				}
 1881|      0|				if ((next_in == 'n') || (next_in == 't')) {
 1882|      0|					// Dutch, [@n] and [@t]
 1883|      0|					return 0x0259; // replace  '  by  unicode schwa character
 1884|      0|				}
 1885|      0|			}
 1886|      0|		}
 1887|      0|		break;
 1888|      0|	}
 1889|      0|	// handle .replace rule in xx_rules file
 1890|      0|	return SubstituteChar(tr, c, next_in, ptr, insert, wordflags);
 1891|      0|}
 1892|       |
 1893|       |static const char *UCase_ga[] = { "bp", "bhf", "dt", "gc", "hA", "mb", "nd", "ng", "ts", "tA", "nA", NULL };
 1894|       |
 1895|       |static int UpperCaseInWord(Translator *tr, char *word, int c)
 1896|      0|{
 1897|      0|	int ix;
 1898|      0|	int len;
 1899|      0|	const char *p;
 1900|      0|
 1901|      0|	if (tr->translator_name == L('g', 'a')) {
 1902|      0|		// Irish
 1903|      0|		for (ix = 0;; ix++) {
 1904|      0|			if ((p = UCase_ga[ix]) == NULL)
 1905|      0|				break;
 1906|      0|
 1907|      0|			len = strlen(p);
 1908|      0|			if ((word[-len] == ' ') && (memcmp(&word[-len+1], p, len-1) == 0)) {
 1909|      0|				if ((c == p[len-1]) || ((p[len-1] == 'A') && IsVowel(tr, c)))
 1910|      0|					return 1;
 1911|      0|			}
 1912|      0|		}
 1913|      0|	}
 1914|      0|	return 0;
 1915|      0|}
 1916|       |
 1917|       |void TranslateClause(Translator *tr, int *tone_out, char **voice_change)
 1918|      0|{
 1919|      0|	int ix;
 1920|      0|	int c;
 1921|      0|	int cc = 0;
 1922|      0|	unsigned int source_index = 0;
 1923|      0|	unsigned int prev_source_index = 0;
 1924|      0|	int source_index_word = 0;
 1925|      0|	int prev_in;
 1926|      0|	int prev_out = ' ';
 1927|      0|	int prev_out2;
 1928|      0|	int prev_in_save = 0;
 1929|      0|	int next_in;
 1930|      0|	int next_in_nbytes;
 1931|      0|	int char_inserted = 0;
 1932|      0|	int clause_pause;
 1933|      0|	int pre_pause_add = 0;
 1934|      0|	int all_upper_case = FLAG_ALL_UPPER;
 1935|      0|	int alpha_count = 0;
 1936|      0|	bool finished = false;
 1937|      0|	bool single_quoted = false;
 1938|      0|	bool phoneme_mode = false;
 1939|      0|	int dict_flags = 0; // returned from dictionary lookup
 1940|      0|	int word_flags; // set here
 1941|      0|	int next_word_flags;
 1942|      0|	bool new_sentence2;
 1943|      0|	int embedded_count = 0;
 1944|      0|	int letter_count = 0;
 1945|      0|	bool space_inserted = false;
 1946|      0|	bool syllable_marked = false;
 1947|      0|	bool decimal_sep_count = false;
 1948|      0|	char *word;
 1949|      0|	char *p;
 1950|      0|	int j, k;
 1951|      0|	int n_digits;
 1952|      0|	int charix_top = 0;
 1953|      0|
 1954|      0|	short charix[N_TR_SOURCE+4];
 1955|      0|	WORD_TAB words[N_CLAUSE_WORDS];
 1956|      0|	static char voice_change_name[40];
 1957|      0|	int word_count = 0; // index into words
 1958|      0|
 1959|      0|	char sbuf[N_TR_SOURCE];
 1960|      0|
 1961|      0|	int terminator;
 1962|      0|	int tone;
 1963|      0|
 1964|      0|	if (tr == NULL)
 1965|      0|		return;
 1966|      0|
 1967|      0|	embedded_ix = 0;
 1968|      0|	embedded_read = 0;
 1969|      0|	pre_pause = 0;
 1970|      0|	any_stressed_words = false;
 1971|      0|
 1972|      0|	if ((clause_start_char = count_characters) < 0)
 1973|      0|		clause_start_char = 0;
 1974|      0|	clause_start_word = count_words + 1;
 1975|      0|
 1976|      0|	for (ix = 0; ix < N_TR_SOURCE; ix++)
 1977|      0|		charix[ix] = 0;
 1978|      0|	terminator = ReadClause(tr, source, charix, &charix_top, N_TR_SOURCE, &tone, voice_change_name);
 1979|      0|
 1980|      0|	if (tone_out != NULL) {
 1981|      0|		if (tone == 0)
 1982|      0|			*tone_out = (terminator & CLAUSE_INTONATION_TYPE) >> 12; // tone type not overridden in ReadClause, use default
 1983|      0|		else
 1984|      0|			*tone_out = tone; // override tone type
 1985|      0|	}
 1986|      0|
 1987|      0|	charix[charix_top+1] = 0;
 1988|      0|	charix[charix_top+2] = 0x7fff;
 1989|      0|	charix[charix_top+3] = 0;
 1990|      0|
 1991|      0|	clause_pause = (terminator & CLAUSE_PAUSE) * 10; // mS
 1992|      0|	if (terminator & CLAUSE_PAUSE_LONG)
 1993|      0|		clause_pause = clause_pause * 32; // pause value is *320mS not *10mS
 1994|      0|
 1995|      0|	for (p = source; *p != 0; p++) {
 1996|      0|		if (!isspace2(*p))
 1997|      0|			break;
 1998|      0|	}
 1999|      0|	if (*p == 0) {
 2000|      0|		// No characters except spaces. This is not a sentence.
 2001|      0|		// Don't add this pause, just make up the previous pause to this value;
 2002|      0|		clause_pause -= max_clause_pause;
 2003|      0|		if (clause_pause < 0)
 2004|      0|			clause_pause = 0;
 2005|      0|
 2006|      0|		if (new_sentence)
 2007|      0|			terminator |= CLAUSE_TYPE_SENTENCE; // carry forward an end-of-sentence indicator
 2008|      0|		max_clause_pause += clause_pause;
 2009|      0|		new_sentence2 = false;
 2010|      0|	} else {
 2011|      0|		max_clause_pause = clause_pause;
 2012|      0|		new_sentence2 = new_sentence;
 2013|      0|	}
 2014|      0|	tr->clause_terminator = terminator;
 2015|      0|
 2016|      0|	if (new_sentence2) {
 2017|      0|		count_sentences++;
 2018|      0|		if (skip_sentences > 0) {
 2019|      0|			skip_sentences--;
 2020|      0|			if (skip_sentences == 0)
 2021|      0|				skipping_text = false;
 2022|      0|		}
 2023|      0|	}
 2024|      0|
 2025|      0|	memset(&ph_list2[0], 0, sizeof(ph_list2[0]));
 2026|      0|	ph_list2[0].phcode = phonPAUSE_SHORT;
 2027|      0|
 2028|      0|	n_ph_list2 = 1;
 2029|      0|	tr->prev_last_stress = 0;
 2030|      0|	tr->prepause_timeout = 0;
 2031|      0|	tr->expect_verb = 0;
 2032|      0|	tr->expect_noun = 0;
 2033|      0|	tr->expect_past = 0;
 2034|      0|	tr->expect_verb_s = 0;
 2035|      0|	tr->phonemes_repeat_count = 0;
 2036|      0|	tr->end_stressed_vowel = 0;
 2037|      0|	tr->prev_dict_flags[0] = 0;
 2038|      0|	tr->prev_dict_flags[1] = 0;
 2039|      0|
 2040|      0|	word_count = 0;
 2041|      0|	word_flags = 0;
 2042|      0|	next_word_flags = 0;
 2043|      0|
 2044|      0|	sbuf[0] = 0;
 2045|      0|	sbuf[1] = ' ';
 2046|      0|	sbuf[2] = ' ';
 2047|      0|	ix = 3;
 2048|      0|	prev_in = ' ';
 2049|      0|
 2050|      0|	words[0].start = ix;
 2051|      0|	words[0].flags = 0;
 2052|      0|
 2053|      0|	for (j = 0; charix[j] <= 0; j++) ;
 2054|      0|	words[0].sourceix = charix[j];
 2055|      0|	k = 0;
 2056|      0|	while (charix[j] != 0) {
 2057|      0|		// count the number of characters (excluding multibyte continuation bytes)
 2058|      0|		if (charix[j++] != -1)
 2059|      0|			k++;
 2060|      0|	}
 2061|      0|	words[0].length = k;
 2062|      0|
 2063|      0|	while (!finished && (ix < (int)sizeof(sbuf) - 1) && (n_ph_list2 < N_PHONEME_LIST-4)) {
 2064|      0|		prev_out2 = prev_out;
 2065|      0|		utf8_in2(&prev_out, &sbuf[ix-1], 1);
 2066|      0|
 2067|      0|		if (tr->langopts.tone_numbers && IsDigit09(prev_out) && IsAlpha(prev_out2)) {
 2068|      0|			// tone numbers can be part of a word, consider them as alphabetic
 2069|      0|			prev_out = 'a';
 2070|      0|		}
 2071|      0|
 2072|      0|		if (prev_in_save != 0) {
 2073|      0|			prev_in = prev_in_save;
 2074|      0|			prev_in_save = 0;
 2075|      0|		} else if (source_index > 0)
 2076|      0|			utf8_in2(&prev_in, &source[source_index-1], 1);
 2077|      0|
 2078|      0|		prev_source_index = source_index;
 2079|      0|
 2080|      0|		if (char_inserted) {
 2081|      0|			c = char_inserted;
 2082|      0|			char_inserted = 0;
 2083|      0|		} else {
 2084|      0|			source_index += utf8_in(&cc, &source[source_index]);
 2085|      0|			c = cc;
 2086|      0|		}
 2087|      0|		next_in_nbytes = utf8_in(&next_in, &source[source_index]);
 2088|      0|
 2089|      0|		if (c == 0) {
 2090|      0|			finished = true;
 2091|      0|			c = ' ';
 2092|      0|		}
 2093|      0|
 2094|      0|		if (c == CTRL_EMBEDDED) {
 2095|      0|			// start of embedded command in the text
 2096|      0|			int srcix = source_index-1;
 2097|      0|
 2098|      0|			if (prev_in != ' ') {
 2099|      0|				c = ' ';
 2100|      0|				prev_in_save = c;
 2101|      0|				source_index--;
 2102|      0|			} else {
 2103|      0|				embedded_count += EmbeddedCommand(&source_index);
 2104|      0|				prev_in_save = prev_in;
 2105|      0|				// replace the embedded command by spaces
 2106|      0|				memset(&source[srcix], ' ', source_index-srcix);
 2107|      0|				source_index = srcix;
 2108|      0|				continue;
 2109|      0|			}
 2110|      0|		}
 2111|      0|
 2112|      0|		if ((option_sayas2 == SAYAS_KEY) && (c != ' ')) {
 2113|      0|			if ((prev_in == ' ') && (next_in == ' '))
 2114|      0|				option_sayas2 = SAYAS_SINGLE_CHARS; // single character, speak its name
 2115|      0|			c = towlower2(c, tr);
 2116|      0|		}
 2117|      0|
 2118|      0|
 2119|      0|		if (phoneme_mode) {
 2120|      0|			all_upper_case = FLAG_PHONEMES;
 2121|      0|
 2122|      0|			if ((c == ']') && (next_in == ']')) {
 2123|      0|				phoneme_mode = false;
 2124|      0|				source_index++;
 2125|      0|				c = ' ';
 2126|      0|			}
 2127|      0|		} else if ((option_sayas2 & 0xf0) == SAYAS_DIGITS) {
 2128|      0|			if (iswdigit(c)) {
 2129|      0|				count_sayas_digits++;
 2130|      0|				if (count_sayas_digits > (option_sayas2 & 0xf)) {
 2131|      0|					// break after the specified number of digits
 2132|      0|					c = ' ';
 2133|      0|					space_inserted = true;
 2134|      0|					count_sayas_digits = 0;
 2135|      0|				}
 2136|      0|			} else {
 2137|      0|				count_sayas_digits = 0;
 2138|      0|				if (iswdigit(prev_out)) {
 2139|      0|					c = ' ';
 2140|      0|					space_inserted = true;
 2141|      0|				}
 2142|      0|			}
 2143|      0|		} else if ((option_sayas2 & 0x10) == 0) {
 2144|      0|			// speak as words
 2145|      0|
 2146|      0|			if ((c == 0x92) || (c == 0xb4) || (c == 0x2019) || (c == 0x2032))
 2147|      0|				c = '\''; // 'microsoft' quote or sexed closing single quote, or prime - possibly used as apostrophe
 2148|      0|
 2149|      0|			if (((c == 0x2018) || (c == '?')) && IsAlpha(prev_out) && IsAlpha(next_in)) {
 2150|      0|				// ? between two letters may be a smart-quote replaced by ?
 2151|      0|				c = '\'';
 2152|      0|			}
 2153|      0|
 2154|      0|			if (c == CHAR_EMPHASIS) {
 2155|      0|				// this character is a marker that the previous word is the focus of the clause
 2156|      0|				c = ' ';
 2157|      0|				word_flags |= FLAG_FOCUS;
 2158|      0|			}
 2159|      0|
 2160|      0|			if (c == CHAR_COMMA_BREAK) {
 2161|      0|				c = ' ';
 2162|      0|				word_flags |= FLAG_COMMA_AFTER;
 2163|      0|			}
 2164|      0|			// language specific character translations
 2165|      0|			c = TranslateChar(tr, &source[source_index], prev_in, c, next_in, &char_inserted, &word_flags);
 2166|      0|			if (c == 8)
 2167|      0|				continue; // ignore this character
 2168|      0|
 2169|      0|			if (char_inserted)
 2170|      0|				next_in = char_inserted;
 2171|      0|
 2172|      0|			// allow certain punctuation within a word (usually only apostrophe)
 2173|      0|			if (!IsAlpha(c) && !IsSpace(c) && (wcschr(tr->punct_within_word, c) == 0)) {
 2174|      0|				if (IsAlpha(prev_out)) {
 2175|      0|					if (tr->langopts.tone_numbers && IsDigit09(c) && !IsDigit09(next_in)) {
 2176|      0|						// allow a tone number as part of the word
 2177|      0|					} else {
 2178|      0|						c = ' '; // ensure we have an end-of-word terminator
 2179|      0|						space_inserted = true;
 2180|      0|					}
 2181|      0|				}
 2182|      0|			}
 2183|      0|
 2184|      0|			if (iswdigit(prev_out)) {
 2185|      0|				if (!iswdigit(c) && (c != '.') && (c != ',') && (c != ' ')) {
 2186|      0|					c = ' '; // terminate digit string with a space
 2187|      0|					space_inserted = true;
 2188|      0|				}
 2189|      0|			} else { // Prev output is not digit
 2190|      0|				if (prev_in == ',') {
 2191|      0|					// Workaround for several consecutive commas —
 2192|      0|					// replace current character with space
 2193|      0|					if (c == ',')
 2194|      0|						c = ' ';
 2195|      0|				} else {
 2196|      0|					decimal_sep_count = false;
 2197|      0|				}
 2198|      0|			}
 2199|      0|
 2200|      0|			if (c == '[') {
 2201|      0|				if ((next_in == '\002') || ((next_in == '[') && option_phoneme_input)) {
 2202|      0|					//  "[\002" is used internally to start phoneme mode
 2203|      0|					phoneme_mode = true;
 2204|      0|					source_index++;
 2205|      0|					continue;
 2206|      0|				}
 2207|      0|			}
 2208|      0|
 2209|      0|			if (IsAlpha(c)) {
 2210|      0|				alpha_count++;
 2211|      0|				if (!IsAlpha(prev_out) || (tr->langopts.ideographs && ((c > 0x3040) || (prev_out > 0x3040)))) {
 2212|      0|					if (wcschr(tr->punct_within_word, prev_out) == 0)
 2213|      0|						letter_count = 0; // don't reset count for an apostrophy within a word
 2214|      0|
 2215|      0|					if ((prev_out != ' ') && (wcschr(tr->punct_within_word, prev_out) == 0)) {
 2216|      0|						// start of word, insert space if not one there already
 2217|      0|						c = ' ';
 2218|      0|						space_inserted = true;
 2219|      0|
 2220|      0|						if (!IsBracket(prev_out)) // ?? perhaps only set FLAG_NOSPACE for . - /  (hyphenated words, URLs, etc)
 2221|      0|							next_word_flags |= FLAG_NOSPACE;
 2222|      0|					} else {
 2223|      0|						if (iswupper(c))
 2224|      0|							word_flags |= FLAG_FIRST_UPPER;
 2225|      0|
 2226|      0|						if ((prev_out == ' ') && iswdigit(sbuf[ix-2]) && !iswdigit(prev_in)) {
 2227|      0|							// word, following a number, but with a space between
 2228|      0|							// Add an extra space, to distinguish "2 a" from "2a"
 2229|      0|							sbuf[ix++] = ' ';
 2230|      0|							words[word_count].start++;
 2231|      0|						}
 2232|      0|					}
 2233|      0|				}
 2234|      0|
 2235|      0|				if (c != ' ') {
 2236|      0|					letter_count++;
 2237|      0|
 2238|      0|					if (tr->letter_bits_offset > 0) {
 2239|      0|						if (((c < 0x250) && (prev_out >= tr->letter_bits_offset)) ||
 2240|      0|						    ((c >= tr->letter_bits_offset) && (letter_count > 1) && (prev_out < 0x250))) {
 2241|      0|							// Don't mix native and Latin characters in the same word
 2242|      0|							// Break into separate words
 2243|      0|							if (IsAlpha(prev_out)) {
 2244|      0|								c = ' ';
 2245|      0|								space_inserted = true;
 2246|      0|								word_flags |= FLAG_HYPHEN_AFTER;
 2247|      0|								next_word_flags |= FLAG_HYPHEN;
 2248|      0|							}
 2249|      0|						}
 2250|      0|					}
 2251|      0|				}
 2252|      0|
 2253|      0|				if (iswupper(c)) {
 2254|      0|					c = towlower2(c, tr);
 2255|      0|
 2256|      0|					if (tr->langopts.param[LOPT_CAPS_IN_WORD]) {
 2257|      0|						if (syllable_marked == false) {
 2258|      0|							char_inserted = c;
 2259|      0|							c = 0x2c8; // stress marker
 2260|      0|							syllable_marked = true;
 2261|      0|						}
 2262|      0|					} else {
 2263|      0|						if (iswlower(prev_in)) {
 2264|      0|							// lower case followed by upper case, possibly CamelCase
 2265|      0|							if (UpperCaseInWord(tr, &sbuf[ix], c) == 0) { // start a new word
 2266|      0|								c = ' ';
 2267|      0|								space_inserted = true;
 2268|      0|								prev_in_save = c;
 2269|      0|							}
 2270|      0|						} else if ((c != ' ') && iswupper(prev_in) && iswlower(next_in)) {
 2271|      0|							int next2_in;
 2272|      0|							utf8_in(&next2_in, &source[source_index + next_in_nbytes]);
 2273|      0|
 2274|      0|							if ((tr->translator_name == L('n', 'l')) && (letter_count == 2) && (c == 'j') && (prev_in == 'I')) {
 2275|      0|								// Dutch words may capitalise initial IJ, don't split
 2276|      0|							} else if (IsAlpha(next2_in)) {
 2277|      0|								// changing from upper to lower case, start new word at the last uppercase, if 3 or more letters
 2278|      0|								c = ' ';
 2279|      0|								space_inserted = true;
 2280|      0|								prev_in_save = c;
 2281|      0|								next_word_flags |= FLAG_NOSPACE;
 2282|      0|							}
 2283|      0|						}
 2284|      0|					}
 2285|      0|				} else {
 2286|      0|					if ((all_upper_case) && (letter_count > 2)) {
 2287|      0|						// Flag as plural only English
 2288|      0|						if (tr->translator_name == L('e', 'n') && (c == 's') && (next_in == ' ')) {
 2289|      0|							c = ' ';
 2290|      0|							all_upper_case |= FLAG_HAS_PLURAL;
 2291|      0|
 2292|      0|							if (sbuf[ix-1] == '\'')
 2293|      0|								sbuf[ix-1] = ' ';
 2294|      0|						} else
 2295|      0|							all_upper_case = 0; // current word contains lower case letters, not "'s"
 2296|      0|					} else
 2297|      0|						all_upper_case = 0;
 2298|      0|				}
 2299|      0|			} else if (c == '-') {
 2300|      0|				if (!IsSpace(prev_in) && IsAlpha(next_in)) {
 2301|      0|					if (prev_out != ' ') {
 2302|      0|						// previous 'word' not yet ended (not alpha or numeric), start new word now.
 2303|      0|						c = ' ';
 2304|      0|						space_inserted = true;
 2305|      0|					} else {
 2306|      0|						// '-' between two letters is a hyphen, treat as a space
 2307|      0|						word_flags |= FLAG_HYPHEN;
 2308|      0|						if (word_count > 0)
 2309|      0|							words[word_count-1].flags |= FLAG_HYPHEN_AFTER;
 2310|      0|						c = ' ';
 2311|      0|					}
 2312|      0|				} else if ((prev_in == ' ') && (next_in == ' ')) {
 2313|      0|					// ' - ' dash between two spaces, treat as pause
 2314|      0|					c = ' ';
 2315|      0|					pre_pause_add = 4;
 2316|      0|				} else if (next_in == '-') {
 2317|      0|					// double hyphen, treat as pause
 2318|      0|					source_index++;
 2319|      0|					c = ' ';
 2320|      0|					pre_pause_add = 4;
 2321|      0|				} else if ((prev_out == ' ') && IsAlpha(prev_out2) && !IsAlpha(prev_in)) {
 2322|      0|					// insert extra space between a word + space + hyphen, to distinguish 'a -2' from 'a-2'
 2323|      0|					sbuf[ix++] = ' ';
 2324|      0|					words[word_count].start++;
 2325|      0|				}
 2326|      0|			} else if (c == '.') {
 2327|      0|				if (prev_out == '.') {
 2328|      0|					// multiple dots, separate by spaces. Note >3 dots has been replaced by elipsis
 2329|      0|					c = ' ';
 2330|      0|					space_inserted = true;
 2331|      0|				} else if ((word_count > 0) && !(words[word_count-1].flags & FLAG_NOSPACE) && IsAlpha(prev_in)) {
 2332|      0|					// dot after a word, with space following, probably an abbreviation
 2333|      0|					words[word_count-1].flags |= FLAG_HAS_DOT;
 2334|      0|
 2335|      0|					if (IsSpace(next_in) || (next_in == '-'))
 2336|      0|						c = ' '; // remove the dot if it's followed by a space or hyphen, so that it's not pronounced
 2337|      0|				}
 2338|      0|			} else if (c == '\'') {
 2339|      0|				if (((prev_in == '.' && next_in == 's') || iswalnum(prev_in)) && IsAlpha(next_in)) {
 2340|      0|					// between two letters, or in an abbreviation (eg. u.s.a.'s). Consider the apostrophe as part of the word
 2341|      0|					single_quoted = false;
 2342|      0|				} else if ((tr->langopts.param[LOPT_APOSTROPHE] & 1) && IsAlpha(next_in))
 2343|      0|					single_quoted = false; // apostrophe at start of word is part of the word
 2344|      0|				else if ((tr->langopts.param[LOPT_APOSTROPHE] & 2) && IsAlpha(prev_in))
 2345|      0|					single_quoted = false; // apostrophe at end of word is part of the word
 2346|      0|				else if ((wcschr(tr->char_plus_apostrophe, prev_in) != 0) && (prev_out2 == ' ')) {
 2347|      0|					// consider single character plus apostrophe as a word
 2348|      0|					single_quoted = false;
 2349|      0|					if (next_in == ' ')
 2350|      0|						source_index++; // skip following space
 2351|      0|				} else {
 2352|      0|					if ((prev_out == 's') && (single_quoted == false)) {
 2353|      0|						// looks like apostrophe after an 's'
 2354|      0|						c = ' ';
 2355|      0|					} else {
 2356|      0|						if (IsSpace(prev_out))
 2357|      0|							single_quoted = true;
 2358|      0|						else
 2359|      0|							single_quoted = false;
 2360|      0|
 2361|      0|						pre_pause_add = 4; // single quote
 2362|      0|						c = ' ';
 2363|      0|					}
 2364|      0|				}
 2365|      0|			} else if (lookupwchar(breaks, c) != 0)
 2366|      0|				c = ' '; // various characters to treat as space
 2367|      0|			else if (iswdigit(c)) {
 2368|      0|				if (tr->langopts.tone_numbers && IsAlpha(prev_out) && !IsDigit(next_in)) {
 2369|      0|				} else if ((prev_out != ' ') && !iswdigit(prev_out)) {
 2370|      0|					if ((prev_out != tr->langopts.decimal_sep) || ((decimal_sep_count == true) && (tr->langopts.decimal_sep == ','))) {
 2371|      0|						c = ' ';
 2372|      0|						space_inserted = true;
 2373|      0|					} else
 2374|      0|						decimal_sep_count = true;
 2375|      0|				} else if ((prev_out == ' ') && IsAlpha(prev_out2) && !IsAlpha(prev_in)) {
 2376|      0|					// insert extra space between a word and a number, to distinguish 'a 2' from 'a2'
 2377|      0|					sbuf[ix++] = ' ';
 2378|      0|					words[word_count].start++;
 2379|      0|				}
 2380|      0|			}
 2381|      0|		}
 2382|      0|
 2383|      0|		if (IsSpace(c)) {
 2384|      0|			if (prev_out == ' ') {
 2385|      0|				word_flags |= FLAG_MULTIPLE_SPACES;
 2386|      0|				continue; // multiple spaces
 2387|      0|			}
 2388|      0|
 2389|      0|			if ((cc == 0x09) || (cc == 0x0a))
 2390|      0|				next_word_flags |= FLAG_MULTIPLE_SPACES; // tab or newline, not a simple space
 2391|      0|
 2392|      0|			if (space_inserted) {
 2393|      0|				// count the number of characters since the start of the word
 2394|      0|				j = 0;
 2395|      0|				k = source_index - 1;
 2396|      0|				while ((k >= source_index_word) && (charix[k] != 0)) {
 2397|      0|					if (charix[k] > 0) // don't count initial bytes of multi-byte character
 2398|      0|						j++;
 2399|      0|					k--;
 2400|      0|				}
 2401|      0|				words[word_count].length = j;
 2402|      0|			}
 2403|      0|
 2404|      0|			source_index_word = source_index;
 2405|      0|
 2406|      0|			// end of 'word'
 2407|      0|			sbuf[ix++] = ' ';
 2408|      0|
 2409|      0|			if ((word_count < N_CLAUSE_WORDS-1) && (ix > words[word_count].start)) {
 2410|      0|				if (embedded_count > 0) {
 2411|      0|					// there are embedded commands before this word
 2412|      0|					embedded_list[embedded_ix-1] |= 0x80; // terminate list of commands for this word
 2413|      0|					words[word_count].flags |= FLAG_EMBEDDED;
 2414|      0|					embedded_count = 0;
 2415|      0|				}
 2416|      0|				if (alpha_count == 0) {
 2417|      0|					all_upper_case &= ~FLAG_ALL_UPPER;
 2418|      0|				}
 2419|      0|				words[word_count].pre_pause = pre_pause;
 2420|      0|				words[word_count].flags |= (all_upper_case | word_flags | word_emphasis);
 2421|      0|
 2422|      0|				if (pre_pause > 0) {
 2423|      0|					// insert an extra space before the word, to prevent influence from previous word across the pause
 2424|      0|					for (j = ix; j > words[word_count].start; j--)
 2425|      0|						sbuf[j] = sbuf[j-1];
 2426|      0|					sbuf[j] = ' ';
 2427|      0|					words[word_count].start++;
 2428|      0|					ix++;
 2429|      0|				}
 2430|      0|
 2431|      0|				word_count++;
 2432|      0|				words[word_count].start = ix;
 2433|      0|				words[word_count].flags = 0;
 2434|      0|
 2435|      0|				for (j = source_index; j < charix_top && charix[j] <= 0; j++) // skip blanks
 2436|      0|					;
 2437|      0|				words[word_count].sourceix = charix[j];
 2438|      0|				k = 0;
 2439|      0|				while (charix[j] != 0) {
 2440|      0|					// count the number of characters (excluding multibyte continuation bytes)
 2441|      0|					if (charix[j++] != -1)
 2442|      0|						k++;
 2443|      0|				}
 2444|      0|				words[word_count].length = k;
 2445|      0|
 2446|      0|				word_flags = next_word_flags;
 2447|      0|				next_word_flags = 0;
 2448|      0|				pre_pause = 0;
 2449|      0|				all_upper_case = FLAG_ALL_UPPER;
 2450|      0|				alpha_count = 0;
 2451|      0|				syllable_marked = false;
 2452|      0|			}
 2453|      0|
 2454|      0|			if (space_inserted) {
 2455|      0|				source_index = prev_source_index; // rewind to the previous character
 2456|      0|				char_inserted = 0;
 2457|      0|				space_inserted = false;
 2458|      0|			}
 2459|      0|		} else {
 2460|      0|			if ((ix < (N_TR_SOURCE - 4)))
 2461|      0|				ix += utf8_out(c, &sbuf[ix]);
 2462|      0|		}
 2463|      0|		if (pre_pause_add > pre_pause)
 2464|      0|			pre_pause = pre_pause_add;
 2465|      0|		pre_pause_add = 0;
 2466|      0|	}
 2467|      0|
 2468|      0|	if ((word_count == 0) && (embedded_count > 0)) {
 2469|      0|		// add a null 'word' to carry the embedded command flag
 2470|      0|		embedded_list[embedded_ix-1] |= 0x80;
 2471|      0|		words[word_count].flags |= FLAG_EMBEDDED;
 2472|      0|		word_count = 1;
 2473|      0|	}
 2474|      0|
 2475|      0|	tr->clause_end = &sbuf[ix-1];
 2476|      0|	sbuf[ix] = 0;
 2477|      0|	words[0].pre_pause = 0; // don't add extra pause at beginning of clause
 2478|      0|	words[word_count].pre_pause = 8;
 2479|      0|	if (word_count > 0) {
 2480|      0|		ix = word_count-1;
 2481|      0|		while ((ix > 0) && (IsBracket(sbuf[words[ix].start])))
 2482|      0|			ix--; // the last word is a bracket, mark the previous word as last
 2483|      0|		words[ix].flags |= FLAG_LAST_WORD;
 2484|      0|
 2485|      0|		// FLAG_NOSPACE check to avoid recognizing  .mr  -mr
 2486|      0|		if ((terminator & CLAUSE_DOT_AFTER_LAST_WORD) && !(words[word_count-1].flags & FLAG_NOSPACE))
 2487|      0|			words[word_count-1].flags |= FLAG_HAS_DOT;
 2488|      0|	}
 2489|      0|	words[0].flags |= FLAG_FIRST_WORD;
 2490|      0|
 2491|      0|	for (ix = 0; ix < word_count; ix++) {
 2492|      0|		int nx;
 2493|      0|		int c_temp;
 2494|      0|		char *pn;
 2495|      0|		char *pw;
 2496|      0|		int nw;
 2497|      0|		char number_buf[150];
 2498|      0|		WORD_TAB num_wtab[50]; // copy of 'words', when splitting numbers into parts
 2499|      0|
 2500|      0|		// start speaking at a specified word position in the text?
 2501|      0|		count_words++;
 2502|      0|		if (skip_words > 0) {
 2503|      0|			skip_words--;
 2504|      0|			if (skip_words == 0)
 2505|      0|				skipping_text = false;
 2506|      0|		}
 2507|      0|		if (skipping_text)
 2508|      0|			continue;
 2509|      0|
 2510|      0|		current_alphabet = NULL;
 2511|      0|
 2512|      0|		// digits should have been converted to Latin alphabet ('0' to '9')
 2513|      0|		word = pw = &sbuf[words[ix].start];
 2514|      0|
 2515|      0|		if (iswdigit(word[0]) && (tr->langopts.break_numbers != BREAK_THOUSANDS)) {
 2516|      0|			// Languages with 100000 numbers.  Remove thousands separators so that we can insert them again later
 2517|      0|			pn = number_buf;
 2518|      0|			while (pn < &number_buf[sizeof(number_buf)-20]) {
 2519|      0|				if (iswdigit(*pw))
 2520|      0|					*pn++ = *pw++;
 2521|      0|				else if ((*pw == tr->langopts.thousands_sep) && (pw[1] == ' ')
 2522|      0|				           && iswdigit(pw[2]) && (pw[3] != ' ') && (pw[4] != ' ')) { // don't allow only 1 or 2 digits in the final part
 2523|      0|					pw += 2;
 2524|      0|					ix++; // skip "word"
 2525|      0|				} else {
 2526|      0|					nx = pw - word;
 2527|      0|					memset(word, ' ', nx);
 2528|      0|					nx = pn - number_buf;
 2529|      0|					memcpy(word, number_buf, nx);
 2530|      0|					break;
 2531|      0|				}
 2532|      0|			}
 2533|      0|			pw = word;
 2534|      0|		}
 2535|      0|
 2536|      0|		for (n_digits = 0; iswdigit(word[n_digits]); n_digits++) // count consecutive digits
 2537|      0|			;
 2538|      0|
 2539|      0|		if (n_digits > 4) {
 2540|      0|			// word is entirely digits, insert commas and break into 3 digit "words"
 2541|      0|			number_buf[0] = ' ';
 2542|      0|			pn = &number_buf[1];
 2543|      0|			nx = n_digits;
 2544|      0|			nw = 0;
 2545|      0|
 2546|      0|			if ((n_digits > tr->langopts.max_digits) || (word[0] == '0'))
 2547|      0|				words[ix].flags |= FLAG_INDIVIDUAL_DIGITS;
 2548|      0|
 2549|      0|			while (pn < &number_buf[sizeof(number_buf)-20]) {
 2550|      0|				if (!IsDigit09(c = *pw++) && (c != tr->langopts.decimal_sep))
 2551|      0|					break;
 2552|      0|
 2553|      0|				*pn++ = c;
 2554|      0|				nx--;
 2555|      0|				if ((nx > 0) && (tr->langopts.break_numbers & (1 << nx))) {
 2556|      0|					memcpy(&num_wtab[nw++], &words[ix], sizeof(WORD_TAB)); // copy the 'words' entry for each word of numbers
 2557|      0|
 2558|      0|					if (tr->langopts.thousands_sep != ' ')
 2559|      0|						*pn++ = tr->langopts.thousands_sep;
 2560|      0|					*pn++ = ' ';
 2561|      0|
 2562|      0|					if ((words[ix].flags & FLAG_INDIVIDUAL_DIGITS) == 0) {
 2563|      0|						if (tr->langopts.break_numbers & (1 << (nx-1))) {
 2564|      0|							// the next group only has 1 digits, make it three
 2565|      0|							*pn++ = '0';
 2566|      0|							*pn++ = '0';
 2567|      0|						}
 2568|      0|						if (tr->langopts.break_numbers & (1 << (nx-2))) {
 2569|      0|							// the next group only has 2 digits (eg. Indian languages), make it three
 2570|      0|							*pn++ = '0';
 2571|      0|						}
 2572|      0|					}
 2573|      0|				}
 2574|      0|			}
 2575|      0|			pw--;
 2576|      0|			memcpy(&num_wtab[nw], &words[ix], sizeof(WORD_TAB)*2); // the original number word, and the word after it
 2577|      0|
 2578|      0|			for (j = 1; j <= nw; j++)
 2579|      0|				num_wtab[j].flags &= ~(FLAG_MULTIPLE_SPACES | FLAG_EMBEDDED); // don't use these flags for subsequent parts when splitting a number
 2580|      0|
 2581|      0|			// include the next few characters, in case there are an ordinal indicator or other suffix
 2582|      0|			memcpy(pn, pw, 16);
 2583|      0|			pn[16] = 0;
 2584|      0|			nw = 0;
 2585|      0|
 2586|      0|			for (pw = &number_buf[1]; pw < pn;) {
 2587|      0|				// keep wflags for each part, for FLAG_HYPHEN_AFTER
 2588|      0|				dict_flags = TranslateWord2(tr, pw, &num_wtab[nw++], words[ix].pre_pause);
 2589|      0|				while (*pw++ != ' ')
 2590|      0|					;
 2591|      0|				words[ix].pre_pause = 0;
 2592|      0|			}
 2593|      0|		} else {
 2594|      0|			pre_pause = 0;
 2595|      0|
 2596|      0|			dict_flags = TranslateWord2(tr, word, &words[ix], words[ix].pre_pause);
 2597|      0|
 2598|      0|			if (pre_pause > words[ix+1].pre_pause) {
 2599|      0|				words[ix+1].pre_pause = pre_pause;
 2600|      0|				pre_pause = 0;
 2601|      0|			}
 2602|      0|
 2603|      0|			if (dict_flags & FLAG_SPELLWORD) {
 2604|      0|				// redo the word, speaking single letters
 2605|      0|				for (pw = word; *pw != ' ';) {
 2606|      0|					memset(number_buf, ' ', 9);
 2607|      0|					nx = utf8_in(&c_temp, pw);
 2608|      0|					memcpy(&number_buf[2], pw, nx);
 2609|      0|					TranslateWord2(tr, &number_buf[2], &words[ix], 0);
 2610|      0|					pw += nx;
 2611|      0|				}
 2612|      0|			}
 2613|      0|
 2614|      0|			if ((dict_flags & (FLAG_ALLOW_DOT | FLAG_NEEDS_DOT)) && (ix == word_count - 1 - dictionary_skipwords) && (terminator & CLAUSE_DOT_AFTER_LAST_WORD)) {
 2615|      0|				// probably an abbreviation such as Mr. or B. rather than end of sentence
 2616|      0|				clause_pause = 10;
 2617|      0|				if (tone_out != NULL)
 2618|      0|					*tone_out = 4;
 2619|      0|			}
 2620|      0|		}
 2621|      0|
 2622|      0|		if (dict_flags & FLAG_SKIPWORDS) {
 2623|      0|			// dictionary indicates skip next word(s)
 2624|      0|			while (dictionary_skipwords > 0) {
 2625|      0|				words[ix+dictionary_skipwords].flags |= FLAG_DELETE_WORD;
 2626|      0|				dictionary_skipwords--;
 2627|      0|			}
 2628|      0|		}
 2629|      0|	}
 2630|      0|
 2631|      0|	if (embedded_read < embedded_ix) {
 2632|      0|		// any embedded commands not yet processed?
 2633|      0|		Word_EmbeddedCmd();
 2634|      0|	}
 2635|      0|
 2636|      0|	for (ix = 0; ix < 2; ix++) {
 2637|      0|		// terminate the clause with 2 PAUSE phonemes
 2638|      0|		PHONEME_LIST2 *p2;
 2639|      0|		p2 = &ph_list2[n_ph_list2 + ix];
 2640|      0|		p2->phcode = phonPAUSE;
 2641|      0|		p2->stresslevel = 0;
 2642|      0|		p2->sourceix = source_index;
 2643|      0|		p2->synthflags = 0;
 2644|      0|	}
 2645|      0|	n_ph_list2 += 2;
 2646|      0|
 2647|      0|	if (count_words == 0)
 2648|      0|		clause_pause = 0;
 2649|      0|	if (Eof() && ((word_count == 0) || (option_endpause == 0)))
 2650|      0|		clause_pause = 10;
 2651|      0|
 2652|      0|	MakePhonemeList(tr, clause_pause, new_sentence2);
 2653|      0|	phoneme_list[N_PHONEME_LIST].ph = NULL; // recognize end of phoneme_list array, in Generate()
 2654|      0|	phoneme_list[N_PHONEME_LIST].sourceix = 1;
 2655|      0|
 2656|      0|	if (embedded_count) { // ???? is this needed
 2657|      0|		phoneme_list[n_phoneme_list-2].synthflags = SFLAG_EMBEDDED;
 2658|      0|		embedded_list[embedded_ix-1] |= 0x80;
 2659|      0|		embedded_list[embedded_ix] = 0x80;
 2660|      0|	}
 2661|      0|
 2662|      0|	prev_clause_pause = clause_pause;
 2663|      0|
 2664|      0|	new_sentence = false;
 2665|      0|	if (terminator & CLAUSE_TYPE_SENTENCE)
 2666|      0|		new_sentence = true; // next clause is a new sentence
 2667|      0|
 2668|      0|	if (voice_change != NULL) {
 2669|      0|		// return new voice name if an embedded voice change command terminated the clause
 2670|      0|		if (terminator & CLAUSE_TYPE_VOICE_CHANGE)
 2671|      0|			*voice_change = voice_change_name;
 2672|      0|		else
 2673|      0|			*voice_change = NULL;
 2674|      0|	}
 2675|      0|}
 2676|       |
 2677|       |void InitText(int control)
 2678|      0|{
 2679|      0|	count_sentences = 0;
 2680|      0|	count_words = 0;
 2681|      0|	end_character_position = 0;
 2682|      0|	skip_sentences = 0;
 2683|      0|	skip_marker[0] = 0;
 2684|      0|	skip_words = 0;
 2685|      0|	skip_characters = 0;
 2686|      0|	skipping_text = false;
 2687|      0|	new_sentence = true;
 2688|      0|
 2689|      0|	prev_clause_pause = 0;
 2690|      0|
 2691|      0|	option_sayas = 0;
 2692|      0|	option_sayas2 = 0;
 2693|      0|	option_emphasis = 0;
 2694|      0|	word_emphasis = 0;
 2695|      0|	embedded_flag = 0;
 2696|      0|
 2697|      0|	InitText2();
 2698|      0|
 2699|      0|	if ((control & espeakKEEP_NAMEDATA) == 0)
 2700|      0|		InitNamedata();
 2701|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/translate.h:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2014 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2017, 2020 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#ifndef ESPEAK_NG_TRANSLATE_H
   21|       |#define ESPEAK_NG_TRANSLATE_H
   22|       |
   23|       |#include <stdbool.h>
   24|       |
   25|       |#include <espeak-ng/espeak_ng.h>
   26|       |#include <espeak-ng/encoding.h>
   27|       |
   28|       |#ifdef __cplusplus
   29|       |extern "C"
   30|       |{
   31|       |#endif
   32|       |
   33|      0|#define L(c1, c2) (c1<<8)+c2 // combine two characters into an integer for translator name
   34|      0|#define L3(c1, c2, c3) (c1<<16)+(c2<<8) + c3 // combine three characters into an integer for translator name
   35|      0|#define L4(c1, c2, c3, c4) (c1<<24)+(c2<<16)+(c3<<8) + c4 // combine four characters into an integer for translator name
   36|       |
   37|      0|#define CTRL_EMBEDDED    0x01 // control character at the start of an embedded command
   38|      0|#define REPLACED_E       'E' // 'e' replaced by silent e
   39|       |
   40|      0|#define N_WORD_PHONEMES  200 // max phonemes in a word
   41|      0|#define N_WORD_BYTES     160 // max bytes for the UTF8 characters in a word
   42|      0|#define N_CLAUSE_WORDS   300 // max words in a clause
   43|      0|#define N_TR_SOURCE      800 // the source text of a single clause (UTF8 bytes)
   44|       |
   45|       |#define N_RULE_GROUP2    120 // max num of two-letter rule chains
   46|      0|#define N_HASH_DICT     1024
   47|      0|#define N_LETTER_GROUPS   95 // maximum is 127-32
   48|       |
   49|       |// dictionary flags, word 1
   50|       |// bits 0-3  stressed syllable,  bit 6=unstressed
   51|      0|#define FLAG_SKIPWORDS        0x80
   52|      0|#define FLAG_PREPAUSE        0x100
   53|       |
   54|      0|#define FLAG_STRESS_END      0x200 // full stress if at end of clause
   55|      0|#define FLAG_STRESS_END2     0x400 // full stress if at end of clause, or only followed by unstressed
   56|      0|#define FLAG_UNSTRESS_END    0x800 // reduce stress at end of clause
   57|      0|#define FLAG_SPELLWORD      0x1000 // re-translate the word as individual letters, separated by spaces
   58|      0|#define FLAG_ACCENT_BEFORE  0x1000 // say this accent name before the letter name
   59|      0|#define FLAG_ABBREV         0x2000 // spell as letters, even with a vowel, OR use specified pronunciation rather than split into letters
   60|      0|#define FLAG_DOUBLING       0x4000 // doubles the following consonant
   61|       |
   62|      0|#define BITNUM_FLAG_ALT         14 // bit number of FLAG_ALT_TRANS - 1
   63|      0|#define FLAG_ALT_TRANS      0x8000 // language specific
   64|      0|#define FLAG_ALT2_TRANS    0x10000 // language specific
   65|      0|#define FLAG_ALT3_TRANS    0x20000 // language specific
   66|       |#define FLAG_ALT4_TRANS    0x40000 // language specific
   67|       |#define FLAG_ALT5_TRANS    0x80000 // language specific
   68|       |#define FLAG_ALT6_TRANS   0x100000 // language specific
   69|      0|#define FLAG_ALT7_TRANS   0x200000 // language specific
   70|       |
   71|      0|#define FLAG_COMBINE      0x800000 // combine with the next word
   72|      0|#define FLAG_ALLOW_DOT  0x01000000 // ignore '.' after word (abbreviation)
   73|      0|#define FLAG_NEEDS_DOT  0x02000000 // only if the word is followed by a dot
   74|      0|#define FLAG_WAS_UNPRONOUNCABLE  0x04000000  // the unpronounceable routine was used
   75|      0|#define FLAG_MAX3       0x08000000 // limit to 3 repeats
   76|      0|#define FLAG_PAUSE1     0x10000000 // shorter prepause
   77|      0|#define FLAG_TEXTMODE   0x20000000 // word translates to replacement text, not phonemes
   78|      0|#define BITNUM_FLAG_TEXTMODE    29
   79|       |
   80|      0|#define FLAG_FOUND_ATTRIBUTES 0x40000000 // word was found in the dictionary list (has attributes)
   81|      0|#define FLAG_FOUND            0x80000000 // pronunciation was found in the dictionary list
   82|       |
   83|       |// dictionary flags, word 2
   84|      0|#define FLAG_VERBF             0x1 // verb follows
   85|      0|#define FLAG_VERBSF            0x2 // verb follows, may have -s suffix
   86|      0|#define FLAG_NOUNF             0x4 // noun follows
   87|      0|#define FLAG_PASTF             0x8 // past tense follows
   88|      0|#define FLAG_VERB             0x10 // pronunciation for verb
   89|      0|#define FLAG_NOUN             0x20 // pronunciation for noun
   90|      0|#define FLAG_PAST             0x40 // pronunciation for past tense
   91|      0|#define FLAG_VERB_EXT        0x100 // extend the 'verb follows'
   92|      0|#define FLAG_CAPITAL         0x200 // pronunciation if initial letter is upper case
   93|      0|#define FLAG_ALLCAPS         0x400 // only if the word is all capitals
   94|      0|#define FLAG_ACCENT          0x800 // character name is base-character name + accent name
   95|      0|#define FLAG_SENTENCE       0x2000 // only if the clause is a sentence
   96|      0|#define FLAG_ONLY           0x4000
   97|      0|#define FLAG_ONLY_S         0x8000
   98|      0|#define FLAG_STEM          0x10000 // must have a suffix
   99|      0|#define FLAG_ATEND         0x20000 // use this pronunciation if at end of clause
  100|      0|#define FLAG_ATSTART       0x40000 // use this pronunciation if at start of clause
  101|      0|#define FLAG_NATIVE        0x80000 // not if we've switched translators
  102|      0|#define FLAG_LOOKUP_SYMBOL 0x40000000 // to indicate called from Lookup()
  103|       |
  104|      0|#define BITNUM_FLAG_ALLCAPS    0x2a
  105|      0|#define BITNUM_FLAG_HYPHENATED 0x2c
  106|       |#define BITNUM_FLAG_ONLY       0x2e
  107|      0|#define BITNUM_FLAG_ONLY_S     0x2f
  108|       |
  109|       |// wordflags, flags in source word
  110|      0|#define FLAG_ALL_UPPER     0x1   // no lower case letters in the word
  111|      0|#define FLAG_FIRST_UPPER   0x2   // first letter is upper case
  112|      0|#define FLAG_UPPERS        0x3   // FLAG_ALL_UPPER | FLAG_FIRST_UPPER
  113|      0|#define FLAG_HAS_PLURAL    0x4   // upper-case word with s or 's lower-case ending
  114|      0|#define FLAG_PHONEMES      0x8   // word is phonemes
  115|      0|#define FLAG_LAST_WORD     0x10  // last word in clause
  116|      0|#define FLAG_EMBEDDED      0x40  // word is preceded by embedded commands
  117|      0|#define FLAG_HYPHEN        0x80
  118|      0|#define FLAG_NOSPACE       0x100 // word is not separated from previous word by a space
  119|      0|#define FLAG_FIRST_WORD    0x200 // first word in clause
  120|      0|#define FLAG_FOCUS         0x400 // the focus word of a clause
  121|      0|#define FLAG_EMPHASIZED    0x800
  122|      0|#define FLAG_EMPHASIZED2   0xc00 // FLAG_FOCUS | FLAG_EMPHASIZED
  123|      0|#define FLAG_DONT_SWITCH_TRANSLATOR  0x1000
  124|      0|#define FLAG_SUFFIX_REMOVED  0x2000
  125|      0|#define FLAG_HYPHEN_AFTER    0x4000
  126|      0|#define FLAG_ORDINAL       0x8000   // passed to TranslateNumber() to indicate an ordinal number
  127|      0|#define FLAG_HAS_DOT       0x10000  // dot after this word
  128|      0|#define FLAG_COMMA_AFTER   0x20000  // comma after this word
  129|      0|#define FLAG_MULTIPLE_SPACES 0x40000  // word is preceded by multiple spaces, newline, or tab
  130|      0|#define FLAG_INDIVIDUAL_DIGITS 0x80000  // speak number as individual digits
  131|      0|#define FLAG_DELETE_WORD     0x100000   // don't speak this word, it has been spoken as part of the previous word
  132|      0|#define FLAG_CHAR_REPLACED   0x200000   // characters have been replaced by .replace in the *_rules
  133|      0|#define FLAG_TRANSLATOR2     0x400000   // retranslating using a different language
  134|      0|#define FLAG_PREFIX_REMOVED  0x800000   // a prefix has been removed from this word
  135|       |
  136|      0|#define FLAG_SUFFIX_VOWEL  0x08000000 // remember an initial vowel from the suffix
  137|      0|#define FLAG_NO_TRACE      0x10000000 // passed to TranslateRules() to suppress dictionary lookup printout
  138|      0|#define FLAG_NO_PREFIX     0x20000000
  139|      0|#define FLAG_UNPRON_TEST   0x80000000 // do unpronounability test on the beginning of the word
  140|       |
  141|       |// prefix/suffix flags (bits 8 to 14, bits 16 to 22) don't use 0x8000, 0x800000
  142|      0|#define SUFX_E        0x0100   // e may have been added
  143|      0|#define SUFX_I        0x0200   // y may have been changed to i
  144|      0|#define SUFX_P        0x0400   // prefix
  145|      0|#define SUFX_V        0x0800   // suffix means use the verb form pronunciation
  146|      0|#define SUFX_D        0x1000   // previous letter may have been doubled
  147|      0|#define SUFX_F        0x2000   // verb follows
  148|      0|#define SUFX_Q        0x4000   // don't retranslate
  149|      0|#define SUFX_T        0x10000   // don't affect the stress position in the stem
  150|      0|#define SUFX_B        0x20000  // break, this character breaks the word into stem and suffix (used with SUFX_P)
  151|      0|#define SUFX_A        0x40000  // remember that the suffix starts with a vowel
  152|      0|#define SUFX_M        0x80000  // bit 19, allow multiple suffixes
  153|       |
  154|      0|#define SUFX_UNPRON     0x8000   // used to return $unpron flag from *_rules
  155|       |
  156|      0|#define FLAG_ALLOW_TEXTMODE  0x02  // allow dictionary to translate to text rather than phonemes
  157|      0|#define FLAG_SUFX       0x04
  158|      0|#define FLAG_SUFX_S     0x08
  159|      0|#define FLAG_SUFX_E_ADDED 0x10
  160|       |
  161|       |// codes in dictionary rules
  162|      0|#define RULE_PRE         1
  163|      0|#define RULE_POST        2
  164|      0|#define RULE_PHONEMES    3
  165|      0|#define RULE_PH_COMMON   4 // At start of rule. Its phoneme string is used by subsequent rules
  166|      0|#define RULE_CONDITION   5 // followed by condition number (byte)
  167|      0|#define RULE_GROUP_START 6
  168|      0|#define RULE_GROUP_END   7
  169|      0|#define RULE_PRE_ATSTART 8 // as RULE_PRE but also match with 'start of word'
  170|      0|#define RULE_LINENUM     9 // next 2 bytes give a line number, for debugging purposes
  171|       |
  172|      0|#define RULE_STRESSED     10 // &
  173|      0|#define RULE_DOUBLE       11 // %
  174|      0|#define RULE_INC_SCORE    12 // +
  175|      0|#define RULE_DEL_FWD      13 // #
  176|      0|#define RULE_ENDING       14 // S
  177|      0|#define RULE_DIGIT        15 // D digit
  178|      0|#define RULE_NONALPHA     16 // Z non-alpha
  179|      0|#define RULE_LETTERGP     17 // A B C H F G Y   letter group number
  180|      0|#define RULE_LETTERGP2    18 // L + letter group number
  181|      0|#define RULE_CAPITAL      19 // !   word starts with a capital letter
  182|      0|#define RULE_REPLACEMENTS 20 // section for character replacements
  183|      0|#define RULE_SYLLABLE     21 // @
  184|      0|#define RULE_SKIPCHARS    23 // J
  185|      0|#define RULE_NO_SUFFIX    24 // N
  186|      0|#define RULE_NOTVOWEL     25 // K
  187|      0|#define RULE_IFVERB       26 // V
  188|      0|#define RULE_DOLLAR       28 // $ commands
  189|      0|#define RULE_NOVOWELS     29 // X no vowels up to word boundary
  190|      0|#define RULE_SPELLING     31 // W while spelling letter-by-letter
  191|      0|#define RULE_LAST_RULE    31
  192|       |// Rule codes above 31 are the ASCII code representation of the character
  193|       |// used to specify the rule.
  194|      0|#define RULE_SPACE        32 // ascii space
  195|      0|#define RULE_DEC_SCORE    60 // <
  196|       |
  197|      0|#define DOLLAR_UNPR     0x01
  198|      0|#define DOLLAR_NOPREFIX 0x02
  199|      0|#define DOLLAR_LIST     0x03
  200|       |
  201|      0|#define LETTERGP_A      0
  202|      0|#define LETTERGP_B      1
  203|      0|#define LETTERGP_C      2
  204|      0|#define LETTERGP_H      3
  205|      0|#define LETTERGP_F      4
  206|      0|#define LETTERGP_G      5
  207|      0|#define LETTERGP_Y      6
  208|      0|#define LETTERGP_VOWEL2 7
  209|       |
  210|       |// Punctuation types returned by ReadClause()
  211|       |//@{
  212|       |
  213|      0|#define CLAUSE_PAUSE                  0x00000FFF // pause (x 10mS)
  214|      0|#define CLAUSE_INTONATION_TYPE        0x00007000 // intonation type
  215|      0|#define CLAUSE_OPTIONAL_SPACE_AFTER   0x00008000 // don't need space after the punctuation
  216|       |#define CLAUSE_TYPE                   0x000F0000 // phrase type
  217|      0|#define CLAUSE_PUNCTUATION_IN_WORD    0x00100000 // punctuation character can be inside a word (Armenian)
  218|      0|#define CLAUSE_SPEAK_PUNCTUATION_NAME 0x00200000 // speak the name of the punctuation character
  219|      0|#define CLAUSE_DOT_AFTER_LAST_WORD    0x00400000 // dot after the last word
  220|      0|#define CLAUSE_PAUSE_LONG             0x00800000 // x 320mS to the CLAUSE_PAUSE value
  221|       |
  222|      0|#define CLAUSE_INTONATION_FULL_STOP   0x00000000
  223|      0|#define CLAUSE_INTONATION_COMMA       0x00001000
  224|      0|#define CLAUSE_INTONATION_QUESTION    0x00002000
  225|      0|#define CLAUSE_INTONATION_EXCLAMATION 0x00003000
  226|      0|#define CLAUSE_INTONATION_NONE        0x00004000
  227|       |
  228|      0|#define CLAUSE_TYPE_NONE              0x00000000
  229|      0|#define CLAUSE_TYPE_EOF               0x00010000
  230|      0|#define CLAUSE_TYPE_VOICE_CHANGE      0x00020000
  231|      0|#define CLAUSE_TYPE_CLAUSE            0x00040000
  232|      0|#define CLAUSE_TYPE_SENTENCE          0x00080000
  233|       |
  234|      0|#define CLAUSE_NONE        ( 0 | CLAUSE_INTONATION_NONE        | CLAUSE_TYPE_NONE)
  235|      0|#define CLAUSE_PARAGRAPH   (70 | CLAUSE_INTONATION_FULL_STOP   | CLAUSE_TYPE_SENTENCE)
  236|      0|#define CLAUSE_EOF         (40 | CLAUSE_INTONATION_FULL_STOP   | CLAUSE_TYPE_SENTENCE | CLAUSE_TYPE_EOF)
  237|      0|#define CLAUSE_VOICE       ( 0 | CLAUSE_INTONATION_NONE        | CLAUSE_TYPE_VOICE_CHANGE)
  238|      0|#define CLAUSE_PERIOD      (40 | CLAUSE_INTONATION_FULL_STOP   | CLAUSE_TYPE_SENTENCE)
  239|      0|#define CLAUSE_COMMA       (20 | CLAUSE_INTONATION_COMMA       | CLAUSE_TYPE_CLAUSE)
  240|      0|#define CLAUSE_SHORTCOMMA  ( 4 | CLAUSE_INTONATION_COMMA       | CLAUSE_TYPE_CLAUSE)
  241|      0|#define CLAUSE_SHORTFALL   ( 4 | CLAUSE_INTONATION_FULL_STOP   | CLAUSE_TYPE_CLAUSE)
  242|      0|#define CLAUSE_QUESTION    (40 | CLAUSE_INTONATION_QUESTION    | CLAUSE_TYPE_SENTENCE)
  243|      0|#define CLAUSE_EXCLAMATION (45 | CLAUSE_INTONATION_EXCLAMATION | CLAUSE_TYPE_SENTENCE)
  244|      0|#define CLAUSE_COLON       (30 | CLAUSE_INTONATION_FULL_STOP   | CLAUSE_TYPE_CLAUSE)
  245|      0|#define CLAUSE_SEMICOLON   (30 | CLAUSE_INTONATION_COMMA       | CLAUSE_TYPE_CLAUSE)
  246|       |
  247|       |//@}
  248|       |
  249|      0|#define SAYAS_CHARS        0x12
  250|      0|#define SAYAS_GLYPHS       0x13
  251|      0|#define SAYAS_SINGLE_CHARS 0x14
  252|      0|#define SAYAS_KEY          0x24
  253|      0|#define SAYAS_DIGITS       0x40 // + number of digits
  254|      0|#define SAYAS_DIGITS1      0xc1
  255|       |
  256|      0|#define CHAR_EMPHASIS    0x0530 // this is an unused character code
  257|      0|#define CHAR_COMMA_BREAK 0x0557 // unused character code
  258|       |
  259|       |// Rule:
  260|       |// [4] [match] [1 pre] [2 post] [3 phonemes] 0
  261|       |//     match 1 pre 2 post 0     - use common phoneme string
  262|       |//     match 1 pre 2 post 3 0   - empty phoneme string
  263|       |
  264|       |// used to mark words with the source[] buffer
  265|       |typedef struct {
  266|       |	unsigned int flags;
  267|       |	unsigned short start;
  268|       |	unsigned char pre_pause;
  269|       |	unsigned short sourceix;
  270|       |	unsigned char length;
  271|       |} WORD_TAB;
  272|       |
  273|       |typedef struct {
  274|       |	const char *name;
  275|       |	int offset;
  276|       |	unsigned short range_min, range_max;
  277|       |	int language;
  278|       |	int flags;
  279|       |} ALPHABET;
  280|       |
  281|       |// alphabet flags
  282|      0|#define AL_DONT_NAME    0x01 // don't speak the alphabet name
  283|      0|#define AL_NOT_LETTERS  0x02 // don't use the language for speaking letters
  284|      0|#define AL_WORDS        0x04 // use the language to speak words
  285|      0|#define AL_NOT_CODE     0x08 // don't speak the character code
  286|      0|#define AL_NO_SYMBOL    0x10 // don't repeat "symbol" or "character"
  287|       |
  288|       |#define N_LOPTS       22
  289|      0|#define LOPT_DIERESES  1
  290|       |// 1=remove [:] from unstressed syllables, 2= remove from unstressed or non-penultimate syllables
  291|       |// bit 4=0, if stress < 4,  bit 4=1, if not the highest stress in the word
  292|      0|#define LOPT_IT_LENGTHEN 2
  293|       |
  294|       |// 1=german
  295|      0|#define LOPT_PREFIXES 3
  296|       |
  297|       |// non-zero, change voiced/unoiced to match last consonant in a cluster
  298|       |// bit 0=use regressive voicing
  299|       |// bit 1=LANG=cz,bg  don't propagate over [v]
  300|       |// bit 2=don't propagate acress word boundaries
  301|       |// bit 3=LANG=pl,  propagate over liquids and nasals
  302|       |// bit 4=LANG=cz,sk  don't propagate to [v]
  303|       |// bit 8=devoice word-final consonants
  304|      0|#define LOPT_REGRESSIVE_VOICING 4
  305|       |
  306|       |// 0=default, 1=no check, other allow this character as an extra initial letter (default is 's')
  307|      0|#define LOPT_UNPRONOUNCABLE 5
  308|       |
  309|       |// increase this to prevent sonorants being shortened before shortened (eg. unstressed) vowels
  310|      0|#define LOPT_SONORANT_MIN 7
  311|       |
  312|       |// bit 0: don't break vowels at word boundary
  313|      0|#define LOPT_WORD_MERGE 8
  314|       |
  315|       |// max. amplitude for vowel at the end of a clause
  316|      0|#define LOPT_MAXAMP_EOC 9
  317|       |
  318|       |// bit 0=reduce even if phonemes are specified in the **_list file
  319|       |// bit 1=don't reduce the strongest vowel in a word which is marked 'unstressed'
  320|      0|#define LOPT_REDUCE 10
  321|       |
  322|       |// LANG=cs,sk  combine some prepositions with the following word, if the combination has N or fewer syllables
  323|       |// bits 0-3  N syllables
  324|       |// bit 4=only if the second word has $alt attribute
  325|       |// bit 5=not if the second word is end-of-sentence
  326|      0|#define LOPT_COMBINE_WORDS 11
  327|       |
  328|       |// 1 = stressed syllable is indicated by capitals
  329|      0|#define LOPT_CAPS_IN_WORD 13
  330|       |
  331|       |// bit 0=Italian "syntactic doubling" of consoants in the word after a word marked with $double attribute
  332|       |// bit 1=also after a word which ends with a stressed vowel
  333|      0|#define LOPT_IT_DOUBLING 14
  334|       |
  335|       |// Call ApplySpecialAttributes() if $alt or $alt2 is set for a word
  336|       |// bit 1: stressed syllable: $alt change [e],[o] to [E],[O],  $alt2 change [E],[O] to [e],[o]
  337|      0|#define LOPT_ALT 15
  338|       |
  339|       |// pause for bracket (default=4), also see LOPT_BRACKET_PAUSE_ANNOUNCED
  340|      0|#define LOPT_BRACKET_PAUSE 16
  341|       |
  342|       |// bit 1, don't break clause before annoucning . ? !
  343|      0|#define LOPT_ANNOUNCE_PUNCT 17
  344|       |
  345|       |// recognize long vowels (0 = don't recognize)
  346|      0|#define LOPT_LONG_VOWEL_THRESHOLD 18
  347|       |
  348|       |// bit 0:  Don't allow suffices if there is no previous syllable
  349|      0|#define LOPT_SUFFIX 19
  350|       |
  351|       |// bit 0  Apostrophe at start of word is part of the word
  352|       |// bit 1  Apostrophe at end of word is part of the word
  353|      0|#define LOPT_APOSTROPHE 20
  354|       |
  355|       |// pause when announcing bracket names (default=2), also see LOPT_BRACKET_PAUSE
  356|      0|#define LOPT_BRACKET_PAUSE_ANNOUNCED 21
  357|       |
  358|       |// stress_rule
  359|      0|#define STRESSPOSN_1L 0 // 1st syllable
  360|      0|#define STRESSPOSN_2L 1 // 2nd syllable
  361|      0|#define STRESSPOSN_2R 2 // penultimate
  362|      0|#define STRESSPOSN_1R 3 // final syllable
  363|      0|#define STRESSPOSN_3R 4 // antipenultimate
  364|      0|#define STRESSPOSN_SYLCOUNT 5 // stress depends on syllable count
  365|      0|#define STRESSPOSN_1RH 6 // last heaviest syllable, excluding final syllable
  366|      0|#define STRESSPOSN_1RU 7 // stress on the last syllable, before any explicitly unstressed syllable
  367|      0|#define STRESSPOSN_2LLH 8 // first syllable, unless it is a light syllable followed by a heavy syllable
  368|      0|#define STRESSPOSN_ALL 9 // mark all stressed
  369|      0|#define STRESSPOSN_GREENLANDIC 12
  370|      0|#define STRESSPOSN_1SL 13 // 1st syllable, unless 1st vowel is short and 2nd is long
  371|      0|#define STRESSPOSN_EU 15 // If more than 2 syllables: primary stress in second syllable and secondary on last.
  372|       |
  373|       |typedef struct {
  374|       |// bits0-2  separate words with (1=pause_vshort, 2=pause_short, 3=pause, 4=pause_long 5=[?] phonemme)
  375|       |// bit 3=don't use linking phoneme
  376|       |// bit4=longer pause before STOP, VSTOP,FRIC
  377|       |// bit5=length of a final vowel doesn't depend on the next phoneme
  378|       |	int word_gap;
  379|       |	int vowel_pause;
  380|       |	int stress_rule; // see #defines for STRESSPOSN_*
  381|       |
  382|      0|#define S_NO_DIM            0x02
  383|      0|#define S_FINAL_DIM         0x04
  384|      0|#define S_FINAL_DIM_ONLY    0x06
  385|       |// bit1=don't set diminished stress,
  386|       |// bit2=mark unstressed final syllables as diminished
  387|       |
  388|       |// bit3=set consecutive unstressed syllables in unstressed words to diminished, but not in stressed words
  389|       |
  390|      0|#define S_FINAL_NO_2        0x10
  391|       |// bit4=don't allow secondary stress on last syllable
  392|       |
  393|      0|#define S_NO_AUTO_2         0x20
  394|       |// bit5-don't use automatic secondary stress
  395|       |
  396|      0|#define S_2_TO_HEAVY        0x40
  397|       |// bit6=light syllable followed by heavy, move secondary stress to the heavy syllable. LANG=Finnish
  398|       |
  399|      0|#define S_FIRST_PRIMARY     0x80
  400|       |// bit7=if more than one primary stress, make the subsequent primaries to secondary stress
  401|       |
  402|      0|#define S_FINAL_VOWEL_UNSTRESSED    0x100
  403|       |// bit8=don't apply default stress to a word-final vowel
  404|       |
  405|      0|#define S_FINAL_SPANISH     0x200
  406|       |// bit9=stress last syllable if it doesn't end in vowel or "s" or "n"  LANG=Spanish
  407|       |
  408|      0|#define S_2_SYL_2           0x1000
  409|       |// bit12= In a 2-syllable word, if one has primary stress then give the other secondary stress
  410|       |
  411|      0|#define S_INITIAL_2         0x2000
  412|       |// bit13= If there is only one syllable before the primary stress, give it a secondary stress
  413|       |
  414|      0|#define S_MID_DIM           0x10000
  415|       |// bit 16= Set (not first or last) syllables to diminished stress
  416|       |
  417|      0|#define S_PRIORITY_STRESS   0x20000
  418|       |// bit17= "priority" stress reduces other primary stress to "unstressed" not "secondary"
  419|       |
  420|      0|#define S_EO_CLAUSE1        0x40000
  421|       |// bit18= don't lengthen short vowels more than long vowels at end-of-clause
  422|       |
  423|      0|#define S_FINAL_LONG         0x80000
  424|       |// bit19=stress on final syllable if it has a long vowel, but previous syllable has a short vowel
  425|       |
  426|       |
  427|      0|#define S_HYPEN_UNSTRESS    0x100000
  428|       |// bit20= hyphenated words, 2nd part is unstressed
  429|       |
  430|      0|#define S_NO_EOC_LENGTHEN   0x200000
  431|       |// bit21= don't lengthen vowels at end-of-clause
  432|       |
  433|       |// bit15= Give stress to the first unstressed syllable
  434|       |
  435|       |	int stress_flags;
  436|       |	int unstressed_wd1; // stress for $u word of 1 syllable
  437|       |	int unstressed_wd2; // stress for $u word of >1 syllable
  438|       |	int param[N_LOPTS];
  439|       |	unsigned char *length_mods;
  440|       |	unsigned char *length_mods0;
  441|       |
  442|      0|#define NUM_DEFAULT           0x00000001 // enable number processing; use if no other NUM_ option is specified
  443|      0|#define NUM_THOUS_SPACE       0x00000004 // thousands separator must be space
  444|      0|#define NUM_DECIMAL_COMMA     0x00000008 // , decimal separator, not .
  445|      0|#define NUM_SWAP_TENS         0x00000010 // use three-and-twenty rather than twenty-three
  446|      0|#define NUM_AND_UNITS         0x00000020 // 'and' between tens and units
  447|      0|#define NUM_HUNDRED_AND       0x00000040 // add "and" after hundred or thousand
  448|      0|#define NUM_SINGLE_AND        0x00000080 // don't have "and" both after hundreds and also between tens and units
  449|      0|#define NUM_SINGLE_STRESS     0x00000100 // only one primary stress in tens+units
  450|      0|#define NUM_SINGLE_VOWEL      0x00000200 // only one vowel between tens and units
  451|      0|#define NUM_OMIT_1_HUNDRED    0x00000400 // omit "one" before "hundred"
  452|      0|#define NUM_1900              0x00000800 // say 19** as nineteen hundred
  453|      0|#define NUM_ALLOW_SPACE       0x00001000 // allow space as thousands separator (in addition to langopts.thousands_sep)
  454|      0|#define NUM_DFRACTION_BITS    0x0000e000 // post-decimal-digits 0=single digits, 1=(LANG=it) 2=(LANG=pl) 3=(LANG=ro)
  455|      0|#define NUM_ORDINAL_DOT       0x00010000 // dot after number indicates ordinal
  456|      0|#define NUM_NOPAUSE           0x00020000 // don't add pause after a number
  457|      0|#define NUM_AND_HUNDRED       0x00040000 // 'and' before hundreds
  458|      0|#define NUM_THOUSAND_AND      0x00080000 // 'and' after thousands if there are no hundreds
  459|      0|#define NUM_VIGESIMAL         0x00100000 // vigesimal number, if tens are not found
  460|      0|#define NUM_OMIT_1_THOUSAND   0x00200000 // omit "one" before "thousand"
  461|      0|#define NUM_ZERO_HUNDRED      0x00400000 // say "zero" before hundred
  462|      0|#define NUM_HUNDRED_AND_DIGIT 0x00800000 // add "and" after hundreds and thousands, only if there are digits and no tens
  463|      0|#define NUM_ROMAN             0x01000000 // recognize roman numbers
  464|      0|#define NUM_ROMAN_CAPITALS    0x02000000 // Roman numbers only if upper case
  465|      0|#define NUM_ROMAN_AFTER       0x04000000 // say "roman" after the number, not before
  466|      0|#define NUM_ROMAN_ORDINAL     0x08000000 // Roman numbers are ordinal numbers
  467|      0|#define NUM_SINGLE_STRESS_L   0x10000000 // only one primary stress in tens+units (on the tens)
  468|       |
  469|      0|#define NUM_DFRACTION_1       0x00002000
  470|      0|#define NUM_DFRACTION_2       0x00004000
  471|      0|#define NUM_DFRACTION_3       0x00006000
  472|      0|#define NUM_DFRACTION_4       0x00008000
  473|      0|#define NUM_DFRACTION_5       0x0000a000
  474|      0|#define NUM_DFRACTION_6       0x0000c000
  475|      0|#define NUM_DFRACTION_7       0x0000e000    // lang=si, alternative form of number for decimal fraction digits (except the last)
  476|       |
  477|       |	int numbers;
  478|       |
  479|      0|#define NUM2_THOUSANDS_VAR_BITS    0x000001c0 // use different forms of thousand, million, etc (M MA MB)
  480|      0|#define NUM2_SWAP_THOUSANDS        0x00000200 // say "thousand" and "million" before its number, not after
  481|      0|#define NUM2_ORDINAL_NO_AND        0x00000800 // don't say 'and' between tens and units for ordinal numbers
  482|      0|#define NUM2_MULTIPLE_ORDINAL      0x00001000 // use ordinal form of hundreds and tens as well as units
  483|      0|#define NUM2_NO_TEEN_ORDINALS      0x00002000 // don't use 11-19 numbers to make ordinals
  484|      0|#define NUM2_MYRIADS               0x00004000 // use myriads (groups of 4 digits) not thousands (groups of 3)
  485|      0|#define NUM2_ENGLISH_NUMERALS      0x00008000 // speak (non-replaced) English numerals in English
  486|      0|#define NUM2_PERCENT_BEFORE        0x00010000 // say "%" before the number
  487|      0|#define NUM2_OMIT_1_HUNDRED_ONLY   0x00020000 // omit "one" before hundred only if there are no previous digits
  488|      0|#define NUM2_ORDINAL_AND_THOUSANDS 0x00040000 // same variant for ordinals and thousands (#o = #a)
  489|      0|#define NUM2_ORDINAL_DROP_VOWEL    0x00080000 // drop final vowel from cardial number before adding ordinal suffix (currently only tens and units)
  490|      0|#define NUM2_ZERO_TENS             0x00100000 // say zero tens
  491|       |
  492|      0|#define NUM2_THOUSANDPLEX_VAR_THOUSANDS 0x00000002
  493|      0|#define NUM2_THOUSANDPLEX_VAR_MILLIARDS 0x00000008
  494|      0|#define NUM2_THOUSANDPLEX_VAR_ALL       0x0000001e
  495|       |
  496|      0|#define NUM2_THOUSANDS_VAR1        0x00000040
  497|      0|#define NUM2_THOUSANDS_VAR2        0x00000080
  498|      0|#define NUM2_THOUSANDS_VAR3        0x000000c0
  499|      0|#define NUM2_THOUSANDS_VAR4        0x00000100 // plural forms for millions, etc.
  500|      0|#define NUM2_THOUSANDS_VAR5        0x00000140
  501|       |
  502|       |	int numbers2;
  503|       |
  504|       |// Bit 2^n is set if 10^n separates a number grouping (max n=31).
  505|       |//                                      0         1         2         3
  506|       |//                                  n = 01234567890123456789012345678901
  507|      0|#define BREAK_THOUSANDS   0x49249248 // b  b  b  b  b  b  b  b  b  b  b  // 10,000,000,000,000,000,000,000,000,000,000
  508|      0|#define BREAK_MYRIADS     0x11111110 // b   b   b   b   b   b   b   b    // 1000,0000,0000,0000,0000,0000,0000,0000
  509|      0|#define BREAK_LAKH        0xaaaaaaa8 // b  b b b b b b b b b b b b b b b // 10,00,00,00,00,00,00,00,00,00,00,00,00,00,00,000
  510|      0|#define BREAK_LAKH_BN     0x24924aa8 // b  b b b b b  b  b  b  b  b  b   // 100,000,000,000,000,000,000,00,00,00,00,000
  511|      0|#define BREAK_LAKH_DV     0x000014a8 // b  b b b  b b                    // 100,00,000,00,00,000
  512|      0|#define BREAK_LAKH_HI     0x00014aa8 // b  b b b b b  b b                // 100,00,000,00,00,00,00,000
  513|      0|#define BREAK_LAKH_UR     0x000052a8 // b  b b b b  b b                  // 100,00,000,00,00,00,000
  514|      0|#define BREAK_INDIVIDUAL  0x00000018 // b  bb                            // 100,0,000
  515|       |
  516|       |	int break_numbers;  // which digits to break the number into thousands, millions, etc (Hindi has 100,000 not 1,000,000)
  517|       |	int max_roman;
  518|       |	int min_roman;
  519|       |	int thousands_sep;
  520|       |	int decimal_sep;
  521|       |	int max_digits;    // max number of digits which can be spoken as an integer number (rather than individual digits)
  522|       |	const char *ordinal_indicator;   // UTF-8 string
  523|       |	const unsigned char *roman_suffix;    // add this (ordinal) suffix to Roman numbers (LANG=an)
  524|       |
  525|       |	// bit 0, accent name before the letter name, bit 1 "capital" after letter name
  526|       |	int accents;
  527|       |
  528|       |	int tone_language;          // 1=tone language
  529|       |	int intonation_group;
  530|       |	unsigned char tunes[6];
  531|       |	int long_stop;          // extra mS pause for a lengthened stop
  532|       |	char max_initial_consonants;
  533|       |	char spelling_stress;   // 0=default, 1=stress first letter
  534|       |	char tone_numbers;
  535|       |	char ideographs;      // treat as separate words
  536|       |	bool textmode;          // the meaning of FLAG_TEXTMODE is reversed (to save data when *_list file is compiled)
  537|       |	char dotless_i;         // uses letter U+0131
  538|       |	int listx;    // compile *_listx after *list
  539|       |	const unsigned char *replace_chars;      // characters to be substitutes
  540|       |	int our_alphabet;           // offset for main alphabet (if not set in letter_bits_offset)
  541|       |	int alt_alphabet;       // offset for another language to recognize
  542|       |	int alt_alphabet_lang;  // language for the alt_alphabet
  543|       |	int max_lengthmod;
  544|       |	int lengthen_tonic;   // lengthen the tonic syllable
  545|       |	int suffix_add_e;      // replace a suffix (which has the SUFX_E flag) with this character
  546|       |	bool lowercase_sentence;	// when true, a period . causes a sentence stop even if next character is lowercase
  547|       |} LANGUAGE_OPTIONS;
  548|       |
  549|       |typedef struct {
  550|       |	LANGUAGE_OPTIONS langopts;
  551|       |	int translator_name;
  552|       |	int transpose_max;
  553|       |	int transpose_min;
  554|       |	const char *transpose_map;
  555|       |	char dictionary_name[40];
  556|       |
  557|       |	char phonemes_repeat[20];
  558|       |	int phonemes_repeat_count;
  559|       |	int phoneme_tab_ix;
  560|       |
  561|       |	unsigned char stress_amps[8];
  562|       |	short stress_lengths[8];
  563|       |	int dict_condition;    // conditional apply some pronunciation rules and dict.lookups
  564|       |	int dict_min_size;
  565|       |	espeak_ng_ENCODING encoding;
  566|       |	const wchar_t *char_plus_apostrophe;  // single chars + apostrophe treated as words
  567|       |	const wchar_t *punct_within_word;   // allow these punctuation characters within words
  568|       |	const unsigned short *chars_ignore;
  569|       |
  570|       |// holds properties of characters: vowel, consonant, etc for pronunciation rules
  571|       |	unsigned char letter_bits[256];
  572|       |	int letter_bits_offset;
  573|       |	const wchar_t *letter_groups[8];
  574|       |
  575|       |	/* index1=option, index2 by 0=. 1=, 2=?, 3=! 4=none */
  576|      0|	#define INTONATION_TYPES 8
  577|       |	#define PUNCT_INTONATIONS 6
  578|       |	unsigned char punct_to_tone[INTONATION_TYPES][PUNCT_INTONATIONS];
  579|       |
  580|       |	char *data_dictrules;     // language_1   translation rules file
  581|       |	char *data_dictlist;      // language_2   dictionary lookup file
  582|       |	char *dict_hashtab[N_HASH_DICT];   // hash table to index dictionary lookup file
  583|       |	char *letterGroups[N_LETTER_GROUPS];
  584|       |
  585|       |	// groups1 and groups2 are indexes into data_dictrules, set up by InitGroups()
  586|       |	// the two-letter rules for each letter must be consecutive in the language_rules source
  587|       |
  588|       |	char *groups1[256];         // translation rule lists, index by single letter
  589|       |	char *groups3[128];         // index by offset letter
  590|       |	char *groups2[N_RULE_GROUP2];   // translation rule lists, indexed by two-letter pairs
  591|       |	unsigned int groups2_name[N_RULE_GROUP2];  // the two letter pairs for groups2[]
  592|       |	int n_groups2;              // number of groups2[] entries used
  593|       |
  594|       |	unsigned char groups2_count[256];    // number of 2 letter groups for this initial letter
  595|       |	unsigned char groups2_start[256];    // index into groups2
  596|       |	const short *frequent_pairs;   // list of frequent pairs of letters, for use in compressed *_list
  597|       |
  598|       |	int expect_verb;
  599|       |	int expect_past;    // expect past tense
  600|       |	int expect_verb_s;
  601|       |	int expect_noun;
  602|       |	int prev_last_stress;
  603|       |	char *clause_end;
  604|       |
  605|       |	int word_vowel_count;     // number of vowels so far
  606|       |	int word_stressed_count;  // number of vowels so far which could be stressed
  607|       |
  608|       |	int clause_upper_count;   // number of upper case letters in the clause
  609|       |	int clause_lower_count;   // number of lower case letters in the clause
  610|       |
  611|       |	int prepause_timeout;
  612|       |	int end_stressed_vowel;  // word ends with stressed vowel
  613|       |	int prev_dict_flags[2];     // dictionary flags from previous word
  614|       |	int clause_terminator;
  615|       |
  616|       |} Translator;
  617|       |
  618|      0|#define OPTION_EMPHASIZE_ALLCAPS  0x100
  619|      0|#define OPTION_EMPHASIZE_PENULTIMATE 0x200
  620|       |extern int option_tone_flags;
  621|       |extern int option_phonemes;
  622|       |extern int option_phoneme_events;
  623|       |extern int option_linelength;     // treat lines shorter than this as end-of-clause
  624|       |extern int option_capitals;
  625|       |extern int option_punctuation;
  626|       |extern int option_endpause;
  627|       |extern int option_ssml;
  628|       |extern int option_phoneme_input;   // allow [[phonemes]] in input text
  629|       |extern int option_sayas;
  630|       |extern int option_wordgap;
  631|       |
  632|       |extern int count_characters;
  633|       |extern int count_sentences;
  634|       |extern int skip_characters;
  635|       |extern int skip_words;
  636|       |extern int skip_sentences;
  637|       |extern bool skipping_text;
  638|       |extern int end_character_position;
  639|       |extern int clause_start_char;
  640|       |extern int clause_start_word;
  641|       |extern char *namedata;
  642|       |extern int pre_pause;
  643|       |
  644|       |#define N_MARKER_LENGTH 50   // max.length of a mark name
  645|       |extern char skip_marker[N_MARKER_LENGTH];
  646|       |
  647|      0|#define N_PUNCTLIST  60
  648|       |extern wchar_t option_punctlist[N_PUNCTLIST];  // which punctuation characters to announce
  649|       |
  650|       |extern Translator *translator;
  651|       |extern Translator *translator2;
  652|       |extern char dictionary_name[40];
  653|       |extern espeak_ng_TEXT_DECODER *p_decoder;
  654|       |extern int dictionary_skipwords;
  655|       |
  656|       |extern int (*uri_callback)(int, const char *, const char *);
  657|       |extern int (*phoneme_callback)(const char *);
  658|       |
  659|      0|#define LEADING_2_BITS 0xC0 // 0b11000000
  660|      0|#define UTF8_TAIL_BITS 0x80 // 0b10000000
  661|       |
  662|       |ESPEAK_NG_API int utf8_in(int *c, const char *buf);
  663|       |int utf8_in2(int *c, const char *buf, int backwards);
  664|       |int utf8_out(unsigned int c, char *buf);
  665|       |int utf8_nbytes(const char *buf);
  666|       |
  667|       |int lookupwchar(const unsigned short *list, int c);
  668|       |int lookupwchar2(const unsigned short *list, int c);
  669|       |char *strchr_w(const char *s, int c);
  670|       |int IsBracket(int c);
  671|       |void InitNamedata(void);
  672|       |void InitText(int flags);
  673|       |void InitText2(void);
  674|       |int IsDigit(unsigned int c);
  675|       |int IsDigit09(unsigned int c);
  676|       |int IsAlpha(unsigned int c);
  677|       |int isspace2(unsigned int c);
  678|       |ALPHABET *AlphabetFromChar(int c);
  679|       |
  680|       |Translator *SelectTranslator(const char *name);
  681|       |int SetTranslator2(const char *name);
  682|       |void DeleteTranslator(Translator *tr);
  683|       |void ProcessLanguageOptions(LANGUAGE_OPTIONS *langopts);
  684|       |
  685|       |void print_dictionary_flags(unsigned int *flags, char *buf, int buf_len);
  686|       |
  687|       |void ApplySpecialAttribute2(Translator *tr, char *phonemes, int dict_flags);
  688|       |
  689|       |int TranslateWord(Translator *tr, char *word1, WORD_TAB *wtab, char *word_out);
  690|       |void TranslateClause(Translator *tr, int *tone, char **voice_change);
  691|       |
  692|       |void SetVoiceStack(espeak_VOICE *v, const char *variant_name);
  693|       |
  694|       |extern FILE *f_trans; // for logging
  695|       |
  696|       |#ifdef __cplusplus
  697|       |}
  698|       |#endif
  699|       |
  700|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/voice.h:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2007 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#ifndef ESPEAK_NG_VOICE_H
   21|       |#define ESPEAK_NG_VOICE_H
   22|       |
   23|       |#include <espeak-ng/espeak_ng.h>
   24|       |
   25|       |#ifdef __cplusplus
   26|       |extern "C"
   27|       |{
   28|       |#endif
   29|       |
   30|      0|#define N_PEAKS   9
   31|       |
   32|       |typedef struct {
   33|       |	char v_name[40];
   34|       |	char language_name[20];
   35|       |
   36|       |	int phoneme_tab_ix; // phoneme table number
   37|       |	int pitch_base; // Hz<<12
   38|       |	int pitch_range; // standard = 0x1000
   39|       |
   40|       |	int speedf1;
   41|       |	int speedf2;
   42|       |	int speedf3;
   43|       |
   44|       |	int speed_percent;      // adjust the WPM speed by this percentage
   45|       |	int flutter;
   46|       |	int roughness;
   47|       |	int echo_delay;
   48|       |	int echo_amp;
   49|       |	int n_harmonic_peaks;  // highest formant which is formed from adding harmonics
   50|       |	int peak_shape;        // alternative shape for formant peaks (0=standard 1=squarer)
   51|       |	int voicing;           // 100% = 64, level of formant-synthesized sound
   52|       |	int formant_factor;    // adjust nominal formant frequencies by this  because of the voice's pitch (256ths)
   53|       |	int consonant_amp;     // amplitude of unvoiced consonants
   54|       |	int consonant_ampv;    // amplitude of the noise component of voiced consonants
   55|       |	int samplerate;
   56|       |	int klattv[8];
   57|       |
   58|       |	// parameters used by Wavegen
   59|       |	short freq[N_PEAKS];    // 100% = 256
   60|       |	short height[N_PEAKS];  // 100% = 256
   61|       |	short width[N_PEAKS];   // 100% = 256
   62|       |	short freqadd[N_PEAKS]; // Hz
   63|       |
   64|       |	// copies without temporary adjustments from embedded commands
   65|       |	short freq2[N_PEAKS];    // 100% = 256
   66|       |	short height2[N_PEAKS];  // 100% = 256
   67|       |
   68|       |	int breath[N_PEAKS];  // amount of breath for each formant. breath[0] indicates whether any are set.
   69|       |	int breathw[N_PEAKS]; // width of each breath formant
   70|       |
   71|       |	// This table provides the opportunity for tone control.
   72|       |	// Adjustment of harmonic amplitudes, steps of 8Hz
   73|       |	// value of 128 means no change
   74|      0|	#define N_TONE_ADJUST  1000
   75|       |	unsigned char tone_adjust[N_TONE_ADJUST];   //  8Hz steps * 1000 = 8kHz
   76|       |
   77|       |} voice_t;
   78|       |
   79|       |extern espeak_VOICE current_voice_selected;
   80|       |
   81|       |extern voice_t *voice;
   82|       |extern int tone_points[12];
   83|       |
   84|       |const char *SelectVoice(espeak_VOICE *voice_select, int *found);
   85|       |espeak_VOICE *SelectVoiceByName(espeak_VOICE **voices, const char *name);
   86|       |voice_t *LoadVoice(const char *voice_name, int control);
   87|       |voice_t *LoadVoiceVariant(const char *voice_name, int variant);
   88|       |espeak_ng_STATUS DoVoiceChange(voice_t *v);
   89|       |void WavegenSetVoice(voice_t *v);
   90|       |void ReadTonePoints(char *string, int *tone_pts);
   91|       |void VoiceReset(int control);
   92|       |void FreeVoiceList(void);
   93|       |
   94|       |#ifdef __cplusplus
   95|       |}
   96|       |#endif
   97|       |
   98|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/voices.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2015 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2017 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |#include "config.h"
   21|       |
   22|       |#include <ctype.h>
   23|       |#include <wctype.h>
   24|       |#include <errno.h>
   25|       |#include <stdint.h>
   26|       |#include <stdio.h>
   27|       |#include <stdlib.h>
   28|       |#include <string.h>
   29|       |#include <strings.h>
   30|       |
   31|       |#if defined(_WIN32) || defined(_WIN64)
   32|       |#include <windows.h>
   33|       |#else
   34|       |#include <dirent.h>
   35|       |#endif
   36|       |
   37|       |#include <espeak-ng/espeak_ng.h>
   38|       |#include <espeak-ng/speak_lib.h>
   39|       |#include <espeak-ng/encoding.h>
   40|       |
   41|       |#include "voice.h"                    // for voice_t, DoVoiceChange, N_PEAKS
   42|       |#include "dictionary.h"               // for strncpy0, LoadDictionary
   43|       |#include "mnemonics.h"               // for LookupMnemName, MNEM_TAB
   44|       |#include "phoneme.h"                  // for REPLACE_PHONEMES, n_replace_pho...
   45|       |#include "speech.h"                   // for GetFileLength, PATHSEP
   46|       |#include "mbrola.h"                   // for LoadMbrolaTable
   47|       |#include "synthdata.h"                // for SelectPhonemeTableName, LookupP...
   48|       |#include "synthesize.h"               // for SetSpeed, SPEED_FACTORS, speed
   49|       |#include "translate.h"                // for LANGUAGE_OPTIONS, DeleteTranslator
   50|       |#include "wavegen.h"                  // for InitBreath
   51|       |
   52|       |MNEM_TAB genders[] = {
   53|       |	{ "male", ENGENDER_MALE },
   54|       |	{ "female", ENGENDER_FEMALE },
   55|       |	{ NULL, ENGENDER_MALE }
   56|       |};
   57|       |
   58|       |int tone_points[12] = { 600, 170, 1200, 135, 2000, 110, 3000, 110, -1, 0 };
   59|       |
   60|       |// limit the rate of change for each formant number
   61|       |static int formant_rate_22050[9] = { 240, 170, 170, 170, 170, 170, 170, 170, 170 }; // values for 22kHz sample rate
   62|       |int formant_rate[9]; // values adjusted for actual sample rate
   63|       |
   64|      0|#define DEFAULT_LANGUAGE_PRIORITY  5
   65|      0|#define N_VOICES_LIST  350
   66|       |static int n_voices_list = 0;
   67|       |static espeak_VOICE *voices_list[N_VOICES_LIST];
   68|       |
   69|       |espeak_VOICE current_voice_selected;
   70|       |
   71|       |enum {
   72|       |	V_NAME = 1,
   73|       |	V_LANGUAGE,
   74|       |	V_GENDER,
   75|       |	V_PHONEMES,
   76|       |	V_DICTIONARY,
   77|       |	V_VARIANTS,
   78|       |
   79|       |	V_MAINTAINER,
   80|       |	V_STATUS,
   81|       |
   82|       |	// these affect voice quality, are independent of language
   83|       |	V_FORMANT,
   84|       |	V_PITCH,
   85|       |	V_ECHO,
   86|       |	V_FLUTTER,
   87|       |	V_ROUGHNESS,
   88|       |	V_CLARITY,
   89|       |	V_TONE,
   90|       |	V_VOICING,
   91|       |	V_BREATH,
   92|       |	V_BREATHW,
   93|       |
   94|       |	// these override defaults set by the translator
   95|       |	V_LOWERCASE_SENTENCE,
   96|       |	V_WORDGAP,
   97|       |	V_INTONATION,
   98|       |	V_TUNES,
   99|       |	V_STRESSLENGTH,
  100|       |	V_STRESSAMP,
  101|       |	V_STRESSADD,
  102|       |	V_DICTRULES,
  103|       |	V_STRESSRULE,
  104|       |	V_STRESSOPT,
  105|       |	V_NUMBERS,
  106|       |
  107|       |	V_MBROLA,
  108|       |	V_KLATT,
  109|       |	V_FAST,
  110|       |	V_SPEED,
  111|       |	V_DICTMIN,
  112|       |
  113|       |	// these need a phoneme table to have been specified
  114|       |	V_REPLACE,
  115|       |	V_CONSONANTS
  116|       |};
  117|       |
  118|       |static MNEM_TAB keyword_tab[] = {
  119|       |	{ "name",         V_NAME },
  120|       |	{ "language",     V_LANGUAGE },
  121|       |	{ "gender",       V_GENDER },
  122|       |
  123|       |	{ "maintainer",   V_MAINTAINER },
  124|       |	{ "status",       V_STATUS },
  125|       |
  126|       |
  127|       |	{ "lowercaseSentence",	V_LOWERCASE_SENTENCE },
  128|       |	{ "variants",     V_VARIANTS },
  129|       |	{ "formant",      V_FORMANT },
  130|       |	{ "pitch",        V_PITCH },
  131|       |	{ "phonemes",     V_PHONEMES },
  132|       |	{ "dictionary",   V_DICTIONARY },
  133|       |	{ "stressLength", V_STRESSLENGTH },
  134|       |	{ "stressAmp",    V_STRESSAMP },
  135|       |	{ "stressAdd",    V_STRESSADD },
  136|       |	{ "intonation",   V_INTONATION },
  137|       |	{ "tunes",        V_TUNES },
  138|       |	{ "dictrules",    V_DICTRULES },
  139|       |	{ "stressRule",   V_STRESSRULE },
  140|       |	{ "stressOpt",    V_STRESSOPT },
  141|       |	{ "replace",      V_REPLACE },
  142|       |	{ "words",        V_WORDGAP },
  143|       |	{ "echo",         V_ECHO },
  144|       |	{ "flutter",      V_FLUTTER },
  145|       |	{ "roughness",    V_ROUGHNESS },
  146|       |	{ "clarity",      V_CLARITY },
  147|       |	{ "tone",         V_TONE },
  148|       |	{ "voicing",      V_VOICING },
  149|       |	{ "breath",       V_BREATH },
  150|       |	{ "breathw",      V_BREATHW },
  151|       |	{ "numbers",      V_NUMBERS },
  152|       |	{ "mbrola",       V_MBROLA },
  153|       |	{ "consonants",   V_CONSONANTS },
  154|       |	{ "klatt",        V_KLATT },
  155|       |	{ "fast_test2",   V_FAST },
  156|       |	{ "speed",        V_SPEED },
  157|       |	{ "dict_min",     V_DICTMIN },
  158|       |
  159|       |	// these just set a value in langopts.param[]
  160|       |	{ "l_dieresis",       0x100+LOPT_DIERESES },
  161|       |	{ "l_prefix",         0x100+LOPT_PREFIXES },
  162|       |	{ "l_regressive_v",   0x100+LOPT_REGRESSIVE_VOICING },
  163|       |	{ "l_unpronouncable", 0x100+LOPT_UNPRONOUNCABLE },
  164|       |	{ "l_sonorant_min",   0x100+LOPT_SONORANT_MIN },
  165|       |	{ "apostrophe",       0x100+LOPT_APOSTROPHE },
  166|       |	{ "brackets",       0x100+LOPT_BRACKET_PAUSE },
  167|       |	{ "bracketsAnnounced",       0x100+LOPT_BRACKET_PAUSE_ANNOUNCED },
  168|       |
  169|       |	{ NULL, 0 }
  170|       |};
  171|       |
  172|      0|#define N_VOICE_VARIANTS   12
  173|       |const char variants_either[N_VOICE_VARIANTS] = { 1, 2, 12, 3, 13, 4, 14, 5, 11, 0 };
  174|       |const char variants_male[N_VOICE_VARIANTS] = { 1, 2, 3, 4, 5, 6, 0 };
  175|       |const char variants_female[N_VOICE_VARIANTS] = { 11, 12, 13, 14, 0 };
  176|       |const char *variant_lists[3] = { variants_either, variants_male, variants_female };
  177|       |
  178|       |static voice_t voicedata;
  179|       |voice_t *voice = &voicedata;
  180|       |
  181|       |static char *fgets_strip(char *buf, int size, FILE *f_in)
  182|      0|{
  183|      0|	// strip trailing spaces, and truncate lines at // comment
  184|      0|	int len;
  185|      0|	char *p;
  186|      0|
  187|      0|	if (fgets(buf, size, f_in) == NULL)
  188|      0|		return NULL;
  189|      0|
  190|      0|	if (buf[0] == '#') {
  191|      0|		buf[0] = 0;
  192|      0|		return buf;
  193|      0|	}
  194|      0|
  195|      0|	len = strlen(buf);
  196|      0|	while ((--len > 0) && isspace(buf[len]))
  197|      0|		buf[len] = 0;
  198|      0|
  199|      0|	if ((p = strstr(buf, "//")) != NULL)
  200|      0|		*p = 0;
  201|      0|
  202|      0|	return buf;
  203|      0|}
  204|       |
  205|       |static int LookupTune(const char *name)
  206|      0|{
  207|      0|	int ix;
  208|      0|
  209|      0|	for (ix = 0; ix < n_tunes; ix++) {
  210|      0|		if (strcmp(name, tunes[ix].name) == 0)
  211|      0|			return ix;
  212|      0|	}
  213|      0|	return -1;
  214|      0|}
  215|       |
  216|       |static void SetToneAdjust(voice_t *voice, int *tone_pts)
  217|      0|{
  218|      0|	int ix;
  219|      0|	int pt;
  220|      0|	int y;
  221|      0|	int freq1 = 0;
  222|      0|	int freq2;
  223|      0|	int height1 = tone_pts[1];
  224|      0|	int height2;
  225|      0|	double rate;
  226|      0|
  227|      0|	for (pt = 0; pt < 12; pt += 2) {
  228|      0|		if (tone_pts[pt] == -1) {
  229|      0|			tone_pts[pt] = N_TONE_ADJUST*8;
  230|      0|			if (pt > 0)
  231|      0|				tone_pts[pt+1] = tone_pts[pt-1];
  232|      0|		}
  233|      0|		freq2 = tone_pts[pt] / 8; // 8Hz steps
  234|      0|		height2 = tone_pts[pt+1];
  235|      0|		if ((freq2 - freq1) > 0) {
  236|      0|			rate = (double)(height2-height1)/(freq2-freq1);
  237|      0|
  238|      0|			for (ix = freq1; ix < freq2; ix++) {
  239|      0|				y = height1 + (int)(rate * (ix-freq1));
  240|      0|				if (y > 255)
  241|      0|					y = 255;
  242|      0|				voice->tone_adjust[ix] = y;
  243|      0|			}
  244|      0|		}
  245|      0|		freq1 = freq2;
  246|      0|		height1 = height2;
  247|      0|	}
  248|      0|}
  249|       |
  250|       |void ReadTonePoints(char *string, int *tone_pts)
  251|      0|{
  252|      0|	// tone_pts[] is int[12]
  253|      0|	int ix;
  254|      0|
  255|      0|	for (ix = 0; ix < 12; ix++)
  256|      0|		tone_pts[ix] = -1;
  257|      0|
  258|      0|	sscanf(string, "%d %d %d %d %d %d %d %d %d %d",
  259|      0|	       &tone_pts[0], &tone_pts[1], &tone_pts[2], &tone_pts[3],
  260|      0|	       &tone_pts[4], &tone_pts[5], &tone_pts[6], &tone_pts[7],
  261|      0|	       &tone_pts[8], &tone_pts[9]);
  262|      0|}
  263|       |
  264|       |static espeak_VOICE *ReadVoiceFile(FILE *f_in, const char *fname, int is_language_file)
  265|      0|{
  266|      0|	// Read a Voice file, allocate a VOICE_DATA and set data from the
  267|      0|	// file's  language, gender, name  lines
  268|      0|
  269|      0|	char linebuf[120];
  270|      0|	char vname[80];
  271|      0|	char vgender[80];
  272|      0|	char vlanguage[80];
  273|      0|	char languages[300]; // allow space for several alternate language names and priorities
  274|      0|
  275|      0|	unsigned int len;
  276|      0|	int langix = 0;
  277|      0|	int n_languages = 0;
  278|      0|	char *p;
  279|      0|	espeak_VOICE *voice_data;
  280|      0|	int priority;
  281|      0|	int age;
  282|      0|	int n_variants = 4; // default, number of variants of this voice before using another voice
  283|      0|	int gender;
  284|      0|
  285|      0|	vname[0] = 0;
  286|      0|	vgender[0] = 0;
  287|      0|	age = 0;
  288|      0|
  289|      0|	while (fgets_strip(linebuf, sizeof(linebuf), f_in) != NULL) {
  290|      0|		// isolate the attribute name
  291|      0|		for (p = linebuf; (*p != 0) && !iswspace(*p); p++) ;
  292|      0|		*p++ = 0;
  293|      0|
  294|      0|		if (linebuf[0] == 0) continue;
  295|      0|
  296|      0|		switch (LookupMnem(keyword_tab, linebuf))
  297|      0|		{
  298|      0|		case V_NAME:
  299|      0|			while (isspace(*p)) p++;
  300|      0|			strncpy0(vname, p, sizeof(vname));
  301|      0|			break;
  302|      0|		case V_LANGUAGE:
  303|      0|			priority = DEFAULT_LANGUAGE_PRIORITY;
  304|      0|			vlanguage[0] = 0;
  305|      0|
  306|      0|			sscanf(p, "%s %d", vlanguage, &priority);
  307|      0|			len = strlen(vlanguage) + 2;
  308|      0|			// check for space in languages[]
  309|      0|			if (len < (sizeof(languages)-langix-1)) {
  310|      0|				languages[langix] = priority;
  311|      0|
  312|      0|				strcpy(&languages[langix+1], vlanguage);
  313|      0|				langix += len;
  314|      0|				n_languages++;
  315|      0|			}
  316|      0|			break;
  317|      0|		case V_GENDER:
  318|      0|			sscanf(p, "%s %d", vgender, &age);
  319|      0|			if (is_language_file)
  320|      0|				fprintf(stderr, "Error (%s): gender attribute specified on a language file\n", fname);
  321|      0|			break;
  322|      0|		case V_VARIANTS:
  323|      0|			sscanf(p, "%d", &n_variants);
  324|      0|		}
  325|      0|	}
  326|      0|	languages[langix++] = 0;
  327|      0|
  328|      0|	gender = LookupMnem(genders, vgender);
  329|      0|
  330|      0|	if (n_languages == 0)
  331|      0|		return NULL; // no language lines in the voice file
  332|      0|
  333|      0|	p = (char *)calloc(sizeof(espeak_VOICE) + langix + strlen(fname) + strlen(vname) + 3, 1);
  334|      0|	voice_data = (espeak_VOICE *)p;
  335|      0|	p = &p[sizeof(espeak_VOICE)];
  336|      0|
  337|      0|	memcpy(p, languages, langix);
  338|      0|	voice_data->languages = p;
  339|      0|
  340|      0|	strcpy(&p[langix], fname);
  341|      0|	voice_data->identifier = &p[langix];
  342|      0|	voice_data->name = &p[langix];
  343|      0|
  344|      0|	if (vname[0] != 0) {
  345|      0|		langix += strlen(fname)+1;
  346|      0|		strcpy(&p[langix], vname);
  347|      0|		voice_data->name = &p[langix];
  348|      0|	}
  349|      0|
  350|      0|	voice_data->age = age;
  351|      0|	voice_data->gender = gender;
  352|      0|	voice_data->variant = 0;
  353|      0|	voice_data->xx1 = n_variants;
  354|      0|	return voice_data;
  355|      0|}
  356|       |
  357|       |void VoiceReset(int tone_only)
  358|      0|{
  359|      0|	// Set voice to the default values
  360|      0|
  361|      0|	int pk;
  362|      0|	static unsigned char default_heights[N_PEAKS] = { 130, 128, 120, 116, 100, 100, 128, 128, 128 }; // changed for v.1.47
  363|      0|	static unsigned char default_widths[N_PEAKS] = { 140, 128, 128, 160, 171, 171, 128, 128, 128 };
  364|      0|
  365|      0|	static int breath_widths[N_PEAKS] = { 0, 200, 200, 400, 400, 400, 600, 600, 600 };
  366|      0|
  367|      0|	// default is:  pitch 80,118
  368|      0|	voice->pitch_base = 0x47000;
  369|      0|	voice->pitch_range = 4104;
  370|      0|
  371|      0|	voice->formant_factor = 256;
  372|      0|
  373|      0|	voice->speed_percent = 100;
  374|      0|	voice->echo_delay = 0;
  375|      0|	voice->echo_amp = 0;
  376|      0|	voice->flutter = 64;
  377|      0|	voice->n_harmonic_peaks = 5;
  378|      0|	voice->peak_shape = 0;
  379|      0|	voice->voicing = 64;
  380|      0|	voice->consonant_amp = 90; // change from 100 to 90 for v.1.47
  381|      0|	voice->consonant_ampv = 100;
  382|      0|	voice->samplerate = samplerate_native;
  383|      0|	memset(voice->klattv, 0, sizeof(voice->klattv));
  384|      0|
  385|      0|	speed.fast_settings = espeakRATE_MAXIMUM;
  386|      0|
  387|      0|	voice->roughness = 2;
  388|      0|
  389|      0|	InitBreath();
  390|      0|	for (pk = 0; pk < N_PEAKS; pk++) {
  391|      0|		voice->freq[pk] = 256;
  392|      0|		voice->freq2[pk] = voice->freq[pk];
  393|      0|		voice->height[pk] = default_heights[pk]*2;
  394|      0|		voice->height2[pk] = voice->height[pk];
  395|      0|		voice->width[pk] = default_widths[pk]*2;
  396|      0|		voice->breath[pk] = 0;
  397|      0|		voice->breathw[pk] = breath_widths[pk]; // default breath formant widths
  398|      0|		voice->freqadd[pk] = 0;
  399|      0|
  400|      0|		// adjust formant smoothing depending on sample rate
  401|      0|		formant_rate[pk] = (formant_rate_22050[pk] * 22050)/samplerate;
  402|      0|	}
  403|      0|
  404|      0|	// This table provides the opportunity for tone control.
  405|      0|	// Adjustment of harmonic amplitudes, steps of 8Hz
  406|      0|	// value of 128 means no change
  407|      0|	SetToneAdjust(voice, tone_points);
  408|      0|
  409|      0|	// default values of speed factors
  410|      0|	voice->speedf1 = 256;
  411|      0|	voice->speedf2 = 238;
  412|      0|	voice->speedf3 = 232;
  413|      0|
  414|      0|	if (tone_only == 0) {
  415|      0|		n_replace_phonemes = 0;
  416|      0|		LoadMbrolaTable(NULL, NULL, 0);
  417|      0|	}
  418|      0|
  419|      0|// probably unnecessary, but removing this would break tests
  420|      0|voice->width[0] = (voice->width[0] * 105)/100;
  421|      0|}
  422|       |
  423|       |static void VoiceFormant(char *p)
  424|      0|{
  425|      0|	// Set parameters for a formant
  426|      0|	int ix;
  427|      0|	int formant;
  428|      0|	int freq = 100;
  429|      0|	int height = 100;
  430|      0|	int width = 100;
  431|      0|	int freqadd = 0;
  432|      0|
  433|      0|	ix = sscanf(p, "%d %d %d %d %d", &formant, &freq, &height, &width, &freqadd);
  434|      0|	if (ix < 2)
  435|      0|		return;
  436|      0|
  437|      0|	if ((formant < 0) || (formant > 8))
  438|      0|		return;
  439|      0|
  440|      0|	if (freq >= 0) {
  441|      0|		voice->freq[formant] = (int)(freq * 2.56001);
  442|      0|		voice->freq2[formant] = voice->freq[formant];
  443|      0|	}
  444|      0|	if (height >= 0) {
  445|      0|		voice->height[formant] = (int)(height * 2.56001);
  446|      0|		voice->height2[formant] = voice->height[formant];
  447|      0|	}
  448|      0|	if (width >= 0)
  449|      0|		voice->width[formant] = (int)(width * 2.56001);
  450|      0|	voice->freqadd[formant] = freqadd;
  451|      0|
  452|      0|	// probably unnecessary, but removing this would break tests
  453|      0|	if (formant == 0)
  454|      0|		voice->width[0] = (voice->width[0] * 105)/100;
  455|      0|}
  456|       |
  457|       |static void PhonemeReplacement(char *p)
  458|      0|{
  459|      0|	int n;
  460|      0|	int phon;
  461|      0|	int flags = 0;
  462|      0|	char phon_string1[12];
  463|      0|	char phon_string2[12];
  464|      0|
  465|      0|	strcpy(phon_string2, "NULL");
  466|      0|	n = sscanf(p, "%d %s %s", &flags, phon_string1, phon_string2);
  467|      0|	if ((n < 2) || (n_replace_phonemes >= N_REPLACE_PHONEMES))
  468|      0|		return;
  469|      0|
  470|      0|	if ((phon = LookupPhonemeString(phon_string1)) == 0)
  471|      0|		return; // not recognised
  472|      0|
  473|      0|	replace_phonemes[n_replace_phonemes].old_ph = phon;
  474|      0|	replace_phonemes[n_replace_phonemes].new_ph = LookupPhonemeString(phon_string2);
  475|      0|	replace_phonemes[n_replace_phonemes++].type = flags;
  476|      0|}
  477|       |
  478|       |static int Read8Numbers(char *data_in, int *data)
  479|      0|{
  480|      0|	// Read 8 integer numbers
  481|      0|	memset(data, 0, 8+sizeof(int));
  482|      0|	return sscanf(data_in, "%d %d %d %d %d %d %d %d",
  483|      0|	              &data[0], &data[1], &data[2], &data[3], &data[4], &data[5], &data[6], &data[7]);
  484|      0|}
  485|       |
  486|      0|static void ReadNumbers(char *p, int *flags, int maxValue,  MNEM_TAB *keyword_tab, int key) {
  487|      0|	// read a list of numbers from string p
  488|      0|	// store them as flags in *flags
  489|      0|	// the meaning of the  numbers is bit ordinals, not integer values
  490|      0|	// give an error if number > maxValue is read
  491|      0|	int n;
  492|      0|	while (*p != 0) {
  493|      0|		while (isspace(*p)) p++;
  494|      0|		if ((n = atoi(p)) > 0) {
  495|      0|			p++;
  496|      0|			if (n < maxValue) {
  497|      0|				*flags |= (1 << n);
  498|      0|			} else {
  499|      0|				fprintf(stderr, "%s: Bad option number %d\n", LookupMnemName(keyword_tab, key), n);
  500|      0|			}
  501|      0|		}
  502|      0|	while (isalnum(*p)) p++;
  503|      0|	}
  504|      0|}
  505|       |
  506|       |static int CheckTranslator(Translator *tr, MNEM_TAB *keyword_tab, int key)
  507|      0|{
  508|      0|	// Return 0 if translator is set.
  509|      0|	// Return 1 and print an error message for specified key if not
  510|      0|	// used for parsing language options
  511|      0|	if (tr)
  512|      0|		return 0;
  513|      0|
  514|      0|	fprintf(stderr, "Cannot set %s: language not set, or is invalid.\n", LookupMnemName(keyword_tab, key));
  515|      0|	return 1;
  516|      0|}
  517|       |
  518|       |voice_t *LoadVoice(const char *vname, int control)
  519|      0|{
  520|      0|	// control, bit 0  1= no_default
  521|      0|	//          bit 1  1 = change tone only, not language
  522|      0|	//          bit 2  1 = don't report error on LoadDictionary
  523|      0|	//          bit 4  1 = vname = full path
  524|      0|        //          bit 8  1 = INTERNAL: compiling phonemes; do not try to
  525|      0|        //                     load the phoneme table
  526|      0|        //          bit 16 1 = UNDOCUMENTED
  527|      0|
  528|      0|	FILE *f_voice = NULL;
  529|      0|	char *p;
  530|      0|	int key;
  531|      0|	int ix;
  532|      0|	int n;
  533|      0|	int value;
  534|      0|	int langix = 0;
  535|      0|	int tone_only = control & 2;
  536|      0|	bool language_set = false;
  537|      0|	bool phonemes_set = false;
  538|      0|
  539|      0|	char voicename[40];
  540|      0|	char language_name[40];
  541|      0|	char translator_name[40];
  542|      0|	char new_dictionary[40];
  543|      0|	char phonemes_name[40];
  544|      0|	const char *language_type;
  545|      0|	char buf[sizeof(path_home)+30];
  546|      0|	char path_voices[sizeof(path_home)+12];
  547|      0|
  548|      0|	int stress_add[8];
  549|      0|	char names[8][40];
  550|      0|	char name1[40];
  551|      0|	char name2[80];
  552|      0|
  553|      0|	int pitch1;
  554|      0|	int pitch2;
  555|      0|
  556|      0|	static char voice_identifier[40]; // file name for  current_voice_selected
  557|      0|	static char voice_name[40];       // voice name for current_voice_selected
  558|      0|	static char voice_languages[100]; // list of languages and priorities for current_voice_selected
  559|      0|
  560|      0|	strncpy0(voicename, vname, sizeof(voicename));
  561|      0|	if (control & 0x10) {
  562|      0|		strcpy(buf, vname);
  563|      0|		if (GetFileLength(buf) <= 0)
  564|      0|			return NULL;
  565|      0|	} else {
  566|      0|		if (voicename[0] == 0 && !(control & 8)/*compiling phonemes*/)
  567|      0|			strcpy(voicename, ESPEAKNG_DEFAULT_VOICE);
  568|      0|
  569|      0|		sprintf(path_voices, "%s%cvoices%c", path_home, PATHSEP, PATHSEP);
  570|      0|		sprintf(buf, "%s%s", path_voices, voicename); // look in the main voices directory
  571|      0|
  572|      0|		if (GetFileLength(buf) <= 0) {
  573|      0|			sprintf(path_voices, "%s%clang%c", path_home, PATHSEP, PATHSEP);
  574|      0|			sprintf(buf, "%s%s", path_voices, voicename); // look in the main languages directory
  575|      0|		}
  576|      0|	}
  577|      0|
  578|      0|	f_voice = fopen(buf, "r");
  579|      0|
  580|      0|        if (!(control & 8)/*compiling phonemes*/)
  581|      0|            language_type = ESPEAKNG_DEFAULT_VOICE; // default
  582|      0|        else
  583|      0|            language_type = "";
  584|      0|
  585|      0|	if (f_voice == NULL) {
  586|      0|		if (control & 3)
  587|      0|			return NULL; // can't open file
  588|      0|
  589|      0|		if (SelectPhonemeTableName(voicename) >= 0)
  590|      0|			language_type = voicename;
  591|      0|	}
  592|      0|
  593|      0|	if (!tone_only && (translator != NULL)) {
  594|      0|		DeleteTranslator(translator);
  595|      0|		translator = NULL;
  596|      0|	}
  597|      0|
  598|      0|	strcpy(translator_name, language_type);
  599|      0|	strcpy(new_dictionary, language_type);
  600|      0|
  601|      0|	if (!tone_only) {
  602|      0|		voice = &voicedata;
  603|      0|		strncpy0(voice_identifier, vname, sizeof(voice_identifier));
  604|      0|		voice_name[0] = 0;
  605|      0|		voice_languages[0] = 0;
  606|      0|
  607|      0|		current_voice_selected.identifier = voice_identifier;
  608|      0|		current_voice_selected.name = voice_name;
  609|      0|		current_voice_selected.languages = voice_languages;
  610|      0|	} else {
  611|      0|		// append the variant file name to the voice identifier
  612|      0|		if ((p = strchr(voice_identifier, '+')) != NULL)
  613|      0|			*p = 0;    // remove previous variant name
  614|      0|		sprintf(buf, "+%s", &vname[3]);    // omit  !v/  from the variant filename
  615|      0|		strcat(voice_identifier, buf);
  616|      0|	}
  617|      0|	VoiceReset(tone_only);
  618|      0|
  619|      0|	while ((f_voice != NULL) && (fgets_strip(buf, sizeof(buf), f_voice) != NULL)) {
  620|      0|		// isolate the attribute name
  621|      0|		for (p = buf; (*p != 0) && !isspace(*p); p++) ;
  622|      0|		*p++ = 0;
  623|      0|
  624|      0|		if (buf[0] == 0) continue;
  625|      0|
  626|      0|		key = LookupMnem(keyword_tab, buf);
  627|      0|
  628|      0|		switch (key)
  629|      0|		{
  630|      0|		case V_LANGUAGE:
  631|      0|		{
  632|      0|			unsigned int len;
  633|      0|			int priority;
  634|      0|
  635|      0|			if (tone_only)
  636|      0|				break;
  637|      0|
  638|      0|			priority = DEFAULT_LANGUAGE_PRIORITY;
  639|      0|			language_name[0] = 0;
  640|      0|
  641|      0|			sscanf(p, "%s %d", language_name, &priority);
  642|      0|			if (strcmp(language_name, "variant") == 0)
  643|      0|				break;
  644|      0|
  645|      0|			len = strlen(language_name) + 2;
  646|      0|			// check for space in languages[]
  647|      0|			if (len < (sizeof(voice_languages)-langix-1)) {
  648|      0|				voice_languages[langix] = priority;
  649|      0|
  650|      0|				strcpy(&voice_languages[langix+1], language_name);
  651|      0|				langix += len;
  652|      0|			}
  653|      0|
  654|      0|			// only act on the first language line
  655|      0|			if (language_set == false) {
  656|      0|				language_type = strtok(language_name, "-");
  657|      0|				language_set = true;
  658|      0|				strcpy(translator_name, language_type);
  659|      0|				strcpy(new_dictionary, language_type);
  660|      0|				strcpy(phonemes_name, language_type);
  661|      0|				SelectPhonemeTableName(phonemes_name);
  662|      0|
  663|      0|				translator = SelectTranslator(translator_name);
  664|      0|				strncpy0(voice->language_name, language_name, sizeof(voice->language_name));
  665|      0|			}
  666|      0|		}
  667|      0|			break;
  668|      0|		case V_NAME:
  669|      0|			if (tone_only == 0) {
  670|      0|				while (isspace(*p)) p++;
  671|      0|				strncpy0(voice_name, p, sizeof(voice_name));
  672|      0|			}
  673|      0|			break;
  674|      0|		case V_GENDER:
  675|      0|		{
  676|      0|			int age = 0;
  677|      0|			char vgender[80];
  678|      0|			sscanf(p, "%s %d", vgender, &age);
  679|      0|			current_voice_selected.gender = LookupMnem(genders, vgender);
  680|      0|			current_voice_selected.age = age;
  681|      0|		}
  682|      0|			break;
  683|      0|		case V_DICTIONARY: // dictionary
  684|      0|			sscanf(p, "%s", new_dictionary);
  685|      0|			break;
  686|      0|		case V_PHONEMES: // phoneme table
  687|      0|			sscanf(p, "%s", phonemes_name);
  688|      0|			break;
  689|      0|		case V_FORMANT:
  690|      0|			VoiceFormant(p);
  691|      0|			break;
  692|      0|		case V_LOWERCASE_SENTENCE: {
  693|      0|			if (CheckTranslator(translator, keyword_tab, key) != 0)
  694|      0|				break;
  695|      0|
  696|      0|			translator->langopts.lowercase_sentence = true;
  697|      0|			break;
  698|      0|			}
  699|      0|
  700|      0|		case V_PITCH:
  701|      0|			// default is  pitch 82 118
  702|      0|			if (sscanf(p, "%d %d", &pitch1, &pitch2) == 2) {
  703|      0|				voice->pitch_base = (pitch1 - 9) << 12;
  704|      0|				voice->pitch_range = (pitch2 - pitch1) * 108;
  705|      0|				double factor = (double)(pitch1 - 82)/82;
  706|      0|				voice->formant_factor = (int)((1+factor/4) * 256); // nominal formant shift for a different voice pitch
  707|      0|			}
  708|      0|			break;
  709|      0|		case V_STRESSLENGTH: {// stressLength
  710|      0|			if (CheckTranslator(translator, keyword_tab, key) != 0)
  711|      0|				break;
  712|      0|
  713|      0|			int stress_lengths_set = 0;
  714|      0|			int stress_lengths[8];
  715|      0|			stress_lengths_set = Read8Numbers(p, stress_lengths);
  716|      0|
  717|      0|			for (ix = 0; ix < stress_lengths_set; ix++) {
  718|      0|				translator->stress_lengths[ix] = stress_lengths[ix];
  719|      0|			}
  720|      0|
  721|      0|			break;
  722|      0|		}
  723|      0|		case V_STRESSAMP: { // stressAmp
  724|      0|			if (CheckTranslator(translator, keyword_tab, key) != 0)
  725|      0|				break;
  726|      0|
  727|      0|			int stress_amps_set = 0;
  728|      0|			int stress_amps[8];
  729|      0|			stress_amps_set = Read8Numbers(p, stress_amps);
  730|      0|			for (ix = 0; ix < stress_amps_set; ix++) {
  731|      0|				translator->stress_amps[ix] = stress_amps[ix];
  732|      0|			}
  733|      0|
  734|      0|			break;
  735|      0|		}
  736|      0|		case V_STRESSADD: { // stressAdd
  737|      0|			if (CheckTranslator(translator, keyword_tab, key) != 0)
  738|      0|				break;
  739|      0|
  740|      0|			int stress_add_set = 0;
  741|      0|			stress_add_set = Read8Numbers(p, stress_add);
  742|      0|
  743|      0|			for (ix = 0; ix < stress_add_set; ix++) {
  744|      0|				translator->stress_lengths[ix] += stress_add[ix];
  745|      0|			}
  746|      0|
  747|      0|			break;
  748|      0|		}
  749|      0|		case V_INTONATION: // intonation
  750|      0|			sscanf(p, "%d", &option_tone_flags);
  751|      0|			if ((option_tone_flags & 0xff) != 0) {
  752|      0|				if (CheckTranslator(translator, keyword_tab, key) != 0)
  753|      0|					break;
  754|      0|
  755|      0|				translator->langopts.intonation_group = option_tone_flags & 0xff;
  756|      0|			}
  757|      0|			break;
  758|      0|		case V_TUNES:
  759|      0|			if (CheckTranslator(translator, keyword_tab, key) != 0)
  760|      0|				break;
  761|      0|
  762|      0|			n = sscanf(p, "%s %s %s %s %s %s", names[0], names[1], names[2], names[3], names[4], names[5]);
  763|      0|			translator->langopts.intonation_group = 0;
  764|      0|
  765|      0|			for (ix = 0; ix < n; ix++) {
  766|      0|				if (strcmp(names[ix], "NULL") == 0)
  767|      0|					continue;
  768|      0|
  769|      0|				if ((value = LookupTune(names[ix])) < 0)
  770|      0|					fprintf(stderr, "Unknown tune '%s'\n", names[ix]);
  771|      0|				else
  772|      0|					translator->langopts.tunes[ix] = value;
  773|      0|			}
  774|      0|			break;
  775|      0|
  776|      0|		case V_DICTRULES: // conditional dictionary rules and list entries
  777|      0|			if (CheckTranslator(translator, keyword_tab, key) != 0)
  778|      0|				break;
  779|      0|
  780|      0|			ReadNumbers(p, &translator->dict_condition, 32, keyword_tab, key);
  781|      0|			break;
  782|      0|		case V_STRESSOPT:
  783|      0|			if (CheckTranslator(translator, keyword_tab, key) != 0)
  784|      0|				 break;
  785|      0|
  786|      0|			ReadNumbers(p, &translator->langopts.stress_flags, 32, keyword_tab, key);
  787|      0|			break;
  788|      0|
  789|      0|		case V_NUMBERS:
  790|      0|			if (CheckTranslator(translator, keyword_tab, key) != 0)
  791|      0|				break;
  792|      0|
  793|      0|			// expect a list of numbers
  794|      0|			while (*p != 0) {
  795|      0|				while (isspace(*p)) p++;
  796|      0|				if ((n = atoi(p)) > 0) {
  797|      0|					p++;
  798|      0|					if (n < 32) {
  799|      0|							translator->langopts.numbers |= (1 << n);
  800|      0|					} else {
  801|      0|						if (n < 64)
  802|      0|							translator->langopts.numbers2 |= (1 << (n-32));
  803|      0|						else
  804|      0|							fprintf(stderr, "numbers: Bad option number %d\n", n);					}
  805|      0|				}
  806|      0|				while (isalnum(*p)) p++;
  807|      0|			}
  808|      0|			ProcessLanguageOptions(&(translator->langopts));
  809|      0|
  810|      0|			break;
  811|      0|		case V_REPLACE:
  812|      0|			if (phonemes_set == false) {
  813|      0|				// must set up a phoneme table before we can lookup phoneme mnemonics
  814|      0|				SelectPhonemeTableName(phonemes_name);
  815|      0|				phonemes_set = true;
  816|      0|			}
  817|      0|			PhonemeReplacement(p);
  818|      0|			break;
  819|      0|		case V_WORDGAP: // words
  820|      0|			if (CheckTranslator(translator, keyword_tab, key) != 0)
  821|      0|				break;
  822|      0|
  823|      0|			sscanf(p, "%d %d", &translator->langopts.word_gap, &translator->langopts.vowel_pause);
  824|      0|			break;
  825|      0|		case V_STRESSRULE:
  826|      0|			if (CheckTranslator(translator, keyword_tab, key) != 0)
  827|      0|				break;
  828|      0|
  829|      0|			sscanf(p, "%d %d %d", &translator->langopts.stress_rule,
  830|      0|			       &translator->langopts.unstressed_wd1,
  831|      0|			       &translator->langopts.unstressed_wd2);
  832|      0|
  833|      0|			break;
  834|      0|		case V_ECHO:
  835|      0|			// echo.  suggest: 135mS  11%
  836|      0|			value = 0;
  837|      0|			voice->echo_amp = 0;
  838|      0|			sscanf(p, "%d %d", &voice->echo_delay, &voice->echo_amp);
  839|      0|			break;
  840|      0|		case V_FLUTTER: // flutter
  841|      0|			if (sscanf(p, "%d", &value) == 1)
  842|      0|				voice->flutter = value * 32;
  843|      0|			break;
  844|      0|		case V_ROUGHNESS: // roughness
  845|      0|			if (sscanf(p, "%d", &value) == 1)
  846|      0|				voice->roughness = value;
  847|      0|			break;
  848|      0|		case V_CLARITY: // formantshape
  849|      0|			if (sscanf(p, "%d", &value) == 1) {
  850|      0|				if (value > 4) {
  851|      0|					voice->peak_shape = 1; // squarer formant peaks
  852|      0|					value = 4;
  853|      0|				}
  854|      0|				voice->n_harmonic_peaks = 1+value;
  855|      0|			}
  856|      0|			break;
  857|      0|		case V_TONE:
  858|      0|		{
  859|      0|			int tone_data[12];
  860|      0|			ReadTonePoints(p, tone_data);
  861|      0|			SetToneAdjust(voice, tone_data);
  862|      0|		}
  863|      0|			break;
  864|      0|		case V_VOICING:
  865|      0|			if (sscanf(p, "%d", &value) == 1)
  866|      0|				voice->voicing = (value * 64)/100;
  867|      0|			break;
  868|      0|		case V_BREATH:
  869|      0|			voice->breath[0] = Read8Numbers(p, &voice->breath[1]);
  870|      0|			for (ix = 1; ix < 8; ix++) {
  871|      0|				if (ix % 2)
  872|      0|					voice->breath[ix] = -voice->breath[ix];
  873|      0|			}
  874|      0|			break;
  875|      0|		case V_BREATHW:
  876|      0|			voice->breathw[0] = Read8Numbers(p, &voice->breathw[1]);
  877|      0|			break;
  878|      0|		case V_CONSONANTS:
  879|      0|			value = sscanf(p, "%d %d", &voice->consonant_amp, &voice->consonant_ampv);
  880|      0|			break;
  881|      0|		case V_SPEED:
  882|      0|			sscanf(p, "%d", &voice->speed_percent);
  883|      0|			SetSpeed(3);
  884|      0|			break;
  885|      0|		case V_MBROLA:
  886|      0|		{
  887|      0|			int srate = 16000;
  888|      0|
  889|      0|			name2[0] = 0;
  890|      0|			sscanf(p, "%s %s %d", name1, name2, &srate);
  891|      0|			espeak_ng_STATUS status = LoadMbrolaTable(name1, name2, &srate);
  892|      0|			if (status != ENS_OK) {
  893|      0|				espeak_ng_PrintStatusCodeMessage(status, stderr, NULL);
  894|      0|				fclose(f_voice);
  895|      0|				return NULL;
  896|      0|			}
  897|      0|			else
  898|      0|				voice->samplerate = srate;
  899|      0|		}
  900|      0|			break;
  901|      0|		case V_KLATT:
  902|      0|			voice->klattv[0] = 1; // default source: IMPULSIVE
  903|      0|			Read8Numbers(p, voice->klattv);
  904|      0|			voice->klattv[KLATT_Kopen] -= 40;
  905|      0|			break;
  906|      0|		case V_FAST:
  907|      0|			sscanf(p, "%d", &speed.fast_settings);
  908|      0|			SetSpeed(3);
  909|      0|			break;
  910|      0|		case V_DICTMIN: {
  911|      0|			if (CheckTranslator(translator, keyword_tab, key) != 0)
  912|      0|				break;
  913|      0|
  914|      0|			if (sscanf(p, "%d", &value) == 1)
  915|      0|				translator->dict_min_size = value;
  916|      0|			break;
  917|      0|			}
  918|      0|
  919|      0|			break;
  920|      0|		case V_MAINTAINER:
  921|      0|		case V_STATUS:
  922|      0|			break;
  923|      0|		default:
  924|      0|			if ((key & 0xff00) == 0x100) {
  925|      0|				if (CheckTranslator(translator, keyword_tab, key) != 0)
  926|      0|					break;
  927|      0|				sscanf(p, "%d", &translator->langopts.param[key &0xff]);
  928|      0|			} else
  929|      0|				fprintf(stderr, "Bad voice attribute: %s\n", buf);
  930|      0|			break;
  931|      0|		}
  932|      0|	}
  933|      0|	if (f_voice != NULL)
  934|      0|		fclose(f_voice);
  935|      0|
  936|      0|	if ((translator == NULL) && (!tone_only)) {
  937|      0|		// not set by language attribute
  938|      0|		translator = SelectTranslator(translator_name);
  939|      0|	}
  940|      0|
  941|      0|	if (!tone_only) {
  942|      0|		if (!!(control & 8/*compiling phonemes*/)) {
  943|      0|                        /* Set by espeak_ng_CompilePhonemeDataPath when it
  944|      0|                         * calls LoadVoice("", 8) to set up a dummy(?) voice.
  945|      0|                         * As phontab may not yet exist this avoids the spurious
  946|      0|                         * error message and guarantees consistent results by
  947|      0|                         * not actually reading a potentially bogus phontab...
  948|      0|                         */
  949|      0|                        ix = 0;
  950|      0|                } else if ((ix = SelectPhonemeTableName(phonemes_name)) < 0) {
  951|      0|			fprintf(stderr, "Unknown phoneme table: '%s'\n", phonemes_name);
  952|      0|			ix = 0;
  953|      0|		}
  954|      0|
  955|      0|		voice->phoneme_tab_ix = ix;
  956|      0|		translator->phoneme_tab_ix = ix;
  957|      0|
  958|      0|		if (!(control & 8/*compiling phonemes*/)) {
  959|      0|			LoadDictionary(translator, new_dictionary, control & 4);
  960|      0|			if (dictionary_name[0] == 0) {
  961|      0|				DeleteTranslator(translator);
  962|      0|				return NULL; // no dictionary loaded
  963|      0|			}
  964|      0|		}
  965|      0|	}
  966|      0|
  967|      0|	return voice;
  968|      0|}
  969|       |
  970|       |static char *ExtractVoiceVariantName(char *vname, int variant_num, int add_dir)
  971|      0|{
  972|      0|	// Remove any voice variant suffix (name or number) from a voice name
  973|      0|	// Returns the voice variant name
  974|      0|
  975|      0|	char *p;
  976|      0|	static char variant_name[40];
  977|      0|	char variant_prefix[5];
  978|      0|
  979|      0|	variant_name[0] = 0;
  980|      0|	sprintf(variant_prefix, "!v%c", PATHSEP);
  981|      0|	if (add_dir == 0)
  982|      0|		variant_prefix[0] = 0;
  983|      0|
  984|      0|	if (vname != NULL) {
  985|      0|		if ((p = strchr(vname, '+')) != NULL) {
  986|      0|			// The voice name has a +variant suffix
  987|      0|			variant_num = 0;
  988|      0|			*p++ = 0; // delete the suffix from the voice name
  989|      0|			if (IsDigit09(*p))
  990|      0|				variant_num = atoi(p); // variant number
  991|      0|			else {
  992|      0|				// voice variant name, not number
  993|      0|				sprintf(variant_name, "%s%s", variant_prefix, p);
  994|      0|			}
  995|      0|		}
  996|      0|	}
  997|      0|
  998|      0|	if (variant_num > 0) {
  999|      0|		if (variant_num < 10)
 1000|      0|			sprintf(variant_name, "%sm%d", variant_prefix, variant_num); // male
 1001|      0|		else
 1002|      0|			sprintf(variant_name, "%sf%d", variant_prefix, variant_num-10); // female
 1003|      0|	}
 1004|      0|
 1005|      0|	return variant_name;
 1006|      0|}
 1007|       |
 1008|       |voice_t *LoadVoiceVariant(const char *vname, int variant_num)
 1009|      0|{
 1010|      0|	// Load a voice file.
 1011|      0|	// Also apply a voice variant if specified by "variant", or by "+number" or "+name" in the "vname"
 1012|      0|
 1013|      0|	voice_t *v;
 1014|      0|	char *variant_name;
 1015|      0|	char buf[60];
 1016|      0|
 1017|      0|	strncpy0(buf, vname, sizeof(buf));
 1018|      0|	variant_name = ExtractVoiceVariantName(buf, variant_num, 1);
 1019|      0|
 1020|      0|	if ((v = LoadVoice(buf, 0)) == NULL)
 1021|      0|		return NULL;
 1022|      0|
 1023|      0|	if (variant_name[0] != 0)
 1024|      0|		v = LoadVoice(variant_name, 2);
 1025|      0|	return v;
 1026|      0|}
 1027|       |
 1028|       |static int __cdecl VoiceNameSorter(const void *p1, const void *p2)
 1029|      0|{
 1030|      0|	int ix;
 1031|      0|	espeak_VOICE *v1 = *(espeak_VOICE **)p1;
 1032|      0|	espeak_VOICE *v2 = *(espeak_VOICE **)p2;
 1033|      0|
 1034|      0|	if ((ix = strcmp(&v1->languages[1], &v2->languages[1])) != 0) // primary language name
 1035|      0|		return ix;
 1036|      0|	if ((ix = v1->languages[0] - v2->languages[0]) != 0) // priority number
 1037|      0|		return ix;
 1038|      0|	return strcmp(v1->name, v2->name);
 1039|      0|}
 1040|       |
 1041|       |static int __cdecl VoiceScoreSorter(const void *p1, const void *p2)
 1042|      0|{
 1043|      0|	int ix;
 1044|      0|	espeak_VOICE *v1 = *(espeak_VOICE **)p1;
 1045|      0|	espeak_VOICE *v2 = *(espeak_VOICE **)p2;
 1046|      0|
 1047|      0|	if ((ix = v2->score - v1->score) != 0)
 1048|      0|		return ix;
 1049|      0|	return strcmp(v1->name, v2->name);
 1050|      0|}
 1051|       |
 1052|       |static int ScoreVoice(espeak_VOICE *voice_spec, const char *spec_language, int spec_n_parts, int spec_lang_len, espeak_VOICE *voice)
 1053|      0|{
 1054|      0|	int ix;
 1055|      0|	const char *p;
 1056|      0|	int c1, c2;
 1057|      0|	int language_priority;
 1058|      0|	int n_parts;
 1059|      0|	int matching;
 1060|      0|	int matching_parts;
 1061|      0|	int score = 0;
 1062|      0|	int x;
 1063|      0|	int ratio;
 1064|      0|	int required_age;
 1065|      0|	int diff;
 1066|      0|
 1067|      0|	p = voice->languages; // list of languages+dialects for which this voice is suitable
 1068|      0|
 1069|      0|	if (spec_n_parts < 0) {
 1070|      0|		// match on the subdirectory
 1071|      0|		if (memcmp(voice->identifier, spec_language, spec_lang_len) == 0)
 1072|      0|			return 100;
 1073|      0|		return 0;
 1074|      0|	}
 1075|      0|
 1076|      0|	if (spec_n_parts == 0)
 1077|      0|		score = 100;
 1078|      0|	else {
 1079|      0|		if ((*p == 0) && (strcmp(spec_language, "variants") == 0)) {
 1080|      0|			// match on a voice with no languages if the required language is "variants"
 1081|      0|			score = 100;
 1082|      0|		}
 1083|      0|
 1084|      0|		// compare the required language with each of the languages of this voice
 1085|      0|		while (*p != 0) {
 1086|      0|			language_priority = *p++;
 1087|      0|
 1088|      0|			matching = 1;
 1089|      0|			matching_parts = 0;
 1090|      0|			n_parts = 1;
 1091|      0|
 1092|      0|			for (ix = 0;; ix++) {
 1093|      0|				if ((ix >= spec_lang_len) || ((c1 = spec_language[ix]) == '-'))
 1094|      0|					c1 = 0;
 1095|      0|				if ((c2 = p[ix]) == '-')
 1096|      0|					c2 = 0;
 1097|      0|
 1098|      0|				if (c1 != c2)
 1099|      0|					matching = 0;
 1100|      0|
 1101|      0|				if (p[ix] == '-') {
 1102|      0|					n_parts++;
 1103|      0|					if (matching)
 1104|      0|						matching_parts++;
 1105|      0|				}
 1106|      0|				if (p[ix] == 0)
 1107|      0|					break;
 1108|      0|			}
 1109|      0|			p += (ix+1);
 1110|      0|			matching_parts += matching; // number of parts which match
 1111|      0|
 1112|      0|			if (matching_parts == 0)
 1113|      0|				continue; // no matching parts for this language
 1114|      0|
 1115|      0|			x = 5;
 1116|      0|			// reduce the score if not all parts of the required language match
 1117|      0|			if ((diff = (spec_n_parts - matching_parts)) > 0)
 1118|      0|				x -= diff;
 1119|      0|
 1120|      0|			// reduce score if the language is more specific than required
 1121|      0|			if ((diff = (n_parts - matching_parts)) > 0)
 1122|      0|				x -= diff;
 1123|      0|
 1124|      0|			x = x*100 - (language_priority * 2);
 1125|      0|
 1126|      0|			if (x > score)
 1127|      0|				score = x;
 1128|      0|		}
 1129|      0|	}
 1130|      0|	if (score == 0)
 1131|      0|		return 0;
 1132|      0|
 1133|      0|	if (voice_spec->name != NULL) {
 1134|      0|		if (strcmp(voice_spec->name, voice->name) == 0) {
 1135|      0|			// match on voice name
 1136|      0|			score += 500;
 1137|      0|		} else if (strcmp(voice_spec->name, voice->identifier) == 0)
 1138|      0|			score += 400;
 1139|      0|	}
 1140|      0|
 1141|      0|	if (((voice_spec->gender == ENGENDER_MALE) || (voice_spec->gender == ENGENDER_FEMALE)) &&
 1142|      0|	    ((voice->gender == ENGENDER_MALE) || (voice->gender == ENGENDER_FEMALE))) {
 1143|      0|		if (voice_spec->gender == voice->gender)
 1144|      0|			score += 50;
 1145|      0|		else
 1146|      0|			score -= 50;
 1147|      0|	}
 1148|      0|
 1149|      0|	if ((voice_spec->age <= 12) && (voice->gender == ENGENDER_FEMALE) && (voice->age > 12))
 1150|      0|		score += 5; // give some preference for non-child female voice if a child is requested
 1151|      0|
 1152|      0|	if (voice->age != 0) {
 1153|      0|		if (voice_spec->age == 0)
 1154|      0|			required_age = 30;
 1155|      0|		else
 1156|      0|			required_age = voice_spec->age;
 1157|      0|
 1158|      0|		ratio = (required_age*100)/voice->age;
 1159|      0|		if (ratio < 100)
 1160|      0|			ratio = 10000/ratio;
 1161|      0|		ratio = (ratio - 100)/10; // 0=exact match, 10=out by factor of 2
 1162|      0|		x = 5 - ratio;
 1163|      0|		if (x > 0) x = 0;
 1164|      0|
 1165|      0|		score = score + x;
 1166|      0|
 1167|      0|		if (voice_spec->age > 0)
 1168|      0|			score += 10; // required age specified, favour voices with a specified age (near it)
 1169|      0|	}
 1170|      0|	if (score < 1)
 1171|      0|		score = 1;
 1172|      0|	return score;
 1173|      0|}
 1174|       |
 1175|       |static int SetVoiceScores(espeak_VOICE *voice_select, espeak_VOICE **voices, int control)
 1176|      0|{
 1177|      0|	// control: bit0=1  include mbrola voices
 1178|      0|	int ix;
 1179|      0|	int score;
 1180|      0|	int nv; // number of candidates
 1181|      0|	int n_parts = 0;
 1182|      0|	int lang_len = 0;
 1183|      0|	espeak_VOICE *vp;
 1184|      0|	char language[80];
 1185|      0|	char buf[sizeof(path_home)+80];
 1186|      0|
 1187|      0|	// count number of parts in the specified language
 1188|      0|	if ((voice_select->languages != NULL) && (voice_select->languages[0] != 0)) {
 1189|      0|		n_parts = 1;
 1190|      0|		lang_len = strlen(voice_select->languages);
 1191|      0|		for (ix = 0; (ix <= lang_len) && ((unsigned)ix < sizeof(language)); ix++) {
 1192|      0|			if ((language[ix] = tolower(voice_select->languages[ix])) == '-')
 1193|      0|				n_parts++;
 1194|      0|		}
 1195|      0|	}
 1196|      0|
 1197|      0|	if ((n_parts == 1) && (control & 1)) {
 1198|      0|		if (strcmp(language, "mbrola") == 0) {
 1199|      0|			language[2] = 0; // truncate to "mb"
 1200|      0|			lang_len = 2;
 1201|      0|		}
 1202|      0|
 1203|      0|		sprintf(buf, "%s/voices/%s", path_home, language);
 1204|      0|		if (GetFileLength(buf) == -EISDIR) {
 1205|      0|			// A subdirectory name has been specified.  List all the voices in that subdirectory
 1206|      0|			language[lang_len++] = PATHSEP;
 1207|      0|			language[lang_len] = 0;
 1208|      0|			n_parts = -1;
 1209|      0|		}
 1210|      0|	}
 1211|      0|
 1212|      0|	// select those voices which match the specified language
 1213|      0|	nv = 0;
 1214|      0|	for (ix = 0; ix < n_voices_list; ix++) {
 1215|      0|		vp = voices_list[ix];
 1216|      0|
 1217|      0|		if (((control & 1) == 0) && (memcmp(vp->identifier, "mb/", 3) == 0))
 1218|      0|			continue;
 1219|      0|
 1220|      0|		if (voice_select->languages == NULL || memcmp(voice_select->languages,"all", 3) == 0) {
 1221|      0|			voices[nv++] = vp;
 1222|      0|			continue;
 1223|      0|		}
 1224|      0|
 1225|      0|		if ((score = ScoreVoice(voice_select, language, n_parts, lang_len, voices_list[ix])) > 0) {
 1226|      0|			voices[nv++] = vp;
 1227|      0|			vp->score = score;
 1228|      0|		}
 1229|      0|	}
 1230|      0|	voices[nv] = NULL; // list terminator
 1231|      0|
 1232|      0|	if (nv == 0)
 1233|      0|		return 0;
 1234|      0|
 1235|      0|	// sort the selected voices by their score
 1236|      0|	qsort(voices, nv, sizeof(espeak_VOICE *), (int(__cdecl *)(const void *, const void *))VoiceScoreSorter);
 1237|      0|
 1238|      0|	return nv;
 1239|      0|}
 1240|       |
 1241|       |espeak_VOICE *SelectVoiceByName(espeak_VOICE **voices, const char *name2)
 1242|      0|{
 1243|      0|	int ix;
 1244|      0|	int match_fname = -1;
 1245|      0|	int match_fname2 = -1;
 1246|      0|	int match_name = -1;
 1247|      0|	const char *id; // this is the filename within espeak-ng-data/voices
 1248|      0|	char *variant_name;
 1249|      0|	int last_part_len;
 1250|      0|	char last_part[41];
 1251|      0|	char name[40];
 1252|      0|
 1253|      0|	if (voices == NULL) {
 1254|      0|		if (n_voices_list == 0)
 1255|      0|			espeak_ListVoices(NULL); // create the voices list
 1256|      0|		voices = voices_list;
 1257|      0|	}
 1258|      0|
 1259|      0|	strncpy0(name, name2, sizeof(name));
 1260|      0|	if ((variant_name = strchr(name, '+')) != NULL) {
 1261|      0|		*variant_name = 0;
 1262|      0|		variant_name++;
 1263|      0|	}
 1264|      0|
 1265|      0|	sprintf(last_part, "%c%s", PATHSEP, name);
 1266|      0|	last_part_len = strlen(last_part);
 1267|      0|
 1268|      0|	for (ix = 0; voices[ix] != NULL; ix++) {
 1269|      0|		if (strcasecmp(name, voices[ix]->name) == 0) {
 1270|      0|			match_name = ix; // found matching voice name
 1271|      0|			break;
 1272|      0|		} else {
 1273|      0|			id = voices[ix]->identifier;
 1274|      0|			if (strcasecmp(name, id) == 0)
 1275|      0|				match_fname = ix; // matching identifier, use this if no matching name
 1276|      0|			else if (strcasecmp(last_part, &id[strlen(id)-last_part_len]) == 0)
 1277|      0|				match_fname2 = ix;
 1278|      0|		}
 1279|      0|	}
 1280|      0|
 1281|      0|	if (match_name < 0) {
 1282|      0|		match_name = match_fname; // no matching name, try matching filename
 1283|      0|		if (match_name < 0)
 1284|      0|			match_name = match_fname2; // try matching just the last part of the filename
 1285|      0|	}
 1286|      0|
 1287|      0|	if (match_name < 0)
 1288|      0|		return NULL;
 1289|      0|
 1290|      0|	return voices[match_name];
 1291|      0|}
 1292|       |
 1293|       |char const *SelectVoice(espeak_VOICE *voice_select, int *found)
 1294|      0|{
 1295|      0|	// Returns a path within espeak-voices, with a possible +variant suffix
 1296|      0|	// variant is an output-only parameter
 1297|      0|
 1298|      0|	int nv; // number of candidates
 1299|      0|	int ix, ix2;
 1300|      0|	int j;
 1301|      0|	int n_variants;
 1302|      0|	int variant_number;
 1303|      0|	int gender;
 1304|      0|	int skip;
 1305|      0|	int aged = 1;
 1306|      0|	char *variant_name;
 1307|      0|	const char *p, *p_start;
 1308|      0|	espeak_VOICE *vp = NULL;
 1309|      0|	espeak_VOICE *vp2;
 1310|      0|	espeak_VOICE voice_select2;
 1311|      0|	espeak_VOICE *voices[N_VOICES_LIST]; // list of candidates
 1312|      0|	espeak_VOICE *voices2[N_VOICES_LIST+N_VOICE_VARIANTS];
 1313|      0|	static espeak_VOICE voice_variants[N_VOICE_VARIANTS];
 1314|      0|	static char voice_id[50];
 1315|      0|
 1316|      0|	*found = 1;
 1317|      0|	memcpy(&voice_select2, voice_select, sizeof(voice_select2));
 1318|      0|
 1319|      0|	if (n_voices_list == 0)
 1320|      0|		espeak_ListVoices(NULL); // create the voices list
 1321|      0|
 1322|      0|	if ((voice_select2.languages == NULL) || (voice_select2.languages[0] == 0)) {
 1323|      0|		// no language is specified. Get language from the named voice
 1324|      0|		static char buf[60];
 1325|      0|
 1326|      0|		if (voice_select2.name == NULL) {
 1327|      0|			if ((voice_select2.name = voice_select2.identifier) == NULL)
 1328|      0|				voice_select2.name = ESPEAKNG_DEFAULT_VOICE;
 1329|      0|		}
 1330|      0|
 1331|      0|		strncpy0(buf, voice_select2.name, sizeof(buf));
 1332|      0|		variant_name = ExtractVoiceVariantName(buf, 0, 0);
 1333|      0|
 1334|      0|		vp = SelectVoiceByName(voices_list, buf);
 1335|      0|		if (vp != NULL) {
 1336|      0|			voice_select2.languages = &(vp->languages[1]);
 1337|      0|
 1338|      0|			if ((voice_select2.gender == ENGENDER_UNKNOWN) && (voice_select2.age == 0) && (voice_select2.variant == 0)) {
 1339|      0|				if (variant_name[0] != 0) {
 1340|      0|					sprintf(voice_id, "%s+%s", vp->identifier, variant_name);
 1341|      0|					return voice_id;
 1342|      0|				}
 1343|      0|
 1344|      0|				return vp->identifier;
 1345|      0|			}
 1346|      0|		}
 1347|      0|	}
 1348|      0|
 1349|      0|	// select and sort voices for the required language
 1350|      0|	nv = SetVoiceScores(&voice_select2, voices, 0);
 1351|      0|
 1352|      0|	if (nv == 0) {
 1353|      0|		// no matching voice, choose the default
 1354|      0|		*found = 0;
 1355|      0|		if ((voices[0] = SelectVoiceByName(voices_list, ESPEAKNG_DEFAULT_VOICE)) != NULL)
 1356|      0|			nv = 1;
 1357|      0|	}
 1358|      0|
 1359|      0|	gender = 0;
 1360|      0|	if ((voice_select2.gender == ENGENDER_FEMALE) || ((voice_select2.age > 0) && (voice_select2.age < 13)))
 1361|      0|		gender = ENGENDER_FEMALE;
 1362|      0|	else if (voice_select2.gender == ENGENDER_MALE)
 1363|      0|		gender = ENGENDER_MALE;
 1364|      0|
 1365|      0|	#define AGE_OLD 60
 1366|      0|	if (voice_select2.age < AGE_OLD)
 1367|      0|		aged = 0;
 1368|      0|
 1369|      0|	p = p_start = variant_lists[gender];
 1370|      0|	if (aged == 0)
 1371|      0|		p++; // the first voice in the variants list is older
 1372|      0|
 1373|      0|	// add variants for the top voices
 1374|      0|	n_variants = 0;
 1375|      0|	for (ix = 0, ix2 = 0; ix < nv; ix++) {
 1376|      0|		vp = voices[ix];
 1377|      0|		// is the main voice the required gender?
 1378|      0|		skip = 0;
 1379|      0|
 1380|      0|		if ((gender != ENGENDER_UNKNOWN) && (vp->gender != gender))
 1381|      0|			skip = 1;
 1382|      0|		if ((ix2 == 0) && aged && (vp->age < AGE_OLD))
 1383|      0|			skip = 1;
 1384|      0|
 1385|      0|		if (skip == 0)
 1386|      0|			voices2[ix2++] = vp;
 1387|      0|
 1388|      0|		for (j = 0; (j < vp->xx1) && (n_variants < N_VOICE_VARIANTS);) {
 1389|      0|			if ((variant_number = *p) == 0) {
 1390|      0|				p = p_start;
 1391|      0|				continue;
 1392|      0|			}
 1393|      0|
 1394|      0|			vp2 = &voice_variants[n_variants++]; // allocate space for voice variant
 1395|      0|			memcpy(vp2, vp, sizeof(espeak_VOICE)); // copy from the original voice
 1396|      0|			vp2->variant = variant_number;
 1397|      0|			voices2[ix2++] = vp2;
 1398|      0|			p++;
 1399|      0|			j++;
 1400|      0|		}
 1401|      0|	}
 1402|      0|	// add any more variants to the end of the list
 1403|      0|	while ((vp != NULL) && ((variant_number = *p++) != 0) && (n_variants < N_VOICE_VARIANTS)) {
 1404|      0|		vp2 = &voice_variants[n_variants++]; // allocate space for voice variant
 1405|      0|		memcpy(vp2, vp, sizeof(espeak_VOICE)); // copy from the original voice
 1406|      0|		vp2->variant = variant_number;
 1407|      0|		voices2[ix2++] = vp2;
 1408|      0|	}
 1409|      0|
 1410|      0|	// index the sorted list by the required variant number
 1411|      0|	if (ix2 == 0)
 1412|      0|		return NULL;
 1413|      0|	vp = voices2[voice_select2.variant % ix2];
 1414|      0|
 1415|      0|	if (vp->variant != 0) {
 1416|      0|		variant_name = ExtractVoiceVariantName(NULL, vp->variant, 0);
 1417|      0|		sprintf(voice_id, "%s+%s", vp->identifier, variant_name);
 1418|      0|		return voice_id;
 1419|      0|	}
 1420|      0|
 1421|      0|	return vp->identifier;
 1422|      0|}
 1423|       |
 1424|       |static void GetVoices(const char *path, int len_path_voices, int is_language_file)
 1425|      0|{
 1426|      0|	FILE *f_voice;
 1427|      0|	espeak_VOICE *voice_data;
 1428|      0|	int ftype;
 1429|      0|	char fname[sizeof(path_home)+100];
 1430|      0|
 1431|       |#ifdef PLATFORM_WINDOWS
 1432|       |	WIN32_FIND_DATAA FindFileData;
 1433|       |	HANDLE hFind = INVALID_HANDLE_VALUE;
 1434|       |
 1435|       |	#undef UNICODE // we need FindFirstFileA() which takes an 8-bit c-string
 1436|       |	sprintf(fname, "%s\\*", path);
 1437|       |	hFind = FindFirstFileA(fname, &FindFileData);
 1438|       |	if (hFind == INVALID_HANDLE_VALUE)
 1439|       |		return;
 1440|       |
 1441|       |	do {
 1442|       |		if (n_voices_list >= (N_VOICES_LIST-2)) {
 1443|       |			fprintf(stderr, "Warning: maximum number %d of (N_VOICES_LIST = %d - 1) reached\n", n_voices_list + 1, N_VOICES_LIST);
 1444|       |			break; // voices list is full
 1445|       |		}
 1446|       |
 1447|       |		if (FindFileData.cFileName[0] != '.') {
 1448|       |			sprintf(fname, "%s%c%s", path, PATHSEP, FindFileData.cFileName);
 1449|       |			ftype = GetFileLength(fname);
 1450|       |
 1451|       |			if (ftype == -EISDIR) {
 1452|       |				// a sub-directory
 1453|       |				GetVoices(fname, len_path_voices, is_language_file);
 1454|       |			} else if (ftype > 0) {
 1455|       |				// a regular file, add it to the voices list
 1456|       |				if ((f_voice = fopen(fname, "r")) == NULL)
 1457|       |					continue;
 1458|       |
 1459|       |				// pass voice file name within the voices directory
 1460|       |				voice_data = ReadVoiceFile(f_voice, fname+len_path_voices, is_language_file);
 1461|       |				fclose(f_voice);
 1462|       |
 1463|       |				if (voice_data != NULL)
 1464|       |					voices_list[n_voices_list++] = voice_data;
 1465|       |			}
 1466|       |		}
 1467|       |	} while (FindNextFileA(hFind, &FindFileData) != 0);
 1468|       |	FindClose(hFind);
 1469|       |#else
 1470|       |	DIR *dir;
 1471|      0|	struct dirent *ent;
 1472|      0|
 1473|      0|	if ((dir = opendir((char *)path)) == NULL) // note: (char *) is needed for WINCE
 1474|      0|		return;
 1475|      0|
 1476|      0|	while ((ent = readdir(dir)) != NULL) {
 1477|      0|		if (n_voices_list >= (N_VOICES_LIST-2)) {
 1478|      0|			fprintf(stderr, "Warning: maximum number %d of (N_VOICES_LIST = %d - 1) reached\n", n_voices_list + 1, N_VOICES_LIST);
 1479|      0|			break; // voices list is full
 1480|      0|		}
 1481|      0|
 1482|      0|		if (ent->d_name[0] == '.')
 1483|      0|			continue;
 1484|      0|
 1485|      0|		sprintf(fname, "%s%c%s", path, PATHSEP, ent->d_name);
 1486|      0|
 1487|      0|		ftype = GetFileLength(fname);
 1488|      0|
 1489|      0|		if (ftype == -EISDIR) {
 1490|      0|			// a sub-directory
 1491|      0|			GetVoices(fname, len_path_voices, is_language_file);
 1492|      0|		} else if (ftype > 0) {
 1493|      0|			// a regular file, add it to the voices list
 1494|      0|			if ((f_voice = fopen(fname, "r")) == NULL)
 1495|      0|				continue;
 1496|      0|
 1497|      0|			// pass voice file name within the voices directory
 1498|      0|			voice_data = ReadVoiceFile(f_voice, fname+len_path_voices, is_language_file);
 1499|      0|			fclose(f_voice);
 1500|      0|
 1501|      0|			if (voice_data != NULL)
 1502|      0|				voices_list[n_voices_list++] = voice_data;
 1503|      0|		}
 1504|      0|	}
 1505|      0|	closedir(dir);
 1506|      0|#endif
 1507|      0|}
 1508|       |
 1509|       |#pragma GCC visibility push(default)
 1510|       |
 1511|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_SetVoiceByFile(const char *filename)
 1512|      0|{
 1513|      0|	int ix;
 1514|      0|	espeak_VOICE voice_selector;
 1515|      0|	char *variant_name;
 1516|      0|	static char buf[60];
 1517|      0|
 1518|      0|	strncpy0(buf, filename, sizeof(buf));
 1519|      0|
 1520|      0|	variant_name = ExtractVoiceVariantName(buf, 0, 1);
 1521|      0|
 1522|      0|	for (ix = 0;; ix++) {
 1523|      0|		// convert voice name to lower case  (ascii)
 1524|      0|		if ((buf[ix] = tolower(buf[ix])) == 0)
 1525|      0|			break;
 1526|      0|	}
 1527|      0|
 1528|      0|	memset(&voice_selector, 0, sizeof(voice_selector));
 1529|      0|	voice_selector.name = (char *)filename; // include variant name in voice stack ??
 1530|      0|
 1531|      0|	// first check for a voice with this filename
 1532|      0|	// This may avoid the need to call espeak_ListVoices().
 1533|      0|
 1534|      0|	if (LoadVoice(buf, 0x10) != NULL) {
 1535|      0|		if (variant_name[0] != 0)
 1536|      0|			LoadVoice(variant_name, 2);
 1537|      0|
 1538|      0|		DoVoiceChange(voice);
 1539|      0|		voice_selector.languages = voice->language_name;
 1540|      0|		SetVoiceStack(&voice_selector, variant_name);
 1541|      0|		return ENS_OK;
 1542|      0|	}
 1543|      0|
 1544|      0|	return ENS_VOICE_NOT_FOUND;
 1545|      0|}
 1546|       |
 1547|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_SetVoiceByName(const char *name)
 1548|      0|{
 1549|      0|	espeak_VOICE *v;
 1550|      0|	int ix;
 1551|      0|	espeak_VOICE voice_selector;
 1552|      0|	char *variant_name;
 1553|      0|	static char buf[60];
 1554|      0|
 1555|      0|	strncpy0(buf, name, sizeof(buf));
 1556|      0|
 1557|      0|	variant_name = ExtractVoiceVariantName(buf, 0, 1);
 1558|      0|
 1559|      0|	for (ix = 0;; ix++) {
 1560|      0|		// convert voice name to lower case  (ascii)
 1561|      0|		if ((buf[ix] = tolower(buf[ix])) == 0)
 1562|      0|			break;
 1563|      0|	}
 1564|      0|
 1565|      0|	memset(&voice_selector, 0, sizeof(voice_selector));
 1566|      0|	voice_selector.name = (char *)name; // include variant name in voice stack ??
 1567|      0|
 1568|      0|	// first check for a voice with this filename
 1569|      0|	// This may avoid the need to call espeak_ListVoices().
 1570|      0|
 1571|      0|	if (LoadVoice(buf, 1) != NULL) {
 1572|      0|		if (variant_name[0] != 0)
 1573|      0|			LoadVoice(variant_name, 2);
 1574|      0|
 1575|      0|		DoVoiceChange(voice);
 1576|      0|		voice_selector.languages = voice->language_name;
 1577|      0|		SetVoiceStack(&voice_selector, variant_name);
 1578|      0|		return ENS_OK;
 1579|      0|	}
 1580|      0|
 1581|      0|	if (n_voices_list == 0)
 1582|      0|		espeak_ListVoices(NULL); // create the voices list
 1583|      0|
 1584|      0|	if ((v = SelectVoiceByName(voices_list, buf)) != NULL) {
 1585|      0|		if (LoadVoice(v->identifier, 0) != NULL) {
 1586|      0|			if (variant_name[0] != 0)
 1587|      0|				LoadVoice(variant_name, 2);
 1588|      0|			DoVoiceChange(voice);
 1589|      0|			voice_selector.languages = voice->language_name;
 1590|      0|			SetVoiceStack(&voice_selector, variant_name);
 1591|      0|			return ENS_OK;
 1592|      0|		}
 1593|      0|	}
 1594|      0|	return ENS_VOICE_NOT_FOUND;
 1595|      0|}
 1596|       |
 1597|       |ESPEAK_NG_API espeak_ng_STATUS espeak_ng_SetVoiceByProperties(espeak_VOICE *voice_selector)
 1598|      0|{
 1599|      0|	const char *voice_id;
 1600|      0|	int voice_found;
 1601|      0|
 1602|      0|	voice_id = SelectVoice(voice_selector, &voice_found);
 1603|      0|	if (voice_found == 0)
 1604|      0|		return ENS_VOICE_NOT_FOUND;
 1605|      0|
 1606|      0|	LoadVoiceVariant(voice_id, 0);
 1607|      0|	DoVoiceChange(voice);
 1608|      0|	SetVoiceStack(voice_selector, "");
 1609|      0|
 1610|      0|	return ENS_OK;
 1611|      0|}
 1612|       |
 1613|       |#pragma GCC visibility pop
 1614|       |
 1615|       |void FreeVoiceList()
 1616|      0|{
 1617|      0|	int ix;
 1618|      0|	for (ix = 0; ix < n_voices_list; ix++) {
 1619|      0|		if (voices_list[ix] != NULL) {
 1620|      0|			free(voices_list[ix]);
 1621|      0|			voices_list[ix] = NULL;
 1622|      0|		}
 1623|      0|	}
 1624|      0|	n_voices_list = 0;
 1625|      0|}
 1626|       |
 1627|       |#pragma GCC visibility push(default)
 1628|       |
 1629|       |ESPEAK_API const espeak_VOICE **espeak_ListVoices(espeak_VOICE *voice_spec)
 1630|      0|{
 1631|      0|	char path_voices[sizeof(path_home)+12];
 1632|      0|
 1633|      0|	int ix;
 1634|      0|	int j;
 1635|      0|	espeak_VOICE *v;
 1636|      0|	static espeak_VOICE **voices = NULL;
 1637|      0|
 1638|      0|	// free previous voice list data
 1639|      0|	FreeVoiceList();
 1640|      0|
 1641|      0|	sprintf(path_voices, "%s%cvoices", path_home, PATHSEP);
 1642|      0|	GetVoices(path_voices, strlen(path_voices)+1, 0);
 1643|      0|
 1644|      0|	sprintf(path_voices, "%s%clang", path_home, PATHSEP);
 1645|      0|	GetVoices(path_voices, strlen(path_voices)+1, 1);
 1646|      0|
 1647|      0|	voices_list[n_voices_list] = NULL; // voices list terminator
 1648|      0|	espeak_VOICE **new_voices = (espeak_VOICE **)realloc(voices, sizeof(espeak_VOICE *)*(n_voices_list+1));
 1649|      0|	if (new_voices == NULL)
 1650|      0|		return (const espeak_VOICE **)voices;
 1651|      0|	voices = new_voices;
 1652|      0|
 1653|      0|	// sort the voices list
 1654|      0|	qsort(voices_list, n_voices_list, sizeof(espeak_VOICE *),
 1655|      0|	      (int(__cdecl *)(const void *, const void *))VoiceNameSorter);
 1656|      0|
 1657|      0|	if (voice_spec) {
 1658|      0|		// select the voices which match the voice_spec, and sort them by preference
 1659|      0|		SetVoiceScores(voice_spec, voices, 1);
 1660|      0|	} else {
 1661|      0|		// list all: omit variant and mbrola voices
 1662|      0|		j = 0;
 1663|      0|		for (ix = 0; (v = voices_list[ix]) != NULL; ix++) {
 1664|      0|			if ((v->languages[0] != 0) && (strcmp(&v->languages[1], "variant") != 0)
 1665|      0|			    && (memcmp(v->identifier, "mb/", 3) != 0))
 1666|      0|				voices[j++] = v;
 1667|      0|		}
 1668|      0|		voices[j] = NULL;
 1669|      0|	}
 1670|      0|	return (const espeak_VOICE **)voices;
 1671|      0|}
 1672|       |
 1673|       |ESPEAK_API espeak_VOICE *espeak_GetCurrentVoice(void)
 1674|      0|{
 1675|      0|	return &current_voice_selected;
 1676|      0|}
 1677|       |
 1678|       |#pragma GCC visibility pop

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/libespeak-ng/wavegen.c:
    1|       |/*
    2|       | * Copyright (C) 2005 to 2013 by Jonathan Duddington
    3|       | * email: jonsd@users.sourceforge.net
    4|       | * Copyright (C) 2015-2016 Reece H. Dunn
    5|       | *
    6|       | * This program is free software; you can redistribute it and/or modify
    7|       | * it under the terms of the GNU General Public License as published by
    8|       | * the Free Software Foundation; either version 3 of the License, or
    9|       | * (at your option) any later version.
   10|       | *
   11|       | * This program is distributed in the hope that it will be useful,
   12|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   13|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   14|       | * GNU General Public License for more details.
   15|       | *
   16|       | * You should have received a copy of the GNU General Public License
   17|       | * along with this program; if not, see: <http://www.gnu.org/licenses/>.
   18|       | */
   19|       |
   20|       |// this version keeps wavemult window as a constant fraction
   21|       |// of the cycle length - but that spreads out the HF peaks too much
   22|       |
   23|       |#include "config.h"
   24|       |
   25|       |#include <math.h>
   26|       |#include <stdbool.h>
   27|       |#include <stdint.h>
   28|       |#include <stdio.h>
   29|       |#include <stdlib.h>
   30|       |#include <string.h>
   31|       |
   32|       |#include <espeak-ng/espeak_ng.h>
   33|       |#include <espeak-ng/speak_lib.h>
   34|       |
   35|       |#include "wavegen.h"
   36|       |#include "synthesize.h"               // for WGEN_DATA, RESONATOR, frame_t
   37|       |#include "mbrola.h"                  // for MbrolaFill, MbrolaReset, mbrola...
   38|       |
   39|       |#ifdef INCLUDE_KLATT
   40|       |#include "klatt.h"
   41|       |#endif
   42|       |
   43|       |#if HAVE_SONIC_H
   44|       |#include "sonic.h"
   45|       |#endif
   46|       |
   47|       |#include "sintab.h"
   48|       |
   49|       |static void SetSynth(int length, int modn, frame_t *fr1, frame_t *fr2, voice_t *v);
   50|       |
   51|       |voice_t *wvoice = NULL;
   52|       |
   53|       |static int option_harmonic1 = 10;
   54|       |static int flutter_amp = 64;
   55|       |
   56|       |static int general_amplitude = 60;
   57|       |static int consonant_amp = 26;
   58|       |
   59|       |int embedded_value[N_EMBEDDED_VALUES];
   60|       |
   61|       |static int PHASE_INC_FACTOR;
   62|       |int samplerate = 0; // this is set by Wavegeninit()
   63|       |int samplerate_native = 0;
   64|       |
   65|       |static wavegen_peaks_t peaks[N_PEAKS];
   66|       |static int peak_harmonic[N_PEAKS];
   67|       |static int peak_height[N_PEAKS];
   68|       |
   69|       |int echo_head;
   70|       |int echo_tail;
   71|       |int echo_amp = 0;
   72|       |short echo_buf[N_ECHO_BUF];
   73|       |static int echo_length = 0; // period (in sample\) to ensure completion of echo at the end of speech, set in WavegenSetEcho()
   74|       |
   75|       |static int voicing;
   76|       |static RESONATOR rbreath[N_PEAKS];
   77|       |
   78|      0|#define N_LOWHARM  30
   79|      0|#define MAX_HARMONIC 400 // 400 * 50Hz = 20 kHz, more than enough
   80|       |static int harm_inc[N_LOWHARM]; // only for these harmonics do we interpolate amplitude between steps
   81|       |static int *harmspect;
   82|       |static int hswitch = 0;
   83|       |static int hspect[2][MAX_HARMONIC]; // 2 copies, we interpolate between then
   84|       |
   85|       |static int nsamples = 0; // number to do
   86|       |static int modulation_type = 0;
   87|       |static int glottal_flag = 0;
   88|       |static int glottal_reduce = 0;
   89|       |
   90|       |WGEN_DATA wdata;
   91|       |
   92|       |static int amp_ix;
   93|       |static int amp_inc;
   94|       |static unsigned char *amplitude_env = NULL;
   95|       |
   96|       |static int samplecount = 0; // number done
   97|       |static int samplecount_start = 0; // count at start of this segment
   98|       |static int end_wave = 0; // continue to end of wave cycle
   99|       |static int wavephase;
  100|       |static int phaseinc;
  101|       |static int cycle_samples; // number of samples in a cycle at current pitch
  102|       |static int cbytes;
  103|       |static int hf_factor;
  104|       |
  105|       |static double minus_pi_t;
  106|       |static double two_pi_t;
  107|       |
  108|       |unsigned char *out_ptr;
  109|       |unsigned char *out_end;
  110|       |
  111|       |espeak_ng_OUTPUT_HOOKS* output_hooks = NULL;
  112|       |int const_f0 = 0;
  113|       |
  114|       |// the queue of operations passed to wavegen from sythesize
  115|       |intptr_t wcmdq[N_WCMDQ][4];
  116|       |int wcmdq_head = 0;
  117|       |int wcmdq_tail = 0;
  118|       |
  119|       |// pitch,speed,
  120|       |int embedded_default[N_EMBEDDED_VALUES]    = { 0,     50, espeakRATE_NORMAL, 100, 50,  0,  0, 0, espeakRATE_NORMAL, 0, 0, 0, 0, 0, 0 };
  121|       |static int embedded_max[N_EMBEDDED_VALUES] = { 0, 0x7fff, 750, 300, 99, 99, 99, 0, 750, 0, 0, 0, 0, 4, 0 };
  122|       |
  123|       |int current_source_index = 0;
  124|       |
  125|       |#if HAVE_SONIC_H
  126|       |static sonicStream sonicSpeedupStream = NULL;
  127|       |double sonicSpeed = 1.0;
  128|       |#endif
  129|       |
  130|       |// 1st index=roughness
  131|       |// 2nd index=modulation_type
  132|       |// value: bits 0-3  amplitude (16ths), bits 4-7 every n cycles
  133|      0|#define N_ROUGHNESS 8
  134|       |static unsigned char modulation_tab[N_ROUGHNESS][8] = {
  135|       |	{ 0, 0x00, 0x00, 0x00, 0, 0x46, 0xf2, 0x29 },
  136|       |	{ 0, 0x2f, 0x00, 0x2f, 0, 0x45, 0xf2, 0x29 },
  137|       |	{ 0, 0x2f, 0x00, 0x2e, 0, 0x45, 0xf2, 0x28 },
  138|       |	{ 0, 0x2e, 0x00, 0x2d, 0, 0x34, 0xf2, 0x28 },
  139|       |	{ 0, 0x2d, 0x2d, 0x2c, 0, 0x34, 0xf2, 0x28 },
  140|       |	{ 0, 0x2b, 0x2b, 0x2b, 0, 0x34, 0xf2, 0x28 },
  141|       |	{ 0, 0x2a, 0x2a, 0x2a, 0, 0x34, 0xf2, 0x28 },
  142|       |	{ 0, 0x29, 0x29, 0x29, 0, 0x34, 0xf2, 0x28 },
  143|       |};
  144|       |
  145|       |// Flutter table, to add natural variations to the pitch
  146|      0|#define N_FLUTTER  0x170
  147|       |static int Flutter_inc;
  148|       |static const unsigned char Flutter_tab[N_FLUTTER] = {
  149|       |	0x80, 0x9b, 0xb5, 0xcb, 0xdc, 0xe8, 0xed, 0xec,
  150|       |	0xe6, 0xdc, 0xce, 0xbf, 0xb0, 0xa3, 0x98, 0x90,
  151|       |	0x8c, 0x8b, 0x8c, 0x8f, 0x92, 0x94, 0x95, 0x92,
  152|       |	0x8c, 0x83, 0x78, 0x69, 0x59, 0x49, 0x3c, 0x31,
  153|       |	0x2a, 0x29, 0x2d, 0x36, 0x44, 0x56, 0x69, 0x7d,
  154|       |	0x8f, 0x9f, 0xaa, 0xb1, 0xb2, 0xad, 0xa4, 0x96,
  155|       |	0x87, 0x78, 0x69, 0x5c, 0x53, 0x4f, 0x4f, 0x55,
  156|       |	0x5e, 0x6b, 0x7a, 0x88, 0x96, 0xa2, 0xab, 0xb0,
  157|       |
  158|       |	0xb1, 0xae, 0xa8, 0xa0, 0x98, 0x91, 0x8b, 0x88,
  159|       |	0x89, 0x8d, 0x94, 0x9d, 0xa8, 0xb2, 0xbb, 0xc0,
  160|       |	0xc1, 0xbd, 0xb4, 0xa5, 0x92, 0x7c, 0x63, 0x4a,
  161|       |	0x32, 0x1e, 0x0e, 0x05, 0x02, 0x05, 0x0f, 0x1e,
  162|       |	0x30, 0x44, 0x59, 0x6d, 0x7f, 0x8c, 0x96, 0x9c,
  163|       |	0x9f, 0x9f, 0x9d, 0x9b, 0x99, 0x99, 0x9c, 0xa1,
  164|       |	0xa9, 0xb3, 0xbf, 0xca, 0xd5, 0xdc, 0xe0, 0xde,
  165|       |	0xd8, 0xcc, 0xbb, 0xa6, 0x8f, 0x77, 0x60, 0x4b,
  166|       |
  167|       |	0x3a, 0x2e, 0x28, 0x29, 0x2f, 0x3a, 0x48, 0x59,
  168|       |	0x6a, 0x7a, 0x86, 0x90, 0x94, 0x95, 0x91, 0x89,
  169|       |	0x80, 0x75, 0x6b, 0x62, 0x5c, 0x5a, 0x5c, 0x61,
  170|       |	0x69, 0x74, 0x80, 0x8a, 0x94, 0x9a, 0x9e, 0x9d,
  171|       |	0x98, 0x90, 0x86, 0x7c, 0x71, 0x68, 0x62, 0x60,
  172|       |	0x63, 0x6b, 0x78, 0x88, 0x9b, 0xaf, 0xc2, 0xd2,
  173|       |	0xdf, 0xe6, 0xe7, 0xe2, 0xd7, 0xc6, 0xb2, 0x9c,
  174|       |	0x84, 0x6f, 0x5b, 0x4b, 0x40, 0x39, 0x37, 0x38,
  175|       |
  176|       |	0x3d, 0x43, 0x4a, 0x50, 0x54, 0x56, 0x55, 0x52,
  177|       |	0x4d, 0x48, 0x42, 0x3f, 0x3e, 0x41, 0x49, 0x56,
  178|       |	0x67, 0x7c, 0x93, 0xab, 0xc3, 0xd9, 0xea, 0xf6,
  179|       |	0xfc, 0xfb, 0xf4, 0xe7, 0xd5, 0xc0, 0xaa, 0x94,
  180|       |	0x80, 0x71, 0x64, 0x5d, 0x5a, 0x5c, 0x61, 0x68,
  181|       |	0x70, 0x77, 0x7d, 0x7f, 0x7f, 0x7b, 0x74, 0x6b,
  182|       |	0x61, 0x57, 0x4e, 0x48, 0x46, 0x48, 0x4e, 0x59,
  183|       |	0x66, 0x75, 0x84, 0x93, 0x9f, 0xa7, 0xab, 0xaa,
  184|       |
  185|       |	0xa4, 0x99, 0x8b, 0x7b, 0x6a, 0x5b, 0x4e, 0x46,
  186|       |	0x43, 0x45, 0x4d, 0x5a, 0x6b, 0x7f, 0x92, 0xa6,
  187|       |	0xb8, 0xc5, 0xcf, 0xd3, 0xd2, 0xcd, 0xc4, 0xb9,
  188|       |	0xad, 0xa1, 0x96, 0x8e, 0x89, 0x87, 0x87, 0x8a,
  189|       |	0x8d, 0x91, 0x92, 0x91, 0x8c, 0x84, 0x78, 0x68,
  190|       |	0x55, 0x41, 0x2e, 0x1c, 0x0e, 0x05, 0x01, 0x05,
  191|       |	0x0f, 0x1f, 0x34, 0x4d, 0x68, 0x81, 0x9a, 0xb0,
  192|       |	0xc1, 0xcd, 0xd3, 0xd3, 0xd0, 0xc8, 0xbf, 0xb5,
  193|       |
  194|       |	0xab, 0xa4, 0x9f, 0x9c, 0x9d, 0xa0, 0xa5, 0xaa,
  195|       |	0xae, 0xb1, 0xb0, 0xab, 0xa3, 0x96, 0x87, 0x76,
  196|       |	0x63, 0x51, 0x42, 0x36, 0x2f, 0x2d, 0x31, 0x3a,
  197|       |	0x48, 0x59, 0x6b, 0x7e, 0x8e, 0x9c, 0xa6, 0xaa,
  198|       |	0xa9, 0xa3, 0x98, 0x8a, 0x7b, 0x6c, 0x5d, 0x52,
  199|       |	0x4a, 0x48, 0x4a, 0x50, 0x5a, 0x67, 0x75, 0x82
  200|       |};
  201|       |
  202|       |// waveform shape table for HF peaks, formants 6,7,8
  203|      0|#define N_WAVEMULT 128
  204|       |static int wavemult_offset = 0;
  205|       |static int wavemult_max = 0;
  206|       |
  207|       |// the presets are for 22050 Hz sample rate.
  208|       |// A different rate will need to recalculate the presets in WavegenInit()
  209|       |static unsigned char wavemult[N_WAVEMULT] = {
  210|       |	  0,   0,   0,   2,   3,   5,   8,  11,  14,  18,  22,  27,  32,  37,  43,  49,
  211|       |	 55,  62,  69,  76,  83,  90,  98, 105, 113, 121, 128, 136, 144, 152, 159, 166,
  212|       |	174, 181, 188, 194, 201, 207, 213, 218, 224, 228, 233, 237, 240, 244, 246, 249,
  213|       |	251, 252, 253, 253, 253, 253, 252, 251, 249, 246, 244, 240, 237, 233, 228, 224,
  214|       |	218, 213, 207, 201, 194, 188, 181, 174, 166, 159, 152, 144, 136, 128, 121, 113,
  215|       |	105,  98,  90,  83,  76,  69,  62,  55,  49,  43,  37,  32,  27,  22,  18,  14,
  216|       |	 11,   8,   5,   3,   2,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  217|       |	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0
  218|       |};
  219|       |
  220|       |// set from y = pow(2,x) * 128,  x=-1 to 1
  221|       |unsigned char pitch_adjust_tab[MAX_PITCH_VALUE+1] = {
  222|       |	 64,  65,  66,  67,  68,  69,  70,  71,
  223|       |	 72,  73,  74,  75,  76,  77,  78,  79,
  224|       |	 80,  81,  82,  83,  84,  86,  87,  88,
  225|       |	 89,  91,  92,  93,  94,  96,  97,  98,
  226|       |	100, 101, 103, 104, 105, 107, 108, 110,
  227|       |	111, 113, 115, 116, 118, 119, 121, 123,
  228|       |	124, 126, 128, 130, 132, 133, 135, 137,
  229|       |	139, 141, 143, 145, 147, 149, 151, 153,
  230|       |	155, 158, 160, 162, 164, 167, 169, 171,
  231|       |	174, 176, 179, 181, 184, 186, 189, 191,
  232|       |	194, 197, 199, 202, 205, 208, 211, 214,
  233|       |	217, 220, 223, 226, 229, 232, 236, 239,
  234|       |	242, 246, 249, 252, 254, 255
  235|       |};
  236|       |
  237|       |void WcmdqStop()
  238|      0|{
  239|      0|	wcmdq_head = 0;
  240|      0|	wcmdq_tail = 0;
  241|      0|
  242|       |#if HAVE_SONIC_H
  243|       |	if (sonicSpeedupStream != NULL) {
  244|       |		sonicDestroyStream(sonicSpeedupStream);
  245|       |		sonicSpeedupStream = NULL;
  246|       |	}
  247|       |#endif
  248|       |
  249|      0|	if (mbrola_name[0] != 0)
  250|      0|		MbrolaReset();
  251|      0|}
  252|       |
  253|       |int WcmdqFree()
  254|      0|{
  255|      0|	int i;
  256|      0|	i = wcmdq_head - wcmdq_tail;
  257|      0|	if (i <= 0) i += N_WCMDQ;
  258|      0|	return i;
  259|      0|}
  260|       |
  261|       |int WcmdqUsed()
  262|      0|{
  263|      0|	return N_WCMDQ - WcmdqFree();
  264|      0|}
  265|       |
  266|       |void WcmdqInc()
  267|      0|{
  268|      0|	wcmdq_tail++;
  269|      0|	if (wcmdq_tail >= N_WCMDQ) wcmdq_tail = 0;
  270|      0|}
  271|       |
  272|       |static void WcmdqIncHead()
  273|      0|{
  274|      0|	wcmdq_head++;
  275|      0|	if (wcmdq_head >= N_WCMDQ) wcmdq_head = 0;
  276|      0|}
  277|       |
  278|       |#define PEAKSHAPEW 256
  279|       |
  280|       |unsigned char pk_shape1[PEAKSHAPEW+1] = {
  281|       |	255, 254, 254, 254, 254, 254, 253, 253, 252, 251, 251, 250, 249, 248, 247, 246,
  282|       |	245, 244, 242, 241, 239, 238, 236, 234, 233, 231, 229, 227, 225, 223, 220, 218,
  283|       |	216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 191, 189, 187, 185,
  284|       |	183, 180, 178, 176, 173, 171, 169, 166, 164, 161, 159, 156, 154, 151, 148, 146,
  285|       |	143, 140, 138, 135, 132, 129, 126, 123, 120, 118, 115, 112, 108, 105, 102,  99,
  286|       |	 96,  95,  93,  91,  90,  88,  86,  85,  83,  82,  80,  79,  77,  76,  74,  73,
  287|       |	 72,  70,  69,  68,  67,  66,  64,  63,  62,  61,  60,  59,  58,  57,  56,  55,
  288|       |	 55,  54,  53,  52,  52,  51,  50,  50,  49,  48,  48,  47,  47,  46,  46,  46,
  289|       |	 45,  45,  45,  44,  44,  44,  44,  44,  44,  44,  43,  43,  43,  43,  44,  43,
  290|       |	 42,  42,  41,  40,  40,  39,  38,  38,  37,  36,  36,  35,  35,  34,  33,  33,
  291|       |	 32,  32,  31,  30,  30,  29,  29,  28,  28,  27,  26,  26,  25,  25,  24,  24,
  292|       |	 23,  23,  22,  22,  21,  21,  20,  20,  19,  19,  18,  18,  18,  17,  17,  16,
  293|       |	 16,  15,  15,  15,  14,  14,  13,  13,  13,  12,  12,  11,  11,  11,  10,  10,
  294|       |	 10,   9,   9,   9,   8,   8,   8,   7,   7,   7,   7,   6,   6,   6,   5,   5,
  295|       |	  5,   5,   4,   4,   4,   4,   4,   3,   3,   3,   3,   2,   2,   2,   2,   2,
  296|       |	  2,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  297|       |	  0
  298|       |};
  299|       |
  300|       |static unsigned char pk_shape2[PEAKSHAPEW+1] = {
  301|       |	255, 254, 254, 254, 254, 254, 254, 254, 254, 254, 253, 253, 253, 253, 252, 252,
  302|       |	252, 251, 251, 251, 250, 250, 249, 249, 248, 248, 247, 247, 246, 245, 245, 244,
  303|       |	243, 243, 242, 241, 239, 237, 235, 233, 231, 229, 227, 225, 223, 221, 218, 216,
  304|       |	213, 211, 208, 205, 203, 200, 197, 194, 191, 187, 184, 181, 178, 174, 171, 167,
  305|       |	163, 160, 156, 152, 148, 144, 140, 136, 132, 127, 123, 119, 114, 110, 105, 100,
  306|       |	 96,  94,  91,  88,  86,  83,  81,  78,  76,  74,  71,  69,  66,  64,  62,  60,
  307|       |	 57,  55,  53,  51,  49,  47,  44,  42,  40,  38,  36,  34,  32,  30,  29,  27,
  308|       |	 25,  23,  21,  19,  18,  16,  14,  12,  11,   9,   7,   6,   4,   3,   1,   0,
  309|       |	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  310|       |	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  311|       |	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  312|       |	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  313|       |	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  314|       |	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  315|       |	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  316|       |	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  317|       |	  0
  318|       |};
  319|       |
  320|       |static unsigned char *pk_shape;
  321|       |
  322|       |void WavegenInit(int rate, int wavemult_fact)
  323|      0|{
  324|      0|	int ix;
  325|      0|	double x;
  326|      0|
  327|      0|	if (wavemult_fact == 0)
  328|      0|		wavemult_fact = 60; // default
  329|      0|
  330|      0|	wvoice = NULL;
  331|      0|	samplerate = samplerate_native = rate;
  332|      0|	PHASE_INC_FACTOR = 0x8000000 / samplerate; // assumes pitch is Hz*32
  333|      0|	Flutter_inc = (64 * samplerate)/rate;
  334|      0|	samplecount = 0;
  335|      0|	nsamples = 0;
  336|      0|	wavephase = 0x7fffffff;
  337|      0|
  338|      0|	wdata.amplitude = 32;
  339|      0|	wdata.amplitude_fmt = 100;
  340|      0|
  341|      0|	for (ix = 0; ix < N_EMBEDDED_VALUES; ix++)
  342|      0|		embedded_value[ix] = embedded_default[ix];
  343|      0|
  344|      0|	// set up window to generate a spread of harmonics from a
  345|      0|	// single peak for HF peaks
  346|      0|	wavemult_max = (samplerate * wavemult_fact)/(256 * 50);
  347|      0|	if (wavemult_max > N_WAVEMULT) wavemult_max = N_WAVEMULT;
  348|      0|
  349|      0|	wavemult_offset = wavemult_max/2;
  350|      0|
  351|      0|	if (samplerate != 22050) {
  352|      0|		// wavemult table has preset values for 22050 Hz, we only need to
  353|      0|		// recalculate them if we have a different sample rate
  354|      0|		for (ix = 0; ix < wavemult_max; ix++) {
  355|      0|			x = 127*(1.0 - cos((M_PI*2)*ix/wavemult_max));
  356|      0|			wavemult[ix] = (int)x;
  357|      0|		}
  358|      0|	}
  359|      0|
  360|      0|	pk_shape = pk_shape2;
  361|      0|
  362|      0|#ifdef INCLUDE_KLATT
  363|      0|	KlattInit();
  364|      0|#endif
  365|      0|}
  366|       |
  367|       |int GetAmplitude(void)
  368|      0|{
  369|      0|	int amp;
  370|      0|
  371|      0|	// normal, none, reduced, moderate, strong
  372|      0|	static const unsigned char amp_emphasis[5] = { 16, 16, 10, 16, 22 };
  373|      0|
  374|      0|	amp = (embedded_value[EMBED_A])*55/100;
  375|      0|	general_amplitude = amp * amp_emphasis[embedded_value[EMBED_F]] / 16;
  376|      0|	return general_amplitude;
  377|      0|}
  378|       |
  379|       |static void WavegenSetEcho(void)
  380|      0|{
  381|      0|	if (wvoice == NULL)
  382|      0|		return;
  383|      0|
  384|      0|	int delay;
  385|      0|	int amp;
  386|      0|
  387|      0|	voicing = wvoice->voicing;
  388|      0|	delay = wvoice->echo_delay;
  389|      0|	amp = wvoice->echo_amp;
  390|      0|
  391|      0|	if (delay >= N_ECHO_BUF)
  392|      0|		delay = N_ECHO_BUF-1;
  393|      0|	if (amp > 100)
  394|      0|		amp = 100;
  395|      0|
  396|      0|	memset(echo_buf, 0, sizeof(echo_buf));
  397|      0|	echo_tail = 0;
  398|      0|
  399|      0|	if (embedded_value[EMBED_H] > 0) {
  400|      0|		// set echo from an embedded command in the text
  401|      0|		amp = embedded_value[EMBED_H];
  402|      0|		delay = 130;
  403|      0|	}
  404|      0|
  405|      0|	if (delay == 0)
  406|      0|		amp = 0;
  407|      0|
  408|      0|	echo_head = (delay * samplerate)/1000;
  409|      0|	echo_length = echo_head; // ensure completion of echo at the end of speech. Use 1 delay period?
  410|      0|	if (amp == 0)
  411|      0|		echo_length = 0;
  412|      0|	if (amp > 20)
  413|      0|		echo_length = echo_head * 2; // perhaps allow 2 echo periods if the echo is loud.
  414|      0|
  415|      0|	// echo_amp units are 1/256ths of the amplitude of the original sound.
  416|      0|	echo_amp = amp;
  417|      0|	// compensate (partially) for increase in amplitude due to echo
  418|      0|	general_amplitude = GetAmplitude();
  419|      0|	general_amplitude = ((general_amplitude * (500-amp))/500);
  420|      0|}
  421|       |
  422|       |int PeaksToHarmspect(wavegen_peaks_t *peaks, int pitch, int *htab, int control)
  423|      0|{
  424|      0|	if (wvoice == NULL)
  425|      0|		return 1;
  426|      0|
  427|      0|	// Calculate the amplitude of each  harmonics from the formants
  428|      0|	// Only for formants 0 to 5
  429|      0|
  430|      0|	// control 0=initial call, 1=every 64 cycles
  431|      0|
  432|      0|	// pitch and freqs are Hz<<16
  433|      0|
  434|      0|	int f;
  435|      0|	wavegen_peaks_t *p;
  436|      0|	int fp;  // centre freq of peak
  437|      0|	int fhi; // high freq of peak
  438|      0|	int h;   // harmonic number
  439|      0|	int pk;
  440|      0|	int hmax;
  441|      0|	int hmax_samplerate; // highest harmonic allowed for the samplerate
  442|      0|	int x;
  443|      0|	int ix;
  444|      0|	int h1;
  445|      0|
  446|      0|	// initialise as much of *out as we will need
  447|      0|	hmax = (peaks[wvoice->n_harmonic_peaks].freq + peaks[wvoice->n_harmonic_peaks].right)/pitch;
  448|      0|	if (hmax >= MAX_HARMONIC)
  449|      0|		hmax = MAX_HARMONIC-1;
  450|      0|
  451|      0|	// restrict highest harmonic to half the samplerate
  452|      0|	hmax_samplerate = (((samplerate * 19)/40) << 16)/pitch; // only 95% of Nyquist freq
  453|      0|
  454|      0|	if (hmax > hmax_samplerate)
  455|      0|		hmax = hmax_samplerate;
  456|      0|
  457|      0|	for (h = 0; h <= hmax; h++)
  458|      0|		htab[h] = 0;
  459|      0|
  460|      0|	for (pk = 0; pk <= wvoice->n_harmonic_peaks; pk++) {
  461|      0|		p = &peaks[pk];
  462|      0|		if ((p->height == 0) || (fp = p->freq) == 0)
  463|      0|			continue;
  464|      0|
  465|      0|		fhi = p->freq + p->right;
  466|      0|		h = ((p->freq - p->left) / pitch) + 1;
  467|      0|		if (h <= 0) h = 1;
  468|      0|
  469|      0|		for (f = pitch*h; f < fp; f += pitch)
  470|      0|			htab[h++] += pk_shape[(fp-f)/(p->left>>8)] * p->height;
  471|      0|		for (; f < fhi; f += pitch)
  472|      0|			htab[h++] += pk_shape[(f-fp)/(p->right>>8)] * p->height;
  473|      0|	}
  474|      0|
  475|      0|	int y;
  476|      0|	int h2;
  477|      0|	// increase bass
  478|      0|	y = peaks[1].height * 10; // addition as a multiple of 1/256s
  479|      0|	h2 = (1000<<16)/pitch; // decrease until 1000Hz
  480|      0|	if (h2 > 0) {
  481|      0|		x = y/h2;
  482|      0|		h = 1;
  483|      0|		while (y > 0) {
  484|      0|			htab[h++] += y;
  485|      0|			y -= x;
  486|      0|		}
  487|      0|	}
  488|      0|
  489|      0|	// find the nearest harmonic for HF peaks where we don't use shape
  490|      0|	for (; pk < N_PEAKS; pk++) {
  491|      0|		x = peaks[pk].height >> 14;
  492|      0|		peak_height[pk] = (x * x * 5)/2;
  493|      0|
  494|      0|		// find the nearest harmonic for HF peaks where we don't use shape
  495|      0|		if (control == 0) {
  496|      0|			// set this initially, but make changes only at the quiet point
  497|      0|			peak_harmonic[pk] = peaks[pk].freq / pitch;
  498|      0|		}
  499|      0|		// only use harmonics up to half the samplerate
  500|      0|		if (peak_harmonic[pk] >= hmax_samplerate)
  501|      0|			peak_height[pk] = 0;
  502|      0|	}
  503|      0|
  504|      0|	// convert from the square-rooted values
  505|      0|	f = 0;
  506|      0|	for (h = 0; h <= hmax; h++, f += pitch) {
  507|      0|		x = htab[h] >> 15;
  508|      0|		htab[h] = (x * x) >> 8;
  509|      0|
  510|      0|		if ((ix = (f >> 19)) < N_TONE_ADJUST)
  511|      0|			htab[h] = (htab[h] * wvoice->tone_adjust[ix]) >> 13; // index tone_adjust with Hz/8
  512|      0|	}
  513|      0|
  514|      0|	// adjust the amplitude of the first harmonic, affects tonal quality
  515|      0|	h1 = htab[1] * option_harmonic1;
  516|      0|	htab[1] = h1/8;
  517|      0|
  518|      0|	// calc intermediate increments of LF harmonics
  519|      0|	if (control & 1) {
  520|      0|		for (h = 1; h < N_LOWHARM; h++)
  521|      0|			harm_inc[h] = (htab[h] - harmspect[h]) >> 3;
  522|      0|	}
  523|      0|
  524|      0|	return hmax; // highest harmonic number
  525|      0|}
  526|       |
  527|       |static void AdvanceParameters()
  528|      0|{
  529|      0|	// Called every 64 samples to increment the formant freq, height, and widths
  530|      0|	if (wvoice == NULL)
  531|      0|		return;
  532|      0|
  533|      0|	int x;
  534|      0|	int ix;
  535|      0|	static int Flutter_ix = 0;
  536|      0|
  537|      0|	// advance the pitch
  538|      0|	wdata.pitch_ix += wdata.pitch_inc;
  539|      0|	if ((ix = wdata.pitch_ix>>8) > 127) ix = 127;
  540|      0|	x = wdata.pitch_env[ix] * wdata.pitch_range;
  541|      0|	wdata.pitch = (x>>8) + wdata.pitch_base;
  542|      0|	
  543|      0|	
  544|      0|
  545|      0|	amp_ix += amp_inc;
  546|      0|
  547|      0|	/* add pitch flutter */
  548|      0|	if (Flutter_ix >= (N_FLUTTER*64))
  549|      0|		Flutter_ix = 0;
  550|      0|	x = ((int)(Flutter_tab[Flutter_ix >> 6])-0x80) * flutter_amp;
  551|      0|	Flutter_ix += Flutter_inc;
  552|      0|	wdata.pitch += x;
  553|      0|	
  554|      0|	if(const_f0)
  555|      0|		wdata.pitch = (const_f0<<12);
  556|      0|	
  557|      0|	if (wdata.pitch < 102400)
  558|      0|		wdata.pitch = 102400; // min pitch, 25 Hz  (25 << 12)
  559|      0|
  560|      0|	if (samplecount == samplecount_start)
  561|      0|		return;
  562|      0|
  563|      0|	for (ix = 0; ix <= wvoice->n_harmonic_peaks; ix++) {
  564|      0|		peaks[ix].freq1 += peaks[ix].freq_inc;
  565|      0|		peaks[ix].freq = (int)peaks[ix].freq1;
  566|      0|		peaks[ix].height1 += peaks[ix].height_inc;
  567|      0|		if ((peaks[ix].height = (int)peaks[ix].height1) < 0)
  568|      0|			peaks[ix].height = 0;
  569|      0|		peaks[ix].left1 += peaks[ix].left_inc;
  570|      0|		peaks[ix].left = (int)peaks[ix].left1;
  571|      0|		if (ix < 3) {
  572|      0|			peaks[ix].right1 += peaks[ix].right_inc;
  573|      0|			peaks[ix].right = (int)peaks[ix].right1;
  574|      0|		} else
  575|      0|			peaks[ix].right = peaks[ix].left;
  576|      0|	}
  577|      0|	for (; ix < 8; ix++) {
  578|      0|		// formants 6,7,8 don't have a width parameter
  579|      0|		if (ix < 7) {
  580|      0|			peaks[ix].freq1 += peaks[ix].freq_inc;
  581|      0|			peaks[ix].freq = (int)peaks[ix].freq1;
  582|      0|		}
  583|      0|		peaks[ix].height1 += peaks[ix].height_inc;
  584|      0|		if ((peaks[ix].height = (int)peaks[ix].height1) < 0)
  585|      0|			peaks[ix].height = 0;
  586|      0|	}
  587|      0|}
  588|       |
  589|       |static double resonator(RESONATOR *r, double input)
  590|      0|{
  591|      0|	double x;
  592|      0|
  593|      0|	x = r->a * input + r->b * r->x1 + r->c * r->x2;
  594|      0|	r->x2 = r->x1;
  595|      0|	r->x1 = x;
  596|      0|
  597|      0|	return x;
  598|      0|}
  599|       |
  600|       |static void setresonator(RESONATOR *rp, int freq, int bwidth, int init)
  601|      0|{
  602|      0|	// freq    Frequency of resonator in Hz
  603|      0|	// bwidth  Bandwidth of resonator in Hz
  604|      0|	// init    Initialize internal data
  605|      0|
  606|      0|	double x;
  607|      0|	double arg;
  608|      0|
  609|      0|	if (init) {
  610|      0|		rp->x1 = 0;
  611|      0|		rp->x2 = 0;
  612|      0|	}
  613|      0|
  614|      0|	arg = minus_pi_t * bwidth;
  615|      0|	x = exp(arg);
  616|      0|
  617|      0|	rp->c = -(x * x);
  618|      0|
  619|      0|	arg = two_pi_t * freq;
  620|      0|	rp->b = x * cos(arg) * 2.0;
  621|      0|
  622|      0|	rp->a = 1.0 - rp->b - rp->c;
  623|      0|}
  624|       |
  625|       |void InitBreath(void)
  626|      0|{
  627|      0|	int ix;
  628|      0|
  629|      0|	minus_pi_t = -M_PI / samplerate;
  630|      0|	two_pi_t = -2.0 * minus_pi_t;
  631|      0|
  632|      0|	for (ix = 0; ix < N_PEAKS; ix++)
  633|      0|		setresonator(&rbreath[ix], 2000, 200, 1);
  634|      0|}
  635|       |
  636|       |static void SetBreath()
  637|      0|{
  638|      0|	int pk;
  639|      0|
  640|      0|	if (wvoice == NULL || wvoice->breath[0] == 0)
  641|      0|		return;
  642|      0|
  643|      0|	for (pk = 1; pk < N_PEAKS; pk++) {
  644|      0|		if (wvoice->breath[pk] != 0) {
  645|      0|			// breath[0] indicates that some breath formants are needed
  646|      0|			// set the freq from the current synthesis formant and the width from the voice data
  647|      0|			setresonator(&rbreath[pk], peaks[pk].freq >> 16, wvoice->breathw[pk], 0);
  648|      0|		}
  649|      0|	}
  650|      0|}
  651|       |
  652|       |static int ApplyBreath(void)
  653|      0|{
  654|      0|	if (wvoice == NULL)
  655|      0|		return 0;
  656|      0|
  657|      0|	int value = 0;
  658|      0|	int noise;
  659|      0|	int ix;
  660|      0|	int amp;
  661|      0|
  662|      0|	// use two random numbers, for alternate formants
  663|      0|	noise = (rand() & 0x3fff) - 0x2000;
  664|      0|
  665|      0|	for (ix = 1; ix < N_PEAKS; ix++) {
  666|      0|		if ((amp = wvoice->breath[ix]) != 0) {
  667|      0|			amp *= (peaks[ix].height >> 14);
  668|      0|			value += (int)resonator(&rbreath[ix], noise) * amp;
  669|      0|		}
  670|      0|	}
  671|      0|	return value;
  672|      0|}
  673|       |
  674|       |static int Wavegen(int length, int modulation, bool resume, frame_t *fr1, frame_t *fr2, voice_t *wvoice)
  675|      0|{
  676|      0|	if (resume == false)
  677|      0|		SetSynth(length, modulation, fr1, fr2, wvoice);
  678|      0|
  679|      0|	if (wvoice == NULL)
  680|      0|		return 0;
  681|      0|
  682|      0|	unsigned short waveph;
  683|      0|	unsigned short theta;
  684|      0|	int total;
  685|      0|	int h;
  686|      0|	int ix;
  687|      0|	int z, z1, z2;
  688|      0|	int echo;
  689|      0|	int ov;
  690|      0|	static int maxh, maxh2;
  691|      0|	int pk;
  692|      0|	signed char c;
  693|      0|	int sample;
  694|      0|	int amp;
  695|      0|	int modn_amp = 1, modn_period;
  696|      0|	static int agc = 256;
  697|      0|	static int h_switch_sign = 0;
  698|      0|	static int cycle_count = 0;
  699|      0|	static int amplitude2 = 0; // adjusted for pitch
  700|      0|
  701|      0|	// continue until the output buffer is full, or
  702|      0|	// the required number of samples have been produced
  703|      0|
  704|      0|	for (;;) {
  705|      0|		if ((end_wave == 0) && (samplecount == nsamples))
  706|      0|			return 0;
  707|      0|
  708|      0|		if ((samplecount & 0x3f) == 0) {
  709|      0|			// every 64 samples, adjust the parameters
  710|      0|			if (samplecount == 0) {
  711|      0|				hswitch = 0;
  712|      0|				harmspect = hspect[0];
  713|      0|				maxh2 = PeaksToHarmspect(peaks, wdata.pitch<<4, hspect[0], 0);
  714|      0|
  715|      0|				// adjust amplitude to compensate for fewer harmonics at higher pitch
  716|      0|				amplitude2 = (wdata.amplitude * (wdata.pitch >> 8) * wdata.amplitude_fmt)/(10000 << 3);
  717|      0|
  718|      0|				// switch sign of harmonics above about 900Hz, to reduce max peak amplitude
  719|      0|				h_switch_sign = 890 / (wdata.pitch >> 12);
  720|      0|			} else
  721|      0|				AdvanceParameters();
  722|      0|
  723|      0|			// pitch is Hz<<12
  724|      0|			phaseinc = (wdata.pitch>>7) * PHASE_INC_FACTOR;
  725|      0|			cycle_samples = samplerate/(wdata.pitch >> 12); // sr/(pitch*2)
  726|      0|			hf_factor = wdata.pitch >> 11;
  727|      0|
  728|      0|			maxh = maxh2;
  729|      0|			harmspect = hspect[hswitch];
  730|      0|			hswitch ^= 1;
  731|      0|			maxh2 = PeaksToHarmspect(peaks, wdata.pitch<<4, hspect[hswitch], 1);
  732|      0|
  733|      0|			SetBreath();
  734|      0|		} else if ((samplecount & 0x07) == 0) {
  735|      0|			for (h = 1; h < N_LOWHARM && h <= maxh2 && h <= maxh; h++)
  736|      0|				harmspect[h] += harm_inc[h];
  737|      0|
  738|      0|			// bring automatic gain control back towards unity
  739|      0|			if (agc < 256) agc++;
  740|      0|		}
  741|      0|
  742|      0|		samplecount++;
  743|      0|
  744|      0|		if (wavephase > 0) {
  745|      0|			wavephase += phaseinc;
  746|      0|			if (wavephase < 0) {
  747|      0|				// sign has changed, reached a quiet point in the waveform
  748|      0|				cbytes = wavemult_offset - (cycle_samples)/2;
  749|      0|				if (samplecount > nsamples)
  750|      0|					return 0;
  751|      0|
  752|      0|				cycle_count++;
  753|      0|
  754|      0|				for (pk = wvoice->n_harmonic_peaks+1; pk < N_PEAKS; pk++) {
  755|      0|					// find the nearest harmonic for HF peaks where we don't use shape
  756|      0|					peak_harmonic[pk] = ((peaks[pk].freq / (wdata.pitch*8)) + 1) / 2;
  757|      0|				}
  758|      0|
  759|      0|				// adjust amplitude to compensate for fewer harmonics at higher pitch
  760|      0|				amplitude2 = (wdata.amplitude * (wdata.pitch >> 8) * wdata.amplitude_fmt)/(10000 << 3);
  761|      0|
  762|      0|				if (glottal_flag > 0) {
  763|      0|					if (glottal_flag == 3) {
  764|      0|						if ((nsamples-samplecount) < (cycle_samples*2)) {
  765|      0|							// Vowel before glottal-stop.
  766|      0|							// This is the start of the penultimate cycle, reduce its amplitude
  767|      0|							glottal_flag = 2;
  768|      0|							amplitude2 = (amplitude2 *  glottal_reduce)/256;
  769|      0|						}
  770|      0|					} else if (glottal_flag == 4) {
  771|      0|						// Vowel following a glottal-stop.
  772|      0|						// This is the start of the second cycle, reduce its amplitude
  773|      0|						glottal_flag = 2;
  774|      0|						amplitude2 = (amplitude2 * glottal_reduce)/256;
  775|      0|					} else
  776|      0|						glottal_flag--;
  777|      0|				}
  778|      0|
  779|      0|				if (amplitude_env != NULL) {
  780|      0|					// amplitude envelope is only used for creaky voice effect on certain vowels/tones
  781|      0|					if ((ix = amp_ix>>8) > 127) ix = 127;
  782|      0|					amp = amplitude_env[ix];
  783|      0|					amplitude2 = (amplitude2 * amp)/128;
  784|      0|				}
  785|      0|
  786|      0|				// introduce roughness into the sound by reducing the amplitude of
  787|      0|				modn_period = 0;
  788|      0|				if (voice->roughness < N_ROUGHNESS) {
  789|      0|					modn_period = modulation_tab[voice->roughness][modulation_type];
  790|      0|					modn_amp = modn_period & 0xf;
  791|      0|					modn_period = modn_period >> 4;
  792|      0|				}
  793|      0|
  794|      0|				if (modn_period != 0) {
  795|      0|					if (modn_period == 0xf) {
  796|      0|						// just once */
  797|      0|						amplitude2 = (amplitude2 * modn_amp)/16;
  798|      0|						modulation_type = 0;
  799|      0|					} else {
  800|      0|						// reduce amplitude every [modn_period} cycles
  801|      0|						if ((cycle_count % modn_period) == 0)
  802|      0|							amplitude2 = (amplitude2 * modn_amp)/16;
  803|      0|					}
  804|      0|				}
  805|      0|			}
  806|      0|		} else
  807|      0|			wavephase += phaseinc;
  808|      0|		waveph = (unsigned short)(wavephase >> 16);
  809|      0|		total = 0;
  810|      0|
  811|      0|		// apply HF peaks, formants 6,7,8
  812|      0|		// add a single harmonic and then spread this my multiplying by a
  813|      0|		// window.  This is to reduce the processing power needed to add the
  814|      0|		// higher frequence harmonics.
  815|      0|		cbytes++;
  816|      0|		if (cbytes >= 0 && cbytes < wavemult_max) {
  817|      0|			for (pk = wvoice->n_harmonic_peaks+1; pk < N_PEAKS; pk++) {
  818|      0|				theta = peak_harmonic[pk] * waveph;
  819|      0|				total += (long)sin_tab[theta >> 5] * peak_height[pk];
  820|      0|			}
  821|      0|
  822|      0|			// spread the peaks by multiplying by a window
  823|      0|			total = (long)(total / hf_factor) * wavemult[cbytes];
  824|      0|		}
  825|      0|
  826|      0|		// apply main peaks, formants 0 to 5
  827|       |#ifdef USE_ASSEMBLER_1
  828|       |		// use an optimised routine for this loop, if available
  829|       |		total += AddSineWaves(waveph, h_switch_sign, maxh, harmspect);  // call an assembler code routine
  830|       |#else
  831|       |		theta = waveph;
  832|      0|
  833|      0|		for (h = 1; h <= h_switch_sign; h++) {
  834|      0|			total += ((int)sin_tab[theta >> 5] * harmspect[h]);
  835|      0|			theta += waveph;
  836|      0|		}
  837|      0|		while (h <= maxh) {
  838|      0|			total -= ((int)sin_tab[theta >> 5] * harmspect[h]);
  839|      0|			theta += waveph;
  840|      0|			h++;
  841|      0|		}
  842|      0|#endif
  843|      0|
  844|      0|		if (voicing != 64)
  845|      0|			total = (total >> 6) * voicing;
  846|      0|
  847|      0|		if (wvoice->breath[0])
  848|      0|			total +=  ApplyBreath();
  849|      0|
  850|      0|		// mix with sampled wave if required
  851|      0|		z2 = 0;
  852|      0|		if (wdata.mix_wavefile_ix < wdata.n_mix_wavefile) {
  853|      0|			if (wdata.mix_wave_scale == 0) {
  854|      0|				// a 16 bit sample
  855|      0|				c = wdata.mix_wavefile[wdata.mix_wavefile_ix+wdata.mix_wavefile_offset+1];
  856|      0|				sample = wdata.mix_wavefile[wdata.mix_wavefile_ix+wdata.mix_wavefile_offset] + (c * 256);
  857|      0|				wdata.mix_wavefile_ix += 2;
  858|      0|			} else {
  859|      0|				// a 8 bit sample, scaled
  860|      0|				sample = (signed char)wdata.mix_wavefile[wdata.mix_wavefile_offset+wdata.mix_wavefile_ix++] * wdata.mix_wave_scale;
  861|      0|			}
  862|      0|			z2 = (sample * wdata.amplitude_v) >> 10;
  863|      0|			z2 = (z2 * wdata.mix_wave_amp)/32;
  864|      0|
  865|      0|			if ((wdata.mix_wavefile_ix + wdata.mix_wavefile_offset) >= wdata.mix_wavefile_max)  // reached the end of available WAV data
  866|      0|				wdata.mix_wavefile_offset -= (wdata.mix_wavefile_max*3)/4;
  867|      0|		}
  868|      0|
  869|      0|		z1 = z2 + (((total>>8) * amplitude2) >> 13);
  870|      0|
  871|      0|		echo = (echo_buf[echo_tail++] * echo_amp);
  872|      0|		z1 += echo >> 8;
  873|      0|		if (echo_tail >= N_ECHO_BUF)
  874|      0|			echo_tail = 0;
  875|      0|
  876|      0|		z = (z1 * agc) >> 8;
  877|      0|
  878|      0|		// check for overflow, 16bit signed samples
  879|      0|		if (z >= 32768) {
  880|      0|			ov = 8388608/z1 - 1;      // 8388608 is 2^23, i.e. max value * 256
  881|      0|			if (ov < agc) agc = ov;    // set agc to number of 1/256ths to multiply the sample by
  882|      0|			z = (z1 * agc) >> 8;      // reduce sample by agc value to prevent overflow
  883|      0|		} else if (z <= -32768) {
  884|      0|			ov = -8388608/z1 - 1;
  885|      0|			if (ov < agc) agc = ov;
  886|      0|			z = (z1 * agc) >> 8;
  887|      0|		}
  888|      0|		*out_ptr++ = z;
  889|      0|		*out_ptr++ = z >> 8;
  890|      0|		if(output_hooks && output_hooks->outputVoiced) output_hooks->outputVoiced(z);
  891|      0|
  892|      0|		echo_buf[echo_head++] = z;
  893|      0|		if (echo_head >= N_ECHO_BUF)
  894|      0|			echo_head = 0;
  895|      0|
  896|      0|		if (out_ptr + 2 > out_end)
  897|      0|			return 1;
  898|      0|	}
  899|      0|}
  900|       |
  901|       |static int PlaySilence(int length, bool resume)
  902|      0|{
  903|      0|	static int n_samples;
  904|      0|	int value = 0;
  905|      0|
  906|      0|	nsamples = 0;
  907|      0|	samplecount = 0;
  908|      0|	wavephase = 0x7fffffff;
  909|      0|
  910|      0|	if (length == 0)
  911|      0|		return 0;
  912|      0|
  913|      0|	if (resume == false)
  914|      0|		n_samples = length;
  915|      0|
  916|      0|	while (n_samples-- > 0) {
  917|      0|		value = (echo_buf[echo_tail++] * echo_amp) >> 8;
  918|      0|
  919|      0|		if (echo_tail >= N_ECHO_BUF)
  920|      0|			echo_tail = 0;
  921|      0|
  922|      0|		*out_ptr++ = value;
  923|      0|		*out_ptr++ = value >> 8;
  924|      0|		if(output_hooks && output_hooks->outputSilence) output_hooks->outputSilence(value);
  925|      0|
  926|      0|		echo_buf[echo_head++] = value;
  927|      0|		if (echo_head >= N_ECHO_BUF)
  928|      0|			echo_head = 0;
  929|      0|
  930|      0|		if (out_ptr + 2 > out_end)
  931|      0|			return 1;
  932|      0|	}
  933|      0|	return 0;
  934|      0|}
  935|       |
  936|       |static int PlayWave(int length, bool resume, unsigned char *data, int scale, int amp)
  937|      0|{
  938|      0|	static int n_samples;
  939|      0|	static int ix = 0;
  940|      0|	int value;
  941|      0|	signed char c;
  942|      0|
  943|      0|	if (resume == false) {
  944|      0|		n_samples = length;
  945|      0|		ix = 0;
  946|      0|	}
  947|      0|
  948|      0|	nsamples = 0;
  949|      0|	samplecount = 0;
  950|      0|
  951|      0|	while (n_samples-- > 0) {
  952|      0|		if (scale == 0) {
  953|      0|			// 16 bits data
  954|      0|			c = data[ix+1];
  955|      0|			value = data[ix] + (c * 256);
  956|      0|			ix += 2;
  957|      0|		} else {
  958|      0|			// 8 bit data, shift by the specified scale factor
  959|      0|			value = (signed char)data[ix++] * scale;
  960|      0|		}
  961|      0|		value *= (consonant_amp * general_amplitude); // reduce strength of consonant
  962|      0|		value = value >> 10;
  963|      0|		value = (value * amp)/32;
  964|      0|
  965|      0|		value += ((echo_buf[echo_tail++] * echo_amp) >> 8);
  966|      0|
  967|      0|		if (value > 32767)
  968|      0|			value = 32768;
  969|      0|		else if (value < -32768)
  970|      0|			value = -32768;
  971|      0|
  972|      0|		if (echo_tail >= N_ECHO_BUF)
  973|      0|			echo_tail = 0;
  974|      0|
  975|      0|		out_ptr[0] = value;
  976|      0|		out_ptr[1] = value >> 8;
  977|      0|		if(output_hooks && output_hooks->outputUnvoiced) output_hooks->outputUnvoiced(value);
  978|      0|		out_ptr += 2;
  979|      0|
  980|      0|		echo_buf[echo_head++] = (value*3)/4;
  981|      0|		if (echo_head >= N_ECHO_BUF)
  982|      0|			echo_head = 0;
  983|      0|
  984|      0|		if (out_ptr + 2 > out_end)
  985|      0|			return 1;
  986|      0|	}
  987|      0|	return 0;
  988|      0|}
  989|       |
  990|       |static int SetWithRange0(int value, int max)
  991|      0|{
  992|      0|	if (value < 0)
  993|      0|		return 0;
  994|      0|	if (value > max)
  995|      0|		return max;
  996|      0|	return value;
  997|      0|}
  998|       |
  999|       |static void SetPitchFormants()
 1000|      0|{
 1001|      0|	if (wvoice == NULL)
 1002|      0|		return;
 1003|      0|
 1004|      0|	int ix;
 1005|      0|	int factor = 256;
 1006|      0|	int pitch_value;
 1007|      0|
 1008|      0|	// adjust formants to give better results for a different voice pitch
 1009|      0|	if ((pitch_value = embedded_value[EMBED_P]) > MAX_PITCH_VALUE)
 1010|      0|		pitch_value = MAX_PITCH_VALUE;
 1011|      0|
 1012|      0|	if (pitch_value > 50) {
 1013|      0|		// only adjust if the pitch is higher than normal
 1014|      0|		factor = 256 + (25 * (pitch_value - 50))/50;
 1015|      0|	}
 1016|      0|
 1017|      0|	for (ix = 0; ix <= 5; ix++)
 1018|      0|		wvoice->freq[ix] = (wvoice->freq2[ix] * factor)/256;
 1019|      0|
 1020|      0|	factor = embedded_value[EMBED_T]*3;
 1021|      0|	wvoice->height[0] = (wvoice->height2[0] * (256 - factor*2))/256;
 1022|      0|	wvoice->height[1] = (wvoice->height2[1] * (256 - factor))/256;
 1023|      0|}
 1024|       |
 1025|       |void SetEmbedded(int control, int value)
 1026|      0|{
 1027|      0|	// there was an embedded command in the text at this point
 1028|      0|	int sign = 0;
 1029|      0|	int command;
 1030|      0|
 1031|      0|	command = control & 0x1f;
 1032|      0|	if ((control & 0x60) == 0x60)
 1033|      0|		sign = -1;
 1034|      0|	else if ((control & 0x60) == 0x40)
 1035|      0|		sign = 1;
 1036|      0|
 1037|      0|	if (command < N_EMBEDDED_VALUES) {
 1038|      0|		if (sign == 0)
 1039|      0|			embedded_value[command] = value;
 1040|      0|		else
 1041|      0|			embedded_value[command] += (value * sign);
 1042|      0|		embedded_value[command] = SetWithRange0(embedded_value[command], embedded_max[command]);
 1043|      0|	}
 1044|      0|
 1045|      0|	switch (command)
 1046|      0|	{
 1047|      0|	case EMBED_T:
 1048|      0|		WavegenSetEcho(); // and drop through to case P
 1049|      0|	case EMBED_P:
 1050|      0|		SetPitchFormants();
 1051|      0|		break;
 1052|      0|	case EMBED_A: // amplitude
 1053|      0|		general_amplitude = GetAmplitude();
 1054|      0|		break;
 1055|      0|	case EMBED_F: // emphasis
 1056|      0|		general_amplitude = GetAmplitude();
 1057|      0|		break;
 1058|      0|	case EMBED_H:
 1059|      0|		WavegenSetEcho();
 1060|      0|		break;
 1061|      0|	}
 1062|      0|}
 1063|       |
 1064|       |void WavegenSetVoice(voice_t *v)
 1065|      0|{
 1066|      0|	static voice_t v2;
 1067|      0|
 1068|      0|	memcpy(&v2, v, sizeof(v2));
 1069|      0|	wvoice = &v2;
 1070|      0|
 1071|      0|	if (v->peak_shape == 0)
 1072|      0|		pk_shape = pk_shape1;
 1073|      0|	else
 1074|      0|		pk_shape = pk_shape2;
 1075|      0|
 1076|      0|	consonant_amp = (v->consonant_amp * 26) /100;
 1077|      0|	if (samplerate <= 11000) {
 1078|      0|		consonant_amp = consonant_amp*2; // emphasize consonants at low sample rates
 1079|      0|		option_harmonic1 = 6;
 1080|      0|	}
 1081|      0|	WavegenSetEcho();
 1082|      0|	SetPitchFormants();
 1083|      0|	MarkerEvent(espeakEVENT_SAMPLERATE, 0, wvoice->samplerate, 0, out_ptr);
 1084|      0|}
 1085|       |
 1086|       |static void SetAmplitude(int length, unsigned char *amp_env, int value)
 1087|      0|{
 1088|      0|	if (wvoice == NULL)
 1089|      0|		return;
 1090|      0|
 1091|      0|	amp_ix = 0;
 1092|      0|	if (length == 0)
 1093|      0|		amp_inc = 0;
 1094|      0|	else
 1095|      0|		amp_inc = (256 * ENV_LEN * STEPSIZE)/length;
 1096|      0|
 1097|      0|	wdata.amplitude = (value * general_amplitude)/16;
 1098|      0|	wdata.amplitude_v = (wdata.amplitude * wvoice->consonant_ampv * 15)/100; // for wave mixed with voiced sounds
 1099|      0|
 1100|      0|	amplitude_env = amp_env;
 1101|      0|}
 1102|       |
 1103|       |void SetPitch2(voice_t *voice, int pitch1, int pitch2, int *pitch_base, int *pitch_range)
 1104|      0|{
 1105|      0|	int x;
 1106|      0|	int base;
 1107|      0|	int range;
 1108|      0|	int pitch_value;
 1109|      0|
 1110|      0|	if (pitch1 > pitch2) {
 1111|      0|		x = pitch1; // swap values
 1112|      0|		pitch1 = pitch2;
 1113|      0|		pitch2 = x;
 1114|      0|	}
 1115|      0|
 1116|      0|	if ((pitch_value = embedded_value[EMBED_P]) > MAX_PITCH_VALUE)
 1117|      0|		pitch_value = MAX_PITCH_VALUE;
 1118|      0|	pitch_value -= embedded_value[EMBED_T]; // adjust tone for announcing punctuation
 1119|      0|	if (pitch_value < 0)
 1120|      0|		pitch_value = 0;
 1121|      0|
 1122|      0|	base = (voice->pitch_base * pitch_adjust_tab[pitch_value])/128;
 1123|      0|	range =  (voice->pitch_range * embedded_value[EMBED_R])/50;
 1124|      0|
 1125|      0|	// compensate for change in pitch when the range is narrowed or widened
 1126|      0|	base -= (range - voice->pitch_range)*18;
 1127|      0|
 1128|      0|	*pitch_base = base + (pitch1 * range)/2;
 1129|      0|	*pitch_range = base + (pitch2 * range)/2 - *pitch_base;
 1130|      0|}
 1131|       |
 1132|       |static void SetPitch(int length, unsigned char *env, int pitch1, int pitch2)
 1133|      0|{
 1134|      0|	if (wvoice == NULL)
 1135|      0|		return;
 1136|      0|
 1137|      0|	// length in samples
 1138|      0|
 1139|      0|	if ((wdata.pitch_env = env) == NULL)
 1140|      0|		wdata.pitch_env = env_fall; // default
 1141|      0|
 1142|      0|	wdata.pitch_ix = 0;
 1143|      0|	if (length == 0)
 1144|      0|		wdata.pitch_inc = 0;
 1145|      0|	else
 1146|      0|		wdata.pitch_inc = (256 * ENV_LEN * STEPSIZE)/length;
 1147|      0|
 1148|      0|	SetPitch2(wvoice, pitch1, pitch2, &wdata.pitch_base, &wdata.pitch_range);
 1149|      0|	// set initial pitch
 1150|      0|	wdata.pitch = ((wdata.pitch_env[0] * wdata.pitch_range) >>8) + wdata.pitch_base; // Hz << 12
 1151|      0|
 1152|      0|	flutter_amp = wvoice->flutter;
 1153|      0|}
 1154|       |
 1155|       |static void SetSynth(int length, int modn, frame_t *fr1, frame_t *fr2, voice_t *v)
 1156|      0|{
 1157|      0|	if (wvoice == NULL || v == NULL)
 1158|      0|		return;
 1159|      0|
 1160|      0|	int ix;
 1161|      0|	double next;
 1162|      0|	int length2;
 1163|      0|	int length4;
 1164|      0|	int qix;
 1165|      0|	int cmd;
 1166|      0|	static int glottal_reduce_tab1[4] = { 0x30, 0x30, 0x40, 0x50 }; // vowel before [?], amp * 1/256
 1167|      0|	static int glottal_reduce_tab2[4] = { 0x90, 0xa0, 0xb0, 0xc0 }; // vowel after [?], amp * 1/256
 1168|      0|
 1169|      0|	end_wave = 1;
 1170|      0|
 1171|      0|	// any additional information in the param1 ?
 1172|      0|	modulation_type = modn & 0xff;
 1173|      0|
 1174|      0|	glottal_flag = 0;
 1175|      0|	if (modn & 0x400) {
 1176|      0|		glottal_flag = 3; // before a glottal stop
 1177|      0|		glottal_reduce = glottal_reduce_tab1[(modn >> 8) & 3];
 1178|      0|	}
 1179|      0|	if (modn & 0x800) {
 1180|      0|		glottal_flag = 4; // after a glottal stop
 1181|      0|		glottal_reduce = glottal_reduce_tab2[(modn >> 8) & 3];
 1182|      0|	}
 1183|      0|
 1184|      0|	for (qix = wcmdq_head+1;; qix++) {
 1185|      0|		if (qix >= N_WCMDQ) qix = 0;
 1186|      0|		if (qix == wcmdq_tail) break;
 1187|      0|
 1188|      0|		cmd = wcmdq[qix][0];
 1189|      0|		if (cmd == WCMD_SPECT) {
 1190|      0|			end_wave = 0; // next wave generation is from another spectrum
 1191|      0|			break;
 1192|      0|		}
 1193|      0|		if ((cmd == WCMD_WAVE) || (cmd == WCMD_PAUSE))
 1194|      0|			break; // next is not from spectrum, so continue until end of wave cycle
 1195|      0|	}
 1196|      0|
 1197|      0|	// round the length to a multiple of the stepsize
 1198|      0|	length2 = (length + STEPSIZE/2) & ~0x3f;
 1199|      0|	if (length2 == 0)
 1200|      0|		length2 = STEPSIZE;
 1201|      0|
 1202|      0|	// add this length to any left over from the previous synth
 1203|      0|	samplecount_start = samplecount;
 1204|      0|	nsamples += length2;
 1205|      0|
 1206|      0|	length4 = length2/4;
 1207|      0|
 1208|      0|	peaks[7].freq = (7800  * v->freq[7] + v->freqadd[7]*256) << 8;
 1209|      0|	peaks[8].freq = (9000  * v->freq[8] + v->freqadd[8]*256) << 8;
 1210|      0|
 1211|      0|	for (ix = 0; ix < 8; ix++) {
 1212|      0|		if (ix < 7) {
 1213|      0|			peaks[ix].freq1 = (fr1->ffreq[ix] * v->freq[ix] + v->freqadd[ix]*256) << 8;
 1214|      0|			peaks[ix].freq = (int)peaks[ix].freq1;
 1215|      0|			next = (fr2->ffreq[ix] * v->freq[ix] + v->freqadd[ix]*256) << 8;
 1216|      0|			peaks[ix].freq_inc =  ((next - peaks[ix].freq1) * (STEPSIZE/4)) / length4; // lower headroom for fixed point math
 1217|      0|		}
 1218|      0|
 1219|      0|		peaks[ix].height1 = (fr1->fheight[ix] * v->height[ix]) << 6;
 1220|      0|		peaks[ix].height = (int)peaks[ix].height1;
 1221|      0|		next = (fr2->fheight[ix] * v->height[ix]) << 6;
 1222|      0|		peaks[ix].height_inc =  ((next - peaks[ix].height1) * STEPSIZE) / length2;
 1223|      0|
 1224|      0|		if ((ix <= 5) && (ix <= wvoice->n_harmonic_peaks)) {
 1225|      0|			peaks[ix].left1 = (fr1->fwidth[ix] * v->width[ix]) << 10;
 1226|      0|			peaks[ix].left = (int)peaks[ix].left1;
 1227|      0|			next = (fr2->fwidth[ix] * v->width[ix]) << 10;
 1228|      0|			peaks[ix].left_inc =  ((next - peaks[ix].left1) * STEPSIZE) / length2;
 1229|      0|
 1230|      0|			if (ix < 3) {
 1231|      0|				peaks[ix].right1 = (fr1->fright[ix] * v->width[ix]) << 10;
 1232|      0|				peaks[ix].right = (int)peaks[ix].right1;
 1233|      0|				next = (fr2->fright[ix] * v->width[ix]) << 10;
 1234|      0|				peaks[ix].right_inc = ((next - peaks[ix].right1) * STEPSIZE) / length2;
 1235|      0|			} else
 1236|      0|				peaks[ix].right = peaks[ix].left;
 1237|      0|		}
 1238|      0|	}
 1239|      0|}
 1240|       |
 1241|       |void Write4Bytes(FILE *f, int value)
 1242|      0|{
 1243|      0|	// Write 4 bytes to a file, least significant first
 1244|      0|	int ix;
 1245|      0|
 1246|      0|	for (ix = 0; ix < 4; ix++) {
 1247|      0|		fputc(value & 0xff, f);
 1248|      0|		value = value >> 8;
 1249|      0|	}
 1250|      0|}
 1251|       |
 1252|       |static int WavegenFill2()
 1253|      0|{
 1254|      0|	// Pick up next wavegen commands from the queue
 1255|      0|	// return: 0  output buffer has been filled
 1256|      0|	// return: 1  input command queue is now empty
 1257|      0|	intptr_t *q;
 1258|      0|	int length;
 1259|      0|	int result;
 1260|      0|	int marker_type;
 1261|      0|	static bool resume = false;
 1262|      0|	static int echo_complete = 0;
 1263|      0|
 1264|      0|	while (out_ptr < out_end) {
 1265|      0|		if (WcmdqUsed() <= 0) {
 1266|      0|			if (echo_complete > 0) {
 1267|      0|				// continue to play silence until echo is completed
 1268|      0|				resume = PlaySilence(echo_complete, resume);
 1269|      0|				if (resume == true)
 1270|      0|					return 0; // not yet finished
 1271|      0|			}
 1272|      0|			return 1; // queue empty, close sound channel
 1273|      0|		}
 1274|      0|
 1275|      0|		result = 0;
 1276|      0|		q = wcmdq[wcmdq_head];
 1277|      0|		length = q[1];
 1278|      0|
 1279|      0|		switch (q[0] & 0xff)
 1280|      0|		{
 1281|      0|		case WCMD_PITCH:
 1282|      0|			SetPitch(length, (unsigned char *)q[2], q[3] >> 16, q[3] & 0xffff);
 1283|      0|			break;
 1284|      0|		case WCMD_PHONEME_ALIGNMENT:
 1285|      0|		{
 1286|      0|			char* data = (char*)q[1];
 1287|      0|			output_hooks->outputPhoSymbol(data,q[2]);
 1288|      0|			free(data);
 1289|      0|		}
 1290|      0|			break;
 1291|      0|		case WCMD_PAUSE:
 1292|      0|			if (resume == false)
 1293|      0|				echo_complete -= length;
 1294|      0|			wdata.n_mix_wavefile = 0;
 1295|      0|			wdata.amplitude_fmt = 100;
 1296|      0|#ifdef INCLUDE_KLATT
 1297|      0|			KlattReset(1);
 1298|      0|#endif
 1299|      0|			result = PlaySilence(length, resume);
 1300|      0|			break;
 1301|      0|		case WCMD_WAVE:
 1302|      0|			echo_complete = echo_length;
 1303|      0|			wdata.n_mix_wavefile = 0;
 1304|      0|#ifdef INCLUDE_KLATT
 1305|      0|			KlattReset(1);
 1306|      0|#endif
 1307|      0|			result = PlayWave(length, resume, (unsigned char *)q[2], q[3] & 0xff, q[3] >> 8);
 1308|      0|			break;
 1309|      0|		case WCMD_WAVE2:
 1310|      0|			// wave file to be played at the same time as synthesis
 1311|      0|			wdata.mix_wave_amp = q[3] >> 8;
 1312|      0|			wdata.mix_wave_scale = q[3] & 0xff;
 1313|      0|			wdata.n_mix_wavefile = (length & 0xffff);
 1314|      0|			wdata.mix_wavefile_max = (length >> 16) & 0xffff;
 1315|      0|			if (wdata.mix_wave_scale == 0) {
 1316|      0|				wdata.n_mix_wavefile *= 2;
 1317|      0|				wdata.mix_wavefile_max *= 2;
 1318|      0|			}
 1319|      0|			wdata.mix_wavefile_ix = 0;
 1320|      0|			wdata.mix_wavefile_offset = 0;
 1321|      0|			wdata.mix_wavefile = (unsigned char *)q[2];
 1322|      0|			break;
 1323|      0|		case WCMD_SPECT2: // as WCMD_SPECT but stop any concurrent wave file
 1324|      0|			wdata.n_mix_wavefile = 0; // ... and drop through to WCMD_SPECT case
 1325|      0|		case WCMD_SPECT:
 1326|      0|			echo_complete = echo_length;
 1327|      0|			result = Wavegen(length & 0xffff, q[1] >> 16, resume, (frame_t *)q[2], (frame_t *)q[3], wvoice);
 1328|      0|			break;
 1329|      0|#ifdef INCLUDE_KLATT
 1330|      0|		case WCMD_KLATT2: // as WCMD_SPECT but stop any concurrent wave file
 1331|      0|			wdata.n_mix_wavefile = 0; // ... and drop through to WCMD_SPECT case
 1332|      0|		case WCMD_KLATT:
 1333|      0|			echo_complete = echo_length;
 1334|      0|			result = Wavegen_Klatt(length & 0xffff, resume, (frame_t *)q[2], (frame_t *)q[3], &wdata, wvoice);
 1335|      0|			break;
 1336|      0|#endif
 1337|      0|		case WCMD_MARKER:
 1338|      0|			marker_type = q[0] >> 8;
 1339|      0|			MarkerEvent(marker_type, q[1], q[2], q[3], out_ptr);
 1340|      0|			if (marker_type == 1) // word marker
 1341|      0|				current_source_index = q[1] & 0xffffff;
 1342|      0|			break;
 1343|      0|		case WCMD_AMPLITUDE:
 1344|      0|			SetAmplitude(length, (unsigned char *)q[2], q[3]);
 1345|      0|			break;
 1346|      0|		case WCMD_VOICE:
 1347|      0|			WavegenSetVoice((voice_t *)q[2]);
 1348|      0|			free((voice_t *)q[2]);
 1349|      0|			break;
 1350|      0|		case WCMD_EMBEDDED:
 1351|      0|			SetEmbedded(q[1], q[2]);
 1352|      0|			break;
 1353|      0|		case WCMD_MBROLA_DATA:
 1354|      0|			if (wvoice != NULL)
 1355|      0|				result = MbrolaFill(length, resume, (general_amplitude * wvoice->voicing)/64);
 1356|      0|			break;
 1357|      0|		case WCMD_FMT_AMPLITUDE:
 1358|      0|			if ((wdata.amplitude_fmt = q[1]) == 0)
 1359|      0|				wdata.amplitude_fmt = 100; // percentage, but value=0 means 100%
 1360|      0|			break;
 1361|       |#if HAVE_SONIC_H
 1362|       |		case WCMD_SONIC_SPEED:
 1363|       |			sonicSpeed = (double)q[1] / 1024;
 1364|       |			break;
 1365|       |#endif
 1366|       |		}
 1367|      0|
 1368|      0|		if (result == 0) {
 1369|      0|			WcmdqIncHead();
 1370|      0|			resume = false;
 1371|      0|		} else
 1372|      0|			resume = true;
 1373|      0|	}
 1374|      0|
 1375|      0|	return 0;
 1376|      0|}
 1377|       |
 1378|       |#if HAVE_SONIC_H
 1379|       |// Speed up the audio samples with libsonic.
 1380|       |static int SpeedUp(short *outbuf, int length_in, int length_out, int end_of_text)
 1381|       |{
 1382|       |	if (length_in > 0) {
 1383|       |		if (sonicSpeedupStream == NULL)
 1384|       |			sonicSpeedupStream = sonicCreateStream(22050, 1);
 1385|       |		if (sonicGetSpeed(sonicSpeedupStream) != sonicSpeed)
 1386|       |			sonicSetSpeed(sonicSpeedupStream, sonicSpeed);
 1387|       |
 1388|       |		sonicWriteShortToStream(sonicSpeedupStream, outbuf, length_in);
 1389|       |	}
 1390|       |
 1391|       |	if (sonicSpeedupStream == NULL)
 1392|       |		return 0;
 1393|       |
 1394|       |	if (end_of_text)
 1395|       |		sonicFlushStream(sonicSpeedupStream);
 1396|       |	return sonicReadShortFromStream(sonicSpeedupStream, outbuf, length_out);
 1397|       |}
 1398|       |#endif
 1399|       |
 1400|       |// Call WavegenFill2, and then speed up the output samples.
 1401|       |int WavegenFill(void)
 1402|      0|{
 1403|      0|	int finished;
 1404|       |#if HAVE_SONIC_H
 1405|       |	unsigned char *p_start;
 1406|       |
 1407|       |	p_start = out_ptr;
 1408|       |#endif
 1409|       |
 1410|      0|	finished = WavegenFill2();
 1411|      0|
 1412|       |#if HAVE_SONIC_H
 1413|       |	if (sonicSpeed > 1.0) {
 1414|       |		int length;
 1415|       |		int max_length;
 1416|       |
 1417|       |		max_length = (out_end - p_start);
 1418|       |		length =  2*SpeedUp((short *)p_start, (out_ptr-p_start)/2, max_length/2, finished);
 1419|       |		out_ptr = p_start + length;
 1420|       |
 1421|       |		if (length >= max_length)
 1422|       |			finished = 0; // there may be more data to flush
 1423|       |	}
 1424|       |#endif
 1425|       |	return finished;
 1426|      0|}
 1427|       |
 1428|       |#pragma GCC visibility push(default)
 1429|       |
 1430|       |ESPEAK_NG_API espeak_ng_STATUS
 1431|       |espeak_ng_SetOutputHooks(espeak_ng_OUTPUT_HOOKS* hooks)
 1432|      0|{
 1433|      0|	output_hooks = hooks;
 1434|      0|	return 0;
 1435|      0|}
 1436|       |
 1437|       |ESPEAK_NG_API espeak_ng_STATUS
 1438|       |espeak_ng_SetConstF0(int f0)
 1439|      0|{
 1440|      0|	const_f0 = f0;
 1441|      0|	return ENS_OK;
 1442|      0|}
 1443|       |
 1444|       |#pragma GCC visibility pop

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/ucd-tools/src/case.c:
    1|       |/* Unicode Case Conversion
    2|       | *
    3|       | * Copyright (C) 2012-2018, 2021 Reece H. Dunn
    4|       | *
    5|       | * This file is part of ucd-tools.
    6|       | *
    7|       | * ucd-tools is free software: you can redistribute it and/or modify
    8|       | * it under the terms of the GNU General Public License as published by
    9|       | * the Free Software Foundation, either version 3 of the License, or
   10|       | * (at your option) any later version.
   11|       | *
   12|       | * ucd-tools is distributed in the hope that it will be useful,
   13|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   14|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   15|       | * GNU General Public License for more details.
   16|       | *
   17|       | * You should have received a copy of the GNU General Public License
   18|       | * along with ucd-tools.  If not, see <http://www.gnu.org/licenses/>.
   19|       | */
   20|       |
   21|       |/* NOTE: This file is automatically generated from the UnicodeData.txt file in
   22|       | * the Unicode Character database by the ucd-tools/tools/case.py script.
   23|       | */
   24|       |
   25|       |#include "ucd/ucd.h"
   26|       |
   27|       |#include <stddef.h>
   28|       |
   29|       |/* Unicode Character Data 11.0.0 */
   30|       |
   31|       |struct case_conversion_entry
   32|       |{
   33|       |	codepoint_t codepoint;
   34|       |	codepoint_t uppercase;
   35|       |	codepoint_t lowercase;
   36|       |	codepoint_t titlecase;
   37|       |};
   38|       |
   39|       |static const struct case_conversion_entry case_conversion_data[] =
   40|       |{
   41|       |	{ 0x000041, 0x000000, 0x000061, 0x000000 },
   42|       |	{ 0x000042, 0x000000, 0x000062, 0x000000 },
   43|       |	{ 0x000043, 0x000000, 0x000063, 0x000000 },
   44|       |	{ 0x000044, 0x000000, 0x000064, 0x000000 },
   45|       |	{ 0x000045, 0x000000, 0x000065, 0x000000 },
   46|       |	{ 0x000046, 0x000000, 0x000066, 0x000000 },
   47|       |	{ 0x000047, 0x000000, 0x000067, 0x000000 },
   48|       |	{ 0x000048, 0x000000, 0x000068, 0x000000 },
   49|       |	{ 0x000049, 0x000000, 0x000069, 0x000000 },
   50|       |	{ 0x00004A, 0x000000, 0x00006A, 0x000000 },
   51|       |	{ 0x00004B, 0x000000, 0x00006B, 0x000000 },
   52|       |	{ 0x00004C, 0x000000, 0x00006C, 0x000000 },
   53|       |	{ 0x00004D, 0x000000, 0x00006D, 0x000000 },
   54|       |	{ 0x00004E, 0x000000, 0x00006E, 0x000000 },
   55|       |	{ 0x00004F, 0x000000, 0x00006F, 0x000000 },
   56|       |	{ 0x000050, 0x000000, 0x000070, 0x000000 },
   57|       |	{ 0x000051, 0x000000, 0x000071, 0x000000 },
   58|       |	{ 0x000052, 0x000000, 0x000072, 0x000000 },
   59|       |	{ 0x000053, 0x000000, 0x000073, 0x000000 },
   60|       |	{ 0x000054, 0x000000, 0x000074, 0x000000 },
   61|       |	{ 0x000055, 0x000000, 0x000075, 0x000000 },
   62|       |	{ 0x000056, 0x000000, 0x000076, 0x000000 },
   63|       |	{ 0x000057, 0x000000, 0x000077, 0x000000 },
   64|       |	{ 0x000058, 0x000000, 0x000078, 0x000000 },
   65|       |	{ 0x000059, 0x000000, 0x000079, 0x000000 },
   66|       |	{ 0x00005A, 0x000000, 0x00007A, 0x000000 },
   67|       |	{ 0x000061, 0x000041, 0x000000, 0x000041 },
   68|       |	{ 0x000062, 0x000042, 0x000000, 0x000042 },
   69|       |	{ 0x000063, 0x000043, 0x000000, 0x000043 },
   70|       |	{ 0x000064, 0x000044, 0x000000, 0x000044 },
   71|       |	{ 0x000065, 0x000045, 0x000000, 0x000045 },
   72|       |	{ 0x000066, 0x000046, 0x000000, 0x000046 },
   73|       |	{ 0x000067, 0x000047, 0x000000, 0x000047 },
   74|       |	{ 0x000068, 0x000048, 0x000000, 0x000048 },
   75|       |	{ 0x000069, 0x000049, 0x000000, 0x000049 },
   76|       |	{ 0x00006A, 0x00004A, 0x000000, 0x00004A },
   77|       |	{ 0x00006B, 0x00004B, 0x000000, 0x00004B },
   78|       |	{ 0x00006C, 0x00004C, 0x000000, 0x00004C },
   79|       |	{ 0x00006D, 0x00004D, 0x000000, 0x00004D },
   80|       |	{ 0x00006E, 0x00004E, 0x000000, 0x00004E },
   81|       |	{ 0x00006F, 0x00004F, 0x000000, 0x00004F },
   82|       |	{ 0x000070, 0x000050, 0x000000, 0x000050 },
   83|       |	{ 0x000071, 0x000051, 0x000000, 0x000051 },
   84|       |	{ 0x000072, 0x000052, 0x000000, 0x000052 },
   85|       |	{ 0x000073, 0x000053, 0x000000, 0x000053 },
   86|       |	{ 0x000074, 0x000054, 0x000000, 0x000054 },
   87|       |	{ 0x000075, 0x000055, 0x000000, 0x000055 },
   88|       |	{ 0x000076, 0x000056, 0x000000, 0x000056 },
   89|       |	{ 0x000077, 0x000057, 0x000000, 0x000057 },
   90|       |	{ 0x000078, 0x000058, 0x000000, 0x000058 },
   91|       |	{ 0x000079, 0x000059, 0x000000, 0x000059 },
   92|       |	{ 0x00007A, 0x00005A, 0x000000, 0x00005A },
   93|       |	{ 0x0000B5, 0x00039C, 0x000000, 0x00039C },
   94|       |	{ 0x0000C0, 0x000000, 0x0000E0, 0x000000 },
   95|       |	{ 0x0000C1, 0x000000, 0x0000E1, 0x000000 },
   96|       |	{ 0x0000C2, 0x000000, 0x0000E2, 0x000000 },
   97|       |	{ 0x0000C3, 0x000000, 0x0000E3, 0x000000 },
   98|       |	{ 0x0000C4, 0x000000, 0x0000E4, 0x000000 },
   99|       |	{ 0x0000C5, 0x000000, 0x0000E5, 0x000000 },
  100|       |	{ 0x0000C6, 0x000000, 0x0000E6, 0x000000 },
  101|       |	{ 0x0000C7, 0x000000, 0x0000E7, 0x000000 },
  102|       |	{ 0x0000C8, 0x000000, 0x0000E8, 0x000000 },
  103|       |	{ 0x0000C9, 0x000000, 0x0000E9, 0x000000 },
  104|       |	{ 0x0000CA, 0x000000, 0x0000EA, 0x000000 },
  105|       |	{ 0x0000CB, 0x000000, 0x0000EB, 0x000000 },
  106|       |	{ 0x0000CC, 0x000000, 0x0000EC, 0x000000 },
  107|       |	{ 0x0000CD, 0x000000, 0x0000ED, 0x000000 },
  108|       |	{ 0x0000CE, 0x000000, 0x0000EE, 0x000000 },
  109|       |	{ 0x0000CF, 0x000000, 0x0000EF, 0x000000 },
  110|       |	{ 0x0000D0, 0x000000, 0x0000F0, 0x000000 },
  111|       |	{ 0x0000D1, 0x000000, 0x0000F1, 0x000000 },
  112|       |	{ 0x0000D2, 0x000000, 0x0000F2, 0x000000 },
  113|       |	{ 0x0000D3, 0x000000, 0x0000F3, 0x000000 },
  114|       |	{ 0x0000D4, 0x000000, 0x0000F4, 0x000000 },
  115|       |	{ 0x0000D5, 0x000000, 0x0000F5, 0x000000 },
  116|       |	{ 0x0000D6, 0x000000, 0x0000F6, 0x000000 },
  117|       |	{ 0x0000D8, 0x000000, 0x0000F8, 0x000000 },
  118|       |	{ 0x0000D9, 0x000000, 0x0000F9, 0x000000 },
  119|       |	{ 0x0000DA, 0x000000, 0x0000FA, 0x000000 },
  120|       |	{ 0x0000DB, 0x000000, 0x0000FB, 0x000000 },
  121|       |	{ 0x0000DC, 0x000000, 0x0000FC, 0x000000 },
  122|       |	{ 0x0000DD, 0x000000, 0x0000FD, 0x000000 },
  123|       |	{ 0x0000DE, 0x000000, 0x0000FE, 0x000000 },
  124|       |	{ 0x0000E0, 0x0000C0, 0x000000, 0x0000C0 },
  125|       |	{ 0x0000E1, 0x0000C1, 0x000000, 0x0000C1 },
  126|       |	{ 0x0000E2, 0x0000C2, 0x000000, 0x0000C2 },
  127|       |	{ 0x0000E3, 0x0000C3, 0x000000, 0x0000C3 },
  128|       |	{ 0x0000E4, 0x0000C4, 0x000000, 0x0000C4 },
  129|       |	{ 0x0000E5, 0x0000C5, 0x000000, 0x0000C5 },
  130|       |	{ 0x0000E6, 0x0000C6, 0x000000, 0x0000C6 },
  131|       |	{ 0x0000E7, 0x0000C7, 0x000000, 0x0000C7 },
  132|       |	{ 0x0000E8, 0x0000C8, 0x000000, 0x0000C8 },
  133|       |	{ 0x0000E9, 0x0000C9, 0x000000, 0x0000C9 },
  134|       |	{ 0x0000EA, 0x0000CA, 0x000000, 0x0000CA },
  135|       |	{ 0x0000EB, 0x0000CB, 0x000000, 0x0000CB },
  136|       |	{ 0x0000EC, 0x0000CC, 0x000000, 0x0000CC },
  137|       |	{ 0x0000ED, 0x0000CD, 0x000000, 0x0000CD },
  138|       |	{ 0x0000EE, 0x0000CE, 0x000000, 0x0000CE },
  139|       |	{ 0x0000EF, 0x0000CF, 0x000000, 0x0000CF },
  140|       |	{ 0x0000F0, 0x0000D0, 0x000000, 0x0000D0 },
  141|       |	{ 0x0000F1, 0x0000D1, 0x000000, 0x0000D1 },
  142|       |	{ 0x0000F2, 0x0000D2, 0x000000, 0x0000D2 },
  143|       |	{ 0x0000F3, 0x0000D3, 0x000000, 0x0000D3 },
  144|       |	{ 0x0000F4, 0x0000D4, 0x000000, 0x0000D4 },
  145|       |	{ 0x0000F5, 0x0000D5, 0x000000, 0x0000D5 },
  146|       |	{ 0x0000F6, 0x0000D6, 0x000000, 0x0000D6 },
  147|       |	{ 0x0000F8, 0x0000D8, 0x000000, 0x0000D8 },
  148|       |	{ 0x0000F9, 0x0000D9, 0x000000, 0x0000D9 },
  149|       |	{ 0x0000FA, 0x0000DA, 0x000000, 0x0000DA },
  150|       |	{ 0x0000FB, 0x0000DB, 0x000000, 0x0000DB },
  151|       |	{ 0x0000FC, 0x0000DC, 0x000000, 0x0000DC },
  152|       |	{ 0x0000FD, 0x0000DD, 0x000000, 0x0000DD },
  153|       |	{ 0x0000FE, 0x0000DE, 0x000000, 0x0000DE },
  154|       |	{ 0x0000FF, 0x000178, 0x000000, 0x000178 },
  155|       |	{ 0x000100, 0x000000, 0x000101, 0x000000 },
  156|       |	{ 0x000101, 0x000100, 0x000000, 0x000100 },
  157|       |	{ 0x000102, 0x000000, 0x000103, 0x000000 },
  158|       |	{ 0x000103, 0x000102, 0x000000, 0x000102 },
  159|       |	{ 0x000104, 0x000000, 0x000105, 0x000000 },
  160|       |	{ 0x000105, 0x000104, 0x000000, 0x000104 },
  161|       |	{ 0x000106, 0x000000, 0x000107, 0x000000 },
  162|       |	{ 0x000107, 0x000106, 0x000000, 0x000106 },
  163|       |	{ 0x000108, 0x000000, 0x000109, 0x000000 },
  164|       |	{ 0x000109, 0x000108, 0x000000, 0x000108 },
  165|       |	{ 0x00010A, 0x000000, 0x00010B, 0x000000 },
  166|       |	{ 0x00010B, 0x00010A, 0x000000, 0x00010A },
  167|       |	{ 0x00010C, 0x000000, 0x00010D, 0x000000 },
  168|       |	{ 0x00010D, 0x00010C, 0x000000, 0x00010C },
  169|       |	{ 0x00010E, 0x000000, 0x00010F, 0x000000 },
  170|       |	{ 0x00010F, 0x00010E, 0x000000, 0x00010E },
  171|       |	{ 0x000110, 0x000000, 0x000111, 0x000000 },
  172|       |	{ 0x000111, 0x000110, 0x000000, 0x000110 },
  173|       |	{ 0x000112, 0x000000, 0x000113, 0x000000 },
  174|       |	{ 0x000113, 0x000112, 0x000000, 0x000112 },
  175|       |	{ 0x000114, 0x000000, 0x000115, 0x000000 },
  176|       |	{ 0x000115, 0x000114, 0x000000, 0x000114 },
  177|       |	{ 0x000116, 0x000000, 0x000117, 0x000000 },
  178|       |	{ 0x000117, 0x000116, 0x000000, 0x000116 },
  179|       |	{ 0x000118, 0x000000, 0x000119, 0x000000 },
  180|       |	{ 0x000119, 0x000118, 0x000000, 0x000118 },
  181|       |	{ 0x00011A, 0x000000, 0x00011B, 0x000000 },
  182|       |	{ 0x00011B, 0x00011A, 0x000000, 0x00011A },
  183|       |	{ 0x00011C, 0x000000, 0x00011D, 0x000000 },
  184|       |	{ 0x00011D, 0x00011C, 0x000000, 0x00011C },
  185|       |	{ 0x00011E, 0x000000, 0x00011F, 0x000000 },
  186|       |	{ 0x00011F, 0x00011E, 0x000000, 0x00011E },
  187|       |	{ 0x000120, 0x000000, 0x000121, 0x000000 },
  188|       |	{ 0x000121, 0x000120, 0x000000, 0x000120 },
  189|       |	{ 0x000122, 0x000000, 0x000123, 0x000000 },
  190|       |	{ 0x000123, 0x000122, 0x000000, 0x000122 },
  191|       |	{ 0x000124, 0x000000, 0x000125, 0x000000 },
  192|       |	{ 0x000125, 0x000124, 0x000000, 0x000124 },
  193|       |	{ 0x000126, 0x000000, 0x000127, 0x000000 },
  194|       |	{ 0x000127, 0x000126, 0x000000, 0x000126 },
  195|       |	{ 0x000128, 0x000000, 0x000129, 0x000000 },
  196|       |	{ 0x000129, 0x000128, 0x000000, 0x000128 },
  197|       |	{ 0x00012A, 0x000000, 0x00012B, 0x000000 },
  198|       |	{ 0x00012B, 0x00012A, 0x000000, 0x00012A },
  199|       |	{ 0x00012C, 0x000000, 0x00012D, 0x000000 },
  200|       |	{ 0x00012D, 0x00012C, 0x000000, 0x00012C },
  201|       |	{ 0x00012E, 0x000000, 0x00012F, 0x000000 },
  202|       |	{ 0x00012F, 0x00012E, 0x000000, 0x00012E },
  203|       |	{ 0x000130, 0x000000, 0x000069, 0x000000 },
  204|       |	{ 0x000131, 0x000049, 0x000000, 0x000049 },
  205|       |	{ 0x000132, 0x000000, 0x000133, 0x000000 },
  206|       |	{ 0x000133, 0x000132, 0x000000, 0x000132 },
  207|       |	{ 0x000134, 0x000000, 0x000135, 0x000000 },
  208|       |	{ 0x000135, 0x000134, 0x000000, 0x000134 },
  209|       |	{ 0x000136, 0x000000, 0x000137, 0x000000 },
  210|       |	{ 0x000137, 0x000136, 0x000000, 0x000136 },
  211|       |	{ 0x000139, 0x000000, 0x00013A, 0x000000 },
  212|       |	{ 0x00013A, 0x000139, 0x000000, 0x000139 },
  213|       |	{ 0x00013B, 0x000000, 0x00013C, 0x000000 },
  214|       |	{ 0x00013C, 0x00013B, 0x000000, 0x00013B },
  215|       |	{ 0x00013D, 0x000000, 0x00013E, 0x000000 },
  216|       |	{ 0x00013E, 0x00013D, 0x000000, 0x00013D },
  217|       |	{ 0x00013F, 0x000000, 0x000140, 0x000000 },
  218|       |	{ 0x000140, 0x00013F, 0x000000, 0x00013F },
  219|       |	{ 0x000141, 0x000000, 0x000142, 0x000000 },
  220|       |	{ 0x000142, 0x000141, 0x000000, 0x000141 },
  221|       |	{ 0x000143, 0x000000, 0x000144, 0x000000 },
  222|       |	{ 0x000144, 0x000143, 0x000000, 0x000143 },
  223|       |	{ 0x000145, 0x000000, 0x000146, 0x000000 },
  224|       |	{ 0x000146, 0x000145, 0x000000, 0x000145 },
  225|       |	{ 0x000147, 0x000000, 0x000148, 0x000000 },
  226|       |	{ 0x000148, 0x000147, 0x000000, 0x000147 },
  227|       |	{ 0x00014A, 0x000000, 0x00014B, 0x000000 },
  228|       |	{ 0x00014B, 0x00014A, 0x000000, 0x00014A },
  229|       |	{ 0x00014C, 0x000000, 0x00014D, 0x000000 },
  230|       |	{ 0x00014D, 0x00014C, 0x000000, 0x00014C },
  231|       |	{ 0x00014E, 0x000000, 0x00014F, 0x000000 },
  232|       |	{ 0x00014F, 0x00014E, 0x000000, 0x00014E },
  233|       |	{ 0x000150, 0x000000, 0x000151, 0x000000 },
  234|       |	{ 0x000151, 0x000150, 0x000000, 0x000150 },
  235|       |	{ 0x000152, 0x000000, 0x000153, 0x000000 },
  236|       |	{ 0x000153, 0x000152, 0x000000, 0x000152 },
  237|       |	{ 0x000154, 0x000000, 0x000155, 0x000000 },
  238|       |	{ 0x000155, 0x000154, 0x000000, 0x000154 },
  239|       |	{ 0x000156, 0x000000, 0x000157, 0x000000 },
  240|       |	{ 0x000157, 0x000156, 0x000000, 0x000156 },
  241|       |	{ 0x000158, 0x000000, 0x000159, 0x000000 },
  242|       |	{ 0x000159, 0x000158, 0x000000, 0x000158 },
  243|       |	{ 0x00015A, 0x000000, 0x00015B, 0x000000 },
  244|       |	{ 0x00015B, 0x00015A, 0x000000, 0x00015A },
  245|       |	{ 0x00015C, 0x000000, 0x00015D, 0x000000 },
  246|       |	{ 0x00015D, 0x00015C, 0x000000, 0x00015C },
  247|       |	{ 0x00015E, 0x000000, 0x00015F, 0x000000 },
  248|       |	{ 0x00015F, 0x00015E, 0x000000, 0x00015E },
  249|       |	{ 0x000160, 0x000000, 0x000161, 0x000000 },
  250|       |	{ 0x000161, 0x000160, 0x000000, 0x000160 },
  251|       |	{ 0x000162, 0x000000, 0x000163, 0x000000 },
  252|       |	{ 0x000163, 0x000162, 0x000000, 0x000162 },
  253|       |	{ 0x000164, 0x000000, 0x000165, 0x000000 },
  254|       |	{ 0x000165, 0x000164, 0x000000, 0x000164 },
  255|       |	{ 0x000166, 0x000000, 0x000167, 0x000000 },
  256|       |	{ 0x000167, 0x000166, 0x000000, 0x000166 },
  257|       |	{ 0x000168, 0x000000, 0x000169, 0x000000 },
  258|       |	{ 0x000169, 0x000168, 0x000000, 0x000168 },
  259|       |	{ 0x00016A, 0x000000, 0x00016B, 0x000000 },
  260|       |	{ 0x00016B, 0x00016A, 0x000000, 0x00016A },
  261|       |	{ 0x00016C, 0x000000, 0x00016D, 0x000000 },
  262|       |	{ 0x00016D, 0x00016C, 0x000000, 0x00016C },
  263|       |	{ 0x00016E, 0x000000, 0x00016F, 0x000000 },
  264|       |	{ 0x00016F, 0x00016E, 0x000000, 0x00016E },
  265|       |	{ 0x000170, 0x000000, 0x000171, 0x000000 },
  266|       |	{ 0x000171, 0x000170, 0x000000, 0x000170 },
  267|       |	{ 0x000172, 0x000000, 0x000173, 0x000000 },
  268|       |	{ 0x000173, 0x000172, 0x000000, 0x000172 },
  269|       |	{ 0x000174, 0x000000, 0x000175, 0x000000 },
  270|       |	{ 0x000175, 0x000174, 0x000000, 0x000174 },
  271|       |	{ 0x000176, 0x000000, 0x000177, 0x000000 },
  272|       |	{ 0x000177, 0x000176, 0x000000, 0x000176 },
  273|       |	{ 0x000178, 0x000000, 0x0000FF, 0x000000 },
  274|       |	{ 0x000179, 0x000000, 0x00017A, 0x000000 },
  275|       |	{ 0x00017A, 0x000179, 0x000000, 0x000179 },
  276|       |	{ 0x00017B, 0x000000, 0x00017C, 0x000000 },
  277|       |	{ 0x00017C, 0x00017B, 0x000000, 0x00017B },
  278|       |	{ 0x00017D, 0x000000, 0x00017E, 0x000000 },
  279|       |	{ 0x00017E, 0x00017D, 0x000000, 0x00017D },
  280|       |	{ 0x00017F, 0x000053, 0x000000, 0x000053 },
  281|       |	{ 0x000180, 0x000243, 0x000000, 0x000243 },
  282|       |	{ 0x000181, 0x000000, 0x000253, 0x000000 },
  283|       |	{ 0x000182, 0x000000, 0x000183, 0x000000 },
  284|       |	{ 0x000183, 0x000182, 0x000000, 0x000182 },
  285|       |	{ 0x000184, 0x000000, 0x000185, 0x000000 },
  286|       |	{ 0x000185, 0x000184, 0x000000, 0x000184 },
  287|       |	{ 0x000186, 0x000000, 0x000254, 0x000000 },
  288|       |	{ 0x000187, 0x000000, 0x000188, 0x000000 },
  289|       |	{ 0x000188, 0x000187, 0x000000, 0x000187 },
  290|       |	{ 0x000189, 0x000000, 0x000256, 0x000000 },
  291|       |	{ 0x00018A, 0x000000, 0x000257, 0x000000 },
  292|       |	{ 0x00018B, 0x000000, 0x00018C, 0x000000 },
  293|       |	{ 0x00018C, 0x00018B, 0x000000, 0x00018B },
  294|       |	{ 0x00018E, 0x000000, 0x0001DD, 0x000000 },
  295|       |	{ 0x00018F, 0x000000, 0x000259, 0x000000 },
  296|       |	{ 0x000190, 0x000000, 0x00025B, 0x000000 },
  297|       |	{ 0x000191, 0x000000, 0x000192, 0x000000 },
  298|       |	{ 0x000192, 0x000191, 0x000000, 0x000191 },
  299|       |	{ 0x000193, 0x000000, 0x000260, 0x000000 },
  300|       |	{ 0x000194, 0x000000, 0x000263, 0x000000 },
  301|       |	{ 0x000195, 0x0001F6, 0x000000, 0x0001F6 },
  302|       |	{ 0x000196, 0x000000, 0x000269, 0x000000 },
  303|       |	{ 0x000197, 0x000000, 0x000268, 0x000000 },
  304|       |	{ 0x000198, 0x000000, 0x000199, 0x000000 },
  305|       |	{ 0x000199, 0x000198, 0x000000, 0x000198 },
  306|       |	{ 0x00019A, 0x00023D, 0x000000, 0x00023D },
  307|       |	{ 0x00019C, 0x000000, 0x00026F, 0x000000 },
  308|       |	{ 0x00019D, 0x000000, 0x000272, 0x000000 },
  309|       |	{ 0x00019E, 0x000220, 0x000000, 0x000220 },
  310|       |	{ 0x00019F, 0x000000, 0x000275, 0x000000 },
  311|       |	{ 0x0001A0, 0x000000, 0x0001A1, 0x000000 },
  312|       |	{ 0x0001A1, 0x0001A0, 0x000000, 0x0001A0 },
  313|       |	{ 0x0001A2, 0x000000, 0x0001A3, 0x000000 },
  314|       |	{ 0x0001A3, 0x0001A2, 0x000000, 0x0001A2 },
  315|       |	{ 0x0001A4, 0x000000, 0x0001A5, 0x000000 },
  316|       |	{ 0x0001A5, 0x0001A4, 0x000000, 0x0001A4 },
  317|       |	{ 0x0001A6, 0x000000, 0x000280, 0x000000 },
  318|       |	{ 0x0001A7, 0x000000, 0x0001A8, 0x000000 },
  319|       |	{ 0x0001A8, 0x0001A7, 0x000000, 0x0001A7 },
  320|       |	{ 0x0001A9, 0x000000, 0x000283, 0x000000 },
  321|       |	{ 0x0001AC, 0x000000, 0x0001AD, 0x000000 },
  322|       |	{ 0x0001AD, 0x0001AC, 0x000000, 0x0001AC },
  323|       |	{ 0x0001AE, 0x000000, 0x000288, 0x000000 },
  324|       |	{ 0x0001AF, 0x000000, 0x0001B0, 0x000000 },
  325|       |	{ 0x0001B0, 0x0001AF, 0x000000, 0x0001AF },
  326|       |	{ 0x0001B1, 0x000000, 0x00028A, 0x000000 },
  327|       |	{ 0x0001B2, 0x000000, 0x00028B, 0x000000 },
  328|       |	{ 0x0001B3, 0x000000, 0x0001B4, 0x000000 },
  329|       |	{ 0x0001B4, 0x0001B3, 0x000000, 0x0001B3 },
  330|       |	{ 0x0001B5, 0x000000, 0x0001B6, 0x000000 },
  331|       |	{ 0x0001B6, 0x0001B5, 0x000000, 0x0001B5 },
  332|       |	{ 0x0001B7, 0x000000, 0x000292, 0x000000 },
  333|       |	{ 0x0001B8, 0x000000, 0x0001B9, 0x000000 },
  334|       |	{ 0x0001B9, 0x0001B8, 0x000000, 0x0001B8 },
  335|       |	{ 0x0001BC, 0x000000, 0x0001BD, 0x000000 },
  336|       |	{ 0x0001BD, 0x0001BC, 0x000000, 0x0001BC },
  337|       |	{ 0x0001BF, 0x0001F7, 0x000000, 0x0001F7 },
  338|       |	{ 0x0001C4, 0x000000, 0x0001C6, 0x0001C5 },
  339|       |	{ 0x0001C5, 0x0001C4, 0x0001C6, 0x0001C5 },
  340|       |	{ 0x0001C6, 0x0001C4, 0x000000, 0x0001C5 },
  341|       |	{ 0x0001C7, 0x000000, 0x0001C9, 0x0001C8 },
  342|       |	{ 0x0001C8, 0x0001C7, 0x0001C9, 0x0001C8 },
  343|       |	{ 0x0001C9, 0x0001C7, 0x000000, 0x0001C8 },
  344|       |	{ 0x0001CA, 0x000000, 0x0001CC, 0x0001CB },
  345|       |	{ 0x0001CB, 0x0001CA, 0x0001CC, 0x0001CB },
  346|       |	{ 0x0001CC, 0x0001CA, 0x000000, 0x0001CB },
  347|       |	{ 0x0001CD, 0x000000, 0x0001CE, 0x000000 },
  348|       |	{ 0x0001CE, 0x0001CD, 0x000000, 0x0001CD },
  349|       |	{ 0x0001CF, 0x000000, 0x0001D0, 0x000000 },
  350|       |	{ 0x0001D0, 0x0001CF, 0x000000, 0x0001CF },
  351|       |	{ 0x0001D1, 0x000000, 0x0001D2, 0x000000 },
  352|       |	{ 0x0001D2, 0x0001D1, 0x000000, 0x0001D1 },
  353|       |	{ 0x0001D3, 0x000000, 0x0001D4, 0x000000 },
  354|       |	{ 0x0001D4, 0x0001D3, 0x000000, 0x0001D3 },
  355|       |	{ 0x0001D5, 0x000000, 0x0001D6, 0x000000 },
  356|       |	{ 0x0001D6, 0x0001D5, 0x000000, 0x0001D5 },
  357|       |	{ 0x0001D7, 0x000000, 0x0001D8, 0x000000 },
  358|       |	{ 0x0001D8, 0x0001D7, 0x000000, 0x0001D7 },
  359|       |	{ 0x0001D9, 0x000000, 0x0001DA, 0x000000 },
  360|       |	{ 0x0001DA, 0x0001D9, 0x000000, 0x0001D9 },
  361|       |	{ 0x0001DB, 0x000000, 0x0001DC, 0x000000 },
  362|       |	{ 0x0001DC, 0x0001DB, 0x000000, 0x0001DB },
  363|       |	{ 0x0001DD, 0x00018E, 0x000000, 0x00018E },
  364|       |	{ 0x0001DE, 0x000000, 0x0001DF, 0x000000 },
  365|       |	{ 0x0001DF, 0x0001DE, 0x000000, 0x0001DE },
  366|       |	{ 0x0001E0, 0x000000, 0x0001E1, 0x000000 },
  367|       |	{ 0x0001E1, 0x0001E0, 0x000000, 0x0001E0 },
  368|       |	{ 0x0001E2, 0x000000, 0x0001E3, 0x000000 },
  369|       |	{ 0x0001E3, 0x0001E2, 0x000000, 0x0001E2 },
  370|       |	{ 0x0001E4, 0x000000, 0x0001E5, 0x000000 },
  371|       |	{ 0x0001E5, 0x0001E4, 0x000000, 0x0001E4 },
  372|       |	{ 0x0001E6, 0x000000, 0x0001E7, 0x000000 },
  373|       |	{ 0x0001E7, 0x0001E6, 0x000000, 0x0001E6 },
  374|       |	{ 0x0001E8, 0x000000, 0x0001E9, 0x000000 },
  375|       |	{ 0x0001E9, 0x0001E8, 0x000000, 0x0001E8 },
  376|       |	{ 0x0001EA, 0x000000, 0x0001EB, 0x000000 },
  377|       |	{ 0x0001EB, 0x0001EA, 0x000000, 0x0001EA },
  378|       |	{ 0x0001EC, 0x000000, 0x0001ED, 0x000000 },
  379|       |	{ 0x0001ED, 0x0001EC, 0x000000, 0x0001EC },
  380|       |	{ 0x0001EE, 0x000000, 0x0001EF, 0x000000 },
  381|       |	{ 0x0001EF, 0x0001EE, 0x000000, 0x0001EE },
  382|       |	{ 0x0001F1, 0x000000, 0x0001F3, 0x0001F2 },
  383|       |	{ 0x0001F2, 0x0001F1, 0x0001F3, 0x0001F2 },
  384|       |	{ 0x0001F3, 0x0001F1, 0x000000, 0x0001F2 },
  385|       |	{ 0x0001F4, 0x000000, 0x0001F5, 0x000000 },
  386|       |	{ 0x0001F5, 0x0001F4, 0x000000, 0x0001F4 },
  387|       |	{ 0x0001F6, 0x000000, 0x000195, 0x000000 },
  388|       |	{ 0x0001F7, 0x000000, 0x0001BF, 0x000000 },
  389|       |	{ 0x0001F8, 0x000000, 0x0001F9, 0x000000 },
  390|       |	{ 0x0001F9, 0x0001F8, 0x000000, 0x0001F8 },
  391|       |	{ 0x0001FA, 0x000000, 0x0001FB, 0x000000 },
  392|       |	{ 0x0001FB, 0x0001FA, 0x000000, 0x0001FA },
  393|       |	{ 0x0001FC, 0x000000, 0x0001FD, 0x000000 },
  394|       |	{ 0x0001FD, 0x0001FC, 0x000000, 0x0001FC },
  395|       |	{ 0x0001FE, 0x000000, 0x0001FF, 0x000000 },
  396|       |	{ 0x0001FF, 0x0001FE, 0x000000, 0x0001FE },
  397|       |	{ 0x000200, 0x000000, 0x000201, 0x000000 },
  398|       |	{ 0x000201, 0x000200, 0x000000, 0x000200 },
  399|       |	{ 0x000202, 0x000000, 0x000203, 0x000000 },
  400|       |	{ 0x000203, 0x000202, 0x000000, 0x000202 },
  401|       |	{ 0x000204, 0x000000, 0x000205, 0x000000 },
  402|       |	{ 0x000205, 0x000204, 0x000000, 0x000204 },
  403|       |	{ 0x000206, 0x000000, 0x000207, 0x000000 },
  404|       |	{ 0x000207, 0x000206, 0x000000, 0x000206 },
  405|       |	{ 0x000208, 0x000000, 0x000209, 0x000000 },
  406|       |	{ 0x000209, 0x000208, 0x000000, 0x000208 },
  407|       |	{ 0x00020A, 0x000000, 0x00020B, 0x000000 },
  408|       |	{ 0x00020B, 0x00020A, 0x000000, 0x00020A },
  409|       |	{ 0x00020C, 0x000000, 0x00020D, 0x000000 },
  410|       |	{ 0x00020D, 0x00020C, 0x000000, 0x00020C },
  411|       |	{ 0x00020E, 0x000000, 0x00020F, 0x000000 },
  412|       |	{ 0x00020F, 0x00020E, 0x000000, 0x00020E },
  413|       |	{ 0x000210, 0x000000, 0x000211, 0x000000 },
  414|       |	{ 0x000211, 0x000210, 0x000000, 0x000210 },
  415|       |	{ 0x000212, 0x000000, 0x000213, 0x000000 },
  416|       |	{ 0x000213, 0x000212, 0x000000, 0x000212 },
  417|       |	{ 0x000214, 0x000000, 0x000215, 0x000000 },
  418|       |	{ 0x000215, 0x000214, 0x000000, 0x000214 },
  419|       |	{ 0x000216, 0x000000, 0x000217, 0x000000 },
  420|       |	{ 0x000217, 0x000216, 0x000000, 0x000216 },
  421|       |	{ 0x000218, 0x000000, 0x000219, 0x000000 },
  422|       |	{ 0x000219, 0x000218, 0x000000, 0x000218 },
  423|       |	{ 0x00021A, 0x000000, 0x00021B, 0x000000 },
  424|       |	{ 0x00021B, 0x00021A, 0x000000, 0x00021A },
  425|       |	{ 0x00021C, 0x000000, 0x00021D, 0x000000 },
  426|       |	{ 0x00021D, 0x00021C, 0x000000, 0x00021C },
  427|       |	{ 0x00021E, 0x000000, 0x00021F, 0x000000 },
  428|       |	{ 0x00021F, 0x00021E, 0x000000, 0x00021E },
  429|       |	{ 0x000220, 0x000000, 0x00019E, 0x000000 },
  430|       |	{ 0x000222, 0x000000, 0x000223, 0x000000 },
  431|       |	{ 0x000223, 0x000222, 0x000000, 0x000222 },
  432|       |	{ 0x000224, 0x000000, 0x000225, 0x000000 },
  433|       |	{ 0x000225, 0x000224, 0x000000, 0x000224 },
  434|       |	{ 0x000226, 0x000000, 0x000227, 0x000000 },
  435|       |	{ 0x000227, 0x000226, 0x000000, 0x000226 },
  436|       |	{ 0x000228, 0x000000, 0x000229, 0x000000 },
  437|       |	{ 0x000229, 0x000228, 0x000000, 0x000228 },
  438|       |	{ 0x00022A, 0x000000, 0x00022B, 0x000000 },
  439|       |	{ 0x00022B, 0x00022A, 0x000000, 0x00022A },
  440|       |	{ 0x00022C, 0x000000, 0x00022D, 0x000000 },
  441|       |	{ 0x00022D, 0x00022C, 0x000000, 0x00022C },
  442|       |	{ 0x00022E, 0x000000, 0x00022F, 0x000000 },
  443|       |	{ 0x00022F, 0x00022E, 0x000000, 0x00022E },
  444|       |	{ 0x000230, 0x000000, 0x000231, 0x000000 },
  445|       |	{ 0x000231, 0x000230, 0x000000, 0x000230 },
  446|       |	{ 0x000232, 0x000000, 0x000233, 0x000000 },
  447|       |	{ 0x000233, 0x000232, 0x000000, 0x000232 },
  448|       |	{ 0x00023A, 0x000000, 0x002C65, 0x000000 },
  449|       |	{ 0x00023B, 0x000000, 0x00023C, 0x000000 },
  450|       |	{ 0x00023C, 0x00023B, 0x000000, 0x00023B },
  451|       |	{ 0x00023D, 0x000000, 0x00019A, 0x000000 },
  452|       |	{ 0x00023E, 0x000000, 0x002C66, 0x000000 },
  453|       |	{ 0x00023F, 0x002C7E, 0x000000, 0x002C7E },
  454|       |	{ 0x000240, 0x002C7F, 0x000000, 0x002C7F },
  455|       |	{ 0x000241, 0x000000, 0x000242, 0x000000 },
  456|       |	{ 0x000242, 0x000241, 0x000000, 0x000241 },
  457|       |	{ 0x000243, 0x000000, 0x000180, 0x000000 },
  458|       |	{ 0x000244, 0x000000, 0x000289, 0x000000 },
  459|       |	{ 0x000245, 0x000000, 0x00028C, 0x000000 },
  460|       |	{ 0x000246, 0x000000, 0x000247, 0x000000 },
  461|       |	{ 0x000247, 0x000246, 0x000000, 0x000246 },
  462|       |	{ 0x000248, 0x000000, 0x000249, 0x000000 },
  463|       |	{ 0x000249, 0x000248, 0x000000, 0x000248 },
  464|       |	{ 0x00024A, 0x000000, 0x00024B, 0x000000 },
  465|       |	{ 0x00024B, 0x00024A, 0x000000, 0x00024A },
  466|       |	{ 0x00024C, 0x000000, 0x00024D, 0x000000 },
  467|       |	{ 0x00024D, 0x00024C, 0x000000, 0x00024C },
  468|       |	{ 0x00024E, 0x000000, 0x00024F, 0x000000 },
  469|       |	{ 0x00024F, 0x00024E, 0x000000, 0x00024E },
  470|       |	{ 0x000250, 0x002C6F, 0x000000, 0x002C6F },
  471|       |	{ 0x000251, 0x002C6D, 0x000000, 0x002C6D },
  472|       |	{ 0x000252, 0x002C70, 0x000000, 0x002C70 },
  473|       |	{ 0x000253, 0x000181, 0x000000, 0x000181 },
  474|       |	{ 0x000254, 0x000186, 0x000000, 0x000186 },
  475|       |	{ 0x000256, 0x000189, 0x000000, 0x000189 },
  476|       |	{ 0x000257, 0x00018A, 0x000000, 0x00018A },
  477|       |	{ 0x000259, 0x00018F, 0x000000, 0x00018F },
  478|       |	{ 0x00025B, 0x000190, 0x000000, 0x000190 },
  479|       |	{ 0x00025C, 0x00A7AB, 0x000000, 0x00A7AB },
  480|       |	{ 0x000260, 0x000193, 0x000000, 0x000193 },
  481|       |	{ 0x000261, 0x00A7AC, 0x000000, 0x00A7AC },
  482|       |	{ 0x000263, 0x000194, 0x000000, 0x000194 },
  483|       |	{ 0x000265, 0x00A78D, 0x000000, 0x00A78D },
  484|       |	{ 0x000266, 0x00A7AA, 0x000000, 0x00A7AA },
  485|       |	{ 0x000268, 0x000197, 0x000000, 0x000197 },
  486|       |	{ 0x000269, 0x000196, 0x000000, 0x000196 },
  487|       |	{ 0x00026A, 0x00A7AE, 0x000000, 0x00A7AE },
  488|       |	{ 0x00026B, 0x002C62, 0x000000, 0x002C62 },
  489|       |	{ 0x00026C, 0x00A7AD, 0x000000, 0x00A7AD },
  490|       |	{ 0x00026F, 0x00019C, 0x000000, 0x00019C },
  491|       |	{ 0x000271, 0x002C6E, 0x000000, 0x002C6E },
  492|       |	{ 0x000272, 0x00019D, 0x000000, 0x00019D },
  493|       |	{ 0x000275, 0x00019F, 0x000000, 0x00019F },
  494|       |	{ 0x00027D, 0x002C64, 0x000000, 0x002C64 },
  495|       |	{ 0x000280, 0x0001A6, 0x000000, 0x0001A6 },
  496|       |	{ 0x000283, 0x0001A9, 0x000000, 0x0001A9 },
  497|       |	{ 0x000287, 0x00A7B1, 0x000000, 0x00A7B1 },
  498|       |	{ 0x000288, 0x0001AE, 0x000000, 0x0001AE },
  499|       |	{ 0x000289, 0x000244, 0x000000, 0x000244 },
  500|       |	{ 0x00028A, 0x0001B1, 0x000000, 0x0001B1 },
  501|       |	{ 0x00028B, 0x0001B2, 0x000000, 0x0001B2 },
  502|       |	{ 0x00028C, 0x000245, 0x000000, 0x000245 },
  503|       |	{ 0x000292, 0x0001B7, 0x000000, 0x0001B7 },
  504|       |	{ 0x00029D, 0x00A7B2, 0x000000, 0x00A7B2 },
  505|       |	{ 0x00029E, 0x00A7B0, 0x000000, 0x00A7B0 },
  506|       |	{ 0x000345, 0x000399, 0x000000, 0x000399 },
  507|       |	{ 0x000370, 0x000000, 0x000371, 0x000000 },
  508|       |	{ 0x000371, 0x000370, 0x000000, 0x000370 },
  509|       |	{ 0x000372, 0x000000, 0x000373, 0x000000 },
  510|       |	{ 0x000373, 0x000372, 0x000000, 0x000372 },
  511|       |	{ 0x000376, 0x000000, 0x000377, 0x000000 },
  512|       |	{ 0x000377, 0x000376, 0x000000, 0x000376 },
  513|       |	{ 0x00037B, 0x0003FD, 0x000000, 0x0003FD },
  514|       |	{ 0x00037C, 0x0003FE, 0x000000, 0x0003FE },
  515|       |	{ 0x00037D, 0x0003FF, 0x000000, 0x0003FF },
  516|       |	{ 0x00037F, 0x000000, 0x0003F3, 0x000000 },
  517|       |	{ 0x000386, 0x000000, 0x0003AC, 0x000000 },
  518|       |	{ 0x000388, 0x000000, 0x0003AD, 0x000000 },
  519|       |	{ 0x000389, 0x000000, 0x0003AE, 0x000000 },
  520|       |	{ 0x00038A, 0x000000, 0x0003AF, 0x000000 },
  521|       |	{ 0x00038C, 0x000000, 0x0003CC, 0x000000 },
  522|       |	{ 0x00038E, 0x000000, 0x0003CD, 0x000000 },
  523|       |	{ 0x00038F, 0x000000, 0x0003CE, 0x000000 },
  524|       |	{ 0x000391, 0x000000, 0x0003B1, 0x000000 },
  525|       |	{ 0x000392, 0x000000, 0x0003B2, 0x000000 },
  526|       |	{ 0x000393, 0x000000, 0x0003B3, 0x000000 },
  527|       |	{ 0x000394, 0x000000, 0x0003B4, 0x000000 },
  528|       |	{ 0x000395, 0x000000, 0x0003B5, 0x000000 },
  529|       |	{ 0x000396, 0x000000, 0x0003B6, 0x000000 },
  530|       |	{ 0x000397, 0x000000, 0x0003B7, 0x000000 },
  531|       |	{ 0x000398, 0x000000, 0x0003B8, 0x000000 },
  532|       |	{ 0x000399, 0x000000, 0x0003B9, 0x000000 },
  533|       |	{ 0x00039A, 0x000000, 0x0003BA, 0x000000 },
  534|       |	{ 0x00039B, 0x000000, 0x0003BB, 0x000000 },
  535|       |	{ 0x00039C, 0x000000, 0x0003BC, 0x000000 },
  536|       |	{ 0x00039D, 0x000000, 0x0003BD, 0x000000 },
  537|       |	{ 0x00039E, 0x000000, 0x0003BE, 0x000000 },
  538|       |	{ 0x00039F, 0x000000, 0x0003BF, 0x000000 },
  539|       |	{ 0x0003A0, 0x000000, 0x0003C0, 0x000000 },
  540|       |	{ 0x0003A1, 0x000000, 0x0003C1, 0x000000 },
  541|       |	{ 0x0003A3, 0x000000, 0x0003C3, 0x000000 },
  542|       |	{ 0x0003A4, 0x000000, 0x0003C4, 0x000000 },
  543|       |	{ 0x0003A5, 0x000000, 0x0003C5, 0x000000 },
  544|       |	{ 0x0003A6, 0x000000, 0x0003C6, 0x000000 },
  545|       |	{ 0x0003A7, 0x000000, 0x0003C7, 0x000000 },
  546|       |	{ 0x0003A8, 0x000000, 0x0003C8, 0x000000 },
  547|       |	{ 0x0003A9, 0x000000, 0x0003C9, 0x000000 },
  548|       |	{ 0x0003AA, 0x000000, 0x0003CA, 0x000000 },
  549|       |	{ 0x0003AB, 0x000000, 0x0003CB, 0x000000 },
  550|       |	{ 0x0003AC, 0x000386, 0x000000, 0x000386 },
  551|       |	{ 0x0003AD, 0x000388, 0x000000, 0x000388 },
  552|       |	{ 0x0003AE, 0x000389, 0x000000, 0x000389 },
  553|       |	{ 0x0003AF, 0x00038A, 0x000000, 0x00038A },
  554|       |	{ 0x0003B1, 0x000391, 0x000000, 0x000391 },
  555|       |	{ 0x0003B2, 0x000392, 0x000000, 0x000392 },
  556|       |	{ 0x0003B3, 0x000393, 0x000000, 0x000393 },
  557|       |	{ 0x0003B4, 0x000394, 0x000000, 0x000394 },
  558|       |	{ 0x0003B5, 0x000395, 0x000000, 0x000395 },
  559|       |	{ 0x0003B6, 0x000396, 0x000000, 0x000396 },
  560|       |	{ 0x0003B7, 0x000397, 0x000000, 0x000397 },
  561|       |	{ 0x0003B8, 0x000398, 0x000000, 0x000398 },
  562|       |	{ 0x0003B9, 0x000399, 0x000000, 0x000399 },
  563|       |	{ 0x0003BA, 0x00039A, 0x000000, 0x00039A },
  564|       |	{ 0x0003BB, 0x00039B, 0x000000, 0x00039B },
  565|       |	{ 0x0003BC, 0x00039C, 0x000000, 0x00039C },
  566|       |	{ 0x0003BD, 0x00039D, 0x000000, 0x00039D },
  567|       |	{ 0x0003BE, 0x00039E, 0x000000, 0x00039E },
  568|       |	{ 0x0003BF, 0x00039F, 0x000000, 0x00039F },
  569|       |	{ 0x0003C0, 0x0003A0, 0x000000, 0x0003A0 },
  570|       |	{ 0x0003C1, 0x0003A1, 0x000000, 0x0003A1 },
  571|       |	{ 0x0003C2, 0x0003A3, 0x000000, 0x0003A3 },
  572|       |	{ 0x0003C3, 0x0003A3, 0x000000, 0x0003A3 },
  573|       |	{ 0x0003C4, 0x0003A4, 0x000000, 0x0003A4 },
  574|       |	{ 0x0003C5, 0x0003A5, 0x000000, 0x0003A5 },
  575|       |	{ 0x0003C6, 0x0003A6, 0x000000, 0x0003A6 },
  576|       |	{ 0x0003C7, 0x0003A7, 0x000000, 0x0003A7 },
  577|       |	{ 0x0003C8, 0x0003A8, 0x000000, 0x0003A8 },
  578|       |	{ 0x0003C9, 0x0003A9, 0x000000, 0x0003A9 },
  579|       |	{ 0x0003CA, 0x0003AA, 0x000000, 0x0003AA },
  580|       |	{ 0x0003CB, 0x0003AB, 0x000000, 0x0003AB },
  581|       |	{ 0x0003CC, 0x00038C, 0x000000, 0x00038C },
  582|       |	{ 0x0003CD, 0x00038E, 0x000000, 0x00038E },
  583|       |	{ 0x0003CE, 0x00038F, 0x000000, 0x00038F },
  584|       |	{ 0x0003CF, 0x000000, 0x0003D7, 0x000000 },
  585|       |	{ 0x0003D0, 0x000392, 0x000000, 0x000392 },
  586|       |	{ 0x0003D1, 0x000398, 0x000000, 0x000398 },
  587|       |	{ 0x0003D5, 0x0003A6, 0x000000, 0x0003A6 },
  588|       |	{ 0x0003D6, 0x0003A0, 0x000000, 0x0003A0 },
  589|       |	{ 0x0003D7, 0x0003CF, 0x000000, 0x0003CF },
  590|       |	{ 0x0003D8, 0x000000, 0x0003D9, 0x000000 },
  591|       |	{ 0x0003D9, 0x0003D8, 0x000000, 0x0003D8 },
  592|       |	{ 0x0003DA, 0x000000, 0x0003DB, 0x000000 },
  593|       |	{ 0x0003DB, 0x0003DA, 0x000000, 0x0003DA },
  594|       |	{ 0x0003DC, 0x000000, 0x0003DD, 0x000000 },
  595|       |	{ 0x0003DD, 0x0003DC, 0x000000, 0x0003DC },
  596|       |	{ 0x0003DE, 0x000000, 0x0003DF, 0x000000 },
  597|       |	{ 0x0003DF, 0x0003DE, 0x000000, 0x0003DE },
  598|       |	{ 0x0003E0, 0x000000, 0x0003E1, 0x000000 },
  599|       |	{ 0x0003E1, 0x0003E0, 0x000000, 0x0003E0 },
  600|       |	{ 0x0003E2, 0x000000, 0x0003E3, 0x000000 },
  601|       |	{ 0x0003E3, 0x0003E2, 0x000000, 0x0003E2 },
  602|       |	{ 0x0003E4, 0x000000, 0x0003E5, 0x000000 },
  603|       |	{ 0x0003E5, 0x0003E4, 0x000000, 0x0003E4 },
  604|       |	{ 0x0003E6, 0x000000, 0x0003E7, 0x000000 },
  605|       |	{ 0x0003E7, 0x0003E6, 0x000000, 0x0003E6 },
  606|       |	{ 0x0003E8, 0x000000, 0x0003E9, 0x000000 },
  607|       |	{ 0x0003E9, 0x0003E8, 0x000000, 0x0003E8 },
  608|       |	{ 0x0003EA, 0x000000, 0x0003EB, 0x000000 },
  609|       |	{ 0x0003EB, 0x0003EA, 0x000000, 0x0003EA },
  610|       |	{ 0x0003EC, 0x000000, 0x0003ED, 0x000000 },
  611|       |	{ 0x0003ED, 0x0003EC, 0x000000, 0x0003EC },
  612|       |	{ 0x0003EE, 0x000000, 0x0003EF, 0x000000 },
  613|       |	{ 0x0003EF, 0x0003EE, 0x000000, 0x0003EE },
  614|       |	{ 0x0003F0, 0x00039A, 0x000000, 0x00039A },
  615|       |	{ 0x0003F1, 0x0003A1, 0x000000, 0x0003A1 },
  616|       |	{ 0x0003F2, 0x0003F9, 0x000000, 0x0003F9 },
  617|       |	{ 0x0003F3, 0x00037F, 0x000000, 0x00037F },
  618|       |	{ 0x0003F4, 0x000000, 0x0003B8, 0x000000 },
  619|       |	{ 0x0003F5, 0x000395, 0x000000, 0x000395 },
  620|       |	{ 0x0003F7, 0x000000, 0x0003F8, 0x000000 },
  621|       |	{ 0x0003F8, 0x0003F7, 0x000000, 0x0003F7 },
  622|       |	{ 0x0003F9, 0x000000, 0x0003F2, 0x000000 },
  623|       |	{ 0x0003FA, 0x000000, 0x0003FB, 0x000000 },
  624|       |	{ 0x0003FB, 0x0003FA, 0x000000, 0x0003FA },
  625|       |	{ 0x0003FD, 0x000000, 0x00037B, 0x000000 },
  626|       |	{ 0x0003FE, 0x000000, 0x00037C, 0x000000 },
  627|       |	{ 0x0003FF, 0x000000, 0x00037D, 0x000000 },
  628|       |	{ 0x000400, 0x000000, 0x000450, 0x000000 },
  629|       |	{ 0x000401, 0x000000, 0x000451, 0x000000 },
  630|       |	{ 0x000402, 0x000000, 0x000452, 0x000000 },
  631|       |	{ 0x000403, 0x000000, 0x000453, 0x000000 },
  632|       |	{ 0x000404, 0x000000, 0x000454, 0x000000 },
  633|       |	{ 0x000405, 0x000000, 0x000455, 0x000000 },
  634|       |	{ 0x000406, 0x000000, 0x000456, 0x000000 },
  635|       |	{ 0x000407, 0x000000, 0x000457, 0x000000 },
  636|       |	{ 0x000408, 0x000000, 0x000458, 0x000000 },
  637|       |	{ 0x000409, 0x000000, 0x000459, 0x000000 },
  638|       |	{ 0x00040A, 0x000000, 0x00045A, 0x000000 },
  639|       |	{ 0x00040B, 0x000000, 0x00045B, 0x000000 },
  640|       |	{ 0x00040C, 0x000000, 0x00045C, 0x000000 },
  641|       |	{ 0x00040D, 0x000000, 0x00045D, 0x000000 },
  642|       |	{ 0x00040E, 0x000000, 0x00045E, 0x000000 },
  643|       |	{ 0x00040F, 0x000000, 0x00045F, 0x000000 },
  644|       |	{ 0x000410, 0x000000, 0x000430, 0x000000 },
  645|       |	{ 0x000411, 0x000000, 0x000431, 0x000000 },
  646|       |	{ 0x000412, 0x000000, 0x000432, 0x000000 },
  647|       |	{ 0x000413, 0x000000, 0x000433, 0x000000 },
  648|       |	{ 0x000414, 0x000000, 0x000434, 0x000000 },
  649|       |	{ 0x000415, 0x000000, 0x000435, 0x000000 },
  650|       |	{ 0x000416, 0x000000, 0x000436, 0x000000 },
  651|       |	{ 0x000417, 0x000000, 0x000437, 0x000000 },
  652|       |	{ 0x000418, 0x000000, 0x000438, 0x000000 },
  653|       |	{ 0x000419, 0x000000, 0x000439, 0x000000 },
  654|       |	{ 0x00041A, 0x000000, 0x00043A, 0x000000 },
  655|       |	{ 0x00041B, 0x000000, 0x00043B, 0x000000 },
  656|       |	{ 0x00041C, 0x000000, 0x00043C, 0x000000 },
  657|       |	{ 0x00041D, 0x000000, 0x00043D, 0x000000 },
  658|       |	{ 0x00041E, 0x000000, 0x00043E, 0x000000 },
  659|       |	{ 0x00041F, 0x000000, 0x00043F, 0x000000 },
  660|       |	{ 0x000420, 0x000000, 0x000440, 0x000000 },
  661|       |	{ 0x000421, 0x000000, 0x000441, 0x000000 },
  662|       |	{ 0x000422, 0x000000, 0x000442, 0x000000 },
  663|       |	{ 0x000423, 0x000000, 0x000443, 0x000000 },
  664|       |	{ 0x000424, 0x000000, 0x000444, 0x000000 },
  665|       |	{ 0x000425, 0x000000, 0x000445, 0x000000 },
  666|       |	{ 0x000426, 0x000000, 0x000446, 0x000000 },
  667|       |	{ 0x000427, 0x000000, 0x000447, 0x000000 },
  668|       |	{ 0x000428, 0x000000, 0x000448, 0x000000 },
  669|       |	{ 0x000429, 0x000000, 0x000449, 0x000000 },
  670|       |	{ 0x00042A, 0x000000, 0x00044A, 0x000000 },
  671|       |	{ 0x00042B, 0x000000, 0x00044B, 0x000000 },
  672|       |	{ 0x00042C, 0x000000, 0x00044C, 0x000000 },
  673|       |	{ 0x00042D, 0x000000, 0x00044D, 0x000000 },
  674|       |	{ 0x00042E, 0x000000, 0x00044E, 0x000000 },
  675|       |	{ 0x00042F, 0x000000, 0x00044F, 0x000000 },
  676|       |	{ 0x000430, 0x000410, 0x000000, 0x000410 },
  677|       |	{ 0x000431, 0x000411, 0x000000, 0x000411 },
  678|       |	{ 0x000432, 0x000412, 0x000000, 0x000412 },
  679|       |	{ 0x000433, 0x000413, 0x000000, 0x000413 },
  680|       |	{ 0x000434, 0x000414, 0x000000, 0x000414 },
  681|       |	{ 0x000435, 0x000415, 0x000000, 0x000415 },
  682|       |	{ 0x000436, 0x000416, 0x000000, 0x000416 },
  683|       |	{ 0x000437, 0x000417, 0x000000, 0x000417 },
  684|       |	{ 0x000438, 0x000418, 0x000000, 0x000418 },
  685|       |	{ 0x000439, 0x000419, 0x000000, 0x000419 },
  686|       |	{ 0x00043A, 0x00041A, 0x000000, 0x00041A },
  687|       |	{ 0x00043B, 0x00041B, 0x000000, 0x00041B },
  688|       |	{ 0x00043C, 0x00041C, 0x000000, 0x00041C },
  689|       |	{ 0x00043D, 0x00041D, 0x000000, 0x00041D },
  690|       |	{ 0x00043E, 0x00041E, 0x000000, 0x00041E },
  691|       |	{ 0x00043F, 0x00041F, 0x000000, 0x00041F },
  692|       |	{ 0x000440, 0x000420, 0x000000, 0x000420 },
  693|       |	{ 0x000441, 0x000421, 0x000000, 0x000421 },
  694|       |	{ 0x000442, 0x000422, 0x000000, 0x000422 },
  695|       |	{ 0x000443, 0x000423, 0x000000, 0x000423 },
  696|       |	{ 0x000444, 0x000424, 0x000000, 0x000424 },
  697|       |	{ 0x000445, 0x000425, 0x000000, 0x000425 },
  698|       |	{ 0x000446, 0x000426, 0x000000, 0x000426 },
  699|       |	{ 0x000447, 0x000427, 0x000000, 0x000427 },
  700|       |	{ 0x000448, 0x000428, 0x000000, 0x000428 },
  701|       |	{ 0x000449, 0x000429, 0x000000, 0x000429 },
  702|       |	{ 0x00044A, 0x00042A, 0x000000, 0x00042A },
  703|       |	{ 0x00044B, 0x00042B, 0x000000, 0x00042B },
  704|       |	{ 0x00044C, 0x00042C, 0x000000, 0x00042C },
  705|       |	{ 0x00044D, 0x00042D, 0x000000, 0x00042D },
  706|       |	{ 0x00044E, 0x00042E, 0x000000, 0x00042E },
  707|       |	{ 0x00044F, 0x00042F, 0x000000, 0x00042F },
  708|       |	{ 0x000450, 0x000400, 0x000000, 0x000400 },
  709|       |	{ 0x000451, 0x000401, 0x000000, 0x000401 },
  710|       |	{ 0x000452, 0x000402, 0x000000, 0x000402 },
  711|       |	{ 0x000453, 0x000403, 0x000000, 0x000403 },
  712|       |	{ 0x000454, 0x000404, 0x000000, 0x000404 },
  713|       |	{ 0x000455, 0x000405, 0x000000, 0x000405 },
  714|       |	{ 0x000456, 0x000406, 0x000000, 0x000406 },
  715|       |	{ 0x000457, 0x000407, 0x000000, 0x000407 },
  716|       |	{ 0x000458, 0x000408, 0x000000, 0x000408 },
  717|       |	{ 0x000459, 0x000409, 0x000000, 0x000409 },
  718|       |	{ 0x00045A, 0x00040A, 0x000000, 0x00040A },
  719|       |	{ 0x00045B, 0x00040B, 0x000000, 0x00040B },
  720|       |	{ 0x00045C, 0x00040C, 0x000000, 0x00040C },
  721|       |	{ 0x00045D, 0x00040D, 0x000000, 0x00040D },
  722|       |	{ 0x00045E, 0x00040E, 0x000000, 0x00040E },
  723|       |	{ 0x00045F, 0x00040F, 0x000000, 0x00040F },
  724|       |	{ 0x000460, 0x000000, 0x000461, 0x000000 },
  725|       |	{ 0x000461, 0x000460, 0x000000, 0x000460 },
  726|       |	{ 0x000462, 0x000000, 0x000463, 0x000000 },
  727|       |	{ 0x000463, 0x000462, 0x000000, 0x000462 },
  728|       |	{ 0x000464, 0x000000, 0x000465, 0x000000 },
  729|       |	{ 0x000465, 0x000464, 0x000000, 0x000464 },
  730|       |	{ 0x000466, 0x000000, 0x000467, 0x000000 },
  731|       |	{ 0x000467, 0x000466, 0x000000, 0x000466 },
  732|       |	{ 0x000468, 0x000000, 0x000469, 0x000000 },
  733|       |	{ 0x000469, 0x000468, 0x000000, 0x000468 },
  734|       |	{ 0x00046A, 0x000000, 0x00046B, 0x000000 },
  735|       |	{ 0x00046B, 0x00046A, 0x000000, 0x00046A },
  736|       |	{ 0x00046C, 0x000000, 0x00046D, 0x000000 },
  737|       |	{ 0x00046D, 0x00046C, 0x000000, 0x00046C },
  738|       |	{ 0x00046E, 0x000000, 0x00046F, 0x000000 },
  739|       |	{ 0x00046F, 0x00046E, 0x000000, 0x00046E },
  740|       |	{ 0x000470, 0x000000, 0x000471, 0x000000 },
  741|       |	{ 0x000471, 0x000470, 0x000000, 0x000470 },
  742|       |	{ 0x000472, 0x000000, 0x000473, 0x000000 },
  743|       |	{ 0x000473, 0x000472, 0x000000, 0x000472 },
  744|       |	{ 0x000474, 0x000000, 0x000475, 0x000000 },
  745|       |	{ 0x000475, 0x000474, 0x000000, 0x000474 },
  746|       |	{ 0x000476, 0x000000, 0x000477, 0x000000 },
  747|       |	{ 0x000477, 0x000476, 0x000000, 0x000476 },
  748|       |	{ 0x000478, 0x000000, 0x000479, 0x000000 },
  749|       |	{ 0x000479, 0x000478, 0x000000, 0x000478 },
  750|       |	{ 0x00047A, 0x000000, 0x00047B, 0x000000 },
  751|       |	{ 0x00047B, 0x00047A, 0x000000, 0x00047A },
  752|       |	{ 0x00047C, 0x000000, 0x00047D, 0x000000 },
  753|       |	{ 0x00047D, 0x00047C, 0x000000, 0x00047C },
  754|       |	{ 0x00047E, 0x000000, 0x00047F, 0x000000 },
  755|       |	{ 0x00047F, 0x00047E, 0x000000, 0x00047E },
  756|       |	{ 0x000480, 0x000000, 0x000481, 0x000000 },
  757|       |	{ 0x000481, 0x000480, 0x000000, 0x000480 },
  758|       |	{ 0x00048A, 0x000000, 0x00048B, 0x000000 },
  759|       |	{ 0x00048B, 0x00048A, 0x000000, 0x00048A },
  760|       |	{ 0x00048C, 0x000000, 0x00048D, 0x000000 },
  761|       |	{ 0x00048D, 0x00048C, 0x000000, 0x00048C },
  762|       |	{ 0x00048E, 0x000000, 0x00048F, 0x000000 },
  763|       |	{ 0x00048F, 0x00048E, 0x000000, 0x00048E },
  764|       |	{ 0x000490, 0x000000, 0x000491, 0x000000 },
  765|       |	{ 0x000491, 0x000490, 0x000000, 0x000490 },
  766|       |	{ 0x000492, 0x000000, 0x000493, 0x000000 },
  767|       |	{ 0x000493, 0x000492, 0x000000, 0x000492 },
  768|       |	{ 0x000494, 0x000000, 0x000495, 0x000000 },
  769|       |	{ 0x000495, 0x000494, 0x000000, 0x000494 },
  770|       |	{ 0x000496, 0x000000, 0x000497, 0x000000 },
  771|       |	{ 0x000497, 0x000496, 0x000000, 0x000496 },
  772|       |	{ 0x000498, 0x000000, 0x000499, 0x000000 },
  773|       |	{ 0x000499, 0x000498, 0x000000, 0x000498 },
  774|       |	{ 0x00049A, 0x000000, 0x00049B, 0x000000 },
  775|       |	{ 0x00049B, 0x00049A, 0x000000, 0x00049A },
  776|       |	{ 0x00049C, 0x000000, 0x00049D, 0x000000 },
  777|       |	{ 0x00049D, 0x00049C, 0x000000, 0x00049C },
  778|       |	{ 0x00049E, 0x000000, 0x00049F, 0x000000 },
  779|       |	{ 0x00049F, 0x00049E, 0x000000, 0x00049E },
  780|       |	{ 0x0004A0, 0x000000, 0x0004A1, 0x000000 },
  781|       |	{ 0x0004A1, 0x0004A0, 0x000000, 0x0004A0 },
  782|       |	{ 0x0004A2, 0x000000, 0x0004A3, 0x000000 },
  783|       |	{ 0x0004A3, 0x0004A2, 0x000000, 0x0004A2 },
  784|       |	{ 0x0004A4, 0x000000, 0x0004A5, 0x000000 },
  785|       |	{ 0x0004A5, 0x0004A4, 0x000000, 0x0004A4 },
  786|       |	{ 0x0004A6, 0x000000, 0x0004A7, 0x000000 },
  787|       |	{ 0x0004A7, 0x0004A6, 0x000000, 0x0004A6 },
  788|       |	{ 0x0004A8, 0x000000, 0x0004A9, 0x000000 },
  789|       |	{ 0x0004A9, 0x0004A8, 0x000000, 0x0004A8 },
  790|       |	{ 0x0004AA, 0x000000, 0x0004AB, 0x000000 },
  791|       |	{ 0x0004AB, 0x0004AA, 0x000000, 0x0004AA },
  792|       |	{ 0x0004AC, 0x000000, 0x0004AD, 0x000000 },
  793|       |	{ 0x0004AD, 0x0004AC, 0x000000, 0x0004AC },
  794|       |	{ 0x0004AE, 0x000000, 0x0004AF, 0x000000 },
  795|       |	{ 0x0004AF, 0x0004AE, 0x000000, 0x0004AE },
  796|       |	{ 0x0004B0, 0x000000, 0x0004B1, 0x000000 },
  797|       |	{ 0x0004B1, 0x0004B0, 0x000000, 0x0004B0 },
  798|       |	{ 0x0004B2, 0x000000, 0x0004B3, 0x000000 },
  799|       |	{ 0x0004B3, 0x0004B2, 0x000000, 0x0004B2 },
  800|       |	{ 0x0004B4, 0x000000, 0x0004B5, 0x000000 },
  801|       |	{ 0x0004B5, 0x0004B4, 0x000000, 0x0004B4 },
  802|       |	{ 0x0004B6, 0x000000, 0x0004B7, 0x000000 },
  803|       |	{ 0x0004B7, 0x0004B6, 0x000000, 0x0004B6 },
  804|       |	{ 0x0004B8, 0x000000, 0x0004B9, 0x000000 },
  805|       |	{ 0x0004B9, 0x0004B8, 0x000000, 0x0004B8 },
  806|       |	{ 0x0004BA, 0x000000, 0x0004BB, 0x000000 },
  807|       |	{ 0x0004BB, 0x0004BA, 0x000000, 0x0004BA },
  808|       |	{ 0x0004BC, 0x000000, 0x0004BD, 0x000000 },
  809|       |	{ 0x0004BD, 0x0004BC, 0x000000, 0x0004BC },
  810|       |	{ 0x0004BE, 0x000000, 0x0004BF, 0x000000 },
  811|       |	{ 0x0004BF, 0x0004BE, 0x000000, 0x0004BE },
  812|       |	{ 0x0004C0, 0x000000, 0x0004CF, 0x000000 },
  813|       |	{ 0x0004C1, 0x000000, 0x0004C2, 0x000000 },
  814|       |	{ 0x0004C2, 0x0004C1, 0x000000, 0x0004C1 },
  815|       |	{ 0x0004C3, 0x000000, 0x0004C4, 0x000000 },
  816|       |	{ 0x0004C4, 0x0004C3, 0x000000, 0x0004C3 },
  817|       |	{ 0x0004C5, 0x000000, 0x0004C6, 0x000000 },
  818|       |	{ 0x0004C6, 0x0004C5, 0x000000, 0x0004C5 },
  819|       |	{ 0x0004C7, 0x000000, 0x0004C8, 0x000000 },
  820|       |	{ 0x0004C8, 0x0004C7, 0x000000, 0x0004C7 },
  821|       |	{ 0x0004C9, 0x000000, 0x0004CA, 0x000000 },
  822|       |	{ 0x0004CA, 0x0004C9, 0x000000, 0x0004C9 },
  823|       |	{ 0x0004CB, 0x000000, 0x0004CC, 0x000000 },
  824|       |	{ 0x0004CC, 0x0004CB, 0x000000, 0x0004CB },
  825|       |	{ 0x0004CD, 0x000000, 0x0004CE, 0x000000 },
  826|       |	{ 0x0004CE, 0x0004CD, 0x000000, 0x0004CD },
  827|       |	{ 0x0004CF, 0x0004C0, 0x000000, 0x0004C0 },
  828|       |	{ 0x0004D0, 0x000000, 0x0004D1, 0x000000 },
  829|       |	{ 0x0004D1, 0x0004D0, 0x000000, 0x0004D0 },
  830|       |	{ 0x0004D2, 0x000000, 0x0004D3, 0x000000 },
  831|       |	{ 0x0004D3, 0x0004D2, 0x000000, 0x0004D2 },
  832|       |	{ 0x0004D4, 0x000000, 0x0004D5, 0x000000 },
  833|       |	{ 0x0004D5, 0x0004D4, 0x000000, 0x0004D4 },
  834|       |	{ 0x0004D6, 0x000000, 0x0004D7, 0x000000 },
  835|       |	{ 0x0004D7, 0x0004D6, 0x000000, 0x0004D6 },
  836|       |	{ 0x0004D8, 0x000000, 0x0004D9, 0x000000 },
  837|       |	{ 0x0004D9, 0x0004D8, 0x000000, 0x0004D8 },
  838|       |	{ 0x0004DA, 0x000000, 0x0004DB, 0x000000 },
  839|       |	{ 0x0004DB, 0x0004DA, 0x000000, 0x0004DA },
  840|       |	{ 0x0004DC, 0x000000, 0x0004DD, 0x000000 },
  841|       |	{ 0x0004DD, 0x0004DC, 0x000000, 0x0004DC },
  842|       |	{ 0x0004DE, 0x000000, 0x0004DF, 0x000000 },
  843|       |	{ 0x0004DF, 0x0004DE, 0x000000, 0x0004DE },
  844|       |	{ 0x0004E0, 0x000000, 0x0004E1, 0x000000 },
  845|       |	{ 0x0004E1, 0x0004E0, 0x000000, 0x0004E0 },
  846|       |	{ 0x0004E2, 0x000000, 0x0004E3, 0x000000 },
  847|       |	{ 0x0004E3, 0x0004E2, 0x000000, 0x0004E2 },
  848|       |	{ 0x0004E4, 0x000000, 0x0004E5, 0x000000 },
  849|       |	{ 0x0004E5, 0x0004E4, 0x000000, 0x0004E4 },
  850|       |	{ 0x0004E6, 0x000000, 0x0004E7, 0x000000 },
  851|       |	{ 0x0004E7, 0x0004E6, 0x000000, 0x0004E6 },
  852|       |	{ 0x0004E8, 0x000000, 0x0004E9, 0x000000 },
  853|       |	{ 0x0004E9, 0x0004E8, 0x000000, 0x0004E8 },
  854|       |	{ 0x0004EA, 0x000000, 0x0004EB, 0x000000 },
  855|       |	{ 0x0004EB, 0x0004EA, 0x000000, 0x0004EA },
  856|       |	{ 0x0004EC, 0x000000, 0x0004ED, 0x000000 },
  857|       |	{ 0x0004ED, 0x0004EC, 0x000000, 0x0004EC },
  858|       |	{ 0x0004EE, 0x000000, 0x0004EF, 0x000000 },
  859|       |	{ 0x0004EF, 0x0004EE, 0x000000, 0x0004EE },
  860|       |	{ 0x0004F0, 0x000000, 0x0004F1, 0x000000 },
  861|       |	{ 0x0004F1, 0x0004F0, 0x000000, 0x0004F0 },
  862|       |	{ 0x0004F2, 0x000000, 0x0004F3, 0x000000 },
  863|       |	{ 0x0004F3, 0x0004F2, 0x000000, 0x0004F2 },
  864|       |	{ 0x0004F4, 0x000000, 0x0004F5, 0x000000 },
  865|       |	{ 0x0004F5, 0x0004F4, 0x000000, 0x0004F4 },
  866|       |	{ 0x0004F6, 0x000000, 0x0004F7, 0x000000 },
  867|       |	{ 0x0004F7, 0x0004F6, 0x000000, 0x0004F6 },
  868|       |	{ 0x0004F8, 0x000000, 0x0004F9, 0x000000 },
  869|       |	{ 0x0004F9, 0x0004F8, 0x000000, 0x0004F8 },
  870|       |	{ 0x0004FA, 0x000000, 0x0004FB, 0x000000 },
  871|       |	{ 0x0004FB, 0x0004FA, 0x000000, 0x0004FA },
  872|       |	{ 0x0004FC, 0x000000, 0x0004FD, 0x000000 },
  873|       |	{ 0x0004FD, 0x0004FC, 0x000000, 0x0004FC },
  874|       |	{ 0x0004FE, 0x000000, 0x0004FF, 0x000000 },
  875|       |	{ 0x0004FF, 0x0004FE, 0x000000, 0x0004FE },
  876|       |	{ 0x000500, 0x000000, 0x000501, 0x000000 },
  877|       |	{ 0x000501, 0x000500, 0x000000, 0x000500 },
  878|       |	{ 0x000502, 0x000000, 0x000503, 0x000000 },
  879|       |	{ 0x000503, 0x000502, 0x000000, 0x000502 },
  880|       |	{ 0x000504, 0x000000, 0x000505, 0x000000 },
  881|       |	{ 0x000505, 0x000504, 0x000000, 0x000504 },
  882|       |	{ 0x000506, 0x000000, 0x000507, 0x000000 },
  883|       |	{ 0x000507, 0x000506, 0x000000, 0x000506 },
  884|       |	{ 0x000508, 0x000000, 0x000509, 0x000000 },
  885|       |	{ 0x000509, 0x000508, 0x000000, 0x000508 },
  886|       |	{ 0x00050A, 0x000000, 0x00050B, 0x000000 },
  887|       |	{ 0x00050B, 0x00050A, 0x000000, 0x00050A },
  888|       |	{ 0x00050C, 0x000000, 0x00050D, 0x000000 },
  889|       |	{ 0x00050D, 0x00050C, 0x000000, 0x00050C },
  890|       |	{ 0x00050E, 0x000000, 0x00050F, 0x000000 },
  891|       |	{ 0x00050F, 0x00050E, 0x000000, 0x00050E },
  892|       |	{ 0x000510, 0x000000, 0x000511, 0x000000 },
  893|       |	{ 0x000511, 0x000510, 0x000000, 0x000510 },
  894|       |	{ 0x000512, 0x000000, 0x000513, 0x000000 },
  895|       |	{ 0x000513, 0x000512, 0x000000, 0x000512 },
  896|       |	{ 0x000514, 0x000000, 0x000515, 0x000000 },
  897|       |	{ 0x000515, 0x000514, 0x000000, 0x000514 },
  898|       |	{ 0x000516, 0x000000, 0x000517, 0x000000 },
  899|       |	{ 0x000517, 0x000516, 0x000000, 0x000516 },
  900|       |	{ 0x000518, 0x000000, 0x000519, 0x000000 },
  901|       |	{ 0x000519, 0x000518, 0x000000, 0x000518 },
  902|       |	{ 0x00051A, 0x000000, 0x00051B, 0x000000 },
  903|       |	{ 0x00051B, 0x00051A, 0x000000, 0x00051A },
  904|       |	{ 0x00051C, 0x000000, 0x00051D, 0x000000 },
  905|       |	{ 0x00051D, 0x00051C, 0x000000, 0x00051C },
  906|       |	{ 0x00051E, 0x000000, 0x00051F, 0x000000 },
  907|       |	{ 0x00051F, 0x00051E, 0x000000, 0x00051E },
  908|       |	{ 0x000520, 0x000000, 0x000521, 0x000000 },
  909|       |	{ 0x000521, 0x000520, 0x000000, 0x000520 },
  910|       |	{ 0x000522, 0x000000, 0x000523, 0x000000 },
  911|       |	{ 0x000523, 0x000522, 0x000000, 0x000522 },
  912|       |	{ 0x000524, 0x000000, 0x000525, 0x000000 },
  913|       |	{ 0x000525, 0x000524, 0x000000, 0x000524 },
  914|       |	{ 0x000526, 0x000000, 0x000527, 0x000000 },
  915|       |	{ 0x000527, 0x000526, 0x000000, 0x000526 },
  916|       |	{ 0x000528, 0x000000, 0x000529, 0x000000 },
  917|       |	{ 0x000529, 0x000528, 0x000000, 0x000528 },
  918|       |	{ 0x00052A, 0x000000, 0x00052B, 0x000000 },
  919|       |	{ 0x00052B, 0x00052A, 0x000000, 0x00052A },
  920|       |	{ 0x00052C, 0x000000, 0x00052D, 0x000000 },
  921|       |	{ 0x00052D, 0x00052C, 0x000000, 0x00052C },
  922|       |	{ 0x00052E, 0x000000, 0x00052F, 0x000000 },
  923|       |	{ 0x00052F, 0x00052E, 0x000000, 0x00052E },
  924|       |	{ 0x000531, 0x000000, 0x000561, 0x000000 },
  925|       |	{ 0x000532, 0x000000, 0x000562, 0x000000 },
  926|       |	{ 0x000533, 0x000000, 0x000563, 0x000000 },
  927|       |	{ 0x000534, 0x000000, 0x000564, 0x000000 },
  928|       |	{ 0x000535, 0x000000, 0x000565, 0x000000 },
  929|       |	{ 0x000536, 0x000000, 0x000566, 0x000000 },
  930|       |	{ 0x000537, 0x000000, 0x000567, 0x000000 },
  931|       |	{ 0x000538, 0x000000, 0x000568, 0x000000 },
  932|       |	{ 0x000539, 0x000000, 0x000569, 0x000000 },
  933|       |	{ 0x00053A, 0x000000, 0x00056A, 0x000000 },
  934|       |	{ 0x00053B, 0x000000, 0x00056B, 0x000000 },
  935|       |	{ 0x00053C, 0x000000, 0x00056C, 0x000000 },
  936|       |	{ 0x00053D, 0x000000, 0x00056D, 0x000000 },
  937|       |	{ 0x00053E, 0x000000, 0x00056E, 0x000000 },
  938|       |	{ 0x00053F, 0x000000, 0x00056F, 0x000000 },
  939|       |	{ 0x000540, 0x000000, 0x000570, 0x000000 },
  940|       |	{ 0x000541, 0x000000, 0x000571, 0x000000 },
  941|       |	{ 0x000542, 0x000000, 0x000572, 0x000000 },
  942|       |	{ 0x000543, 0x000000, 0x000573, 0x000000 },
  943|       |	{ 0x000544, 0x000000, 0x000574, 0x000000 },
  944|       |	{ 0x000545, 0x000000, 0x000575, 0x000000 },
  945|       |	{ 0x000546, 0x000000, 0x000576, 0x000000 },
  946|       |	{ 0x000547, 0x000000, 0x000577, 0x000000 },
  947|       |	{ 0x000548, 0x000000, 0x000578, 0x000000 },
  948|       |	{ 0x000549, 0x000000, 0x000579, 0x000000 },
  949|       |	{ 0x00054A, 0x000000, 0x00057A, 0x000000 },
  950|       |	{ 0x00054B, 0x000000, 0x00057B, 0x000000 },
  951|       |	{ 0x00054C, 0x000000, 0x00057C, 0x000000 },
  952|       |	{ 0x00054D, 0x000000, 0x00057D, 0x000000 },
  953|       |	{ 0x00054E, 0x000000, 0x00057E, 0x000000 },
  954|       |	{ 0x00054F, 0x000000, 0x00057F, 0x000000 },
  955|       |	{ 0x000550, 0x000000, 0x000580, 0x000000 },
  956|       |	{ 0x000551, 0x000000, 0x000581, 0x000000 },
  957|       |	{ 0x000552, 0x000000, 0x000582, 0x000000 },
  958|       |	{ 0x000553, 0x000000, 0x000583, 0x000000 },
  959|       |	{ 0x000554, 0x000000, 0x000584, 0x000000 },
  960|       |	{ 0x000555, 0x000000, 0x000585, 0x000000 },
  961|       |	{ 0x000556, 0x000000, 0x000586, 0x000000 },
  962|       |	{ 0x000561, 0x000531, 0x000000, 0x000531 },
  963|       |	{ 0x000562, 0x000532, 0x000000, 0x000532 },
  964|       |	{ 0x000563, 0x000533, 0x000000, 0x000533 },
  965|       |	{ 0x000564, 0x000534, 0x000000, 0x000534 },
  966|       |	{ 0x000565, 0x000535, 0x000000, 0x000535 },
  967|       |	{ 0x000566, 0x000536, 0x000000, 0x000536 },
  968|       |	{ 0x000567, 0x000537, 0x000000, 0x000537 },
  969|       |	{ 0x000568, 0x000538, 0x000000, 0x000538 },
  970|       |	{ 0x000569, 0x000539, 0x000000, 0x000539 },
  971|       |	{ 0x00056A, 0x00053A, 0x000000, 0x00053A },
  972|       |	{ 0x00056B, 0x00053B, 0x000000, 0x00053B },
  973|       |	{ 0x00056C, 0x00053C, 0x000000, 0x00053C },
  974|       |	{ 0x00056D, 0x00053D, 0x000000, 0x00053D },
  975|       |	{ 0x00056E, 0x00053E, 0x000000, 0x00053E },
  976|       |	{ 0x00056F, 0x00053F, 0x000000, 0x00053F },
  977|       |	{ 0x000570, 0x000540, 0x000000, 0x000540 },
  978|       |	{ 0x000571, 0x000541, 0x000000, 0x000541 },
  979|       |	{ 0x000572, 0x000542, 0x000000, 0x000542 },
  980|       |	{ 0x000573, 0x000543, 0x000000, 0x000543 },
  981|       |	{ 0x000574, 0x000544, 0x000000, 0x000544 },
  982|       |	{ 0x000575, 0x000545, 0x000000, 0x000545 },
  983|       |	{ 0x000576, 0x000546, 0x000000, 0x000546 },
  984|       |	{ 0x000577, 0x000547, 0x000000, 0x000547 },
  985|       |	{ 0x000578, 0x000548, 0x000000, 0x000548 },
  986|       |	{ 0x000579, 0x000549, 0x000000, 0x000549 },
  987|       |	{ 0x00057A, 0x00054A, 0x000000, 0x00054A },
  988|       |	{ 0x00057B, 0x00054B, 0x000000, 0x00054B },
  989|       |	{ 0x00057C, 0x00054C, 0x000000, 0x00054C },
  990|       |	{ 0x00057D, 0x00054D, 0x000000, 0x00054D },
  991|       |	{ 0x00057E, 0x00054E, 0x000000, 0x00054E },
  992|       |	{ 0x00057F, 0x00054F, 0x000000, 0x00054F },
  993|       |	{ 0x000580, 0x000550, 0x000000, 0x000550 },
  994|       |	{ 0x000581, 0x000551, 0x000000, 0x000551 },
  995|       |	{ 0x000582, 0x000552, 0x000000, 0x000552 },
  996|       |	{ 0x000583, 0x000553, 0x000000, 0x000553 },
  997|       |	{ 0x000584, 0x000554, 0x000000, 0x000554 },
  998|       |	{ 0x000585, 0x000555, 0x000000, 0x000555 },
  999|       |	{ 0x000586, 0x000556, 0x000000, 0x000556 },
 1000|       |	{ 0x0010A0, 0x000000, 0x002D00, 0x000000 },
 1001|       |	{ 0x0010A1, 0x000000, 0x002D01, 0x000000 },
 1002|       |	{ 0x0010A2, 0x000000, 0x002D02, 0x000000 },
 1003|       |	{ 0x0010A3, 0x000000, 0x002D03, 0x000000 },
 1004|       |	{ 0x0010A4, 0x000000, 0x002D04, 0x000000 },
 1005|       |	{ 0x0010A5, 0x000000, 0x002D05, 0x000000 },
 1006|       |	{ 0x0010A6, 0x000000, 0x002D06, 0x000000 },
 1007|       |	{ 0x0010A7, 0x000000, 0x002D07, 0x000000 },
 1008|       |	{ 0x0010A8, 0x000000, 0x002D08, 0x000000 },
 1009|       |	{ 0x0010A9, 0x000000, 0x002D09, 0x000000 },
 1010|       |	{ 0x0010AA, 0x000000, 0x002D0A, 0x000000 },
 1011|       |	{ 0x0010AB, 0x000000, 0x002D0B, 0x000000 },
 1012|       |	{ 0x0010AC, 0x000000, 0x002D0C, 0x000000 },
 1013|       |	{ 0x0010AD, 0x000000, 0x002D0D, 0x000000 },
 1014|       |	{ 0x0010AE, 0x000000, 0x002D0E, 0x000000 },
 1015|       |	{ 0x0010AF, 0x000000, 0x002D0F, 0x000000 },
 1016|       |	{ 0x0010B0, 0x000000, 0x002D10, 0x000000 },
 1017|       |	{ 0x0010B1, 0x000000, 0x002D11, 0x000000 },
 1018|       |	{ 0x0010B2, 0x000000, 0x002D12, 0x000000 },
 1019|       |	{ 0x0010B3, 0x000000, 0x002D13, 0x000000 },
 1020|       |	{ 0x0010B4, 0x000000, 0x002D14, 0x000000 },
 1021|       |	{ 0x0010B5, 0x000000, 0x002D15, 0x000000 },
 1022|       |	{ 0x0010B6, 0x000000, 0x002D16, 0x000000 },
 1023|       |	{ 0x0010B7, 0x000000, 0x002D17, 0x000000 },
 1024|       |	{ 0x0010B8, 0x000000, 0x002D18, 0x000000 },
 1025|       |	{ 0x0010B9, 0x000000, 0x002D19, 0x000000 },
 1026|       |	{ 0x0010BA, 0x000000, 0x002D1A, 0x000000 },
 1027|       |	{ 0x0010BB, 0x000000, 0x002D1B, 0x000000 },
 1028|       |	{ 0x0010BC, 0x000000, 0x002D1C, 0x000000 },
 1029|       |	{ 0x0010BD, 0x000000, 0x002D1D, 0x000000 },
 1030|       |	{ 0x0010BE, 0x000000, 0x002D1E, 0x000000 },
 1031|       |	{ 0x0010BF, 0x000000, 0x002D1F, 0x000000 },
 1032|       |	{ 0x0010C0, 0x000000, 0x002D20, 0x000000 },
 1033|       |	{ 0x0010C1, 0x000000, 0x002D21, 0x000000 },
 1034|       |	{ 0x0010C2, 0x000000, 0x002D22, 0x000000 },
 1035|       |	{ 0x0010C3, 0x000000, 0x002D23, 0x000000 },
 1036|       |	{ 0x0010C4, 0x000000, 0x002D24, 0x000000 },
 1037|       |	{ 0x0010C5, 0x000000, 0x002D25, 0x000000 },
 1038|       |	{ 0x0010C7, 0x000000, 0x002D27, 0x000000 },
 1039|       |	{ 0x0010CD, 0x000000, 0x002D2D, 0x000000 },
 1040|       |	{ 0x0010D0, 0x001C90, 0x000000, 0x0010D0 },
 1041|       |	{ 0x0010D1, 0x001C91, 0x000000, 0x0010D1 },
 1042|       |	{ 0x0010D2, 0x001C92, 0x000000, 0x0010D2 },
 1043|       |	{ 0x0010D3, 0x001C93, 0x000000, 0x0010D3 },
 1044|       |	{ 0x0010D4, 0x001C94, 0x000000, 0x0010D4 },
 1045|       |	{ 0x0010D5, 0x001C95, 0x000000, 0x0010D5 },
 1046|       |	{ 0x0010D6, 0x001C96, 0x000000, 0x0010D6 },
 1047|       |	{ 0x0010D7, 0x001C97, 0x000000, 0x0010D7 },
 1048|       |	{ 0x0010D8, 0x001C98, 0x000000, 0x0010D8 },
 1049|       |	{ 0x0010D9, 0x001C99, 0x000000, 0x0010D9 },
 1050|       |	{ 0x0010DA, 0x001C9A, 0x000000, 0x0010DA },
 1051|       |	{ 0x0010DB, 0x001C9B, 0x000000, 0x0010DB },
 1052|       |	{ 0x0010DC, 0x001C9C, 0x000000, 0x0010DC },
 1053|       |	{ 0x0010DD, 0x001C9D, 0x000000, 0x0010DD },
 1054|       |	{ 0x0010DE, 0x001C9E, 0x000000, 0x0010DE },
 1055|       |	{ 0x0010DF, 0x001C9F, 0x000000, 0x0010DF },
 1056|       |	{ 0x0010E0, 0x001CA0, 0x000000, 0x0010E0 },
 1057|       |	{ 0x0010E1, 0x001CA1, 0x000000, 0x0010E1 },
 1058|       |	{ 0x0010E2, 0x001CA2, 0x000000, 0x0010E2 },
 1059|       |	{ 0x0010E3, 0x001CA3, 0x000000, 0x0010E3 },
 1060|       |	{ 0x0010E4, 0x001CA4, 0x000000, 0x0010E4 },
 1061|       |	{ 0x0010E5, 0x001CA5, 0x000000, 0x0010E5 },
 1062|       |	{ 0x0010E6, 0x001CA6, 0x000000, 0x0010E6 },
 1063|       |	{ 0x0010E7, 0x001CA7, 0x000000, 0x0010E7 },
 1064|       |	{ 0x0010E8, 0x001CA8, 0x000000, 0x0010E8 },
 1065|       |	{ 0x0010E9, 0x001CA9, 0x000000, 0x0010E9 },
 1066|       |	{ 0x0010EA, 0x001CAA, 0x000000, 0x0010EA },
 1067|       |	{ 0x0010EB, 0x001CAB, 0x000000, 0x0010EB },
 1068|       |	{ 0x0010EC, 0x001CAC, 0x000000, 0x0010EC },
 1069|       |	{ 0x0010ED, 0x001CAD, 0x000000, 0x0010ED },
 1070|       |	{ 0x0010EE, 0x001CAE, 0x000000, 0x0010EE },
 1071|       |	{ 0x0010EF, 0x001CAF, 0x000000, 0x0010EF },
 1072|       |	{ 0x0010F0, 0x001CB0, 0x000000, 0x0010F0 },
 1073|       |	{ 0x0010F1, 0x001CB1, 0x000000, 0x0010F1 },
 1074|       |	{ 0x0010F2, 0x001CB2, 0x000000, 0x0010F2 },
 1075|       |	{ 0x0010F3, 0x001CB3, 0x000000, 0x0010F3 },
 1076|       |	{ 0x0010F4, 0x001CB4, 0x000000, 0x0010F4 },
 1077|       |	{ 0x0010F5, 0x001CB5, 0x000000, 0x0010F5 },
 1078|       |	{ 0x0010F6, 0x001CB6, 0x000000, 0x0010F6 },
 1079|       |	{ 0x0010F7, 0x001CB7, 0x000000, 0x0010F7 },
 1080|       |	{ 0x0010F8, 0x001CB8, 0x000000, 0x0010F8 },
 1081|       |	{ 0x0010F9, 0x001CB9, 0x000000, 0x0010F9 },
 1082|       |	{ 0x0010FA, 0x001CBA, 0x000000, 0x0010FA },
 1083|       |	{ 0x0010FD, 0x001CBD, 0x000000, 0x0010FD },
 1084|       |	{ 0x0010FE, 0x001CBE, 0x000000, 0x0010FE },
 1085|       |	{ 0x0010FF, 0x001CBF, 0x000000, 0x0010FF },
 1086|       |	{ 0x0013A0, 0x000000, 0x00AB70, 0x000000 },
 1087|       |	{ 0x0013A1, 0x000000, 0x00AB71, 0x000000 },
 1088|       |	{ 0x0013A2, 0x000000, 0x00AB72, 0x000000 },
 1089|       |	{ 0x0013A3, 0x000000, 0x00AB73, 0x000000 },
 1090|       |	{ 0x0013A4, 0x000000, 0x00AB74, 0x000000 },
 1091|       |	{ 0x0013A5, 0x000000, 0x00AB75, 0x000000 },
 1092|       |	{ 0x0013A6, 0x000000, 0x00AB76, 0x000000 },
 1093|       |	{ 0x0013A7, 0x000000, 0x00AB77, 0x000000 },
 1094|       |	{ 0x0013A8, 0x000000, 0x00AB78, 0x000000 },
 1095|       |	{ 0x0013A9, 0x000000, 0x00AB79, 0x000000 },
 1096|       |	{ 0x0013AA, 0x000000, 0x00AB7A, 0x000000 },
 1097|       |	{ 0x0013AB, 0x000000, 0x00AB7B, 0x000000 },
 1098|       |	{ 0x0013AC, 0x000000, 0x00AB7C, 0x000000 },
 1099|       |	{ 0x0013AD, 0x000000, 0x00AB7D, 0x000000 },
 1100|       |	{ 0x0013AE, 0x000000, 0x00AB7E, 0x000000 },
 1101|       |	{ 0x0013AF, 0x000000, 0x00AB7F, 0x000000 },
 1102|       |	{ 0x0013B0, 0x000000, 0x00AB80, 0x000000 },
 1103|       |	{ 0x0013B1, 0x000000, 0x00AB81, 0x000000 },
 1104|       |	{ 0x0013B2, 0x000000, 0x00AB82, 0x000000 },
 1105|       |	{ 0x0013B3, 0x000000, 0x00AB83, 0x000000 },
 1106|       |	{ 0x0013B4, 0x000000, 0x00AB84, 0x000000 },
 1107|       |	{ 0x0013B5, 0x000000, 0x00AB85, 0x000000 },
 1108|       |	{ 0x0013B6, 0x000000, 0x00AB86, 0x000000 },
 1109|       |	{ 0x0013B7, 0x000000, 0x00AB87, 0x000000 },
 1110|       |	{ 0x0013B8, 0x000000, 0x00AB88, 0x000000 },
 1111|       |	{ 0x0013B9, 0x000000, 0x00AB89, 0x000000 },
 1112|       |	{ 0x0013BA, 0x000000, 0x00AB8A, 0x000000 },
 1113|       |	{ 0x0013BB, 0x000000, 0x00AB8B, 0x000000 },
 1114|       |	{ 0x0013BC, 0x000000, 0x00AB8C, 0x000000 },
 1115|       |	{ 0x0013BD, 0x000000, 0x00AB8D, 0x000000 },
 1116|       |	{ 0x0013BE, 0x000000, 0x00AB8E, 0x000000 },
 1117|       |	{ 0x0013BF, 0x000000, 0x00AB8F, 0x000000 },
 1118|       |	{ 0x0013C0, 0x000000, 0x00AB90, 0x000000 },
 1119|       |	{ 0x0013C1, 0x000000, 0x00AB91, 0x000000 },
 1120|       |	{ 0x0013C2, 0x000000, 0x00AB92, 0x000000 },
 1121|       |	{ 0x0013C3, 0x000000, 0x00AB93, 0x000000 },
 1122|       |	{ 0x0013C4, 0x000000, 0x00AB94, 0x000000 },
 1123|       |	{ 0x0013C5, 0x000000, 0x00AB95, 0x000000 },
 1124|       |	{ 0x0013C6, 0x000000, 0x00AB96, 0x000000 },
 1125|       |	{ 0x0013C7, 0x000000, 0x00AB97, 0x000000 },
 1126|       |	{ 0x0013C8, 0x000000, 0x00AB98, 0x000000 },
 1127|       |	{ 0x0013C9, 0x000000, 0x00AB99, 0x000000 },
 1128|       |	{ 0x0013CA, 0x000000, 0x00AB9A, 0x000000 },
 1129|       |	{ 0x0013CB, 0x000000, 0x00AB9B, 0x000000 },
 1130|       |	{ 0x0013CC, 0x000000, 0x00AB9C, 0x000000 },
 1131|       |	{ 0x0013CD, 0x000000, 0x00AB9D, 0x000000 },
 1132|       |	{ 0x0013CE, 0x000000, 0x00AB9E, 0x000000 },
 1133|       |	{ 0x0013CF, 0x000000, 0x00AB9F, 0x000000 },
 1134|       |	{ 0x0013D0, 0x000000, 0x00ABA0, 0x000000 },
 1135|       |	{ 0x0013D1, 0x000000, 0x00ABA1, 0x000000 },
 1136|       |	{ 0x0013D2, 0x000000, 0x00ABA2, 0x000000 },
 1137|       |	{ 0x0013D3, 0x000000, 0x00ABA3, 0x000000 },
 1138|       |	{ 0x0013D4, 0x000000, 0x00ABA4, 0x000000 },
 1139|       |	{ 0x0013D5, 0x000000, 0x00ABA5, 0x000000 },
 1140|       |	{ 0x0013D6, 0x000000, 0x00ABA6, 0x000000 },
 1141|       |	{ 0x0013D7, 0x000000, 0x00ABA7, 0x000000 },
 1142|       |	{ 0x0013D8, 0x000000, 0x00ABA8, 0x000000 },
 1143|       |	{ 0x0013D9, 0x000000, 0x00ABA9, 0x000000 },
 1144|       |	{ 0x0013DA, 0x000000, 0x00ABAA, 0x000000 },
 1145|       |	{ 0x0013DB, 0x000000, 0x00ABAB, 0x000000 },
 1146|       |	{ 0x0013DC, 0x000000, 0x00ABAC, 0x000000 },
 1147|       |	{ 0x0013DD, 0x000000, 0x00ABAD, 0x000000 },
 1148|       |	{ 0x0013DE, 0x000000, 0x00ABAE, 0x000000 },
 1149|       |	{ 0x0013DF, 0x000000, 0x00ABAF, 0x000000 },
 1150|       |	{ 0x0013E0, 0x000000, 0x00ABB0, 0x000000 },
 1151|       |	{ 0x0013E1, 0x000000, 0x00ABB1, 0x000000 },
 1152|       |	{ 0x0013E2, 0x000000, 0x00ABB2, 0x000000 },
 1153|       |	{ 0x0013E3, 0x000000, 0x00ABB3, 0x000000 },
 1154|       |	{ 0x0013E4, 0x000000, 0x00ABB4, 0x000000 },
 1155|       |	{ 0x0013E5, 0x000000, 0x00ABB5, 0x000000 },
 1156|       |	{ 0x0013E6, 0x000000, 0x00ABB6, 0x000000 },
 1157|       |	{ 0x0013E7, 0x000000, 0x00ABB7, 0x000000 },
 1158|       |	{ 0x0013E8, 0x000000, 0x00ABB8, 0x000000 },
 1159|       |	{ 0x0013E9, 0x000000, 0x00ABB9, 0x000000 },
 1160|       |	{ 0x0013EA, 0x000000, 0x00ABBA, 0x000000 },
 1161|       |	{ 0x0013EB, 0x000000, 0x00ABBB, 0x000000 },
 1162|       |	{ 0x0013EC, 0x000000, 0x00ABBC, 0x000000 },
 1163|       |	{ 0x0013ED, 0x000000, 0x00ABBD, 0x000000 },
 1164|       |	{ 0x0013EE, 0x000000, 0x00ABBE, 0x000000 },
 1165|       |	{ 0x0013EF, 0x000000, 0x00ABBF, 0x000000 },
 1166|       |	{ 0x0013F0, 0x000000, 0x0013F8, 0x000000 },
 1167|       |	{ 0x0013F1, 0x000000, 0x0013F9, 0x000000 },
 1168|       |	{ 0x0013F2, 0x000000, 0x0013FA, 0x000000 },
 1169|       |	{ 0x0013F3, 0x000000, 0x0013FB, 0x000000 },
 1170|       |	{ 0x0013F4, 0x000000, 0x0013FC, 0x000000 },
 1171|       |	{ 0x0013F5, 0x000000, 0x0013FD, 0x000000 },
 1172|       |	{ 0x0013F8, 0x0013F0, 0x000000, 0x0013F0 },
 1173|       |	{ 0x0013F9, 0x0013F1, 0x000000, 0x0013F1 },
 1174|       |	{ 0x0013FA, 0x0013F2, 0x000000, 0x0013F2 },
 1175|       |	{ 0x0013FB, 0x0013F3, 0x000000, 0x0013F3 },
 1176|       |	{ 0x0013FC, 0x0013F4, 0x000000, 0x0013F4 },
 1177|       |	{ 0x0013FD, 0x0013F5, 0x000000, 0x0013F5 },
 1178|       |	{ 0x001C80, 0x000412, 0x000000, 0x000412 },
 1179|       |	{ 0x001C81, 0x000414, 0x000000, 0x000414 },
 1180|       |	{ 0x001C82, 0x00041E, 0x000000, 0x00041E },
 1181|       |	{ 0x001C83, 0x000421, 0x000000, 0x000421 },
 1182|       |	{ 0x001C84, 0x000422, 0x000000, 0x000422 },
 1183|       |	{ 0x001C85, 0x000422, 0x000000, 0x000422 },
 1184|       |	{ 0x001C86, 0x00042A, 0x000000, 0x00042A },
 1185|       |	{ 0x001C87, 0x000462, 0x000000, 0x000462 },
 1186|       |	{ 0x001C88, 0x00A64A, 0x000000, 0x00A64A },
 1187|       |	{ 0x001C90, 0x000000, 0x0010D0, 0x000000 },
 1188|       |	{ 0x001C91, 0x000000, 0x0010D1, 0x000000 },
 1189|       |	{ 0x001C92, 0x000000, 0x0010D2, 0x000000 },
 1190|       |	{ 0x001C93, 0x000000, 0x0010D3, 0x000000 },
 1191|       |	{ 0x001C94, 0x000000, 0x0010D4, 0x000000 },
 1192|       |	{ 0x001C95, 0x000000, 0x0010D5, 0x000000 },
 1193|       |	{ 0x001C96, 0x000000, 0x0010D6, 0x000000 },
 1194|       |	{ 0x001C97, 0x000000, 0x0010D7, 0x000000 },
 1195|       |	{ 0x001C98, 0x000000, 0x0010D8, 0x000000 },
 1196|       |	{ 0x001C99, 0x000000, 0x0010D9, 0x000000 },
 1197|       |	{ 0x001C9A, 0x000000, 0x0010DA, 0x000000 },
 1198|       |	{ 0x001C9B, 0x000000, 0x0010DB, 0x000000 },
 1199|       |	{ 0x001C9C, 0x000000, 0x0010DC, 0x000000 },
 1200|       |	{ 0x001C9D, 0x000000, 0x0010DD, 0x000000 },
 1201|       |	{ 0x001C9E, 0x000000, 0x0010DE, 0x000000 },
 1202|       |	{ 0x001C9F, 0x000000, 0x0010DF, 0x000000 },
 1203|       |	{ 0x001CA0, 0x000000, 0x0010E0, 0x000000 },
 1204|       |	{ 0x001CA1, 0x000000, 0x0010E1, 0x000000 },
 1205|       |	{ 0x001CA2, 0x000000, 0x0010E2, 0x000000 },
 1206|       |	{ 0x001CA3, 0x000000, 0x0010E3, 0x000000 },
 1207|       |	{ 0x001CA4, 0x000000, 0x0010E4, 0x000000 },
 1208|       |	{ 0x001CA5, 0x000000, 0x0010E5, 0x000000 },
 1209|       |	{ 0x001CA6, 0x000000, 0x0010E6, 0x000000 },
 1210|       |	{ 0x001CA7, 0x000000, 0x0010E7, 0x000000 },
 1211|       |	{ 0x001CA8, 0x000000, 0x0010E8, 0x000000 },
 1212|       |	{ 0x001CA9, 0x000000, 0x0010E9, 0x000000 },
 1213|       |	{ 0x001CAA, 0x000000, 0x0010EA, 0x000000 },
 1214|       |	{ 0x001CAB, 0x000000, 0x0010EB, 0x000000 },
 1215|       |	{ 0x001CAC, 0x000000, 0x0010EC, 0x000000 },
 1216|       |	{ 0x001CAD, 0x000000, 0x0010ED, 0x000000 },
 1217|       |	{ 0x001CAE, 0x000000, 0x0010EE, 0x000000 },
 1218|       |	{ 0x001CAF, 0x000000, 0x0010EF, 0x000000 },
 1219|       |	{ 0x001CB0, 0x000000, 0x0010F0, 0x000000 },
 1220|       |	{ 0x001CB1, 0x000000, 0x0010F1, 0x000000 },
 1221|       |	{ 0x001CB2, 0x000000, 0x0010F2, 0x000000 },
 1222|       |	{ 0x001CB3, 0x000000, 0x0010F3, 0x000000 },
 1223|       |	{ 0x001CB4, 0x000000, 0x0010F4, 0x000000 },
 1224|       |	{ 0x001CB5, 0x000000, 0x0010F5, 0x000000 },
 1225|       |	{ 0x001CB6, 0x000000, 0x0010F6, 0x000000 },
 1226|       |	{ 0x001CB7, 0x000000, 0x0010F7, 0x000000 },
 1227|       |	{ 0x001CB8, 0x000000, 0x0010F8, 0x000000 },
 1228|       |	{ 0x001CB9, 0x000000, 0x0010F9, 0x000000 },
 1229|       |	{ 0x001CBA, 0x000000, 0x0010FA, 0x000000 },
 1230|       |	{ 0x001CBD, 0x000000, 0x0010FD, 0x000000 },
 1231|       |	{ 0x001CBE, 0x000000, 0x0010FE, 0x000000 },
 1232|       |	{ 0x001CBF, 0x000000, 0x0010FF, 0x000000 },
 1233|       |	{ 0x001D79, 0x00A77D, 0x000000, 0x00A77D },
 1234|       |	{ 0x001D7D, 0x002C63, 0x000000, 0x002C63 },
 1235|       |	{ 0x001E00, 0x000000, 0x001E01, 0x000000 },
 1236|       |	{ 0x001E01, 0x001E00, 0x000000, 0x001E00 },
 1237|       |	{ 0x001E02, 0x000000, 0x001E03, 0x000000 },
 1238|       |	{ 0x001E03, 0x001E02, 0x000000, 0x001E02 },
 1239|       |	{ 0x001E04, 0x000000, 0x001E05, 0x000000 },
 1240|       |	{ 0x001E05, 0x001E04, 0x000000, 0x001E04 },
 1241|       |	{ 0x001E06, 0x000000, 0x001E07, 0x000000 },
 1242|       |	{ 0x001E07, 0x001E06, 0x000000, 0x001E06 },
 1243|       |	{ 0x001E08, 0x000000, 0x001E09, 0x000000 },
 1244|       |	{ 0x001E09, 0x001E08, 0x000000, 0x001E08 },
 1245|       |	{ 0x001E0A, 0x000000, 0x001E0B, 0x000000 },
 1246|       |	{ 0x001E0B, 0x001E0A, 0x000000, 0x001E0A },
 1247|       |	{ 0x001E0C, 0x000000, 0x001E0D, 0x000000 },
 1248|       |	{ 0x001E0D, 0x001E0C, 0x000000, 0x001E0C },
 1249|       |	{ 0x001E0E, 0x000000, 0x001E0F, 0x000000 },
 1250|       |	{ 0x001E0F, 0x001E0E, 0x000000, 0x001E0E },
 1251|       |	{ 0x001E10, 0x000000, 0x001E11, 0x000000 },
 1252|       |	{ 0x001E11, 0x001E10, 0x000000, 0x001E10 },
 1253|       |	{ 0x001E12, 0x000000, 0x001E13, 0x000000 },
 1254|       |	{ 0x001E13, 0x001E12, 0x000000, 0x001E12 },
 1255|       |	{ 0x001E14, 0x000000, 0x001E15, 0x000000 },
 1256|       |	{ 0x001E15, 0x001E14, 0x000000, 0x001E14 },
 1257|       |	{ 0x001E16, 0x000000, 0x001E17, 0x000000 },
 1258|       |	{ 0x001E17, 0x001E16, 0x000000, 0x001E16 },
 1259|       |	{ 0x001E18, 0x000000, 0x001E19, 0x000000 },
 1260|       |	{ 0x001E19, 0x001E18, 0x000000, 0x001E18 },
 1261|       |	{ 0x001E1A, 0x000000, 0x001E1B, 0x000000 },
 1262|       |	{ 0x001E1B, 0x001E1A, 0x000000, 0x001E1A },
 1263|       |	{ 0x001E1C, 0x000000, 0x001E1D, 0x000000 },
 1264|       |	{ 0x001E1D, 0x001E1C, 0x000000, 0x001E1C },
 1265|       |	{ 0x001E1E, 0x000000, 0x001E1F, 0x000000 },
 1266|       |	{ 0x001E1F, 0x001E1E, 0x000000, 0x001E1E },
 1267|       |	{ 0x001E20, 0x000000, 0x001E21, 0x000000 },
 1268|       |	{ 0x001E21, 0x001E20, 0x000000, 0x001E20 },
 1269|       |	{ 0x001E22, 0x000000, 0x001E23, 0x000000 },
 1270|       |	{ 0x001E23, 0x001E22, 0x000000, 0x001E22 },
 1271|       |	{ 0x001E24, 0x000000, 0x001E25, 0x000000 },
 1272|       |	{ 0x001E25, 0x001E24, 0x000000, 0x001E24 },
 1273|       |	{ 0x001E26, 0x000000, 0x001E27, 0x000000 },
 1274|       |	{ 0x001E27, 0x001E26, 0x000000, 0x001E26 },
 1275|       |	{ 0x001E28, 0x000000, 0x001E29, 0x000000 },
 1276|       |	{ 0x001E29, 0x001E28, 0x000000, 0x001E28 },
 1277|       |	{ 0x001E2A, 0x000000, 0x001E2B, 0x000000 },
 1278|       |	{ 0x001E2B, 0x001E2A, 0x000000, 0x001E2A },
 1279|       |	{ 0x001E2C, 0x000000, 0x001E2D, 0x000000 },
 1280|       |	{ 0x001E2D, 0x001E2C, 0x000000, 0x001E2C },
 1281|       |	{ 0x001E2E, 0x000000, 0x001E2F, 0x000000 },
 1282|       |	{ 0x001E2F, 0x001E2E, 0x000000, 0x001E2E },
 1283|       |	{ 0x001E30, 0x000000, 0x001E31, 0x000000 },
 1284|       |	{ 0x001E31, 0x001E30, 0x000000, 0x001E30 },
 1285|       |	{ 0x001E32, 0x000000, 0x001E33, 0x000000 },
 1286|       |	{ 0x001E33, 0x001E32, 0x000000, 0x001E32 },
 1287|       |	{ 0x001E34, 0x000000, 0x001E35, 0x000000 },
 1288|       |	{ 0x001E35, 0x001E34, 0x000000, 0x001E34 },
 1289|       |	{ 0x001E36, 0x000000, 0x001E37, 0x000000 },
 1290|       |	{ 0x001E37, 0x001E36, 0x000000, 0x001E36 },
 1291|       |	{ 0x001E38, 0x000000, 0x001E39, 0x000000 },
 1292|       |	{ 0x001E39, 0x001E38, 0x000000, 0x001E38 },
 1293|       |	{ 0x001E3A, 0x000000, 0x001E3B, 0x000000 },
 1294|       |	{ 0x001E3B, 0x001E3A, 0x000000, 0x001E3A },
 1295|       |	{ 0x001E3C, 0x000000, 0x001E3D, 0x000000 },
 1296|       |	{ 0x001E3D, 0x001E3C, 0x000000, 0x001E3C },
 1297|       |	{ 0x001E3E, 0x000000, 0x001E3F, 0x000000 },
 1298|       |	{ 0x001E3F, 0x001E3E, 0x000000, 0x001E3E },
 1299|       |	{ 0x001E40, 0x000000, 0x001E41, 0x000000 },
 1300|       |	{ 0x001E41, 0x001E40, 0x000000, 0x001E40 },
 1301|       |	{ 0x001E42, 0x000000, 0x001E43, 0x000000 },
 1302|       |	{ 0x001E43, 0x001E42, 0x000000, 0x001E42 },
 1303|       |	{ 0x001E44, 0x000000, 0x001E45, 0x000000 },
 1304|       |	{ 0x001E45, 0x001E44, 0x000000, 0x001E44 },
 1305|       |	{ 0x001E46, 0x000000, 0x001E47, 0x000000 },
 1306|       |	{ 0x001E47, 0x001E46, 0x000000, 0x001E46 },
 1307|       |	{ 0x001E48, 0x000000, 0x001E49, 0x000000 },
 1308|       |	{ 0x001E49, 0x001E48, 0x000000, 0x001E48 },
 1309|       |	{ 0x001E4A, 0x000000, 0x001E4B, 0x000000 },
 1310|       |	{ 0x001E4B, 0x001E4A, 0x000000, 0x001E4A },
 1311|       |	{ 0x001E4C, 0x000000, 0x001E4D, 0x000000 },
 1312|       |	{ 0x001E4D, 0x001E4C, 0x000000, 0x001E4C },
 1313|       |	{ 0x001E4E, 0x000000, 0x001E4F, 0x000000 },
 1314|       |	{ 0x001E4F, 0x001E4E, 0x000000, 0x001E4E },
 1315|       |	{ 0x001E50, 0x000000, 0x001E51, 0x000000 },
 1316|       |	{ 0x001E51, 0x001E50, 0x000000, 0x001E50 },
 1317|       |	{ 0x001E52, 0x000000, 0x001E53, 0x000000 },
 1318|       |	{ 0x001E53, 0x001E52, 0x000000, 0x001E52 },
 1319|       |	{ 0x001E54, 0x000000, 0x001E55, 0x000000 },
 1320|       |	{ 0x001E55, 0x001E54, 0x000000, 0x001E54 },
 1321|       |	{ 0x001E56, 0x000000, 0x001E57, 0x000000 },
 1322|       |	{ 0x001E57, 0x001E56, 0x000000, 0x001E56 },
 1323|       |	{ 0x001E58, 0x000000, 0x001E59, 0x000000 },
 1324|       |	{ 0x001E59, 0x001E58, 0x000000, 0x001E58 },
 1325|       |	{ 0x001E5A, 0x000000, 0x001E5B, 0x000000 },
 1326|       |	{ 0x001E5B, 0x001E5A, 0x000000, 0x001E5A },
 1327|       |	{ 0x001E5C, 0x000000, 0x001E5D, 0x000000 },
 1328|       |	{ 0x001E5D, 0x001E5C, 0x000000, 0x001E5C },
 1329|       |	{ 0x001E5E, 0x000000, 0x001E5F, 0x000000 },
 1330|       |	{ 0x001E5F, 0x001E5E, 0x000000, 0x001E5E },
 1331|       |	{ 0x001E60, 0x000000, 0x001E61, 0x000000 },
 1332|       |	{ 0x001E61, 0x001E60, 0x000000, 0x001E60 },
 1333|       |	{ 0x001E62, 0x000000, 0x001E63, 0x000000 },
 1334|       |	{ 0x001E63, 0x001E62, 0x000000, 0x001E62 },
 1335|       |	{ 0x001E64, 0x000000, 0x001E65, 0x000000 },
 1336|       |	{ 0x001E65, 0x001E64, 0x000000, 0x001E64 },
 1337|       |	{ 0x001E66, 0x000000, 0x001E67, 0x000000 },
 1338|       |	{ 0x001E67, 0x001E66, 0x000000, 0x001E66 },
 1339|       |	{ 0x001E68, 0x000000, 0x001E69, 0x000000 },
 1340|       |	{ 0x001E69, 0x001E68, 0x000000, 0x001E68 },
 1341|       |	{ 0x001E6A, 0x000000, 0x001E6B, 0x000000 },
 1342|       |	{ 0x001E6B, 0x001E6A, 0x000000, 0x001E6A },
 1343|       |	{ 0x001E6C, 0x000000, 0x001E6D, 0x000000 },
 1344|       |	{ 0x001E6D, 0x001E6C, 0x000000, 0x001E6C },
 1345|       |	{ 0x001E6E, 0x000000, 0x001E6F, 0x000000 },
 1346|       |	{ 0x001E6F, 0x001E6E, 0x000000, 0x001E6E },
 1347|       |	{ 0x001E70, 0x000000, 0x001E71, 0x000000 },
 1348|       |	{ 0x001E71, 0x001E70, 0x000000, 0x001E70 },
 1349|       |	{ 0x001E72, 0x000000, 0x001E73, 0x000000 },
 1350|       |	{ 0x001E73, 0x001E72, 0x000000, 0x001E72 },
 1351|       |	{ 0x001E74, 0x000000, 0x001E75, 0x000000 },
 1352|       |	{ 0x001E75, 0x001E74, 0x000000, 0x001E74 },
 1353|       |	{ 0x001E76, 0x000000, 0x001E77, 0x000000 },
 1354|       |	{ 0x001E77, 0x001E76, 0x000000, 0x001E76 },
 1355|       |	{ 0x001E78, 0x000000, 0x001E79, 0x000000 },
 1356|       |	{ 0x001E79, 0x001E78, 0x000000, 0x001E78 },
 1357|       |	{ 0x001E7A, 0x000000, 0x001E7B, 0x000000 },
 1358|       |	{ 0x001E7B, 0x001E7A, 0x000000, 0x001E7A },
 1359|       |	{ 0x001E7C, 0x000000, 0x001E7D, 0x000000 },
 1360|       |	{ 0x001E7D, 0x001E7C, 0x000000, 0x001E7C },
 1361|       |	{ 0x001E7E, 0x000000, 0x001E7F, 0x000000 },
 1362|       |	{ 0x001E7F, 0x001E7E, 0x000000, 0x001E7E },
 1363|       |	{ 0x001E80, 0x000000, 0x001E81, 0x000000 },
 1364|       |	{ 0x001E81, 0x001E80, 0x000000, 0x001E80 },
 1365|       |	{ 0x001E82, 0x000000, 0x001E83, 0x000000 },
 1366|       |	{ 0x001E83, 0x001E82, 0x000000, 0x001E82 },
 1367|       |	{ 0x001E84, 0x000000, 0x001E85, 0x000000 },
 1368|       |	{ 0x001E85, 0x001E84, 0x000000, 0x001E84 },
 1369|       |	{ 0x001E86, 0x000000, 0x001E87, 0x000000 },
 1370|       |	{ 0x001E87, 0x001E86, 0x000000, 0x001E86 },
 1371|       |	{ 0x001E88, 0x000000, 0x001E89, 0x000000 },
 1372|       |	{ 0x001E89, 0x001E88, 0x000000, 0x001E88 },
 1373|       |	{ 0x001E8A, 0x000000, 0x001E8B, 0x000000 },
 1374|       |	{ 0x001E8B, 0x001E8A, 0x000000, 0x001E8A },
 1375|       |	{ 0x001E8C, 0x000000, 0x001E8D, 0x000000 },
 1376|       |	{ 0x001E8D, 0x001E8C, 0x000000, 0x001E8C },
 1377|       |	{ 0x001E8E, 0x000000, 0x001E8F, 0x000000 },
 1378|       |	{ 0x001E8F, 0x001E8E, 0x000000, 0x001E8E },
 1379|       |	{ 0x001E90, 0x000000, 0x001E91, 0x000000 },
 1380|       |	{ 0x001E91, 0x001E90, 0x000000, 0x001E90 },
 1381|       |	{ 0x001E92, 0x000000, 0x001E93, 0x000000 },
 1382|       |	{ 0x001E93, 0x001E92, 0x000000, 0x001E92 },
 1383|       |	{ 0x001E94, 0x000000, 0x001E95, 0x000000 },
 1384|       |	{ 0x001E95, 0x001E94, 0x000000, 0x001E94 },
 1385|       |	{ 0x001E9B, 0x001E60, 0x000000, 0x001E60 },
 1386|       |	{ 0x001E9E, 0x000000, 0x0000DF, 0x000000 },
 1387|       |	{ 0x001EA0, 0x000000, 0x001EA1, 0x000000 },
 1388|       |	{ 0x001EA1, 0x001EA0, 0x000000, 0x001EA0 },
 1389|       |	{ 0x001EA2, 0x000000, 0x001EA3, 0x000000 },
 1390|       |	{ 0x001EA3, 0x001EA2, 0x000000, 0x001EA2 },
 1391|       |	{ 0x001EA4, 0x000000, 0x001EA5, 0x000000 },
 1392|       |	{ 0x001EA5, 0x001EA4, 0x000000, 0x001EA4 },
 1393|       |	{ 0x001EA6, 0x000000, 0x001EA7, 0x000000 },
 1394|       |	{ 0x001EA7, 0x001EA6, 0x000000, 0x001EA6 },
 1395|       |	{ 0x001EA8, 0x000000, 0x001EA9, 0x000000 },
 1396|       |	{ 0x001EA9, 0x001EA8, 0x000000, 0x001EA8 },
 1397|       |	{ 0x001EAA, 0x000000, 0x001EAB, 0x000000 },
 1398|       |	{ 0x001EAB, 0x001EAA, 0x000000, 0x001EAA },
 1399|       |	{ 0x001EAC, 0x000000, 0x001EAD, 0x000000 },
 1400|       |	{ 0x001EAD, 0x001EAC, 0x000000, 0x001EAC },
 1401|       |	{ 0x001EAE, 0x000000, 0x001EAF, 0x000000 },
 1402|       |	{ 0x001EAF, 0x001EAE, 0x000000, 0x001EAE },
 1403|       |	{ 0x001EB0, 0x000000, 0x001EB1, 0x000000 },
 1404|       |	{ 0x001EB1, 0x001EB0, 0x000000, 0x001EB0 },
 1405|       |	{ 0x001EB2, 0x000000, 0x001EB3, 0x000000 },
 1406|       |	{ 0x001EB3, 0x001EB2, 0x000000, 0x001EB2 },
 1407|       |	{ 0x001EB4, 0x000000, 0x001EB5, 0x000000 },
 1408|       |	{ 0x001EB5, 0x001EB4, 0x000000, 0x001EB4 },
 1409|       |	{ 0x001EB6, 0x000000, 0x001EB7, 0x000000 },
 1410|       |	{ 0x001EB7, 0x001EB6, 0x000000, 0x001EB6 },
 1411|       |	{ 0x001EB8, 0x000000, 0x001EB9, 0x000000 },
 1412|       |	{ 0x001EB9, 0x001EB8, 0x000000, 0x001EB8 },
 1413|       |	{ 0x001EBA, 0x000000, 0x001EBB, 0x000000 },
 1414|       |	{ 0x001EBB, 0x001EBA, 0x000000, 0x001EBA },
 1415|       |	{ 0x001EBC, 0x000000, 0x001EBD, 0x000000 },
 1416|       |	{ 0x001EBD, 0x001EBC, 0x000000, 0x001EBC },
 1417|       |	{ 0x001EBE, 0x000000, 0x001EBF, 0x000000 },
 1418|       |	{ 0x001EBF, 0x001EBE, 0x000000, 0x001EBE },
 1419|       |	{ 0x001EC0, 0x000000, 0x001EC1, 0x000000 },
 1420|       |	{ 0x001EC1, 0x001EC0, 0x000000, 0x001EC0 },
 1421|       |	{ 0x001EC2, 0x000000, 0x001EC3, 0x000000 },
 1422|       |	{ 0x001EC3, 0x001EC2, 0x000000, 0x001EC2 },
 1423|       |	{ 0x001EC4, 0x000000, 0x001EC5, 0x000000 },
 1424|       |	{ 0x001EC5, 0x001EC4, 0x000000, 0x001EC4 },
 1425|       |	{ 0x001EC6, 0x000000, 0x001EC7, 0x000000 },
 1426|       |	{ 0x001EC7, 0x001EC6, 0x000000, 0x001EC6 },
 1427|       |	{ 0x001EC8, 0x000000, 0x001EC9, 0x000000 },
 1428|       |	{ 0x001EC9, 0x001EC8, 0x000000, 0x001EC8 },
 1429|       |	{ 0x001ECA, 0x000000, 0x001ECB, 0x000000 },
 1430|       |	{ 0x001ECB, 0x001ECA, 0x000000, 0x001ECA },
 1431|       |	{ 0x001ECC, 0x000000, 0x001ECD, 0x000000 },
 1432|       |	{ 0x001ECD, 0x001ECC, 0x000000, 0x001ECC },
 1433|       |	{ 0x001ECE, 0x000000, 0x001ECF, 0x000000 },
 1434|       |	{ 0x001ECF, 0x001ECE, 0x000000, 0x001ECE },
 1435|       |	{ 0x001ED0, 0x000000, 0x001ED1, 0x000000 },
 1436|       |	{ 0x001ED1, 0x001ED0, 0x000000, 0x001ED0 },
 1437|       |	{ 0x001ED2, 0x000000, 0x001ED3, 0x000000 },
 1438|       |	{ 0x001ED3, 0x001ED2, 0x000000, 0x001ED2 },
 1439|       |	{ 0x001ED4, 0x000000, 0x001ED5, 0x000000 },
 1440|       |	{ 0x001ED5, 0x001ED4, 0x000000, 0x001ED4 },
 1441|       |	{ 0x001ED6, 0x000000, 0x001ED7, 0x000000 },
 1442|       |	{ 0x001ED7, 0x001ED6, 0x000000, 0x001ED6 },
 1443|       |	{ 0x001ED8, 0x000000, 0x001ED9, 0x000000 },
 1444|       |	{ 0x001ED9, 0x001ED8, 0x000000, 0x001ED8 },
 1445|       |	{ 0x001EDA, 0x000000, 0x001EDB, 0x000000 },
 1446|       |	{ 0x001EDB, 0x001EDA, 0x000000, 0x001EDA },
 1447|       |	{ 0x001EDC, 0x000000, 0x001EDD, 0x000000 },
 1448|       |	{ 0x001EDD, 0x001EDC, 0x000000, 0x001EDC },
 1449|       |	{ 0x001EDE, 0x000000, 0x001EDF, 0x000000 },
 1450|       |	{ 0x001EDF, 0x001EDE, 0x000000, 0x001EDE },
 1451|       |	{ 0x001EE0, 0x000000, 0x001EE1, 0x000000 },
 1452|       |	{ 0x001EE1, 0x001EE0, 0x000000, 0x001EE0 },
 1453|       |	{ 0x001EE2, 0x000000, 0x001EE3, 0x000000 },
 1454|       |	{ 0x001EE3, 0x001EE2, 0x000000, 0x001EE2 },
 1455|       |	{ 0x001EE4, 0x000000, 0x001EE5, 0x000000 },
 1456|       |	{ 0x001EE5, 0x001EE4, 0x000000, 0x001EE4 },
 1457|       |	{ 0x001EE6, 0x000000, 0x001EE7, 0x000000 },
 1458|       |	{ 0x001EE7, 0x001EE6, 0x000000, 0x001EE6 },
 1459|       |	{ 0x001EE8, 0x000000, 0x001EE9, 0x000000 },
 1460|       |	{ 0x001EE9, 0x001EE8, 0x000000, 0x001EE8 },
 1461|       |	{ 0x001EEA, 0x000000, 0x001EEB, 0x000000 },
 1462|       |	{ 0x001EEB, 0x001EEA, 0x000000, 0x001EEA },
 1463|       |	{ 0x001EEC, 0x000000, 0x001EED, 0x000000 },
 1464|       |	{ 0x001EED, 0x001EEC, 0x000000, 0x001EEC },
 1465|       |	{ 0x001EEE, 0x000000, 0x001EEF, 0x000000 },
 1466|       |	{ 0x001EEF, 0x001EEE, 0x000000, 0x001EEE },
 1467|       |	{ 0x001EF0, 0x000000, 0x001EF1, 0x000000 },
 1468|       |	{ 0x001EF1, 0x001EF0, 0x000000, 0x001EF0 },
 1469|       |	{ 0x001EF2, 0x000000, 0x001EF3, 0x000000 },
 1470|       |	{ 0x001EF3, 0x001EF2, 0x000000, 0x001EF2 },
 1471|       |	{ 0x001EF4, 0x000000, 0x001EF5, 0x000000 },
 1472|       |	{ 0x001EF5, 0x001EF4, 0x000000, 0x001EF4 },
 1473|       |	{ 0x001EF6, 0x000000, 0x001EF7, 0x000000 },
 1474|       |	{ 0x001EF7, 0x001EF6, 0x000000, 0x001EF6 },
 1475|       |	{ 0x001EF8, 0x000000, 0x001EF9, 0x000000 },
 1476|       |	{ 0x001EF9, 0x001EF8, 0x000000, 0x001EF8 },
 1477|       |	{ 0x001EFA, 0x000000, 0x001EFB, 0x000000 },
 1478|       |	{ 0x001EFB, 0x001EFA, 0x000000, 0x001EFA },
 1479|       |	{ 0x001EFC, 0x000000, 0x001EFD, 0x000000 },
 1480|       |	{ 0x001EFD, 0x001EFC, 0x000000, 0x001EFC },
 1481|       |	{ 0x001EFE, 0x000000, 0x001EFF, 0x000000 },
 1482|       |	{ 0x001EFF, 0x001EFE, 0x000000, 0x001EFE },
 1483|       |	{ 0x001F00, 0x001F08, 0x000000, 0x001F08 },
 1484|       |	{ 0x001F01, 0x001F09, 0x000000, 0x001F09 },
 1485|       |	{ 0x001F02, 0x001F0A, 0x000000, 0x001F0A },
 1486|       |	{ 0x001F03, 0x001F0B, 0x000000, 0x001F0B },
 1487|       |	{ 0x001F04, 0x001F0C, 0x000000, 0x001F0C },
 1488|       |	{ 0x001F05, 0x001F0D, 0x000000, 0x001F0D },
 1489|       |	{ 0x001F06, 0x001F0E, 0x000000, 0x001F0E },
 1490|       |	{ 0x001F07, 0x001F0F, 0x000000, 0x001F0F },
 1491|       |	{ 0x001F08, 0x000000, 0x001F00, 0x000000 },
 1492|       |	{ 0x001F09, 0x000000, 0x001F01, 0x000000 },
 1493|       |	{ 0x001F0A, 0x000000, 0x001F02, 0x000000 },
 1494|       |	{ 0x001F0B, 0x000000, 0x001F03, 0x000000 },
 1495|       |	{ 0x001F0C, 0x000000, 0x001F04, 0x000000 },
 1496|       |	{ 0x001F0D, 0x000000, 0x001F05, 0x000000 },
 1497|       |	{ 0x001F0E, 0x000000, 0x001F06, 0x000000 },
 1498|       |	{ 0x001F0F, 0x000000, 0x001F07, 0x000000 },
 1499|       |	{ 0x001F10, 0x001F18, 0x000000, 0x001F18 },
 1500|       |	{ 0x001F11, 0x001F19, 0x000000, 0x001F19 },
 1501|       |	{ 0x001F12, 0x001F1A, 0x000000, 0x001F1A },
 1502|       |	{ 0x001F13, 0x001F1B, 0x000000, 0x001F1B },
 1503|       |	{ 0x001F14, 0x001F1C, 0x000000, 0x001F1C },
 1504|       |	{ 0x001F15, 0x001F1D, 0x000000, 0x001F1D },
 1505|       |	{ 0x001F18, 0x000000, 0x001F10, 0x000000 },
 1506|       |	{ 0x001F19, 0x000000, 0x001F11, 0x000000 },
 1507|       |	{ 0x001F1A, 0x000000, 0x001F12, 0x000000 },
 1508|       |	{ 0x001F1B, 0x000000, 0x001F13, 0x000000 },
 1509|       |	{ 0x001F1C, 0x000000, 0x001F14, 0x000000 },
 1510|       |	{ 0x001F1D, 0x000000, 0x001F15, 0x000000 },
 1511|       |	{ 0x001F20, 0x001F28, 0x000000, 0x001F28 },
 1512|       |	{ 0x001F21, 0x001F29, 0x000000, 0x001F29 },
 1513|       |	{ 0x001F22, 0x001F2A, 0x000000, 0x001F2A },
 1514|       |	{ 0x001F23, 0x001F2B, 0x000000, 0x001F2B },
 1515|       |	{ 0x001F24, 0x001F2C, 0x000000, 0x001F2C },
 1516|       |	{ 0x001F25, 0x001F2D, 0x000000, 0x001F2D },
 1517|       |	{ 0x001F26, 0x001F2E, 0x000000, 0x001F2E },
 1518|       |	{ 0x001F27, 0x001F2F, 0x000000, 0x001F2F },
 1519|       |	{ 0x001F28, 0x000000, 0x001F20, 0x000000 },
 1520|       |	{ 0x001F29, 0x000000, 0x001F21, 0x000000 },
 1521|       |	{ 0x001F2A, 0x000000, 0x001F22, 0x000000 },
 1522|       |	{ 0x001F2B, 0x000000, 0x001F23, 0x000000 },
 1523|       |	{ 0x001F2C, 0x000000, 0x001F24, 0x000000 },
 1524|       |	{ 0x001F2D, 0x000000, 0x001F25, 0x000000 },
 1525|       |	{ 0x001F2E, 0x000000, 0x001F26, 0x000000 },
 1526|       |	{ 0x001F2F, 0x000000, 0x001F27, 0x000000 },
 1527|       |	{ 0x001F30, 0x001F38, 0x000000, 0x001F38 },
 1528|       |	{ 0x001F31, 0x001F39, 0x000000, 0x001F39 },
 1529|       |	{ 0x001F32, 0x001F3A, 0x000000, 0x001F3A },
 1530|       |	{ 0x001F33, 0x001F3B, 0x000000, 0x001F3B },
 1531|       |	{ 0x001F34, 0x001F3C, 0x000000, 0x001F3C },
 1532|       |	{ 0x001F35, 0x001F3D, 0x000000, 0x001F3D },
 1533|       |	{ 0x001F36, 0x001F3E, 0x000000, 0x001F3E },
 1534|       |	{ 0x001F37, 0x001F3F, 0x000000, 0x001F3F },
 1535|       |	{ 0x001F38, 0x000000, 0x001F30, 0x000000 },
 1536|       |	{ 0x001F39, 0x000000, 0x001F31, 0x000000 },
 1537|       |	{ 0x001F3A, 0x000000, 0x001F32, 0x000000 },
 1538|       |	{ 0x001F3B, 0x000000, 0x001F33, 0x000000 },
 1539|       |	{ 0x001F3C, 0x000000, 0x001F34, 0x000000 },
 1540|       |	{ 0x001F3D, 0x000000, 0x001F35, 0x000000 },
 1541|       |	{ 0x001F3E, 0x000000, 0x001F36, 0x000000 },
 1542|       |	{ 0x001F3F, 0x000000, 0x001F37, 0x000000 },
 1543|       |	{ 0x001F40, 0x001F48, 0x000000, 0x001F48 },
 1544|       |	{ 0x001F41, 0x001F49, 0x000000, 0x001F49 },
 1545|       |	{ 0x001F42, 0x001F4A, 0x000000, 0x001F4A },
 1546|       |	{ 0x001F43, 0x001F4B, 0x000000, 0x001F4B },
 1547|       |	{ 0x001F44, 0x001F4C, 0x000000, 0x001F4C },
 1548|       |	{ 0x001F45, 0x001F4D, 0x000000, 0x001F4D },
 1549|       |	{ 0x001F48, 0x000000, 0x001F40, 0x000000 },
 1550|       |	{ 0x001F49, 0x000000, 0x001F41, 0x000000 },
 1551|       |	{ 0x001F4A, 0x000000, 0x001F42, 0x000000 },
 1552|       |	{ 0x001F4B, 0x000000, 0x001F43, 0x000000 },
 1553|       |	{ 0x001F4C, 0x000000, 0x001F44, 0x000000 },
 1554|       |	{ 0x001F4D, 0x000000, 0x001F45, 0x000000 },
 1555|       |	{ 0x001F51, 0x001F59, 0x000000, 0x001F59 },
 1556|       |	{ 0x001F53, 0x001F5B, 0x000000, 0x001F5B },
 1557|       |	{ 0x001F55, 0x001F5D, 0x000000, 0x001F5D },
 1558|       |	{ 0x001F57, 0x001F5F, 0x000000, 0x001F5F },
 1559|       |	{ 0x001F59, 0x000000, 0x001F51, 0x000000 },
 1560|       |	{ 0x001F5B, 0x000000, 0x001F53, 0x000000 },
 1561|       |	{ 0x001F5D, 0x000000, 0x001F55, 0x000000 },
 1562|       |	{ 0x001F5F, 0x000000, 0x001F57, 0x000000 },
 1563|       |	{ 0x001F60, 0x001F68, 0x000000, 0x001F68 },
 1564|       |	{ 0x001F61, 0x001F69, 0x000000, 0x001F69 },
 1565|       |	{ 0x001F62, 0x001F6A, 0x000000, 0x001F6A },
 1566|       |	{ 0x001F63, 0x001F6B, 0x000000, 0x001F6B },
 1567|       |	{ 0x001F64, 0x001F6C, 0x000000, 0x001F6C },
 1568|       |	{ 0x001F65, 0x001F6D, 0x000000, 0x001F6D },
 1569|       |	{ 0x001F66, 0x001F6E, 0x000000, 0x001F6E },
 1570|       |	{ 0x001F67, 0x001F6F, 0x000000, 0x001F6F },
 1571|       |	{ 0x001F68, 0x000000, 0x001F60, 0x000000 },
 1572|       |	{ 0x001F69, 0x000000, 0x001F61, 0x000000 },
 1573|       |	{ 0x001F6A, 0x000000, 0x001F62, 0x000000 },
 1574|       |	{ 0x001F6B, 0x000000, 0x001F63, 0x000000 },
 1575|       |	{ 0x001F6C, 0x000000, 0x001F64, 0x000000 },
 1576|       |	{ 0x001F6D, 0x000000, 0x001F65, 0x000000 },
 1577|       |	{ 0x001F6E, 0x000000, 0x001F66, 0x000000 },
 1578|       |	{ 0x001F6F, 0x000000, 0x001F67, 0x000000 },
 1579|       |	{ 0x001F70, 0x001FBA, 0x000000, 0x001FBA },
 1580|       |	{ 0x001F71, 0x001FBB, 0x000000, 0x001FBB },
 1581|       |	{ 0x001F72, 0x001FC8, 0x000000, 0x001FC8 },
 1582|       |	{ 0x001F73, 0x001FC9, 0x000000, 0x001FC9 },
 1583|       |	{ 0x001F74, 0x001FCA, 0x000000, 0x001FCA },
 1584|       |	{ 0x001F75, 0x001FCB, 0x000000, 0x001FCB },
 1585|       |	{ 0x001F76, 0x001FDA, 0x000000, 0x001FDA },
 1586|       |	{ 0x001F77, 0x001FDB, 0x000000, 0x001FDB },
 1587|       |	{ 0x001F78, 0x001FF8, 0x000000, 0x001FF8 },
 1588|       |	{ 0x001F79, 0x001FF9, 0x000000, 0x001FF9 },
 1589|       |	{ 0x001F7A, 0x001FEA, 0x000000, 0x001FEA },
 1590|       |	{ 0x001F7B, 0x001FEB, 0x000000, 0x001FEB },
 1591|       |	{ 0x001F7C, 0x001FFA, 0x000000, 0x001FFA },
 1592|       |	{ 0x001F7D, 0x001FFB, 0x000000, 0x001FFB },
 1593|       |	{ 0x001F80, 0x001F88, 0x000000, 0x001F88 },
 1594|       |	{ 0x001F81, 0x001F89, 0x000000, 0x001F89 },
 1595|       |	{ 0x001F82, 0x001F8A, 0x000000, 0x001F8A },
 1596|       |	{ 0x001F83, 0x001F8B, 0x000000, 0x001F8B },
 1597|       |	{ 0x001F84, 0x001F8C, 0x000000, 0x001F8C },
 1598|       |	{ 0x001F85, 0x001F8D, 0x000000, 0x001F8D },
 1599|       |	{ 0x001F86, 0x001F8E, 0x000000, 0x001F8E },
 1600|       |	{ 0x001F87, 0x001F8F, 0x000000, 0x001F8F },
 1601|       |	{ 0x001F88, 0x000000, 0x001F80, 0x000000 },
 1602|       |	{ 0x001F89, 0x000000, 0x001F81, 0x000000 },
 1603|       |	{ 0x001F8A, 0x000000, 0x001F82, 0x000000 },
 1604|       |	{ 0x001F8B, 0x000000, 0x001F83, 0x000000 },
 1605|       |	{ 0x001F8C, 0x000000, 0x001F84, 0x000000 },
 1606|       |	{ 0x001F8D, 0x000000, 0x001F85, 0x000000 },
 1607|       |	{ 0x001F8E, 0x000000, 0x001F86, 0x000000 },
 1608|       |	{ 0x001F8F, 0x000000, 0x001F87, 0x000000 },
 1609|       |	{ 0x001F90, 0x001F98, 0x000000, 0x001F98 },
 1610|       |	{ 0x001F91, 0x001F99, 0x000000, 0x001F99 },
 1611|       |	{ 0x001F92, 0x001F9A, 0x000000, 0x001F9A },
 1612|       |	{ 0x001F93, 0x001F9B, 0x000000, 0x001F9B },
 1613|       |	{ 0x001F94, 0x001F9C, 0x000000, 0x001F9C },
 1614|       |	{ 0x001F95, 0x001F9D, 0x000000, 0x001F9D },
 1615|       |	{ 0x001F96, 0x001F9E, 0x000000, 0x001F9E },
 1616|       |	{ 0x001F97, 0x001F9F, 0x000000, 0x001F9F },
 1617|       |	{ 0x001F98, 0x000000, 0x001F90, 0x000000 },
 1618|       |	{ 0x001F99, 0x000000, 0x001F91, 0x000000 },
 1619|       |	{ 0x001F9A, 0x000000, 0x001F92, 0x000000 },
 1620|       |	{ 0x001F9B, 0x000000, 0x001F93, 0x000000 },
 1621|       |	{ 0x001F9C, 0x000000, 0x001F94, 0x000000 },
 1622|       |	{ 0x001F9D, 0x000000, 0x001F95, 0x000000 },
 1623|       |	{ 0x001F9E, 0x000000, 0x001F96, 0x000000 },
 1624|       |	{ 0x001F9F, 0x000000, 0x001F97, 0x000000 },
 1625|       |	{ 0x001FA0, 0x001FA8, 0x000000, 0x001FA8 },
 1626|       |	{ 0x001FA1, 0x001FA9, 0x000000, 0x001FA9 },
 1627|       |	{ 0x001FA2, 0x001FAA, 0x000000, 0x001FAA },
 1628|       |	{ 0x001FA3, 0x001FAB, 0x000000, 0x001FAB },
 1629|       |	{ 0x001FA4, 0x001FAC, 0x000000, 0x001FAC },
 1630|       |	{ 0x001FA5, 0x001FAD, 0x000000, 0x001FAD },
 1631|       |	{ 0x001FA6, 0x001FAE, 0x000000, 0x001FAE },
 1632|       |	{ 0x001FA7, 0x001FAF, 0x000000, 0x001FAF },
 1633|       |	{ 0x001FA8, 0x000000, 0x001FA0, 0x000000 },
 1634|       |	{ 0x001FA9, 0x000000, 0x001FA1, 0x000000 },
 1635|       |	{ 0x001FAA, 0x000000, 0x001FA2, 0x000000 },
 1636|       |	{ 0x001FAB, 0x000000, 0x001FA3, 0x000000 },
 1637|       |	{ 0x001FAC, 0x000000, 0x001FA4, 0x000000 },
 1638|       |	{ 0x001FAD, 0x000000, 0x001FA5, 0x000000 },
 1639|       |	{ 0x001FAE, 0x000000, 0x001FA6, 0x000000 },
 1640|       |	{ 0x001FAF, 0x000000, 0x001FA7, 0x000000 },
 1641|       |	{ 0x001FB0, 0x001FB8, 0x000000, 0x001FB8 },
 1642|       |	{ 0x001FB1, 0x001FB9, 0x000000, 0x001FB9 },
 1643|       |	{ 0x001FB3, 0x001FBC, 0x000000, 0x001FBC },
 1644|       |	{ 0x001FB8, 0x000000, 0x001FB0, 0x000000 },
 1645|       |	{ 0x001FB9, 0x000000, 0x001FB1, 0x000000 },
 1646|       |	{ 0x001FBA, 0x000000, 0x001F70, 0x000000 },
 1647|       |	{ 0x001FBB, 0x000000, 0x001F71, 0x000000 },
 1648|       |	{ 0x001FBC, 0x000000, 0x001FB3, 0x000000 },
 1649|       |	{ 0x001FBE, 0x000399, 0x000000, 0x000399 },
 1650|       |	{ 0x001FC3, 0x001FCC, 0x000000, 0x001FCC },
 1651|       |	{ 0x001FC8, 0x000000, 0x001F72, 0x000000 },
 1652|       |	{ 0x001FC9, 0x000000, 0x001F73, 0x000000 },
 1653|       |	{ 0x001FCA, 0x000000, 0x001F74, 0x000000 },
 1654|       |	{ 0x001FCB, 0x000000, 0x001F75, 0x000000 },
 1655|       |	{ 0x001FCC, 0x000000, 0x001FC3, 0x000000 },
 1656|       |	{ 0x001FD0, 0x001FD8, 0x000000, 0x001FD8 },
 1657|       |	{ 0x001FD1, 0x001FD9, 0x000000, 0x001FD9 },
 1658|       |	{ 0x001FD8, 0x000000, 0x001FD0, 0x000000 },
 1659|       |	{ 0x001FD9, 0x000000, 0x001FD1, 0x000000 },
 1660|       |	{ 0x001FDA, 0x000000, 0x001F76, 0x000000 },
 1661|       |	{ 0x001FDB, 0x000000, 0x001F77, 0x000000 },
 1662|       |	{ 0x001FE0, 0x001FE8, 0x000000, 0x001FE8 },
 1663|       |	{ 0x001FE1, 0x001FE9, 0x000000, 0x001FE9 },
 1664|       |	{ 0x001FE5, 0x001FEC, 0x000000, 0x001FEC },
 1665|       |	{ 0x001FE8, 0x000000, 0x001FE0, 0x000000 },
 1666|       |	{ 0x001FE9, 0x000000, 0x001FE1, 0x000000 },
 1667|       |	{ 0x001FEA, 0x000000, 0x001F7A, 0x000000 },
 1668|       |	{ 0x001FEB, 0x000000, 0x001F7B, 0x000000 },
 1669|       |	{ 0x001FEC, 0x000000, 0x001FE5, 0x000000 },
 1670|       |	{ 0x001FF3, 0x001FFC, 0x000000, 0x001FFC },
 1671|       |	{ 0x001FF8, 0x000000, 0x001F78, 0x000000 },
 1672|       |	{ 0x001FF9, 0x000000, 0x001F79, 0x000000 },
 1673|       |	{ 0x001FFA, 0x000000, 0x001F7C, 0x000000 },
 1674|       |	{ 0x001FFB, 0x000000, 0x001F7D, 0x000000 },
 1675|       |	{ 0x001FFC, 0x000000, 0x001FF3, 0x000000 },
 1676|       |	{ 0x002126, 0x000000, 0x0003C9, 0x000000 },
 1677|       |	{ 0x00212A, 0x000000, 0x00006B, 0x000000 },
 1678|       |	{ 0x00212B, 0x000000, 0x0000E5, 0x000000 },
 1679|       |	{ 0x002132, 0x000000, 0x00214E, 0x000000 },
 1680|       |	{ 0x00214E, 0x002132, 0x000000, 0x002132 },
 1681|       |	{ 0x002160, 0x000000, 0x002170, 0x000000 },
 1682|       |	{ 0x002161, 0x000000, 0x002171, 0x000000 },
 1683|       |	{ 0x002162, 0x000000, 0x002172, 0x000000 },
 1684|       |	{ 0x002163, 0x000000, 0x002173, 0x000000 },
 1685|       |	{ 0x002164, 0x000000, 0x002174, 0x000000 },
 1686|       |	{ 0x002165, 0x000000, 0x002175, 0x000000 },
 1687|       |	{ 0x002166, 0x000000, 0x002176, 0x000000 },
 1688|       |	{ 0x002167, 0x000000, 0x002177, 0x000000 },
 1689|       |	{ 0x002168, 0x000000, 0x002178, 0x000000 },
 1690|       |	{ 0x002169, 0x000000, 0x002179, 0x000000 },
 1691|       |	{ 0x00216A, 0x000000, 0x00217A, 0x000000 },
 1692|       |	{ 0x00216B, 0x000000, 0x00217B, 0x000000 },
 1693|       |	{ 0x00216C, 0x000000, 0x00217C, 0x000000 },
 1694|       |	{ 0x00216D, 0x000000, 0x00217D, 0x000000 },
 1695|       |	{ 0x00216E, 0x000000, 0x00217E, 0x000000 },
 1696|       |	{ 0x00216F, 0x000000, 0x00217F, 0x000000 },
 1697|       |	{ 0x002170, 0x002160, 0x000000, 0x002160 },
 1698|       |	{ 0x002171, 0x002161, 0x000000, 0x002161 },
 1699|       |	{ 0x002172, 0x002162, 0x000000, 0x002162 },
 1700|       |	{ 0x002173, 0x002163, 0x000000, 0x002163 },
 1701|       |	{ 0x002174, 0x002164, 0x000000, 0x002164 },
 1702|       |	{ 0x002175, 0x002165, 0x000000, 0x002165 },
 1703|       |	{ 0x002176, 0x002166, 0x000000, 0x002166 },
 1704|       |	{ 0x002177, 0x002167, 0x000000, 0x002167 },
 1705|       |	{ 0x002178, 0x002168, 0x000000, 0x002168 },
 1706|       |	{ 0x002179, 0x002169, 0x000000, 0x002169 },
 1707|       |	{ 0x00217A, 0x00216A, 0x000000, 0x00216A },
 1708|       |	{ 0x00217B, 0x00216B, 0x000000, 0x00216B },
 1709|       |	{ 0x00217C, 0x00216C, 0x000000, 0x00216C },
 1710|       |	{ 0x00217D, 0x00216D, 0x000000, 0x00216D },
 1711|       |	{ 0x00217E, 0x00216E, 0x000000, 0x00216E },
 1712|       |	{ 0x00217F, 0x00216F, 0x000000, 0x00216F },
 1713|       |	{ 0x002183, 0x000000, 0x002184, 0x000000 },
 1714|       |	{ 0x002184, 0x002183, 0x000000, 0x002183 },
 1715|       |	{ 0x0024B6, 0x000000, 0x0024D0, 0x000000 },
 1716|       |	{ 0x0024B7, 0x000000, 0x0024D1, 0x000000 },
 1717|       |	{ 0x0024B8, 0x000000, 0x0024D2, 0x000000 },
 1718|       |	{ 0x0024B9, 0x000000, 0x0024D3, 0x000000 },
 1719|       |	{ 0x0024BA, 0x000000, 0x0024D4, 0x000000 },
 1720|       |	{ 0x0024BB, 0x000000, 0x0024D5, 0x000000 },
 1721|       |	{ 0x0024BC, 0x000000, 0x0024D6, 0x000000 },
 1722|       |	{ 0x0024BD, 0x000000, 0x0024D7, 0x000000 },
 1723|       |	{ 0x0024BE, 0x000000, 0x0024D8, 0x000000 },
 1724|       |	{ 0x0024BF, 0x000000, 0x0024D9, 0x000000 },
 1725|       |	{ 0x0024C0, 0x000000, 0x0024DA, 0x000000 },
 1726|       |	{ 0x0024C1, 0x000000, 0x0024DB, 0x000000 },
 1727|       |	{ 0x0024C2, 0x000000, 0x0024DC, 0x000000 },
 1728|       |	{ 0x0024C3, 0x000000, 0x0024DD, 0x000000 },
 1729|       |	{ 0x0024C4, 0x000000, 0x0024DE, 0x000000 },
 1730|       |	{ 0x0024C5, 0x000000, 0x0024DF, 0x000000 },
 1731|       |	{ 0x0024C6, 0x000000, 0x0024E0, 0x000000 },
 1732|       |	{ 0x0024C7, 0x000000, 0x0024E1, 0x000000 },
 1733|       |	{ 0x0024C8, 0x000000, 0x0024E2, 0x000000 },
 1734|       |	{ 0x0024C9, 0x000000, 0x0024E3, 0x000000 },
 1735|       |	{ 0x0024CA, 0x000000, 0x0024E4, 0x000000 },
 1736|       |	{ 0x0024CB, 0x000000, 0x0024E5, 0x000000 },
 1737|       |	{ 0x0024CC, 0x000000, 0x0024E6, 0x000000 },
 1738|       |	{ 0x0024CD, 0x000000, 0x0024E7, 0x000000 },
 1739|       |	{ 0x0024CE, 0x000000, 0x0024E8, 0x000000 },
 1740|       |	{ 0x0024CF, 0x000000, 0x0024E9, 0x000000 },
 1741|       |	{ 0x0024D0, 0x0024B6, 0x000000, 0x0024B6 },
 1742|       |	{ 0x0024D1, 0x0024B7, 0x000000, 0x0024B7 },
 1743|       |	{ 0x0024D2, 0x0024B8, 0x000000, 0x0024B8 },
 1744|       |	{ 0x0024D3, 0x0024B9, 0x000000, 0x0024B9 },
 1745|       |	{ 0x0024D4, 0x0024BA, 0x000000, 0x0024BA },
 1746|       |	{ 0x0024D5, 0x0024BB, 0x000000, 0x0024BB },
 1747|       |	{ 0x0024D6, 0x0024BC, 0x000000, 0x0024BC },
 1748|       |	{ 0x0024D7, 0x0024BD, 0x000000, 0x0024BD },
 1749|       |	{ 0x0024D8, 0x0024BE, 0x000000, 0x0024BE },
 1750|       |	{ 0x0024D9, 0x0024BF, 0x000000, 0x0024BF },
 1751|       |	{ 0x0024DA, 0x0024C0, 0x000000, 0x0024C0 },
 1752|       |	{ 0x0024DB, 0x0024C1, 0x000000, 0x0024C1 },
 1753|       |	{ 0x0024DC, 0x0024C2, 0x000000, 0x0024C2 },
 1754|       |	{ 0x0024DD, 0x0024C3, 0x000000, 0x0024C3 },
 1755|       |	{ 0x0024DE, 0x0024C4, 0x000000, 0x0024C4 },
 1756|       |	{ 0x0024DF, 0x0024C5, 0x000000, 0x0024C5 },
 1757|       |	{ 0x0024E0, 0x0024C6, 0x000000, 0x0024C6 },
 1758|       |	{ 0x0024E1, 0x0024C7, 0x000000, 0x0024C7 },
 1759|       |	{ 0x0024E2, 0x0024C8, 0x000000, 0x0024C8 },
 1760|       |	{ 0x0024E3, 0x0024C9, 0x000000, 0x0024C9 },
 1761|       |	{ 0x0024E4, 0x0024CA, 0x000000, 0x0024CA },
 1762|       |	{ 0x0024E5, 0x0024CB, 0x000000, 0x0024CB },
 1763|       |	{ 0x0024E6, 0x0024CC, 0x000000, 0x0024CC },
 1764|       |	{ 0x0024E7, 0x0024CD, 0x000000, 0x0024CD },
 1765|       |	{ 0x0024E8, 0x0024CE, 0x000000, 0x0024CE },
 1766|       |	{ 0x0024E9, 0x0024CF, 0x000000, 0x0024CF },
 1767|       |	{ 0x002C00, 0x000000, 0x002C30, 0x000000 },
 1768|       |	{ 0x002C01, 0x000000, 0x002C31, 0x000000 },
 1769|       |	{ 0x002C02, 0x000000, 0x002C32, 0x000000 },
 1770|       |	{ 0x002C03, 0x000000, 0x002C33, 0x000000 },
 1771|       |	{ 0x002C04, 0x000000, 0x002C34, 0x000000 },
 1772|       |	{ 0x002C05, 0x000000, 0x002C35, 0x000000 },
 1773|       |	{ 0x002C06, 0x000000, 0x002C36, 0x000000 },
 1774|       |	{ 0x002C07, 0x000000, 0x002C37, 0x000000 },
 1775|       |	{ 0x002C08, 0x000000, 0x002C38, 0x000000 },
 1776|       |	{ 0x002C09, 0x000000, 0x002C39, 0x000000 },
 1777|       |	{ 0x002C0A, 0x000000, 0x002C3A, 0x000000 },
 1778|       |	{ 0x002C0B, 0x000000, 0x002C3B, 0x000000 },
 1779|       |	{ 0x002C0C, 0x000000, 0x002C3C, 0x000000 },
 1780|       |	{ 0x002C0D, 0x000000, 0x002C3D, 0x000000 },
 1781|       |	{ 0x002C0E, 0x000000, 0x002C3E, 0x000000 },
 1782|       |	{ 0x002C0F, 0x000000, 0x002C3F, 0x000000 },
 1783|       |	{ 0x002C10, 0x000000, 0x002C40, 0x000000 },
 1784|       |	{ 0x002C11, 0x000000, 0x002C41, 0x000000 },
 1785|       |	{ 0x002C12, 0x000000, 0x002C42, 0x000000 },
 1786|       |	{ 0x002C13, 0x000000, 0x002C43, 0x000000 },
 1787|       |	{ 0x002C14, 0x000000, 0x002C44, 0x000000 },
 1788|       |	{ 0x002C15, 0x000000, 0x002C45, 0x000000 },
 1789|       |	{ 0x002C16, 0x000000, 0x002C46, 0x000000 },
 1790|       |	{ 0x002C17, 0x000000, 0x002C47, 0x000000 },
 1791|       |	{ 0x002C18, 0x000000, 0x002C48, 0x000000 },
 1792|       |	{ 0x002C19, 0x000000, 0x002C49, 0x000000 },
 1793|       |	{ 0x002C1A, 0x000000, 0x002C4A, 0x000000 },
 1794|       |	{ 0x002C1B, 0x000000, 0x002C4B, 0x000000 },
 1795|       |	{ 0x002C1C, 0x000000, 0x002C4C, 0x000000 },
 1796|       |	{ 0x002C1D, 0x000000, 0x002C4D, 0x000000 },
 1797|       |	{ 0x002C1E, 0x000000, 0x002C4E, 0x000000 },
 1798|       |	{ 0x002C1F, 0x000000, 0x002C4F, 0x000000 },
 1799|       |	{ 0x002C20, 0x000000, 0x002C50, 0x000000 },
 1800|       |	{ 0x002C21, 0x000000, 0x002C51, 0x000000 },
 1801|       |	{ 0x002C22, 0x000000, 0x002C52, 0x000000 },
 1802|       |	{ 0x002C23, 0x000000, 0x002C53, 0x000000 },
 1803|       |	{ 0x002C24, 0x000000, 0x002C54, 0x000000 },
 1804|       |	{ 0x002C25, 0x000000, 0x002C55, 0x000000 },
 1805|       |	{ 0x002C26, 0x000000, 0x002C56, 0x000000 },
 1806|       |	{ 0x002C27, 0x000000, 0x002C57, 0x000000 },
 1807|       |	{ 0x002C28, 0x000000, 0x002C58, 0x000000 },
 1808|       |	{ 0x002C29, 0x000000, 0x002C59, 0x000000 },
 1809|       |	{ 0x002C2A, 0x000000, 0x002C5A, 0x000000 },
 1810|       |	{ 0x002C2B, 0x000000, 0x002C5B, 0x000000 },
 1811|       |	{ 0x002C2C, 0x000000, 0x002C5C, 0x000000 },
 1812|       |	{ 0x002C2D, 0x000000, 0x002C5D, 0x000000 },
 1813|       |	{ 0x002C2E, 0x000000, 0x002C5E, 0x000000 },
 1814|       |	{ 0x002C30, 0x002C00, 0x000000, 0x002C00 },
 1815|       |	{ 0x002C31, 0x002C01, 0x000000, 0x002C01 },
 1816|       |	{ 0x002C32, 0x002C02, 0x000000, 0x002C02 },
 1817|       |	{ 0x002C33, 0x002C03, 0x000000, 0x002C03 },
 1818|       |	{ 0x002C34, 0x002C04, 0x000000, 0x002C04 },
 1819|       |	{ 0x002C35, 0x002C05, 0x000000, 0x002C05 },
 1820|       |	{ 0x002C36, 0x002C06, 0x000000, 0x002C06 },
 1821|       |	{ 0x002C37, 0x002C07, 0x000000, 0x002C07 },
 1822|       |	{ 0x002C38, 0x002C08, 0x000000, 0x002C08 },
 1823|       |	{ 0x002C39, 0x002C09, 0x000000, 0x002C09 },
 1824|       |	{ 0x002C3A, 0x002C0A, 0x000000, 0x002C0A },
 1825|       |	{ 0x002C3B, 0x002C0B, 0x000000, 0x002C0B },
 1826|       |	{ 0x002C3C, 0x002C0C, 0x000000, 0x002C0C },
 1827|       |	{ 0x002C3D, 0x002C0D, 0x000000, 0x002C0D },
 1828|       |	{ 0x002C3E, 0x002C0E, 0x000000, 0x002C0E },
 1829|       |	{ 0x002C3F, 0x002C0F, 0x000000, 0x002C0F },
 1830|       |	{ 0x002C40, 0x002C10, 0x000000, 0x002C10 },
 1831|       |	{ 0x002C41, 0x002C11, 0x000000, 0x002C11 },
 1832|       |	{ 0x002C42, 0x002C12, 0x000000, 0x002C12 },
 1833|       |	{ 0x002C43, 0x002C13, 0x000000, 0x002C13 },
 1834|       |	{ 0x002C44, 0x002C14, 0x000000, 0x002C14 },
 1835|       |	{ 0x002C45, 0x002C15, 0x000000, 0x002C15 },
 1836|       |	{ 0x002C46, 0x002C16, 0x000000, 0x002C16 },
 1837|       |	{ 0x002C47, 0x002C17, 0x000000, 0x002C17 },
 1838|       |	{ 0x002C48, 0x002C18, 0x000000, 0x002C18 },
 1839|       |	{ 0x002C49, 0x002C19, 0x000000, 0x002C19 },
 1840|       |	{ 0x002C4A, 0x002C1A, 0x000000, 0x002C1A },
 1841|       |	{ 0x002C4B, 0x002C1B, 0x000000, 0x002C1B },
 1842|       |	{ 0x002C4C, 0x002C1C, 0x000000, 0x002C1C },
 1843|       |	{ 0x002C4D, 0x002C1D, 0x000000, 0x002C1D },
 1844|       |	{ 0x002C4E, 0x002C1E, 0x000000, 0x002C1E },
 1845|       |	{ 0x002C4F, 0x002C1F, 0x000000, 0x002C1F },
 1846|       |	{ 0x002C50, 0x002C20, 0x000000, 0x002C20 },
 1847|       |	{ 0x002C51, 0x002C21, 0x000000, 0x002C21 },
 1848|       |	{ 0x002C52, 0x002C22, 0x000000, 0x002C22 },
 1849|       |	{ 0x002C53, 0x002C23, 0x000000, 0x002C23 },
 1850|       |	{ 0x002C54, 0x002C24, 0x000000, 0x002C24 },
 1851|       |	{ 0x002C55, 0x002C25, 0x000000, 0x002C25 },
 1852|       |	{ 0x002C56, 0x002C26, 0x000000, 0x002C26 },
 1853|       |	{ 0x002C57, 0x002C27, 0x000000, 0x002C27 },
 1854|       |	{ 0x002C58, 0x002C28, 0x000000, 0x002C28 },
 1855|       |	{ 0x002C59, 0x002C29, 0x000000, 0x002C29 },
 1856|       |	{ 0x002C5A, 0x002C2A, 0x000000, 0x002C2A },
 1857|       |	{ 0x002C5B, 0x002C2B, 0x000000, 0x002C2B },
 1858|       |	{ 0x002C5C, 0x002C2C, 0x000000, 0x002C2C },
 1859|       |	{ 0x002C5D, 0x002C2D, 0x000000, 0x002C2D },
 1860|       |	{ 0x002C5E, 0x002C2E, 0x000000, 0x002C2E },
 1861|       |	{ 0x002C60, 0x000000, 0x002C61, 0x000000 },
 1862|       |	{ 0x002C61, 0x002C60, 0x000000, 0x002C60 },
 1863|       |	{ 0x002C62, 0x000000, 0x00026B, 0x000000 },
 1864|       |	{ 0x002C63, 0x000000, 0x001D7D, 0x000000 },
 1865|       |	{ 0x002C64, 0x000000, 0x00027D, 0x000000 },
 1866|       |	{ 0x002C65, 0x00023A, 0x000000, 0x00023A },
 1867|       |	{ 0x002C66, 0x00023E, 0x000000, 0x00023E },
 1868|       |	{ 0x002C67, 0x000000, 0x002C68, 0x000000 },
 1869|       |	{ 0x002C68, 0x002C67, 0x000000, 0x002C67 },
 1870|       |	{ 0x002C69, 0x000000, 0x002C6A, 0x000000 },
 1871|       |	{ 0x002C6A, 0x002C69, 0x000000, 0x002C69 },
 1872|       |	{ 0x002C6B, 0x000000, 0x002C6C, 0x000000 },
 1873|       |	{ 0x002C6C, 0x002C6B, 0x000000, 0x002C6B },
 1874|       |	{ 0x002C6D, 0x000000, 0x000251, 0x000000 },
 1875|       |	{ 0x002C6E, 0x000000, 0x000271, 0x000000 },
 1876|       |	{ 0x002C6F, 0x000000, 0x000250, 0x000000 },
 1877|       |	{ 0x002C70, 0x000000, 0x000252, 0x000000 },
 1878|       |	{ 0x002C72, 0x000000, 0x002C73, 0x000000 },
 1879|       |	{ 0x002C73, 0x002C72, 0x000000, 0x002C72 },
 1880|       |	{ 0x002C75, 0x000000, 0x002C76, 0x000000 },
 1881|       |	{ 0x002C76, 0x002C75, 0x000000, 0x002C75 },
 1882|       |	{ 0x002C7E, 0x000000, 0x00023F, 0x000000 },
 1883|       |	{ 0x002C7F, 0x000000, 0x000240, 0x000000 },
 1884|       |	{ 0x002C80, 0x000000, 0x002C81, 0x000000 },
 1885|       |	{ 0x002C81, 0x002C80, 0x000000, 0x002C80 },
 1886|       |	{ 0x002C82, 0x000000, 0x002C83, 0x000000 },
 1887|       |	{ 0x002C83, 0x002C82, 0x000000, 0x002C82 },
 1888|       |	{ 0x002C84, 0x000000, 0x002C85, 0x000000 },
 1889|       |	{ 0x002C85, 0x002C84, 0x000000, 0x002C84 },
 1890|       |	{ 0x002C86, 0x000000, 0x002C87, 0x000000 },
 1891|       |	{ 0x002C87, 0x002C86, 0x000000, 0x002C86 },
 1892|       |	{ 0x002C88, 0x000000, 0x002C89, 0x000000 },
 1893|       |	{ 0x002C89, 0x002C88, 0x000000, 0x002C88 },
 1894|       |	{ 0x002C8A, 0x000000, 0x002C8B, 0x000000 },
 1895|       |	{ 0x002C8B, 0x002C8A, 0x000000, 0x002C8A },
 1896|       |	{ 0x002C8C, 0x000000, 0x002C8D, 0x000000 },
 1897|       |	{ 0x002C8D, 0x002C8C, 0x000000, 0x002C8C },
 1898|       |	{ 0x002C8E, 0x000000, 0x002C8F, 0x000000 },
 1899|       |	{ 0x002C8F, 0x002C8E, 0x000000, 0x002C8E },
 1900|       |	{ 0x002C90, 0x000000, 0x002C91, 0x000000 },
 1901|       |	{ 0x002C91, 0x002C90, 0x000000, 0x002C90 },
 1902|       |	{ 0x002C92, 0x000000, 0x002C93, 0x000000 },
 1903|       |	{ 0x002C93, 0x002C92, 0x000000, 0x002C92 },
 1904|       |	{ 0x002C94, 0x000000, 0x002C95, 0x000000 },
 1905|       |	{ 0x002C95, 0x002C94, 0x000000, 0x002C94 },
 1906|       |	{ 0x002C96, 0x000000, 0x002C97, 0x000000 },
 1907|       |	{ 0x002C97, 0x002C96, 0x000000, 0x002C96 },
 1908|       |	{ 0x002C98, 0x000000, 0x002C99, 0x000000 },
 1909|       |	{ 0x002C99, 0x002C98, 0x000000, 0x002C98 },
 1910|       |	{ 0x002C9A, 0x000000, 0x002C9B, 0x000000 },
 1911|       |	{ 0x002C9B, 0x002C9A, 0x000000, 0x002C9A },
 1912|       |	{ 0x002C9C, 0x000000, 0x002C9D, 0x000000 },
 1913|       |	{ 0x002C9D, 0x002C9C, 0x000000, 0x002C9C },
 1914|       |	{ 0x002C9E, 0x000000, 0x002C9F, 0x000000 },
 1915|       |	{ 0x002C9F, 0x002C9E, 0x000000, 0x002C9E },
 1916|       |	{ 0x002CA0, 0x000000, 0x002CA1, 0x000000 },
 1917|       |	{ 0x002CA1, 0x002CA0, 0x000000, 0x002CA0 },
 1918|       |	{ 0x002CA2, 0x000000, 0x002CA3, 0x000000 },
 1919|       |	{ 0x002CA3, 0x002CA2, 0x000000, 0x002CA2 },
 1920|       |	{ 0x002CA4, 0x000000, 0x002CA5, 0x000000 },
 1921|       |	{ 0x002CA5, 0x002CA4, 0x000000, 0x002CA4 },
 1922|       |	{ 0x002CA6, 0x000000, 0x002CA7, 0x000000 },
 1923|       |	{ 0x002CA7, 0x002CA6, 0x000000, 0x002CA6 },
 1924|       |	{ 0x002CA8, 0x000000, 0x002CA9, 0x000000 },
 1925|       |	{ 0x002CA9, 0x002CA8, 0x000000, 0x002CA8 },
 1926|       |	{ 0x002CAA, 0x000000, 0x002CAB, 0x000000 },
 1927|       |	{ 0x002CAB, 0x002CAA, 0x000000, 0x002CAA },
 1928|       |	{ 0x002CAC, 0x000000, 0x002CAD, 0x000000 },
 1929|       |	{ 0x002CAD, 0x002CAC, 0x000000, 0x002CAC },
 1930|       |	{ 0x002CAE, 0x000000, 0x002CAF, 0x000000 },
 1931|       |	{ 0x002CAF, 0x002CAE, 0x000000, 0x002CAE },
 1932|       |	{ 0x002CB0, 0x000000, 0x002CB1, 0x000000 },
 1933|       |	{ 0x002CB1, 0x002CB0, 0x000000, 0x002CB0 },
 1934|       |	{ 0x002CB2, 0x000000, 0x002CB3, 0x000000 },
 1935|       |	{ 0x002CB3, 0x002CB2, 0x000000, 0x002CB2 },
 1936|       |	{ 0x002CB4, 0x000000, 0x002CB5, 0x000000 },
 1937|       |	{ 0x002CB5, 0x002CB4, 0x000000, 0x002CB4 },
 1938|       |	{ 0x002CB6, 0x000000, 0x002CB7, 0x000000 },
 1939|       |	{ 0x002CB7, 0x002CB6, 0x000000, 0x002CB6 },
 1940|       |	{ 0x002CB8, 0x000000, 0x002CB9, 0x000000 },
 1941|       |	{ 0x002CB9, 0x002CB8, 0x000000, 0x002CB8 },
 1942|       |	{ 0x002CBA, 0x000000, 0x002CBB, 0x000000 },
 1943|       |	{ 0x002CBB, 0x002CBA, 0x000000, 0x002CBA },
 1944|       |	{ 0x002CBC, 0x000000, 0x002CBD, 0x000000 },
 1945|       |	{ 0x002CBD, 0x002CBC, 0x000000, 0x002CBC },
 1946|       |	{ 0x002CBE, 0x000000, 0x002CBF, 0x000000 },
 1947|       |	{ 0x002CBF, 0x002CBE, 0x000000, 0x002CBE },
 1948|       |	{ 0x002CC0, 0x000000, 0x002CC1, 0x000000 },
 1949|       |	{ 0x002CC1, 0x002CC0, 0x000000, 0x002CC0 },
 1950|       |	{ 0x002CC2, 0x000000, 0x002CC3, 0x000000 },
 1951|       |	{ 0x002CC3, 0x002CC2, 0x000000, 0x002CC2 },
 1952|       |	{ 0x002CC4, 0x000000, 0x002CC5, 0x000000 },
 1953|       |	{ 0x002CC5, 0x002CC4, 0x000000, 0x002CC4 },
 1954|       |	{ 0x002CC6, 0x000000, 0x002CC7, 0x000000 },
 1955|       |	{ 0x002CC7, 0x002CC6, 0x000000, 0x002CC6 },
 1956|       |	{ 0x002CC8, 0x000000, 0x002CC9, 0x000000 },
 1957|       |	{ 0x002CC9, 0x002CC8, 0x000000, 0x002CC8 },
 1958|       |	{ 0x002CCA, 0x000000, 0x002CCB, 0x000000 },
 1959|       |	{ 0x002CCB, 0x002CCA, 0x000000, 0x002CCA },
 1960|       |	{ 0x002CCC, 0x000000, 0x002CCD, 0x000000 },
 1961|       |	{ 0x002CCD, 0x002CCC, 0x000000, 0x002CCC },
 1962|       |	{ 0x002CCE, 0x000000, 0x002CCF, 0x000000 },
 1963|       |	{ 0x002CCF, 0x002CCE, 0x000000, 0x002CCE },
 1964|       |	{ 0x002CD0, 0x000000, 0x002CD1, 0x000000 },
 1965|       |	{ 0x002CD1, 0x002CD0, 0x000000, 0x002CD0 },
 1966|       |	{ 0x002CD2, 0x000000, 0x002CD3, 0x000000 },
 1967|       |	{ 0x002CD3, 0x002CD2, 0x000000, 0x002CD2 },
 1968|       |	{ 0x002CD4, 0x000000, 0x002CD5, 0x000000 },
 1969|       |	{ 0x002CD5, 0x002CD4, 0x000000, 0x002CD4 },
 1970|       |	{ 0x002CD6, 0x000000, 0x002CD7, 0x000000 },
 1971|       |	{ 0x002CD7, 0x002CD6, 0x000000, 0x002CD6 },
 1972|       |	{ 0x002CD8, 0x000000, 0x002CD9, 0x000000 },
 1973|       |	{ 0x002CD9, 0x002CD8, 0x000000, 0x002CD8 },
 1974|       |	{ 0x002CDA, 0x000000, 0x002CDB, 0x000000 },
 1975|       |	{ 0x002CDB, 0x002CDA, 0x000000, 0x002CDA },
 1976|       |	{ 0x002CDC, 0x000000, 0x002CDD, 0x000000 },
 1977|       |	{ 0x002CDD, 0x002CDC, 0x000000, 0x002CDC },
 1978|       |	{ 0x002CDE, 0x000000, 0x002CDF, 0x000000 },
 1979|       |	{ 0x002CDF, 0x002CDE, 0x000000, 0x002CDE },
 1980|       |	{ 0x002CE0, 0x000000, 0x002CE1, 0x000000 },
 1981|       |	{ 0x002CE1, 0x002CE0, 0x000000, 0x002CE0 },
 1982|       |	{ 0x002CE2, 0x000000, 0x002CE3, 0x000000 },
 1983|       |	{ 0x002CE3, 0x002CE2, 0x000000, 0x002CE2 },
 1984|       |	{ 0x002CEB, 0x000000, 0x002CEC, 0x000000 },
 1985|       |	{ 0x002CEC, 0x002CEB, 0x000000, 0x002CEB },
 1986|       |	{ 0x002CED, 0x000000, 0x002CEE, 0x000000 },
 1987|       |	{ 0x002CEE, 0x002CED, 0x000000, 0x002CED },
 1988|       |	{ 0x002CF2, 0x000000, 0x002CF3, 0x000000 },
 1989|       |	{ 0x002CF3, 0x002CF2, 0x000000, 0x002CF2 },
 1990|       |	{ 0x002D00, 0x0010A0, 0x000000, 0x0010A0 },
 1991|       |	{ 0x002D01, 0x0010A1, 0x000000, 0x0010A1 },
 1992|       |	{ 0x002D02, 0x0010A2, 0x000000, 0x0010A2 },
 1993|       |	{ 0x002D03, 0x0010A3, 0x000000, 0x0010A3 },
 1994|       |	{ 0x002D04, 0x0010A4, 0x000000, 0x0010A4 },
 1995|       |	{ 0x002D05, 0x0010A5, 0x000000, 0x0010A5 },
 1996|       |	{ 0x002D06, 0x0010A6, 0x000000, 0x0010A6 },
 1997|       |	{ 0x002D07, 0x0010A7, 0x000000, 0x0010A7 },
 1998|       |	{ 0x002D08, 0x0010A8, 0x000000, 0x0010A8 },
 1999|       |	{ 0x002D09, 0x0010A9, 0x000000, 0x0010A9 },
 2000|       |	{ 0x002D0A, 0x0010AA, 0x000000, 0x0010AA },
 2001|       |	{ 0x002D0B, 0x0010AB, 0x000000, 0x0010AB },
 2002|       |	{ 0x002D0C, 0x0010AC, 0x000000, 0x0010AC },
 2003|       |	{ 0x002D0D, 0x0010AD, 0x000000, 0x0010AD },
 2004|       |	{ 0x002D0E, 0x0010AE, 0x000000, 0x0010AE },
 2005|       |	{ 0x002D0F, 0x0010AF, 0x000000, 0x0010AF },
 2006|       |	{ 0x002D10, 0x0010B0, 0x000000, 0x0010B0 },
 2007|       |	{ 0x002D11, 0x0010B1, 0x000000, 0x0010B1 },
 2008|       |	{ 0x002D12, 0x0010B2, 0x000000, 0x0010B2 },
 2009|       |	{ 0x002D13, 0x0010B3, 0x000000, 0x0010B3 },
 2010|       |	{ 0x002D14, 0x0010B4, 0x000000, 0x0010B4 },
 2011|       |	{ 0x002D15, 0x0010B5, 0x000000, 0x0010B5 },
 2012|       |	{ 0x002D16, 0x0010B6, 0x000000, 0x0010B6 },
 2013|       |	{ 0x002D17, 0x0010B7, 0x000000, 0x0010B7 },
 2014|       |	{ 0x002D18, 0x0010B8, 0x000000, 0x0010B8 },
 2015|       |	{ 0x002D19, 0x0010B9, 0x000000, 0x0010B9 },
 2016|       |	{ 0x002D1A, 0x0010BA, 0x000000, 0x0010BA },
 2017|       |	{ 0x002D1B, 0x0010BB, 0x000000, 0x0010BB },
 2018|       |	{ 0x002D1C, 0x0010BC, 0x000000, 0x0010BC },
 2019|       |	{ 0x002D1D, 0x0010BD, 0x000000, 0x0010BD },
 2020|       |	{ 0x002D1E, 0x0010BE, 0x000000, 0x0010BE },
 2021|       |	{ 0x002D1F, 0x0010BF, 0x000000, 0x0010BF },
 2022|       |	{ 0x002D20, 0x0010C0, 0x000000, 0x0010C0 },
 2023|       |	{ 0x002D21, 0x0010C1, 0x000000, 0x0010C1 },
 2024|       |	{ 0x002D22, 0x0010C2, 0x000000, 0x0010C2 },
 2025|       |	{ 0x002D23, 0x0010C3, 0x000000, 0x0010C3 },
 2026|       |	{ 0x002D24, 0x0010C4, 0x000000, 0x0010C4 },
 2027|       |	{ 0x002D25, 0x0010C5, 0x000000, 0x0010C5 },
 2028|       |	{ 0x002D27, 0x0010C7, 0x000000, 0x0010C7 },
 2029|       |	{ 0x002D2D, 0x0010CD, 0x000000, 0x0010CD },
 2030|       |	{ 0x00A640, 0x000000, 0x00A641, 0x000000 },
 2031|       |	{ 0x00A641, 0x00A640, 0x000000, 0x00A640 },
 2032|       |	{ 0x00A642, 0x000000, 0x00A643, 0x000000 },
 2033|       |	{ 0x00A643, 0x00A642, 0x000000, 0x00A642 },
 2034|       |	{ 0x00A644, 0x000000, 0x00A645, 0x000000 },
 2035|       |	{ 0x00A645, 0x00A644, 0x000000, 0x00A644 },
 2036|       |	{ 0x00A646, 0x000000, 0x00A647, 0x000000 },
 2037|       |	{ 0x00A647, 0x00A646, 0x000000, 0x00A646 },
 2038|       |	{ 0x00A648, 0x000000, 0x00A649, 0x000000 },
 2039|       |	{ 0x00A649, 0x00A648, 0x000000, 0x00A648 },
 2040|       |	{ 0x00A64A, 0x000000, 0x00A64B, 0x000000 },
 2041|       |	{ 0x00A64B, 0x00A64A, 0x000000, 0x00A64A },
 2042|       |	{ 0x00A64C, 0x000000, 0x00A64D, 0x000000 },
 2043|       |	{ 0x00A64D, 0x00A64C, 0x000000, 0x00A64C },
 2044|       |	{ 0x00A64E, 0x000000, 0x00A64F, 0x000000 },
 2045|       |	{ 0x00A64F, 0x00A64E, 0x000000, 0x00A64E },
 2046|       |	{ 0x00A650, 0x000000, 0x00A651, 0x000000 },
 2047|       |	{ 0x00A651, 0x00A650, 0x000000, 0x00A650 },
 2048|       |	{ 0x00A652, 0x000000, 0x00A653, 0x000000 },
 2049|       |	{ 0x00A653, 0x00A652, 0x000000, 0x00A652 },
 2050|       |	{ 0x00A654, 0x000000, 0x00A655, 0x000000 },
 2051|       |	{ 0x00A655, 0x00A654, 0x000000, 0x00A654 },
 2052|       |	{ 0x00A656, 0x000000, 0x00A657, 0x000000 },
 2053|       |	{ 0x00A657, 0x00A656, 0x000000, 0x00A656 },
 2054|       |	{ 0x00A658, 0x000000, 0x00A659, 0x000000 },
 2055|       |	{ 0x00A659, 0x00A658, 0x000000, 0x00A658 },
 2056|       |	{ 0x00A65A, 0x000000, 0x00A65B, 0x000000 },
 2057|       |	{ 0x00A65B, 0x00A65A, 0x000000, 0x00A65A },
 2058|       |	{ 0x00A65C, 0x000000, 0x00A65D, 0x000000 },
 2059|       |	{ 0x00A65D, 0x00A65C, 0x000000, 0x00A65C },
 2060|       |	{ 0x00A65E, 0x000000, 0x00A65F, 0x000000 },
 2061|       |	{ 0x00A65F, 0x00A65E, 0x000000, 0x00A65E },
 2062|       |	{ 0x00A660, 0x000000, 0x00A661, 0x000000 },
 2063|       |	{ 0x00A661, 0x00A660, 0x000000, 0x00A660 },
 2064|       |	{ 0x00A662, 0x000000, 0x00A663, 0x000000 },
 2065|       |	{ 0x00A663, 0x00A662, 0x000000, 0x00A662 },
 2066|       |	{ 0x00A664, 0x000000, 0x00A665, 0x000000 },
 2067|       |	{ 0x00A665, 0x00A664, 0x000000, 0x00A664 },
 2068|       |	{ 0x00A666, 0x000000, 0x00A667, 0x000000 },
 2069|       |	{ 0x00A667, 0x00A666, 0x000000, 0x00A666 },
 2070|       |	{ 0x00A668, 0x000000, 0x00A669, 0x000000 },
 2071|       |	{ 0x00A669, 0x00A668, 0x000000, 0x00A668 },
 2072|       |	{ 0x00A66A, 0x000000, 0x00A66B, 0x000000 },
 2073|       |	{ 0x00A66B, 0x00A66A, 0x000000, 0x00A66A },
 2074|       |	{ 0x00A66C, 0x000000, 0x00A66D, 0x000000 },
 2075|       |	{ 0x00A66D, 0x00A66C, 0x000000, 0x00A66C },
 2076|       |	{ 0x00A680, 0x000000, 0x00A681, 0x000000 },
 2077|       |	{ 0x00A681, 0x00A680, 0x000000, 0x00A680 },
 2078|       |	{ 0x00A682, 0x000000, 0x00A683, 0x000000 },
 2079|       |	{ 0x00A683, 0x00A682, 0x000000, 0x00A682 },
 2080|       |	{ 0x00A684, 0x000000, 0x00A685, 0x000000 },
 2081|       |	{ 0x00A685, 0x00A684, 0x000000, 0x00A684 },
 2082|       |	{ 0x00A686, 0x000000, 0x00A687, 0x000000 },
 2083|       |	{ 0x00A687, 0x00A686, 0x000000, 0x00A686 },
 2084|       |	{ 0x00A688, 0x000000, 0x00A689, 0x000000 },
 2085|       |	{ 0x00A689, 0x00A688, 0x000000, 0x00A688 },
 2086|       |	{ 0x00A68A, 0x000000, 0x00A68B, 0x000000 },
 2087|       |	{ 0x00A68B, 0x00A68A, 0x000000, 0x00A68A },
 2088|       |	{ 0x00A68C, 0x000000, 0x00A68D, 0x000000 },
 2089|       |	{ 0x00A68D, 0x00A68C, 0x000000, 0x00A68C },
 2090|       |	{ 0x00A68E, 0x000000, 0x00A68F, 0x000000 },
 2091|       |	{ 0x00A68F, 0x00A68E, 0x000000, 0x00A68E },
 2092|       |	{ 0x00A690, 0x000000, 0x00A691, 0x000000 },
 2093|       |	{ 0x00A691, 0x00A690, 0x000000, 0x00A690 },
 2094|       |	{ 0x00A692, 0x000000, 0x00A693, 0x000000 },
 2095|       |	{ 0x00A693, 0x00A692, 0x000000, 0x00A692 },
 2096|       |	{ 0x00A694, 0x000000, 0x00A695, 0x000000 },
 2097|       |	{ 0x00A695, 0x00A694, 0x000000, 0x00A694 },
 2098|       |	{ 0x00A696, 0x000000, 0x00A697, 0x000000 },
 2099|       |	{ 0x00A697, 0x00A696, 0x000000, 0x00A696 },
 2100|       |	{ 0x00A698, 0x000000, 0x00A699, 0x000000 },
 2101|       |	{ 0x00A699, 0x00A698, 0x000000, 0x00A698 },
 2102|       |	{ 0x00A69A, 0x000000, 0x00A69B, 0x000000 },
 2103|       |	{ 0x00A69B, 0x00A69A, 0x000000, 0x00A69A },
 2104|       |	{ 0x00A722, 0x000000, 0x00A723, 0x000000 },
 2105|       |	{ 0x00A723, 0x00A722, 0x000000, 0x00A722 },
 2106|       |	{ 0x00A724, 0x000000, 0x00A725, 0x000000 },
 2107|       |	{ 0x00A725, 0x00A724, 0x000000, 0x00A724 },
 2108|       |	{ 0x00A726, 0x000000, 0x00A727, 0x000000 },
 2109|       |	{ 0x00A727, 0x00A726, 0x000000, 0x00A726 },
 2110|       |	{ 0x00A728, 0x000000, 0x00A729, 0x000000 },
 2111|       |	{ 0x00A729, 0x00A728, 0x000000, 0x00A728 },
 2112|       |	{ 0x00A72A, 0x000000, 0x00A72B, 0x000000 },
 2113|       |	{ 0x00A72B, 0x00A72A, 0x000000, 0x00A72A },
 2114|       |	{ 0x00A72C, 0x000000, 0x00A72D, 0x000000 },
 2115|       |	{ 0x00A72D, 0x00A72C, 0x000000, 0x00A72C },
 2116|       |	{ 0x00A72E, 0x000000, 0x00A72F, 0x000000 },
 2117|       |	{ 0x00A72F, 0x00A72E, 0x000000, 0x00A72E },
 2118|       |	{ 0x00A732, 0x000000, 0x00A733, 0x000000 },
 2119|       |	{ 0x00A733, 0x00A732, 0x000000, 0x00A732 },
 2120|       |	{ 0x00A734, 0x000000, 0x00A735, 0x000000 },
 2121|       |	{ 0x00A735, 0x00A734, 0x000000, 0x00A734 },
 2122|       |	{ 0x00A736, 0x000000, 0x00A737, 0x000000 },
 2123|       |	{ 0x00A737, 0x00A736, 0x000000, 0x00A736 },
 2124|       |	{ 0x00A738, 0x000000, 0x00A739, 0x000000 },
 2125|       |	{ 0x00A739, 0x00A738, 0x000000, 0x00A738 },
 2126|       |	{ 0x00A73A, 0x000000, 0x00A73B, 0x000000 },
 2127|       |	{ 0x00A73B, 0x00A73A, 0x000000, 0x00A73A },
 2128|       |	{ 0x00A73C, 0x000000, 0x00A73D, 0x000000 },
 2129|       |	{ 0x00A73D, 0x00A73C, 0x000000, 0x00A73C },
 2130|       |	{ 0x00A73E, 0x000000, 0x00A73F, 0x000000 },
 2131|       |	{ 0x00A73F, 0x00A73E, 0x000000, 0x00A73E },
 2132|       |	{ 0x00A740, 0x000000, 0x00A741, 0x000000 },
 2133|       |	{ 0x00A741, 0x00A740, 0x000000, 0x00A740 },
 2134|       |	{ 0x00A742, 0x000000, 0x00A743, 0x000000 },
 2135|       |	{ 0x00A743, 0x00A742, 0x000000, 0x00A742 },
 2136|       |	{ 0x00A744, 0x000000, 0x00A745, 0x000000 },
 2137|       |	{ 0x00A745, 0x00A744, 0x000000, 0x00A744 },
 2138|       |	{ 0x00A746, 0x000000, 0x00A747, 0x000000 },
 2139|       |	{ 0x00A747, 0x00A746, 0x000000, 0x00A746 },
 2140|       |	{ 0x00A748, 0x000000, 0x00A749, 0x000000 },
 2141|       |	{ 0x00A749, 0x00A748, 0x000000, 0x00A748 },
 2142|       |	{ 0x00A74A, 0x000000, 0x00A74B, 0x000000 },
 2143|       |	{ 0x00A74B, 0x00A74A, 0x000000, 0x00A74A },
 2144|       |	{ 0x00A74C, 0x000000, 0x00A74D, 0x000000 },
 2145|       |	{ 0x00A74D, 0x00A74C, 0x000000, 0x00A74C },
 2146|       |	{ 0x00A74E, 0x000000, 0x00A74F, 0x000000 },
 2147|       |	{ 0x00A74F, 0x00A74E, 0x000000, 0x00A74E },
 2148|       |	{ 0x00A750, 0x000000, 0x00A751, 0x000000 },
 2149|       |	{ 0x00A751, 0x00A750, 0x000000, 0x00A750 },
 2150|       |	{ 0x00A752, 0x000000, 0x00A753, 0x000000 },
 2151|       |	{ 0x00A753, 0x00A752, 0x000000, 0x00A752 },
 2152|       |	{ 0x00A754, 0x000000, 0x00A755, 0x000000 },
 2153|       |	{ 0x00A755, 0x00A754, 0x000000, 0x00A754 },
 2154|       |	{ 0x00A756, 0x000000, 0x00A757, 0x000000 },
 2155|       |	{ 0x00A757, 0x00A756, 0x000000, 0x00A756 },
 2156|       |	{ 0x00A758, 0x000000, 0x00A759, 0x000000 },
 2157|       |	{ 0x00A759, 0x00A758, 0x000000, 0x00A758 },
 2158|       |	{ 0x00A75A, 0x000000, 0x00A75B, 0x000000 },
 2159|       |	{ 0x00A75B, 0x00A75A, 0x000000, 0x00A75A },
 2160|       |	{ 0x00A75C, 0x000000, 0x00A75D, 0x000000 },
 2161|       |	{ 0x00A75D, 0x00A75C, 0x000000, 0x00A75C },
 2162|       |	{ 0x00A75E, 0x000000, 0x00A75F, 0x000000 },
 2163|       |	{ 0x00A75F, 0x00A75E, 0x000000, 0x00A75E },
 2164|       |	{ 0x00A760, 0x000000, 0x00A761, 0x000000 },
 2165|       |	{ 0x00A761, 0x00A760, 0x000000, 0x00A760 },
 2166|       |	{ 0x00A762, 0x000000, 0x00A763, 0x000000 },
 2167|       |	{ 0x00A763, 0x00A762, 0x000000, 0x00A762 },
 2168|       |	{ 0x00A764, 0x000000, 0x00A765, 0x000000 },
 2169|       |	{ 0x00A765, 0x00A764, 0x000000, 0x00A764 },
 2170|       |	{ 0x00A766, 0x000000, 0x00A767, 0x000000 },
 2171|       |	{ 0x00A767, 0x00A766, 0x000000, 0x00A766 },
 2172|       |	{ 0x00A768, 0x000000, 0x00A769, 0x000000 },
 2173|       |	{ 0x00A769, 0x00A768, 0x000000, 0x00A768 },
 2174|       |	{ 0x00A76A, 0x000000, 0x00A76B, 0x000000 },
 2175|       |	{ 0x00A76B, 0x00A76A, 0x000000, 0x00A76A },
 2176|       |	{ 0x00A76C, 0x000000, 0x00A76D, 0x000000 },
 2177|       |	{ 0x00A76D, 0x00A76C, 0x000000, 0x00A76C },
 2178|       |	{ 0x00A76E, 0x000000, 0x00A76F, 0x000000 },
 2179|       |	{ 0x00A76F, 0x00A76E, 0x000000, 0x00A76E },
 2180|       |	{ 0x00A779, 0x000000, 0x00A77A, 0x000000 },
 2181|       |	{ 0x00A77A, 0x00A779, 0x000000, 0x00A779 },
 2182|       |	{ 0x00A77B, 0x000000, 0x00A77C, 0x000000 },
 2183|       |	{ 0x00A77C, 0x00A77B, 0x000000, 0x00A77B },
 2184|       |	{ 0x00A77D, 0x000000, 0x001D79, 0x000000 },
 2185|       |	{ 0x00A77E, 0x000000, 0x00A77F, 0x000000 },
 2186|       |	{ 0x00A77F, 0x00A77E, 0x000000, 0x00A77E },
 2187|       |	{ 0x00A780, 0x000000, 0x00A781, 0x000000 },
 2188|       |	{ 0x00A781, 0x00A780, 0x000000, 0x00A780 },
 2189|       |	{ 0x00A782, 0x000000, 0x00A783, 0x000000 },
 2190|       |	{ 0x00A783, 0x00A782, 0x000000, 0x00A782 },
 2191|       |	{ 0x00A784, 0x000000, 0x00A785, 0x000000 },
 2192|       |	{ 0x00A785, 0x00A784, 0x000000, 0x00A784 },
 2193|       |	{ 0x00A786, 0x000000, 0x00A787, 0x000000 },
 2194|       |	{ 0x00A787, 0x00A786, 0x000000, 0x00A786 },
 2195|       |	{ 0x00A78B, 0x000000, 0x00A78C, 0x000000 },
 2196|       |	{ 0x00A78C, 0x00A78B, 0x000000, 0x00A78B },
 2197|       |	{ 0x00A78D, 0x000000, 0x000265, 0x000000 },
 2198|       |	{ 0x00A790, 0x000000, 0x00A791, 0x000000 },
 2199|       |	{ 0x00A791, 0x00A790, 0x000000, 0x00A790 },
 2200|       |	{ 0x00A792, 0x000000, 0x00A793, 0x000000 },
 2201|       |	{ 0x00A793, 0x00A792, 0x000000, 0x00A792 },
 2202|       |	{ 0x00A796, 0x000000, 0x00A797, 0x000000 },
 2203|       |	{ 0x00A797, 0x00A796, 0x000000, 0x00A796 },
 2204|       |	{ 0x00A798, 0x000000, 0x00A799, 0x000000 },
 2205|       |	{ 0x00A799, 0x00A798, 0x000000, 0x00A798 },
 2206|       |	{ 0x00A79A, 0x000000, 0x00A79B, 0x000000 },
 2207|       |	{ 0x00A79B, 0x00A79A, 0x000000, 0x00A79A },
 2208|       |	{ 0x00A79C, 0x000000, 0x00A79D, 0x000000 },
 2209|       |	{ 0x00A79D, 0x00A79C, 0x000000, 0x00A79C },
 2210|       |	{ 0x00A79E, 0x000000, 0x00A79F, 0x000000 },
 2211|       |	{ 0x00A79F, 0x00A79E, 0x000000, 0x00A79E },
 2212|       |	{ 0x00A7A0, 0x000000, 0x00A7A1, 0x000000 },
 2213|       |	{ 0x00A7A1, 0x00A7A0, 0x000000, 0x00A7A0 },
 2214|       |	{ 0x00A7A2, 0x000000, 0x00A7A3, 0x000000 },
 2215|       |	{ 0x00A7A3, 0x00A7A2, 0x000000, 0x00A7A2 },
 2216|       |	{ 0x00A7A4, 0x000000, 0x00A7A5, 0x000000 },
 2217|       |	{ 0x00A7A5, 0x00A7A4, 0x000000, 0x00A7A4 },
 2218|       |	{ 0x00A7A6, 0x000000, 0x00A7A7, 0x000000 },
 2219|       |	{ 0x00A7A7, 0x00A7A6, 0x000000, 0x00A7A6 },
 2220|       |	{ 0x00A7A8, 0x000000, 0x00A7A9, 0x000000 },
 2221|       |	{ 0x00A7A9, 0x00A7A8, 0x000000, 0x00A7A8 },
 2222|       |	{ 0x00A7AA, 0x000000, 0x000266, 0x000000 },
 2223|       |	{ 0x00A7AB, 0x000000, 0x00025C, 0x000000 },
 2224|       |	{ 0x00A7AC, 0x000000, 0x000261, 0x000000 },
 2225|       |	{ 0x00A7AD, 0x000000, 0x00026C, 0x000000 },
 2226|       |	{ 0x00A7AE, 0x000000, 0x00026A, 0x000000 },
 2227|       |	{ 0x00A7B0, 0x000000, 0x00029E, 0x000000 },
 2228|       |	{ 0x00A7B1, 0x000000, 0x000287, 0x000000 },
 2229|       |	{ 0x00A7B2, 0x000000, 0x00029D, 0x000000 },
 2230|       |	{ 0x00A7B3, 0x000000, 0x00AB53, 0x000000 },
 2231|       |	{ 0x00A7B4, 0x000000, 0x00A7B5, 0x000000 },
 2232|       |	{ 0x00A7B5, 0x00A7B4, 0x000000, 0x00A7B4 },
 2233|       |	{ 0x00A7B6, 0x000000, 0x00A7B7, 0x000000 },
 2234|       |	{ 0x00A7B7, 0x00A7B6, 0x000000, 0x00A7B6 },
 2235|       |	{ 0x00A7B8, 0x000000, 0x00A7B9, 0x000000 },
 2236|       |	{ 0x00A7B9, 0x00A7B8, 0x000000, 0x00A7B8 },
 2237|       |	{ 0x00AB53, 0x00A7B3, 0x000000, 0x00A7B3 },
 2238|       |	{ 0x00AB70, 0x0013A0, 0x000000, 0x0013A0 },
 2239|       |	{ 0x00AB71, 0x0013A1, 0x000000, 0x0013A1 },
 2240|       |	{ 0x00AB72, 0x0013A2, 0x000000, 0x0013A2 },
 2241|       |	{ 0x00AB73, 0x0013A3, 0x000000, 0x0013A3 },
 2242|       |	{ 0x00AB74, 0x0013A4, 0x000000, 0x0013A4 },
 2243|       |	{ 0x00AB75, 0x0013A5, 0x000000, 0x0013A5 },
 2244|       |	{ 0x00AB76, 0x0013A6, 0x000000, 0x0013A6 },
 2245|       |	{ 0x00AB77, 0x0013A7, 0x000000, 0x0013A7 },
 2246|       |	{ 0x00AB78, 0x0013A8, 0x000000, 0x0013A8 },
 2247|       |	{ 0x00AB79, 0x0013A9, 0x000000, 0x0013A9 },
 2248|       |	{ 0x00AB7A, 0x0013AA, 0x000000, 0x0013AA },
 2249|       |	{ 0x00AB7B, 0x0013AB, 0x000000, 0x0013AB },
 2250|       |	{ 0x00AB7C, 0x0013AC, 0x000000, 0x0013AC },
 2251|       |	{ 0x00AB7D, 0x0013AD, 0x000000, 0x0013AD },
 2252|       |	{ 0x00AB7E, 0x0013AE, 0x000000, 0x0013AE },
 2253|       |	{ 0x00AB7F, 0x0013AF, 0x000000, 0x0013AF },
 2254|       |	{ 0x00AB80, 0x0013B0, 0x000000, 0x0013B0 },
 2255|       |	{ 0x00AB81, 0x0013B1, 0x000000, 0x0013B1 },
 2256|       |	{ 0x00AB82, 0x0013B2, 0x000000, 0x0013B2 },
 2257|       |	{ 0x00AB83, 0x0013B3, 0x000000, 0x0013B3 },
 2258|       |	{ 0x00AB84, 0x0013B4, 0x000000, 0x0013B4 },
 2259|       |	{ 0x00AB85, 0x0013B5, 0x000000, 0x0013B5 },
 2260|       |	{ 0x00AB86, 0x0013B6, 0x000000, 0x0013B6 },
 2261|       |	{ 0x00AB87, 0x0013B7, 0x000000, 0x0013B7 },
 2262|       |	{ 0x00AB88, 0x0013B8, 0x000000, 0x0013B8 },
 2263|       |	{ 0x00AB89, 0x0013B9, 0x000000, 0x0013B9 },
 2264|       |	{ 0x00AB8A, 0x0013BA, 0x000000, 0x0013BA },
 2265|       |	{ 0x00AB8B, 0x0013BB, 0x000000, 0x0013BB },
 2266|       |	{ 0x00AB8C, 0x0013BC, 0x000000, 0x0013BC },
 2267|       |	{ 0x00AB8D, 0x0013BD, 0x000000, 0x0013BD },
 2268|       |	{ 0x00AB8E, 0x0013BE, 0x000000, 0x0013BE },
 2269|       |	{ 0x00AB8F, 0x0013BF, 0x000000, 0x0013BF },
 2270|       |	{ 0x00AB90, 0x0013C0, 0x000000, 0x0013C0 },
 2271|       |	{ 0x00AB91, 0x0013C1, 0x000000, 0x0013C1 },
 2272|       |	{ 0x00AB92, 0x0013C2, 0x000000, 0x0013C2 },
 2273|       |	{ 0x00AB93, 0x0013C3, 0x000000, 0x0013C3 },
 2274|       |	{ 0x00AB94, 0x0013C4, 0x000000, 0x0013C4 },
 2275|       |	{ 0x00AB95, 0x0013C5, 0x000000, 0x0013C5 },
 2276|       |	{ 0x00AB96, 0x0013C6, 0x000000, 0x0013C6 },
 2277|       |	{ 0x00AB97, 0x0013C7, 0x000000, 0x0013C7 },
 2278|       |	{ 0x00AB98, 0x0013C8, 0x000000, 0x0013C8 },
 2279|       |	{ 0x00AB99, 0x0013C9, 0x000000, 0x0013C9 },
 2280|       |	{ 0x00AB9A, 0x0013CA, 0x000000, 0x0013CA },
 2281|       |	{ 0x00AB9B, 0x0013CB, 0x000000, 0x0013CB },
 2282|       |	{ 0x00AB9C, 0x0013CC, 0x000000, 0x0013CC },
 2283|       |	{ 0x00AB9D, 0x0013CD, 0x000000, 0x0013CD },
 2284|       |	{ 0x00AB9E, 0x0013CE, 0x000000, 0x0013CE },
 2285|       |	{ 0x00AB9F, 0x0013CF, 0x000000, 0x0013CF },
 2286|       |	{ 0x00ABA0, 0x0013D0, 0x000000, 0x0013D0 },
 2287|       |	{ 0x00ABA1, 0x0013D1, 0x000000, 0x0013D1 },
 2288|       |	{ 0x00ABA2, 0x0013D2, 0x000000, 0x0013D2 },
 2289|       |	{ 0x00ABA3, 0x0013D3, 0x000000, 0x0013D3 },
 2290|       |	{ 0x00ABA4, 0x0013D4, 0x000000, 0x0013D4 },
 2291|       |	{ 0x00ABA5, 0x0013D5, 0x000000, 0x0013D5 },
 2292|       |	{ 0x00ABA6, 0x0013D6, 0x000000, 0x0013D6 },
 2293|       |	{ 0x00ABA7, 0x0013D7, 0x000000, 0x0013D7 },
 2294|       |	{ 0x00ABA8, 0x0013D8, 0x000000, 0x0013D8 },
 2295|       |	{ 0x00ABA9, 0x0013D9, 0x000000, 0x0013D9 },
 2296|       |	{ 0x00ABAA, 0x0013DA, 0x000000, 0x0013DA },
 2297|       |	{ 0x00ABAB, 0x0013DB, 0x000000, 0x0013DB },
 2298|       |	{ 0x00ABAC, 0x0013DC, 0x000000, 0x0013DC },
 2299|       |	{ 0x00ABAD, 0x0013DD, 0x000000, 0x0013DD },
 2300|       |	{ 0x00ABAE, 0x0013DE, 0x000000, 0x0013DE },
 2301|       |	{ 0x00ABAF, 0x0013DF, 0x000000, 0x0013DF },
 2302|       |	{ 0x00ABB0, 0x0013E0, 0x000000, 0x0013E0 },
 2303|       |	{ 0x00ABB1, 0x0013E1, 0x000000, 0x0013E1 },
 2304|       |	{ 0x00ABB2, 0x0013E2, 0x000000, 0x0013E2 },
 2305|       |	{ 0x00ABB3, 0x0013E3, 0x000000, 0x0013E3 },
 2306|       |	{ 0x00ABB4, 0x0013E4, 0x000000, 0x0013E4 },
 2307|       |	{ 0x00ABB5, 0x0013E5, 0x000000, 0x0013E5 },
 2308|       |	{ 0x00ABB6, 0x0013E6, 0x000000, 0x0013E6 },
 2309|       |	{ 0x00ABB7, 0x0013E7, 0x000000, 0x0013E7 },
 2310|       |	{ 0x00ABB8, 0x0013E8, 0x000000, 0x0013E8 },
 2311|       |	{ 0x00ABB9, 0x0013E9, 0x000000, 0x0013E9 },
 2312|       |	{ 0x00ABBA, 0x0013EA, 0x000000, 0x0013EA },
 2313|       |	{ 0x00ABBB, 0x0013EB, 0x000000, 0x0013EB },
 2314|       |	{ 0x00ABBC, 0x0013EC, 0x000000, 0x0013EC },
 2315|       |	{ 0x00ABBD, 0x0013ED, 0x000000, 0x0013ED },
 2316|       |	{ 0x00ABBE, 0x0013EE, 0x000000, 0x0013EE },
 2317|       |	{ 0x00ABBF, 0x0013EF, 0x000000, 0x0013EF },
 2318|       |	{ 0x00FF21, 0x000000, 0x00FF41, 0x000000 },
 2319|       |	{ 0x00FF22, 0x000000, 0x00FF42, 0x000000 },
 2320|       |	{ 0x00FF23, 0x000000, 0x00FF43, 0x000000 },
 2321|       |	{ 0x00FF24, 0x000000, 0x00FF44, 0x000000 },
 2322|       |	{ 0x00FF25, 0x000000, 0x00FF45, 0x000000 },
 2323|       |	{ 0x00FF26, 0x000000, 0x00FF46, 0x000000 },
 2324|       |	{ 0x00FF27, 0x000000, 0x00FF47, 0x000000 },
 2325|       |	{ 0x00FF28, 0x000000, 0x00FF48, 0x000000 },
 2326|       |	{ 0x00FF29, 0x000000, 0x00FF49, 0x000000 },
 2327|       |	{ 0x00FF2A, 0x000000, 0x00FF4A, 0x000000 },
 2328|       |	{ 0x00FF2B, 0x000000, 0x00FF4B, 0x000000 },
 2329|       |	{ 0x00FF2C, 0x000000, 0x00FF4C, 0x000000 },
 2330|       |	{ 0x00FF2D, 0x000000, 0x00FF4D, 0x000000 },
 2331|       |	{ 0x00FF2E, 0x000000, 0x00FF4E, 0x000000 },
 2332|       |	{ 0x00FF2F, 0x000000, 0x00FF4F, 0x000000 },
 2333|       |	{ 0x00FF30, 0x000000, 0x00FF50, 0x000000 },
 2334|       |	{ 0x00FF31, 0x000000, 0x00FF51, 0x000000 },
 2335|       |	{ 0x00FF32, 0x000000, 0x00FF52, 0x000000 },
 2336|       |	{ 0x00FF33, 0x000000, 0x00FF53, 0x000000 },
 2337|       |	{ 0x00FF34, 0x000000, 0x00FF54, 0x000000 },
 2338|       |	{ 0x00FF35, 0x000000, 0x00FF55, 0x000000 },
 2339|       |	{ 0x00FF36, 0x000000, 0x00FF56, 0x000000 },
 2340|       |	{ 0x00FF37, 0x000000, 0x00FF57, 0x000000 },
 2341|       |	{ 0x00FF38, 0x000000, 0x00FF58, 0x000000 },
 2342|       |	{ 0x00FF39, 0x000000, 0x00FF59, 0x000000 },
 2343|       |	{ 0x00FF3A, 0x000000, 0x00FF5A, 0x000000 },
 2344|       |	{ 0x00FF41, 0x00FF21, 0x000000, 0x00FF21 },
 2345|       |	{ 0x00FF42, 0x00FF22, 0x000000, 0x00FF22 },
 2346|       |	{ 0x00FF43, 0x00FF23, 0x000000, 0x00FF23 },
 2347|       |	{ 0x00FF44, 0x00FF24, 0x000000, 0x00FF24 },
 2348|       |	{ 0x00FF45, 0x00FF25, 0x000000, 0x00FF25 },
 2349|       |	{ 0x00FF46, 0x00FF26, 0x000000, 0x00FF26 },
 2350|       |	{ 0x00FF47, 0x00FF27, 0x000000, 0x00FF27 },
 2351|       |	{ 0x00FF48, 0x00FF28, 0x000000, 0x00FF28 },
 2352|       |	{ 0x00FF49, 0x00FF29, 0x000000, 0x00FF29 },
 2353|       |	{ 0x00FF4A, 0x00FF2A, 0x000000, 0x00FF2A },
 2354|       |	{ 0x00FF4B, 0x00FF2B, 0x000000, 0x00FF2B },
 2355|       |	{ 0x00FF4C, 0x00FF2C, 0x000000, 0x00FF2C },
 2356|       |	{ 0x00FF4D, 0x00FF2D, 0x000000, 0x00FF2D },
 2357|       |	{ 0x00FF4E, 0x00FF2E, 0x000000, 0x00FF2E },
 2358|       |	{ 0x00FF4F, 0x00FF2F, 0x000000, 0x00FF2F },
 2359|       |	{ 0x00FF50, 0x00FF30, 0x000000, 0x00FF30 },
 2360|       |	{ 0x00FF51, 0x00FF31, 0x000000, 0x00FF31 },
 2361|       |	{ 0x00FF52, 0x00FF32, 0x000000, 0x00FF32 },
 2362|       |	{ 0x00FF53, 0x00FF33, 0x000000, 0x00FF33 },
 2363|       |	{ 0x00FF54, 0x00FF34, 0x000000, 0x00FF34 },
 2364|       |	{ 0x00FF55, 0x00FF35, 0x000000, 0x00FF35 },
 2365|       |	{ 0x00FF56, 0x00FF36, 0x000000, 0x00FF36 },
 2366|       |	{ 0x00FF57, 0x00FF37, 0x000000, 0x00FF37 },
 2367|       |	{ 0x00FF58, 0x00FF38, 0x000000, 0x00FF38 },
 2368|       |	{ 0x00FF59, 0x00FF39, 0x000000, 0x00FF39 },
 2369|       |	{ 0x00FF5A, 0x00FF3A, 0x000000, 0x00FF3A },
 2370|       |	{ 0x010400, 0x000000, 0x010428, 0x000000 },
 2371|       |	{ 0x010401, 0x000000, 0x010429, 0x000000 },
 2372|       |	{ 0x010402, 0x000000, 0x01042A, 0x000000 },
 2373|       |	{ 0x010403, 0x000000, 0x01042B, 0x000000 },
 2374|       |	{ 0x010404, 0x000000, 0x01042C, 0x000000 },
 2375|       |	{ 0x010405, 0x000000, 0x01042D, 0x000000 },
 2376|       |	{ 0x010406, 0x000000, 0x01042E, 0x000000 },
 2377|       |	{ 0x010407, 0x000000, 0x01042F, 0x000000 },
 2378|       |	{ 0x010408, 0x000000, 0x010430, 0x000000 },
 2379|       |	{ 0x010409, 0x000000, 0x010431, 0x000000 },
 2380|       |	{ 0x01040A, 0x000000, 0x010432, 0x000000 },
 2381|       |	{ 0x01040B, 0x000000, 0x010433, 0x000000 },
 2382|       |	{ 0x01040C, 0x000000, 0x010434, 0x000000 },
 2383|       |	{ 0x01040D, 0x000000, 0x010435, 0x000000 },
 2384|       |	{ 0x01040E, 0x000000, 0x010436, 0x000000 },
 2385|       |	{ 0x01040F, 0x000000, 0x010437, 0x000000 },
 2386|       |	{ 0x010410, 0x000000, 0x010438, 0x000000 },
 2387|       |	{ 0x010411, 0x000000, 0x010439, 0x000000 },
 2388|       |	{ 0x010412, 0x000000, 0x01043A, 0x000000 },
 2389|       |	{ 0x010413, 0x000000, 0x01043B, 0x000000 },
 2390|       |	{ 0x010414, 0x000000, 0x01043C, 0x000000 },
 2391|       |	{ 0x010415, 0x000000, 0x01043D, 0x000000 },
 2392|       |	{ 0x010416, 0x000000, 0x01043E, 0x000000 },
 2393|       |	{ 0x010417, 0x000000, 0x01043F, 0x000000 },
 2394|       |	{ 0x010418, 0x000000, 0x010440, 0x000000 },
 2395|       |	{ 0x010419, 0x000000, 0x010441, 0x000000 },
 2396|       |	{ 0x01041A, 0x000000, 0x010442, 0x000000 },
 2397|       |	{ 0x01041B, 0x000000, 0x010443, 0x000000 },
 2398|       |	{ 0x01041C, 0x000000, 0x010444, 0x000000 },
 2399|       |	{ 0x01041D, 0x000000, 0x010445, 0x000000 },
 2400|       |	{ 0x01041E, 0x000000, 0x010446, 0x000000 },
 2401|       |	{ 0x01041F, 0x000000, 0x010447, 0x000000 },
 2402|       |	{ 0x010420, 0x000000, 0x010448, 0x000000 },
 2403|       |	{ 0x010421, 0x000000, 0x010449, 0x000000 },
 2404|       |	{ 0x010422, 0x000000, 0x01044A, 0x000000 },
 2405|       |	{ 0x010423, 0x000000, 0x01044B, 0x000000 },
 2406|       |	{ 0x010424, 0x000000, 0x01044C, 0x000000 },
 2407|       |	{ 0x010425, 0x000000, 0x01044D, 0x000000 },
 2408|       |	{ 0x010426, 0x000000, 0x01044E, 0x000000 },
 2409|       |	{ 0x010427, 0x000000, 0x01044F, 0x000000 },
 2410|       |	{ 0x010428, 0x010400, 0x000000, 0x010400 },
 2411|       |	{ 0x010429, 0x010401, 0x000000, 0x010401 },
 2412|       |	{ 0x01042A, 0x010402, 0x000000, 0x010402 },
 2413|       |	{ 0x01042B, 0x010403, 0x000000, 0x010403 },
 2414|       |	{ 0x01042C, 0x010404, 0x000000, 0x010404 },
 2415|       |	{ 0x01042D, 0x010405, 0x000000, 0x010405 },
 2416|       |	{ 0x01042E, 0x010406, 0x000000, 0x010406 },
 2417|       |	{ 0x01042F, 0x010407, 0x000000, 0x010407 },
 2418|       |	{ 0x010430, 0x010408, 0x000000, 0x010408 },
 2419|       |	{ 0x010431, 0x010409, 0x000000, 0x010409 },
 2420|       |	{ 0x010432, 0x01040A, 0x000000, 0x01040A },
 2421|       |	{ 0x010433, 0x01040B, 0x000000, 0x01040B },
 2422|       |	{ 0x010434, 0x01040C, 0x000000, 0x01040C },
 2423|       |	{ 0x010435, 0x01040D, 0x000000, 0x01040D },
 2424|       |	{ 0x010436, 0x01040E, 0x000000, 0x01040E },
 2425|       |	{ 0x010437, 0x01040F, 0x000000, 0x01040F },
 2426|       |	{ 0x010438, 0x010410, 0x000000, 0x010410 },
 2427|       |	{ 0x010439, 0x010411, 0x000000, 0x010411 },
 2428|       |	{ 0x01043A, 0x010412, 0x000000, 0x010412 },
 2429|       |	{ 0x01043B, 0x010413, 0x000000, 0x010413 },
 2430|       |	{ 0x01043C, 0x010414, 0x000000, 0x010414 },
 2431|       |	{ 0x01043D, 0x010415, 0x000000, 0x010415 },
 2432|       |	{ 0x01043E, 0x010416, 0x000000, 0x010416 },
 2433|       |	{ 0x01043F, 0x010417, 0x000000, 0x010417 },
 2434|       |	{ 0x010440, 0x010418, 0x000000, 0x010418 },
 2435|       |	{ 0x010441, 0x010419, 0x000000, 0x010419 },
 2436|       |	{ 0x010442, 0x01041A, 0x000000, 0x01041A },
 2437|       |	{ 0x010443, 0x01041B, 0x000000, 0x01041B },
 2438|       |	{ 0x010444, 0x01041C, 0x000000, 0x01041C },
 2439|       |	{ 0x010445, 0x01041D, 0x000000, 0x01041D },
 2440|       |	{ 0x010446, 0x01041E, 0x000000, 0x01041E },
 2441|       |	{ 0x010447, 0x01041F, 0x000000, 0x01041F },
 2442|       |	{ 0x010448, 0x010420, 0x000000, 0x010420 },
 2443|       |	{ 0x010449, 0x010421, 0x000000, 0x010421 },
 2444|       |	{ 0x01044A, 0x010422, 0x000000, 0x010422 },
 2445|       |	{ 0x01044B, 0x010423, 0x000000, 0x010423 },
 2446|       |	{ 0x01044C, 0x010424, 0x000000, 0x010424 },
 2447|       |	{ 0x01044D, 0x010425, 0x000000, 0x010425 },
 2448|       |	{ 0x01044E, 0x010426, 0x000000, 0x010426 },
 2449|       |	{ 0x01044F, 0x010427, 0x000000, 0x010427 },
 2450|       |	{ 0x0104B0, 0x000000, 0x0104D8, 0x000000 },
 2451|       |	{ 0x0104B1, 0x000000, 0x0104D9, 0x000000 },
 2452|       |	{ 0x0104B2, 0x000000, 0x0104DA, 0x000000 },
 2453|       |	{ 0x0104B3, 0x000000, 0x0104DB, 0x000000 },
 2454|       |	{ 0x0104B4, 0x000000, 0x0104DC, 0x000000 },
 2455|       |	{ 0x0104B5, 0x000000, 0x0104DD, 0x000000 },
 2456|       |	{ 0x0104B6, 0x000000, 0x0104DE, 0x000000 },
 2457|       |	{ 0x0104B7, 0x000000, 0x0104DF, 0x000000 },
 2458|       |	{ 0x0104B8, 0x000000, 0x0104E0, 0x000000 },
 2459|       |	{ 0x0104B9, 0x000000, 0x0104E1, 0x000000 },
 2460|       |	{ 0x0104BA, 0x000000, 0x0104E2, 0x000000 },
 2461|       |	{ 0x0104BB, 0x000000, 0x0104E3, 0x000000 },
 2462|       |	{ 0x0104BC, 0x000000, 0x0104E4, 0x000000 },
 2463|       |	{ 0x0104BD, 0x000000, 0x0104E5, 0x000000 },
 2464|       |	{ 0x0104BE, 0x000000, 0x0104E6, 0x000000 },
 2465|       |	{ 0x0104BF, 0x000000, 0x0104E7, 0x000000 },
 2466|       |	{ 0x0104C0, 0x000000, 0x0104E8, 0x000000 },
 2467|       |	{ 0x0104C1, 0x000000, 0x0104E9, 0x000000 },
 2468|       |	{ 0x0104C2, 0x000000, 0x0104EA, 0x000000 },
 2469|       |	{ 0x0104C3, 0x000000, 0x0104EB, 0x000000 },
 2470|       |	{ 0x0104C4, 0x000000, 0x0104EC, 0x000000 },
 2471|       |	{ 0x0104C5, 0x000000, 0x0104ED, 0x000000 },
 2472|       |	{ 0x0104C6, 0x000000, 0x0104EE, 0x000000 },
 2473|       |	{ 0x0104C7, 0x000000, 0x0104EF, 0x000000 },
 2474|       |	{ 0x0104C8, 0x000000, 0x0104F0, 0x000000 },
 2475|       |	{ 0x0104C9, 0x000000, 0x0104F1, 0x000000 },
 2476|       |	{ 0x0104CA, 0x000000, 0x0104F2, 0x000000 },
 2477|       |	{ 0x0104CB, 0x000000, 0x0104F3, 0x000000 },
 2478|       |	{ 0x0104CC, 0x000000, 0x0104F4, 0x000000 },
 2479|       |	{ 0x0104CD, 0x000000, 0x0104F5, 0x000000 },
 2480|       |	{ 0x0104CE, 0x000000, 0x0104F6, 0x000000 },
 2481|       |	{ 0x0104CF, 0x000000, 0x0104F7, 0x000000 },
 2482|       |	{ 0x0104D0, 0x000000, 0x0104F8, 0x000000 },
 2483|       |	{ 0x0104D1, 0x000000, 0x0104F9, 0x000000 },
 2484|       |	{ 0x0104D2, 0x000000, 0x0104FA, 0x000000 },
 2485|       |	{ 0x0104D3, 0x000000, 0x0104FB, 0x000000 },
 2486|       |	{ 0x0104D8, 0x0104B0, 0x000000, 0x0104B0 },
 2487|       |	{ 0x0104D9, 0x0104B1, 0x000000, 0x0104B1 },
 2488|       |	{ 0x0104DA, 0x0104B2, 0x000000, 0x0104B2 },
 2489|       |	{ 0x0104DB, 0x0104B3, 0x000000, 0x0104B3 },
 2490|       |	{ 0x0104DC, 0x0104B4, 0x000000, 0x0104B4 },
 2491|       |	{ 0x0104DD, 0x0104B5, 0x000000, 0x0104B5 },
 2492|       |	{ 0x0104DE, 0x0104B6, 0x000000, 0x0104B6 },
 2493|       |	{ 0x0104DF, 0x0104B7, 0x000000, 0x0104B7 },
 2494|       |	{ 0x0104E0, 0x0104B8, 0x000000, 0x0104B8 },
 2495|       |	{ 0x0104E1, 0x0104B9, 0x000000, 0x0104B9 },
 2496|       |	{ 0x0104E2, 0x0104BA, 0x000000, 0x0104BA },
 2497|       |	{ 0x0104E3, 0x0104BB, 0x000000, 0x0104BB },
 2498|       |	{ 0x0104E4, 0x0104BC, 0x000000, 0x0104BC },
 2499|       |	{ 0x0104E5, 0x0104BD, 0x000000, 0x0104BD },
 2500|       |	{ 0x0104E6, 0x0104BE, 0x000000, 0x0104BE },
 2501|       |	{ 0x0104E7, 0x0104BF, 0x000000, 0x0104BF },
 2502|       |	{ 0x0104E8, 0x0104C0, 0x000000, 0x0104C0 },
 2503|       |	{ 0x0104E9, 0x0104C1, 0x000000, 0x0104C1 },
 2504|       |	{ 0x0104EA, 0x0104C2, 0x000000, 0x0104C2 },
 2505|       |	{ 0x0104EB, 0x0104C3, 0x000000, 0x0104C3 },
 2506|       |	{ 0x0104EC, 0x0104C4, 0x000000, 0x0104C4 },
 2507|       |	{ 0x0104ED, 0x0104C5, 0x000000, 0x0104C5 },
 2508|       |	{ 0x0104EE, 0x0104C6, 0x000000, 0x0104C6 },
 2509|       |	{ 0x0104EF, 0x0104C7, 0x000000, 0x0104C7 },
 2510|       |	{ 0x0104F0, 0x0104C8, 0x000000, 0x0104C8 },
 2511|       |	{ 0x0104F1, 0x0104C9, 0x000000, 0x0104C9 },
 2512|       |	{ 0x0104F2, 0x0104CA, 0x000000, 0x0104CA },
 2513|       |	{ 0x0104F3, 0x0104CB, 0x000000, 0x0104CB },
 2514|       |	{ 0x0104F4, 0x0104CC, 0x000000, 0x0104CC },
 2515|       |	{ 0x0104F5, 0x0104CD, 0x000000, 0x0104CD },
 2516|       |	{ 0x0104F6, 0x0104CE, 0x000000, 0x0104CE },
 2517|       |	{ 0x0104F7, 0x0104CF, 0x000000, 0x0104CF },
 2518|       |	{ 0x0104F8, 0x0104D0, 0x000000, 0x0104D0 },
 2519|       |	{ 0x0104F9, 0x0104D1, 0x000000, 0x0104D1 },
 2520|       |	{ 0x0104FA, 0x0104D2, 0x000000, 0x0104D2 },
 2521|       |	{ 0x0104FB, 0x0104D3, 0x000000, 0x0104D3 },
 2522|       |	{ 0x010C80, 0x000000, 0x010CC0, 0x000000 },
 2523|       |	{ 0x010C81, 0x000000, 0x010CC1, 0x000000 },
 2524|       |	{ 0x010C82, 0x000000, 0x010CC2, 0x000000 },
 2525|       |	{ 0x010C83, 0x000000, 0x010CC3, 0x000000 },
 2526|       |	{ 0x010C84, 0x000000, 0x010CC4, 0x000000 },
 2527|       |	{ 0x010C85, 0x000000, 0x010CC5, 0x000000 },
 2528|       |	{ 0x010C86, 0x000000, 0x010CC6, 0x000000 },
 2529|       |	{ 0x010C87, 0x000000, 0x010CC7, 0x000000 },
 2530|       |	{ 0x010C88, 0x000000, 0x010CC8, 0x000000 },
 2531|       |	{ 0x010C89, 0x000000, 0x010CC9, 0x000000 },
 2532|       |	{ 0x010C8A, 0x000000, 0x010CCA, 0x000000 },
 2533|       |	{ 0x010C8B, 0x000000, 0x010CCB, 0x000000 },
 2534|       |	{ 0x010C8C, 0x000000, 0x010CCC, 0x000000 },
 2535|       |	{ 0x010C8D, 0x000000, 0x010CCD, 0x000000 },
 2536|       |	{ 0x010C8E, 0x000000, 0x010CCE, 0x000000 },
 2537|       |	{ 0x010C8F, 0x000000, 0x010CCF, 0x000000 },
 2538|       |	{ 0x010C90, 0x000000, 0x010CD0, 0x000000 },
 2539|       |	{ 0x010C91, 0x000000, 0x010CD1, 0x000000 },
 2540|       |	{ 0x010C92, 0x000000, 0x010CD2, 0x000000 },
 2541|       |	{ 0x010C93, 0x000000, 0x010CD3, 0x000000 },
 2542|       |	{ 0x010C94, 0x000000, 0x010CD4, 0x000000 },
 2543|       |	{ 0x010C95, 0x000000, 0x010CD5, 0x000000 },
 2544|       |	{ 0x010C96, 0x000000, 0x010CD6, 0x000000 },
 2545|       |	{ 0x010C97, 0x000000, 0x010CD7, 0x000000 },
 2546|       |	{ 0x010C98, 0x000000, 0x010CD8, 0x000000 },
 2547|       |	{ 0x010C99, 0x000000, 0x010CD9, 0x000000 },
 2548|       |	{ 0x010C9A, 0x000000, 0x010CDA, 0x000000 },
 2549|       |	{ 0x010C9B, 0x000000, 0x010CDB, 0x000000 },
 2550|       |	{ 0x010C9C, 0x000000, 0x010CDC, 0x000000 },
 2551|       |	{ 0x010C9D, 0x000000, 0x010CDD, 0x000000 },
 2552|       |	{ 0x010C9E, 0x000000, 0x010CDE, 0x000000 },
 2553|       |	{ 0x010C9F, 0x000000, 0x010CDF, 0x000000 },
 2554|       |	{ 0x010CA0, 0x000000, 0x010CE0, 0x000000 },
 2555|       |	{ 0x010CA1, 0x000000, 0x010CE1, 0x000000 },
 2556|       |	{ 0x010CA2, 0x000000, 0x010CE2, 0x000000 },
 2557|       |	{ 0x010CA3, 0x000000, 0x010CE3, 0x000000 },
 2558|       |	{ 0x010CA4, 0x000000, 0x010CE4, 0x000000 },
 2559|       |	{ 0x010CA5, 0x000000, 0x010CE5, 0x000000 },
 2560|       |	{ 0x010CA6, 0x000000, 0x010CE6, 0x000000 },
 2561|       |	{ 0x010CA7, 0x000000, 0x010CE7, 0x000000 },
 2562|       |	{ 0x010CA8, 0x000000, 0x010CE8, 0x000000 },
 2563|       |	{ 0x010CA9, 0x000000, 0x010CE9, 0x000000 },
 2564|       |	{ 0x010CAA, 0x000000, 0x010CEA, 0x000000 },
 2565|       |	{ 0x010CAB, 0x000000, 0x010CEB, 0x000000 },
 2566|       |	{ 0x010CAC, 0x000000, 0x010CEC, 0x000000 },
 2567|       |	{ 0x010CAD, 0x000000, 0x010CED, 0x000000 },
 2568|       |	{ 0x010CAE, 0x000000, 0x010CEE, 0x000000 },
 2569|       |	{ 0x010CAF, 0x000000, 0x010CEF, 0x000000 },
 2570|       |	{ 0x010CB0, 0x000000, 0x010CF0, 0x000000 },
 2571|       |	{ 0x010CB1, 0x000000, 0x010CF1, 0x000000 },
 2572|       |	{ 0x010CB2, 0x000000, 0x010CF2, 0x000000 },
 2573|       |	{ 0x010CC0, 0x010C80, 0x000000, 0x010C80 },
 2574|       |	{ 0x010CC1, 0x010C81, 0x000000, 0x010C81 },
 2575|       |	{ 0x010CC2, 0x010C82, 0x000000, 0x010C82 },
 2576|       |	{ 0x010CC3, 0x010C83, 0x000000, 0x010C83 },
 2577|       |	{ 0x010CC4, 0x010C84, 0x000000, 0x010C84 },
 2578|       |	{ 0x010CC5, 0x010C85, 0x000000, 0x010C85 },
 2579|       |	{ 0x010CC6, 0x010C86, 0x000000, 0x010C86 },
 2580|       |	{ 0x010CC7, 0x010C87, 0x000000, 0x010C87 },
 2581|       |	{ 0x010CC8, 0x010C88, 0x000000, 0x010C88 },
 2582|       |	{ 0x010CC9, 0x010C89, 0x000000, 0x010C89 },
 2583|       |	{ 0x010CCA, 0x010C8A, 0x000000, 0x010C8A },
 2584|       |	{ 0x010CCB, 0x010C8B, 0x000000, 0x010C8B },
 2585|       |	{ 0x010CCC, 0x010C8C, 0x000000, 0x010C8C },
 2586|       |	{ 0x010CCD, 0x010C8D, 0x000000, 0x010C8D },
 2587|       |	{ 0x010CCE, 0x010C8E, 0x000000, 0x010C8E },
 2588|       |	{ 0x010CCF, 0x010C8F, 0x000000, 0x010C8F },
 2589|       |	{ 0x010CD0, 0x010C90, 0x000000, 0x010C90 },
 2590|       |	{ 0x010CD1, 0x010C91, 0x000000, 0x010C91 },
 2591|       |	{ 0x010CD2, 0x010C92, 0x000000, 0x010C92 },
 2592|       |	{ 0x010CD3, 0x010C93, 0x000000, 0x010C93 },
 2593|       |	{ 0x010CD4, 0x010C94, 0x000000, 0x010C94 },
 2594|       |	{ 0x010CD5, 0x010C95, 0x000000, 0x010C95 },
 2595|       |	{ 0x010CD6, 0x010C96, 0x000000, 0x010C96 },
 2596|       |	{ 0x010CD7, 0x010C97, 0x000000, 0x010C97 },
 2597|       |	{ 0x010CD8, 0x010C98, 0x000000, 0x010C98 },
 2598|       |	{ 0x010CD9, 0x010C99, 0x000000, 0x010C99 },
 2599|       |	{ 0x010CDA, 0x010C9A, 0x000000, 0x010C9A },
 2600|       |	{ 0x010CDB, 0x010C9B, 0x000000, 0x010C9B },
 2601|       |	{ 0x010CDC, 0x010C9C, 0x000000, 0x010C9C },
 2602|       |	{ 0x010CDD, 0x010C9D, 0x000000, 0x010C9D },
 2603|       |	{ 0x010CDE, 0x010C9E, 0x000000, 0x010C9E },
 2604|       |	{ 0x010CDF, 0x010C9F, 0x000000, 0x010C9F },
 2605|       |	{ 0x010CE0, 0x010CA0, 0x000000, 0x010CA0 },
 2606|       |	{ 0x010CE1, 0x010CA1, 0x000000, 0x010CA1 },
 2607|       |	{ 0x010CE2, 0x010CA2, 0x000000, 0x010CA2 },
 2608|       |	{ 0x010CE3, 0x010CA3, 0x000000, 0x010CA3 },
 2609|       |	{ 0x010CE4, 0x010CA4, 0x000000, 0x010CA4 },
 2610|       |	{ 0x010CE5, 0x010CA5, 0x000000, 0x010CA5 },
 2611|       |	{ 0x010CE6, 0x010CA6, 0x000000, 0x010CA6 },
 2612|       |	{ 0x010CE7, 0x010CA7, 0x000000, 0x010CA7 },
 2613|       |	{ 0x010CE8, 0x010CA8, 0x000000, 0x010CA8 },
 2614|       |	{ 0x010CE9, 0x010CA9, 0x000000, 0x010CA9 },
 2615|       |	{ 0x010CEA, 0x010CAA, 0x000000, 0x010CAA },
 2616|       |	{ 0x010CEB, 0x010CAB, 0x000000, 0x010CAB },
 2617|       |	{ 0x010CEC, 0x010CAC, 0x000000, 0x010CAC },
 2618|       |	{ 0x010CED, 0x010CAD, 0x000000, 0x010CAD },
 2619|       |	{ 0x010CEE, 0x010CAE, 0x000000, 0x010CAE },
 2620|       |	{ 0x010CEF, 0x010CAF, 0x000000, 0x010CAF },
 2621|       |	{ 0x010CF0, 0x010CB0, 0x000000, 0x010CB0 },
 2622|       |	{ 0x010CF1, 0x010CB1, 0x000000, 0x010CB1 },
 2623|       |	{ 0x010CF2, 0x010CB2, 0x000000, 0x010CB2 },
 2624|       |	{ 0x0118A0, 0x000000, 0x0118C0, 0x000000 },
 2625|       |	{ 0x0118A1, 0x000000, 0x0118C1, 0x000000 },
 2626|       |	{ 0x0118A2, 0x000000, 0x0118C2, 0x000000 },
 2627|       |	{ 0x0118A3, 0x000000, 0x0118C3, 0x000000 },
 2628|       |	{ 0x0118A4, 0x000000, 0x0118C4, 0x000000 },
 2629|       |	{ 0x0118A5, 0x000000, 0x0118C5, 0x000000 },
 2630|       |	{ 0x0118A6, 0x000000, 0x0118C6, 0x000000 },
 2631|       |	{ 0x0118A7, 0x000000, 0x0118C7, 0x000000 },
 2632|       |	{ 0x0118A8, 0x000000, 0x0118C8, 0x000000 },
 2633|       |	{ 0x0118A9, 0x000000, 0x0118C9, 0x000000 },
 2634|       |	{ 0x0118AA, 0x000000, 0x0118CA, 0x000000 },
 2635|       |	{ 0x0118AB, 0x000000, 0x0118CB, 0x000000 },
 2636|       |	{ 0x0118AC, 0x000000, 0x0118CC, 0x000000 },
 2637|       |	{ 0x0118AD, 0x000000, 0x0118CD, 0x000000 },
 2638|       |	{ 0x0118AE, 0x000000, 0x0118CE, 0x000000 },
 2639|       |	{ 0x0118AF, 0x000000, 0x0118CF, 0x000000 },
 2640|       |	{ 0x0118B0, 0x000000, 0x0118D0, 0x000000 },
 2641|       |	{ 0x0118B1, 0x000000, 0x0118D1, 0x000000 },
 2642|       |	{ 0x0118B2, 0x000000, 0x0118D2, 0x000000 },
 2643|       |	{ 0x0118B3, 0x000000, 0x0118D3, 0x000000 },
 2644|       |	{ 0x0118B4, 0x000000, 0x0118D4, 0x000000 },
 2645|       |	{ 0x0118B5, 0x000000, 0x0118D5, 0x000000 },
 2646|       |	{ 0x0118B6, 0x000000, 0x0118D6, 0x000000 },
 2647|       |	{ 0x0118B7, 0x000000, 0x0118D7, 0x000000 },
 2648|       |	{ 0x0118B8, 0x000000, 0x0118D8, 0x000000 },
 2649|       |	{ 0x0118B9, 0x000000, 0x0118D9, 0x000000 },
 2650|       |	{ 0x0118BA, 0x000000, 0x0118DA, 0x000000 },
 2651|       |	{ 0x0118BB, 0x000000, 0x0118DB, 0x000000 },
 2652|       |	{ 0x0118BC, 0x000000, 0x0118DC, 0x000000 },
 2653|       |	{ 0x0118BD, 0x000000, 0x0118DD, 0x000000 },
 2654|       |	{ 0x0118BE, 0x000000, 0x0118DE, 0x000000 },
 2655|       |	{ 0x0118BF, 0x000000, 0x0118DF, 0x000000 },
 2656|       |	{ 0x0118C0, 0x0118A0, 0x000000, 0x0118A0 },
 2657|       |	{ 0x0118C1, 0x0118A1, 0x000000, 0x0118A1 },
 2658|       |	{ 0x0118C2, 0x0118A2, 0x000000, 0x0118A2 },
 2659|       |	{ 0x0118C3, 0x0118A3, 0x000000, 0x0118A3 },
 2660|       |	{ 0x0118C4, 0x0118A4, 0x000000, 0x0118A4 },
 2661|       |	{ 0x0118C5, 0x0118A5, 0x000000, 0x0118A5 },
 2662|       |	{ 0x0118C6, 0x0118A6, 0x000000, 0x0118A6 },
 2663|       |	{ 0x0118C7, 0x0118A7, 0x000000, 0x0118A7 },
 2664|       |	{ 0x0118C8, 0x0118A8, 0x000000, 0x0118A8 },
 2665|       |	{ 0x0118C9, 0x0118A9, 0x000000, 0x0118A9 },
 2666|       |	{ 0x0118CA, 0x0118AA, 0x000000, 0x0118AA },
 2667|       |	{ 0x0118CB, 0x0118AB, 0x000000, 0x0118AB },
 2668|       |	{ 0x0118CC, 0x0118AC, 0x000000, 0x0118AC },
 2669|       |	{ 0x0118CD, 0x0118AD, 0x000000, 0x0118AD },
 2670|       |	{ 0x0118CE, 0x0118AE, 0x000000, 0x0118AE },
 2671|       |	{ 0x0118CF, 0x0118AF, 0x000000, 0x0118AF },
 2672|       |	{ 0x0118D0, 0x0118B0, 0x000000, 0x0118B0 },
 2673|       |	{ 0x0118D1, 0x0118B1, 0x000000, 0x0118B1 },
 2674|       |	{ 0x0118D2, 0x0118B2, 0x000000, 0x0118B2 },
 2675|       |	{ 0x0118D3, 0x0118B3, 0x000000, 0x0118B3 },
 2676|       |	{ 0x0118D4, 0x0118B4, 0x000000, 0x0118B4 },
 2677|       |	{ 0x0118D5, 0x0118B5, 0x000000, 0x0118B5 },
 2678|       |	{ 0x0118D6, 0x0118B6, 0x000000, 0x0118B6 },
 2679|       |	{ 0x0118D7, 0x0118B7, 0x000000, 0x0118B7 },
 2680|       |	{ 0x0118D8, 0x0118B8, 0x000000, 0x0118B8 },
 2681|       |	{ 0x0118D9, 0x0118B9, 0x000000, 0x0118B9 },
 2682|       |	{ 0x0118DA, 0x0118BA, 0x000000, 0x0118BA },
 2683|       |	{ 0x0118DB, 0x0118BB, 0x000000, 0x0118BB },
 2684|       |	{ 0x0118DC, 0x0118BC, 0x000000, 0x0118BC },
 2685|       |	{ 0x0118DD, 0x0118BD, 0x000000, 0x0118BD },
 2686|       |	{ 0x0118DE, 0x0118BE, 0x000000, 0x0118BE },
 2687|       |	{ 0x0118DF, 0x0118BF, 0x000000, 0x0118BF },
 2688|       |	{ 0x016E40, 0x000000, 0x016E60, 0x000000 },
 2689|       |	{ 0x016E41, 0x000000, 0x016E61, 0x000000 },
 2690|       |	{ 0x016E42, 0x000000, 0x016E62, 0x000000 },
 2691|       |	{ 0x016E43, 0x000000, 0x016E63, 0x000000 },
 2692|       |	{ 0x016E44, 0x000000, 0x016E64, 0x000000 },
 2693|       |	{ 0x016E45, 0x000000, 0x016E65, 0x000000 },
 2694|       |	{ 0x016E46, 0x000000, 0x016E66, 0x000000 },
 2695|       |	{ 0x016E47, 0x000000, 0x016E67, 0x000000 },
 2696|       |	{ 0x016E48, 0x000000, 0x016E68, 0x000000 },
 2697|       |	{ 0x016E49, 0x000000, 0x016E69, 0x000000 },
 2698|       |	{ 0x016E4A, 0x000000, 0x016E6A, 0x000000 },
 2699|       |	{ 0x016E4B, 0x000000, 0x016E6B, 0x000000 },
 2700|       |	{ 0x016E4C, 0x000000, 0x016E6C, 0x000000 },
 2701|       |	{ 0x016E4D, 0x000000, 0x016E6D, 0x000000 },
 2702|       |	{ 0x016E4E, 0x000000, 0x016E6E, 0x000000 },
 2703|       |	{ 0x016E4F, 0x000000, 0x016E6F, 0x000000 },
 2704|       |	{ 0x016E50, 0x000000, 0x016E70, 0x000000 },
 2705|       |	{ 0x016E51, 0x000000, 0x016E71, 0x000000 },
 2706|       |	{ 0x016E52, 0x000000, 0x016E72, 0x000000 },
 2707|       |	{ 0x016E53, 0x000000, 0x016E73, 0x000000 },
 2708|       |	{ 0x016E54, 0x000000, 0x016E74, 0x000000 },
 2709|       |	{ 0x016E55, 0x000000, 0x016E75, 0x000000 },
 2710|       |	{ 0x016E56, 0x000000, 0x016E76, 0x000000 },
 2711|       |	{ 0x016E57, 0x000000, 0x016E77, 0x000000 },
 2712|       |	{ 0x016E58, 0x000000, 0x016E78, 0x000000 },
 2713|       |	{ 0x016E59, 0x000000, 0x016E79, 0x000000 },
 2714|       |	{ 0x016E5A, 0x000000, 0x016E7A, 0x000000 },
 2715|       |	{ 0x016E5B, 0x000000, 0x016E7B, 0x000000 },
 2716|       |	{ 0x016E5C, 0x000000, 0x016E7C, 0x000000 },
 2717|       |	{ 0x016E5D, 0x000000, 0x016E7D, 0x000000 },
 2718|       |	{ 0x016E5E, 0x000000, 0x016E7E, 0x000000 },
 2719|       |	{ 0x016E5F, 0x000000, 0x016E7F, 0x000000 },
 2720|       |	{ 0x016E60, 0x016E40, 0x000000, 0x016E40 },
 2721|       |	{ 0x016E61, 0x016E41, 0x000000, 0x016E41 },
 2722|       |	{ 0x016E62, 0x016E42, 0x000000, 0x016E42 },
 2723|       |	{ 0x016E63, 0x016E43, 0x000000, 0x016E43 },
 2724|       |	{ 0x016E64, 0x016E44, 0x000000, 0x016E44 },
 2725|       |	{ 0x016E65, 0x016E45, 0x000000, 0x016E45 },
 2726|       |	{ 0x016E66, 0x016E46, 0x000000, 0x016E46 },
 2727|       |	{ 0x016E67, 0x016E47, 0x000000, 0x016E47 },
 2728|       |	{ 0x016E68, 0x016E48, 0x000000, 0x016E48 },
 2729|       |	{ 0x016E69, 0x016E49, 0x000000, 0x016E49 },
 2730|       |	{ 0x016E6A, 0x016E4A, 0x000000, 0x016E4A },
 2731|       |	{ 0x016E6B, 0x016E4B, 0x000000, 0x016E4B },
 2732|       |	{ 0x016E6C, 0x016E4C, 0x000000, 0x016E4C },
 2733|       |	{ 0x016E6D, 0x016E4D, 0x000000, 0x016E4D },
 2734|       |	{ 0x016E6E, 0x016E4E, 0x000000, 0x016E4E },
 2735|       |	{ 0x016E6F, 0x016E4F, 0x000000, 0x016E4F },
 2736|       |	{ 0x016E70, 0x016E50, 0x000000, 0x016E50 },
 2737|       |	{ 0x016E71, 0x016E51, 0x000000, 0x016E51 },
 2738|       |	{ 0x016E72, 0x016E52, 0x000000, 0x016E52 },
 2739|       |	{ 0x016E73, 0x016E53, 0x000000, 0x016E53 },
 2740|       |	{ 0x016E74, 0x016E54, 0x000000, 0x016E54 },
 2741|       |	{ 0x016E75, 0x016E55, 0x000000, 0x016E55 },
 2742|       |	{ 0x016E76, 0x016E56, 0x000000, 0x016E56 },
 2743|       |	{ 0x016E77, 0x016E57, 0x000000, 0x016E57 },
 2744|       |	{ 0x016E78, 0x016E58, 0x000000, 0x016E58 },
 2745|       |	{ 0x016E79, 0x016E59, 0x000000, 0x016E59 },
 2746|       |	{ 0x016E7A, 0x016E5A, 0x000000, 0x016E5A },
 2747|       |	{ 0x016E7B, 0x016E5B, 0x000000, 0x016E5B },
 2748|       |	{ 0x016E7C, 0x016E5C, 0x000000, 0x016E5C },
 2749|       |	{ 0x016E7D, 0x016E5D, 0x000000, 0x016E5D },
 2750|       |	{ 0x016E7E, 0x016E5E, 0x000000, 0x016E5E },
 2751|       |	{ 0x016E7F, 0x016E5F, 0x000000, 0x016E5F },
 2752|       |	{ 0x01E900, 0x000000, 0x01E922, 0x000000 },
 2753|       |	{ 0x01E901, 0x000000, 0x01E923, 0x000000 },
 2754|       |	{ 0x01E902, 0x000000, 0x01E924, 0x000000 },
 2755|       |	{ 0x01E903, 0x000000, 0x01E925, 0x000000 },
 2756|       |	{ 0x01E904, 0x000000, 0x01E926, 0x000000 },
 2757|       |	{ 0x01E905, 0x000000, 0x01E927, 0x000000 },
 2758|       |	{ 0x01E906, 0x000000, 0x01E928, 0x000000 },
 2759|       |	{ 0x01E907, 0x000000, 0x01E929, 0x000000 },
 2760|       |	{ 0x01E908, 0x000000, 0x01E92A, 0x000000 },
 2761|       |	{ 0x01E909, 0x000000, 0x01E92B, 0x000000 },
 2762|       |	{ 0x01E90A, 0x000000, 0x01E92C, 0x000000 },
 2763|       |	{ 0x01E90B, 0x000000, 0x01E92D, 0x000000 },
 2764|       |	{ 0x01E90C, 0x000000, 0x01E92E, 0x000000 },
 2765|       |	{ 0x01E90D, 0x000000, 0x01E92F, 0x000000 },
 2766|       |	{ 0x01E90E, 0x000000, 0x01E930, 0x000000 },
 2767|       |	{ 0x01E90F, 0x000000, 0x01E931, 0x000000 },
 2768|       |	{ 0x01E910, 0x000000, 0x01E932, 0x000000 },
 2769|       |	{ 0x01E911, 0x000000, 0x01E933, 0x000000 },
 2770|       |	{ 0x01E912, 0x000000, 0x01E934, 0x000000 },
 2771|       |	{ 0x01E913, 0x000000, 0x01E935, 0x000000 },
 2772|       |	{ 0x01E914, 0x000000, 0x01E936, 0x000000 },
 2773|       |	{ 0x01E915, 0x000000, 0x01E937, 0x000000 },
 2774|       |	{ 0x01E916, 0x000000, 0x01E938, 0x000000 },
 2775|       |	{ 0x01E917, 0x000000, 0x01E939, 0x000000 },
 2776|       |	{ 0x01E918, 0x000000, 0x01E93A, 0x000000 },
 2777|       |	{ 0x01E919, 0x000000, 0x01E93B, 0x000000 },
 2778|       |	{ 0x01E91A, 0x000000, 0x01E93C, 0x000000 },
 2779|       |	{ 0x01E91B, 0x000000, 0x01E93D, 0x000000 },
 2780|       |	{ 0x01E91C, 0x000000, 0x01E93E, 0x000000 },
 2781|       |	{ 0x01E91D, 0x000000, 0x01E93F, 0x000000 },
 2782|       |	{ 0x01E91E, 0x000000, 0x01E940, 0x000000 },
 2783|       |	{ 0x01E91F, 0x000000, 0x01E941, 0x000000 },
 2784|       |	{ 0x01E920, 0x000000, 0x01E942, 0x000000 },
 2785|       |	{ 0x01E921, 0x000000, 0x01E943, 0x000000 },
 2786|       |	{ 0x01E922, 0x01E900, 0x000000, 0x01E900 },
 2787|       |	{ 0x01E923, 0x01E901, 0x000000, 0x01E901 },
 2788|       |	{ 0x01E924, 0x01E902, 0x000000, 0x01E902 },
 2789|       |	{ 0x01E925, 0x01E903, 0x000000, 0x01E903 },
 2790|       |	{ 0x01E926, 0x01E904, 0x000000, 0x01E904 },
 2791|       |	{ 0x01E927, 0x01E905, 0x000000, 0x01E905 },
 2792|       |	{ 0x01E928, 0x01E906, 0x000000, 0x01E906 },
 2793|       |	{ 0x01E929, 0x01E907, 0x000000, 0x01E907 },
 2794|       |	{ 0x01E92A, 0x01E908, 0x000000, 0x01E908 },
 2795|       |	{ 0x01E92B, 0x01E909, 0x000000, 0x01E909 },
 2796|       |	{ 0x01E92C, 0x01E90A, 0x000000, 0x01E90A },
 2797|       |	{ 0x01E92D, 0x01E90B, 0x000000, 0x01E90B },
 2798|       |	{ 0x01E92E, 0x01E90C, 0x000000, 0x01E90C },
 2799|       |	{ 0x01E92F, 0x01E90D, 0x000000, 0x01E90D },
 2800|       |	{ 0x01E930, 0x01E90E, 0x000000, 0x01E90E },
 2801|       |	{ 0x01E931, 0x01E90F, 0x000000, 0x01E90F },
 2802|       |	{ 0x01E932, 0x01E910, 0x000000, 0x01E910 },
 2803|       |	{ 0x01E933, 0x01E911, 0x000000, 0x01E911 },
 2804|       |	{ 0x01E934, 0x01E912, 0x000000, 0x01E912 },
 2805|       |	{ 0x01E935, 0x01E913, 0x000000, 0x01E913 },
 2806|       |	{ 0x01E936, 0x01E914, 0x000000, 0x01E914 },
 2807|       |	{ 0x01E937, 0x01E915, 0x000000, 0x01E915 },
 2808|       |	{ 0x01E938, 0x01E916, 0x000000, 0x01E916 },
 2809|       |	{ 0x01E939, 0x01E917, 0x000000, 0x01E917 },
 2810|       |	{ 0x01E93A, 0x01E918, 0x000000, 0x01E918 },
 2811|       |	{ 0x01E93B, 0x01E919, 0x000000, 0x01E919 },
 2812|       |	{ 0x01E93C, 0x01E91A, 0x000000, 0x01E91A },
 2813|       |	{ 0x01E93D, 0x01E91B, 0x000000, 0x01E91B },
 2814|       |	{ 0x01E93E, 0x01E91C, 0x000000, 0x01E91C },
 2815|       |	{ 0x01E93F, 0x01E91D, 0x000000, 0x01E91D },
 2816|       |	{ 0x01E940, 0x01E91E, 0x000000, 0x01E91E },
 2817|       |	{ 0x01E941, 0x01E91F, 0x000000, 0x01E91F },
 2818|       |	{ 0x01E942, 0x01E920, 0x000000, 0x01E920 },
 2819|       |	{ 0x01E943, 0x01E921, 0x000000, 0x01E921 },
 2820|       |};
 2821|       |
 2822|       |codepoint_t ucd_toupper(codepoint_t c)
 2823|      0|{
 2824|      0|	int begin = 0;
 2825|      0|	int end   = sizeof(case_conversion_data)/sizeof(case_conversion_data[0]) - 1;
 2826|      0|	while (begin <= end)
 2827|      0|	{
 2828|      0|		int pos = (begin + end) / 2;
 2829|      0|		const struct case_conversion_entry *item = (case_conversion_data + pos);
 2830|      0|		if (c == item->codepoint)
 2831|      0|			return item->uppercase == 0 ? c : item->uppercase;
 2832|      0|		else if (c > item->codepoint)
 2833|      0|			begin = pos + 1;
 2834|      0|		else
 2835|      0|			end = pos - 1;
 2836|      0|	}
 2837|      0|	return c;
 2838|      0|}
 2839|       |
 2840|       |codepoint_t ucd_tolower(codepoint_t c)
 2841|      0|{
 2842|      0|	int begin = 0;
 2843|      0|	int end   = sizeof(case_conversion_data)/sizeof(case_conversion_data[0]) - 1;
 2844|      0|	while (begin <= end)
 2845|      0|	{
 2846|      0|		int pos = (begin + end) / 2;
 2847|      0|		const struct case_conversion_entry *item = (case_conversion_data + pos);
 2848|      0|		if (c == item->codepoint)
 2849|      0|			return item->lowercase == 0 ? c : item->lowercase;
 2850|      0|		else if (c > item->codepoint)
 2851|      0|			begin = pos + 1;
 2852|      0|		else
 2853|      0|			end = pos - 1;
 2854|      0|	}
 2855|      0|	return c;
 2856|      0|}
 2857|       |
 2858|       |codepoint_t ucd_totitle(codepoint_t c)
 2859|      0|{
 2860|      0|	int begin = 0;
 2861|      0|	int end   = sizeof(case_conversion_data)/sizeof(case_conversion_data[0]) - 1;
 2862|      0|	while (begin <= end)
 2863|      0|	{
 2864|      0|		int pos = (begin + end) / 2;
 2865|      0|		const struct case_conversion_entry *item = (case_conversion_data + pos);
 2866|      0|		if (c == item->codepoint)
 2867|      0|			return item->titlecase == 0 ? c : item->titlecase;
 2868|      0|		else if (c > item->codepoint)
 2869|      0|			begin = pos + 1;
 2870|      0|		else
 2871|      0|			end = pos - 1;
 2872|      0|	}
 2873|      0|	return c;
 2874|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/ucd-tools/src/categories.c:
    1|       |/* Unicode General Categories
    2|       | *
    3|       | * Copyright (C) 2012-2018 Reece H. Dunn
    4|       | *
    5|       | * This file is part of ucd-tools.
    6|       | *
    7|       | * ucd-tools is free software: you can redistribute it and/or modify
    8|       | * it under the terms of the GNU General Public License as published by
    9|       | * the Free Software Foundation, either version 3 of the License, or
   10|       | * (at your option) any later version.
   11|       | *
   12|       | * ucd-tools is distributed in the hope that it will be useful,
   13|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   14|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   15|       | * GNU General Public License for more details.
   16|       | *
   17|       | * You should have received a copy of the GNU General Public License
   18|       | * along with ucd-tools.  If not, see <http://www.gnu.org/licenses/>.
   19|       | */
   20|       |
   21|       |/* NOTE: This file is automatically generated from the UnicodeData.txt file in
   22|       | * the Unicode Character database by the ucd-tools/tools/categories.py script.
   23|       | */
   24|       |
   25|       |#include "ucd/ucd.h"
   26|       |
   27|       |#include <stddef.h>
   28|       |
   29|      0|#define Cc UCD_CATEGORY_Cc
   30|      0|#define Cf UCD_CATEGORY_Cf
   31|      0|#define Cn UCD_CATEGORY_Cn
   32|      0|#define Co UCD_CATEGORY_Co
   33|      0|#define Cs UCD_CATEGORY_Cs
   34|      0|#define Ll UCD_CATEGORY_Ll
   35|      0|#define Lm UCD_CATEGORY_Lm
   36|      0|#define Lo UCD_CATEGORY_Lo
   37|      0|#define Lt UCD_CATEGORY_Lt
   38|      0|#define Lu UCD_CATEGORY_Lu
   39|      0|#define Mc UCD_CATEGORY_Mc
   40|      0|#define Me UCD_CATEGORY_Me
   41|      0|#define Mn UCD_CATEGORY_Mn
   42|      0|#define Nd UCD_CATEGORY_Nd
   43|      0|#define Nl UCD_CATEGORY_Nl
   44|      0|#define No UCD_CATEGORY_No
   45|      0|#define Pc UCD_CATEGORY_Pc
   46|      0|#define Pd UCD_CATEGORY_Pd
   47|      0|#define Pe UCD_CATEGORY_Pe
   48|      0|#define Pf UCD_CATEGORY_Pf
   49|      0|#define Pi UCD_CATEGORY_Pi
   50|      0|#define Po UCD_CATEGORY_Po
   51|      0|#define Ps UCD_CATEGORY_Ps
   52|      0|#define Sc UCD_CATEGORY_Sc
   53|      0|#define Sk UCD_CATEGORY_Sk
   54|      0|#define Sm UCD_CATEGORY_Sm
   55|      0|#define So UCD_CATEGORY_So
   56|      0|#define Zl UCD_CATEGORY_Zl
   57|      0|#define Zp UCD_CATEGORY_Zp
   58|      0|#define Zs UCD_CATEGORY_Zs
   59|      0|#define Ii UCD_CATEGORY_Ii
   60|       |
   61|       |/* Unicode Character Data 11.0.0 */
   62|       |
   63|       |static const uint8_t categories_Cn[256] =
   64|       |{
   65|       |	/* 00 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   66|       |	/* 10 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   67|       |	/* 20 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   68|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   69|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   70|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   71|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   72|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   73|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   74|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   75|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   76|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   77|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   78|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   79|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   80|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
   81|       |};
   82|       |
   83|       |static const uint8_t categories_Co[256] =
   84|       |{
   85|       |	/* 00 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   86|       |	/* 10 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   87|       |	/* 20 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   88|       |	/* 30 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   89|       |	/* 40 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   90|       |	/* 50 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   91|       |	/* 60 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   92|       |	/* 70 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   93|       |	/* 80 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   94|       |	/* 90 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   95|       |	/* A0 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   96|       |	/* B0 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   97|       |	/* C0 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   98|       |	/* D0 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
   99|       |	/* E0 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
  100|       |	/* F0 */ Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co, Co,
  101|       |};
  102|       |
  103|       |static const uint8_t categories_Lo[256] =
  104|       |{
  105|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  106|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  107|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  108|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  109|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  110|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  111|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  112|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  113|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  114|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  115|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  116|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  117|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  118|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  119|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  120|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  121|       |};
  122|       |
  123|       |static const uint8_t categories_Sm[256] =
  124|       |{
  125|       |	/* 00 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  126|       |	/* 10 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  127|       |	/* 20 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  128|       |	/* 30 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  129|       |	/* 40 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  130|       |	/* 50 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  131|       |	/* 60 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  132|       |	/* 70 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  133|       |	/* 80 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  134|       |	/* 90 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  135|       |	/* A0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  136|       |	/* B0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  137|       |	/* C0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  138|       |	/* D0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  139|       |	/* E0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  140|       |	/* F0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  141|       |};
  142|       |
  143|       |static const uint8_t categories_So[256] =
  144|       |{
  145|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  146|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  147|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  148|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  149|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  150|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  151|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  152|       |	/* 70 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  153|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  154|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  155|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  156|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  157|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  158|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  159|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  160|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  161|       |};
  162|       |
  163|       |static const uint8_t categories_000000[256] =
  164|       |{
  165|       |	/* 00 */ Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc,
  166|       |	/* 10 */ Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc,
  167|       |	/* 20 */ Zs, Po, Po, Po, Sc, Po, Po, Po, Ps, Pe, Po, Sm, Po, Pd, Po, Po,
  168|       |	/* 30 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Po, Po, Sm, Sm, Sm, Po,
  169|       |	/* 40 */ Po, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  170|       |	/* 50 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Ps, Po, Pe, Sk, Pc,
  171|       |	/* 60 */ Sk, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  172|       |	/* 70 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ps, Sm, Pe, Sm, Cc,
  173|       |	/* 80 */ Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc,
  174|       |	/* 90 */ Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc, Cc,
  175|       |	/* A0 */ Zs, Po, Sc, Sc, Sc, Sc, So, Po, Sk, So, Lo, Pi, Sm, Cf, So, Sk,
  176|       |	/* B0 */ So, Sm, No, No, Sk, Ll, Po, Po, Sk, No, Lo, Pf, No, No, No, Po,
  177|       |	/* C0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  178|       |	/* D0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Sm, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Ll,
  179|       |	/* E0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  180|       |	/* F0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Sm, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  181|       |};
  182|       |
  183|       |static const uint8_t categories_000100[256] =
  184|       |{
  185|       |	/* 00 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  186|       |	/* 10 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  187|       |	/* 20 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  188|       |	/* 30 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu,
  189|       |	/* 40 */ Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  190|       |	/* 50 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  191|       |	/* 60 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  192|       |	/* 70 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Lu, Ll, Lu, Ll, Lu, Ll, Ll,
  193|       |	/* 80 */ Ll, Lu, Lu, Ll, Lu, Ll, Lu, Lu, Ll, Lu, Lu, Lu, Ll, Ll, Lu, Lu,
  194|       |	/* 90 */ Lu, Lu, Ll, Lu, Lu, Ll, Lu, Lu, Lu, Ll, Ll, Ll, Lu, Lu, Ll, Lu,
  195|       |	/* A0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Lu, Ll, Lu, Ll, Ll, Lu, Ll, Lu, Lu,
  196|       |	/* B0 */ Ll, Lu, Lu, Lu, Ll, Lu, Ll, Lu, Lu, Ll, Ll, Lo, Lu, Ll, Ll, Ll,
  197|       |	/* C0 */ Lo, Lo, Lo, Lo, Lu, Lt, Ll, Lu, Lt, Ll, Lu, Lt, Ll, Lu, Ll, Lu,
  198|       |	/* D0 */ Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Ll, Lu, Ll,
  199|       |	/* E0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  200|       |	/* F0 */ Ll, Lu, Lt, Ll, Lu, Ll, Lu, Lu, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  201|       |};
  202|       |
  203|       |static const uint8_t categories_000200[256] =
  204|       |{
  205|       |	/* 00 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  206|       |	/* 10 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  207|       |	/* 20 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  208|       |	/* 30 */ Lu, Ll, Lu, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Ll, Lu, Lu, Ll,
  209|       |	/* 40 */ Ll, Lu, Ll, Lu, Lu, Lu, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  210|       |	/* 50 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  211|       |	/* 60 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  212|       |	/* 70 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  213|       |	/* 80 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  214|       |	/* 90 */ Ll, Ll, Ll, Ll, Lo, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  215|       |	/* A0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  216|       |	/* B0 */ Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm,
  217|       |	/* C0 */ Lm, Lm, Sk, Sk, Sk, Sk, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm,
  218|       |	/* D0 */ Lm, Lm, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk,
  219|       |	/* E0 */ Lm, Lm, Lm, Lm, Lm, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Lm, Sk, Lm, Sk,
  220|       |	/* F0 */ Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk,
  221|       |};
  222|       |
  223|       |static const uint8_t categories_000300[256] =
  224|       |{
  225|       |	/* 00 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  226|       |	/* 10 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  227|       |	/* 20 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  228|       |	/* 30 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  229|       |	/* 40 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  230|       |	/* 50 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  231|       |	/* 60 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  232|       |	/* 70 */ Lu, Ll, Lu, Ll, Lm, Sk, Lu, Ll, Cn, Cn, Lm, Ll, Ll, Ll, Po, Lu,
  233|       |	/* 80 */ Cn, Cn, Cn, Cn, Sk, Sk, Lu, Po, Lu, Lu, Lu, Cn, Lu, Cn, Lu, Lu,
  234|       |	/* 90 */ Ll, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  235|       |	/* A0 */ Lu, Lu, Cn, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Ll, Ll, Ll, Ll,
  236|       |	/* B0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  237|       |	/* C0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu,
  238|       |	/* D0 */ Ll, Ll, Lu, Lu, Lu, Ll, Ll, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  239|       |	/* E0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  240|       |	/* F0 */ Ll, Ll, Ll, Ll, Lu, Ll, Sm, Lu, Ll, Lu, Lu, Ll, Ll, Lu, Lu, Lu,
  241|       |};
  242|       |
  243|       |static const uint8_t categories_000400[256] =
  244|       |{
  245|       |	/* 00 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  246|       |	/* 10 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  247|       |	/* 20 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  248|       |	/* 30 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  249|       |	/* 40 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  250|       |	/* 50 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  251|       |	/* 60 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  252|       |	/* 70 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  253|       |	/* 80 */ Lu, Ll, So, Mn, Mn, Mn, Mn, Mn, Me, Me, Lu, Ll, Lu, Ll, Lu, Ll,
  254|       |	/* 90 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  255|       |	/* A0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  256|       |	/* B0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  257|       |	/* C0 */ Lu, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Ll,
  258|       |	/* D0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  259|       |	/* E0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  260|       |	/* F0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  261|       |};
  262|       |
  263|       |static const uint8_t categories_000500[256] =
  264|       |{
  265|       |	/* 00 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  266|       |	/* 10 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  267|       |	/* 20 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  268|       |	/* 30 */ Cn, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  269|       |	/* 40 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  270|       |	/* 50 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Cn, Cn, Lm, Po, Po, Po, Po, Po, Po,
  271|       |	/* 60 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  272|       |	/* 70 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  273|       |	/* 80 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Po, Pd, Cn, Cn, So, So, Sc,
  274|       |	/* 90 */ Cn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  275|       |	/* A0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  276|       |	/* B0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Pd, Mn,
  277|       |	/* C0 */ Po, Mn, Mn, Po, Mn, Mn, Po, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  278|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  279|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Lo,
  280|       |	/* F0 */ Lo, Lo, Lo, Po, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  281|       |};
  282|       |
  283|       |static const uint8_t categories_000600[256] =
  284|       |{
  285|       |	/* 00 */ Cf, Cf, Cf, Cf, Cf, Cf, Sm, Sm, Sm, Po, Po, Sc, Po, Po, So, So,
  286|       |	/* 10 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Po, Cf, Cn, Po, Po,
  287|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  288|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  289|       |	/* 40 */ Lm, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Mn,
  290|       |	/* 50 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  291|       |	/* 60 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Po, Po, Po, Po, Lo, Lo,
  292|       |	/* 70 */ Mn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  293|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  294|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  295|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  296|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  297|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  298|       |	/* D0 */ Lo, Lo, Lo, Lo, Po, Lo, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cf, So, Mn,
  299|       |	/* E0 */ Mn, Mn, Mn, Mn, Mn, Lm, Lm, Mn, Mn, So, Mn, Mn, Mn, Mn, Lo, Lo,
  300|       |	/* F0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Lo, Lo, Lo, So, So, Lo,
  301|       |};
  302|       |
  303|       |static const uint8_t categories_000700[256] =
  304|       |{
  305|       |	/* 00 */ Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Cn, Cf,
  306|       |	/* 10 */ Lo, Mn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  307|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  308|       |	/* 30 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  309|       |	/* 40 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Cn, Lo, Lo, Lo,
  310|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  311|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  312|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  313|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  314|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  315|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  316|       |	/* B0 */ Mn, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  317|       |	/* C0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Lo, Lo, Lo, Lo, Lo, Lo,
  318|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  319|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Mn,
  320|       |	/* F0 */ Mn, Mn, Mn, Mn, Lm, Lm, So, Po, Po, Po, Lm, Cn, Cn, Mn, Sc, Sc,
  321|       |};
  322|       |
  323|       |static const uint8_t categories_000800[256] =
  324|       |{
  325|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  326|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Lm, Mn, Mn, Mn, Mn, Mn,
  327|       |	/* 20 */ Mn, Mn, Mn, Mn, Lm, Mn, Mn, Mn, Lm, Mn, Mn, Mn, Mn, Mn, Cn, Cn,
  328|       |	/* 30 */ Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Cn,
  329|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  330|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Cn, Cn, Po, Cn,
  331|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn,
  332|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  333|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  334|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  335|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  336|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn,
  337|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  338|       |	/* D0 */ Cn, Cn, Cn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  339|       |	/* E0 */ Mn, Mn, Cf, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  340|       |	/* F0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  341|       |};
  342|       |
  343|       |static const uint8_t categories_000900[256] =
  344|       |{
  345|       |	/* 00 */ Mn, Mn, Mn, Mc, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  346|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  347|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  348|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mc, Mn, Lo, Mc, Mc,
  349|       |	/* 40 */ Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mc, Mc, Mc, Mc, Mn, Mc, Mc,
  350|       |	/* 50 */ Lo, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  351|       |	/* 60 */ Lo, Lo, Mn, Mn, Po, Po, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
  352|       |	/* 70 */ Po, Lm, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  353|       |	/* 80 */ Lo, Mn, Mc, Mc, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Lo,
  354|       |	/* 90 */ Lo, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  355|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo,
  356|       |	/* B0 */ Lo, Cn, Lo, Cn, Cn, Cn, Lo, Lo, Lo, Lo, Cn, Cn, Mn, Lo, Mc, Mc,
  357|       |	/* C0 */ Mc, Mn, Mn, Mn, Mn, Cn, Cn, Mc, Mc, Cn, Cn, Mc, Mc, Mn, Lo, Cn,
  358|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Mc, Cn, Cn, Cn, Cn, Lo, Lo, Cn, Lo,
  359|       |	/* E0 */ Lo, Lo, Mn, Mn, Cn, Cn, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
  360|       |	/* F0 */ Lo, Lo, Sc, Sc, No, No, No, No, No, No, So, Sc, Lo, Po, Mn, Cn,
  361|       |};
  362|       |
  363|       |static const uint8_t categories_000A00[256] =
  364|       |{
  365|       |	/* 00 */ Cn, Mn, Mn, Mc, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Lo,
  366|       |	/* 10 */ Lo, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  367|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo,
  368|       |	/* 30 */ Lo, Cn, Lo, Lo, Cn, Lo, Lo, Cn, Lo, Lo, Cn, Cn, Mn, Cn, Mc, Mc,
  369|       |	/* 40 */ Mc, Mn, Mn, Cn, Cn, Cn, Cn, Mn, Mn, Cn, Cn, Mn, Mn, Mn, Cn, Cn,
  370|       |	/* 50 */ Cn, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Lo, Lo, Lo, Lo, Cn, Lo, Cn,
  371|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
  372|       |	/* 70 */ Mn, Mn, Lo, Lo, Lo, Mn, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  373|       |	/* 80 */ Cn, Mn, Mn, Mc, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo,
  374|       |	/* 90 */ Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  375|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo,
  376|       |	/* B0 */ Lo, Cn, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Mn, Lo, Mc, Mc,
  377|       |	/* C0 */ Mc, Mn, Mn, Mn, Mn, Mn, Cn, Mn, Mn, Mc, Cn, Mc, Mc, Mn, Cn, Cn,
  378|       |	/* D0 */ Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  379|       |	/* E0 */ Lo, Lo, Mn, Mn, Cn, Cn, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
  380|       |	/* F0 */ Po, Sc, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Lo, Mn, Mn, Mn, Mn, Mn, Mn,
  381|       |};
  382|       |
  383|       |static const uint8_t categories_000B00[256] =
  384|       |{
  385|       |	/* 00 */ Cn, Mn, Mc, Mc, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Lo,
  386|       |	/* 10 */ Lo, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  387|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo,
  388|       |	/* 30 */ Lo, Cn, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Mn, Lo, Mc, Mn,
  389|       |	/* 40 */ Mc, Mn, Mn, Mn, Mn, Cn, Cn, Mc, Mc, Cn, Cn, Mc, Mc, Mn, Cn, Cn,
  390|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Mn, Mc, Cn, Cn, Cn, Cn, Lo, Lo, Cn, Lo,
  391|       |	/* 60 */ Lo, Lo, Mn, Mn, Cn, Cn, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
  392|       |	/* 70 */ So, Lo, No, No, No, No, No, No, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  393|       |	/* 80 */ Cn, Cn, Mn, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Lo, Lo,
  394|       |	/* 90 */ Lo, Cn, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Lo, Lo, Cn, Lo, Cn, Lo, Lo,
  395|       |	/* A0 */ Cn, Cn, Cn, Lo, Lo, Cn, Cn, Cn, Lo, Lo, Lo, Cn, Cn, Cn, Lo, Lo,
  396|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Mc, Mc,
  397|       |	/* C0 */ Mn, Mc, Mc, Cn, Cn, Cn, Mc, Mc, Mc, Cn, Mc, Mc, Mc, Mn, Cn, Cn,
  398|       |	/* D0 */ Lo, Cn, Cn, Cn, Cn, Cn, Cn, Mc, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  399|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
  400|       |	/* F0 */ No, No, No, So, So, So, So, So, So, Sc, So, Cn, Cn, Cn, Cn, Cn,
  401|       |};
  402|       |
  403|       |static const uint8_t categories_000C00[256] =
  404|       |{
  405|       |	/* 00 */ Mn, Mc, Mc, Mc, Mn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo,
  406|       |	/* 10 */ Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  407|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo,
  408|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Lo, Mn, Mn,
  409|       |	/* 40 */ Mn, Mc, Mc, Mc, Mc, Cn, Mn, Mn, Mn, Cn, Mn, Mn, Mn, Mn, Cn, Cn,
  410|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Mn, Mn, Cn, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn,
  411|       |	/* 60 */ Lo, Lo, Mn, Mn, Cn, Cn, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
  412|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, No, No, No, No, No, No, No, So,
  413|       |	/* 80 */ Lo, Mn, Mc, Mc, Po, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo,
  414|       |	/* 90 */ Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  415|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo,
  416|       |	/* B0 */ Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Mn, Lo, Mc, Mn,
  417|       |	/* C0 */ Mc, Mc, Mc, Mc, Mc, Cn, Mn, Mc, Mc, Cn, Mc, Mc, Mn, Mn, Cn, Cn,
  418|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Mc, Mc, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Lo, Cn,
  419|       |	/* E0 */ Lo, Lo, Mn, Mn, Cn, Cn, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
  420|       |	/* F0 */ Cn, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  421|       |};
  422|       |
  423|       |static const uint8_t categories_000D00[256] =
  424|       |{
  425|       |	/* 00 */ Mn, Mn, Mc, Mc, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo,
  426|       |	/* 10 */ Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  427|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  428|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Lo, Mc, Mc,
  429|       |	/* 40 */ Mc, Mn, Mn, Mn, Mn, Cn, Mc, Mc, Mc, Cn, Mc, Mc, Mc, Mn, Lo, So,
  430|       |	/* 50 */ Cn, Cn, Cn, Cn, Lo, Lo, Lo, Mc, No, No, No, No, No, No, No, Lo,
  431|       |	/* 60 */ Lo, Lo, Mn, Mn, Cn, Cn, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
  432|       |	/* 70 */ No, No, No, No, No, No, No, No, No, So, Lo, Lo, Lo, Lo, Lo, Lo,
  433|       |	/* 80 */ Cn, Cn, Mc, Mc, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  434|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo,
  435|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  436|       |	/* B0 */ Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Cn, Cn,
  437|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Mn, Cn, Cn, Cn, Cn, Mc,
  438|       |	/* D0 */ Mc, Mc, Mn, Mn, Mn, Cn, Mn, Cn, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc,
  439|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
  440|       |	/* F0 */ Cn, Cn, Mc, Mc, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  441|       |};
  442|       |
  443|       |static const uint8_t categories_000E00[256] =
  444|       |{
  445|       |	/* 00 */ Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  446|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  447|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  448|       |	/* 30 */ Lo, Mn, Lo, Lo, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Cn, Cn, Cn, Sc,
  449|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lm, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Po,
  450|       |	/* 50 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Po, Po, Cn, Cn, Cn, Cn,
  451|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  452|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  453|       |	/* 80 */ Cn, Lo, Lo, Cn, Lo, Cn, Cn, Lo, Lo, Cn, Lo, Cn, Cn, Lo, Cn, Cn,
  454|       |	/* 90 */ Cn, Cn, Cn, Cn, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  455|       |	/* A0 */ Cn, Lo, Lo, Lo, Cn, Lo, Cn, Lo, Cn, Cn, Lo, Lo, Cn, Lo, Lo, Lo,
  456|       |	/* B0 */ Lo, Mn, Lo, Lo, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Mn, Mn, Lo, Cn, Cn,
  457|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Cn, Lm, Cn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Cn,
  458|       |	/* D0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Lo, Lo, Lo, Lo,
  459|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  460|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  461|       |};
  462|       |
  463|       |static const uint8_t categories_000F00[256] =
  464|       |{
  465|       |	/* 00 */ Lo, So, So, So, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po,
  466|       |	/* 10 */ Po, Po, Po, So, Po, So, So, So, Mn, Mn, So, So, So, So, So, So,
  467|       |	/* 20 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, No, No, No, No, No, No,
  468|       |	/* 30 */ No, No, No, No, So, Mn, So, Mn, So, Mn, Ps, Pe, Ps, Pe, Mc, Mc,
  469|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  470|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  471|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn,
  472|       |	/* 70 */ Cn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mc,
  473|       |	/* 80 */ Mn, Mn, Mn, Mn, Mn, Po, Mn, Mn, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn,
  474|       |	/* 90 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  475|       |	/* A0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  476|       |	/* B0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, So, So,
  477|       |	/* C0 */ So, So, So, So, So, So, Mn, So, So, So, So, So, So, Cn, So, So,
  478|       |	/* D0 */ Po, Po, Po, Po, Po, So, So, So, So, Po, Po, Cn, Cn, Cn, Cn, Cn,
  479|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  480|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  481|       |};
  482|       |
  483|       |static const uint8_t categories_001000[256] =
  484|       |{
  485|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  486|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  487|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mc, Mc, Mn, Mn, Mn,
  488|       |	/* 30 */ Mn, Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mc, Mn, Mn, Mc, Mc, Mn, Mn, Lo,
  489|       |	/* 40 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Po, Po, Po, Po, Po, Po,
  490|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Mc, Mc, Mn, Mn, Lo, Lo, Lo, Lo, Mn, Mn,
  491|       |	/* 60 */ Mn, Lo, Mc, Mc, Mc, Lo, Lo, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Lo, Lo,
  492|       |	/* 70 */ Lo, Mn, Mn, Mn, Mn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  493|       |	/* 80 */ Lo, Lo, Mn, Mc, Mc, Mn, Mn, Mc, Mc, Mc, Mc, Mc, Mc, Mn, Lo, Mc,
  494|       |	/* 90 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Mc, Mc, Mc, Mn, So, So,
  495|       |	/* A0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  496|       |	/* B0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  497|       |	/* C0 */ Lu, Lu, Lu, Lu, Lu, Lu, Cn, Lu, Cn, Cn, Cn, Cn, Cn, Lu, Cn, Cn,
  498|       |	/* D0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  499|       |	/* E0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  500|       |	/* F0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Po, Lm, Ll, Ll, Ll,
  501|       |};
  502|       |
  503|       |static const uint8_t categories_001200[256] =
  504|       |{
  505|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  506|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  507|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  508|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  509|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Cn, Cn,
  510|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Cn, Lo, Lo, Lo, Lo, Cn, Cn,
  511|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  512|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  513|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Cn, Cn,
  514|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  515|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  516|       |	/* B0 */ Lo, Cn, Lo, Lo, Lo, Lo, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
  517|       |	/* C0 */ Lo, Cn, Lo, Lo, Lo, Lo, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  518|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  519|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  520|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  521|       |};
  522|       |
  523|       |static const uint8_t categories_001300[256] =
  524|       |{
  525|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  526|       |	/* 10 */ Lo, Cn, Lo, Lo, Lo, Lo, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  527|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  528|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  529|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  530|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Mn, Mn, Mn,
  531|       |	/* 60 */ Po, Po, Po, Po, Po, Po, Po, Po, Po, No, No, No, No, No, No, No,
  532|       |	/* 70 */ No, No, No, No, No, No, No, No, No, No, No, No, No, Cn, Cn, Cn,
  533|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  534|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn,
  535|       |	/* A0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  536|       |	/* B0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  537|       |	/* C0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  538|       |	/* D0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  539|       |	/* E0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  540|       |	/* F0 */ Lu, Lu, Lu, Lu, Lu, Lu, Cn, Cn, Ll, Ll, Ll, Ll, Ll, Ll, Cn, Cn,
  541|       |};
  542|       |
  543|       |static const uint8_t categories_001400[256] =
  544|       |{
  545|       |	/* 00 */ Pd, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  546|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  547|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  548|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  549|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  550|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  551|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  552|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  553|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  554|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  555|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  556|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  557|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  558|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  559|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  560|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  561|       |};
  562|       |
  563|       |static const uint8_t categories_001600[256] =
  564|       |{
  565|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  566|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  567|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  568|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  569|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  570|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  571|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Po, Po, Lo,
  572|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  573|       |	/* 80 */ Zs, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  574|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Ps, Pe, Cn, Cn, Cn,
  575|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  576|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  577|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  578|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  579|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Po, Po, Po, Nl, Nl,
  580|       |	/* F0 */ Nl, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  581|       |};
  582|       |
  583|       |static const uint8_t categories_001700[256] =
  584|       |{
  585|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo,
  586|       |	/* 10 */ Lo, Lo, Mn, Mn, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  587|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  588|       |	/* 30 */ Lo, Lo, Mn, Mn, Mn, Po, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  589|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  590|       |	/* 50 */ Lo, Lo, Mn, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  591|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo,
  592|       |	/* 70 */ Lo, Cn, Mn, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  593|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  594|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  595|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  596|       |	/* B0 */ Lo, Lo, Lo, Lo, Mn, Mn, Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mc, Mc,
  597|       |	/* C0 */ Mc, Mc, Mc, Mc, Mc, Mc, Mn, Mc, Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  598|       |	/* D0 */ Mn, Mn, Mn, Mn, Po, Po, Po, Lm, Po, Po, Po, Sc, Lo, Mn, Cn, Cn,
  599|       |	/* E0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
  600|       |	/* F0 */ No, No, No, No, No, No, No, No, No, No, Cn, Cn, Cn, Cn, Cn, Cn,
  601|       |};
  602|       |
  603|       |static const uint8_t categories_001800[256] =
  604|       |{
  605|       |	/* 00 */ Po, Po, Po, Po, Po, Po, Pd, Po, Po, Po, Po, Mn, Mn, Mn, Cf, Cn,
  606|       |	/* 10 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
  607|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  608|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  609|       |	/* 40 */ Lo, Lo, Lo, Lm, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  610|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  611|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  612|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  613|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Mn, Mn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  614|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  615|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Lo, Cn, Cn, Cn, Cn, Cn,
  616|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  617|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  618|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  619|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  620|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  621|       |};
  622|       |
  623|       |static const uint8_t categories_001900[256] =
  624|       |{
  625|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  626|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
  627|       |	/* 20 */ Mn, Mn, Mn, Mc, Mc, Mc, Mc, Mn, Mn, Mc, Mc, Mc, Cn, Cn, Cn, Cn,
  628|       |	/* 30 */ Mc, Mc, Mn, Mc, Mc, Mc, Mc, Mc, Mc, Mn, Mn, Mn, Cn, Cn, Cn, Cn,
  629|       |	/* 40 */ So, Cn, Cn, Cn, Po, Po, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
  630|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  631|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn,
  632|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  633|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  634|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  635|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn,
  636|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  637|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn,
  638|       |	/* D0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, No, Cn, Cn, Cn, So, So,
  639|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  640|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  641|       |};
  642|       |
  643|       |static const uint8_t categories_001A00[256] =
  644|       |{
  645|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  646|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mc, Mc, Mn, Cn, Cn, Po, Po,
  647|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  648|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  649|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  650|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Mc, Mn, Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn,
  651|       |	/* 60 */ Mn, Mc, Mn, Mc, Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mc, Mc, Mc,
  652|       |	/* 70 */ Mc, Mc, Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Cn, Mn,
  653|       |	/* 80 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
  654|       |	/* 90 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
  655|       |	/* A0 */ Po, Po, Po, Po, Po, Po, Po, Lm, Po, Po, Po, Po, Po, Po, Cn, Cn,
  656|       |	/* B0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Me, Cn,
  657|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  658|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  659|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  660|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  661|       |};
  662|       |
  663|       |static const uint8_t categories_001B00[256] =
  664|       |{
  665|       |	/* 00 */ Mn, Mn, Mn, Mn, Mc, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  666|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  667|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  668|       |	/* 30 */ Lo, Lo, Lo, Lo, Mn, Mc, Mn, Mn, Mn, Mn, Mn, Mc, Mn, Mc, Mc, Mc,
  669|       |	/* 40 */ Mc, Mc, Mn, Mc, Mc, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn,
  670|       |	/* 50 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Po, Po, Po, Po, Po, Po,
  671|       |	/* 60 */ Po, So, So, So, So, So, So, So, So, So, So, Mn, Mn, Mn, Mn, Mn,
  672|       |	/* 70 */ Mn, Mn, Mn, Mn, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn,
  673|       |	/* 80 */ Mn, Mn, Mc, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  674|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  675|       |	/* A0 */ Lo, Mc, Mn, Mn, Mn, Mn, Mc, Mc, Mn, Mn, Mc, Mn, Mn, Mn, Lo, Lo,
  676|       |	/* B0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Lo, Lo, Lo, Lo, Lo, Lo,
  677|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  678|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  679|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mc, Mn, Mn, Mc, Mc, Mc, Mn, Mc, Mn,
  680|       |	/* F0 */ Mn, Mn, Mc, Mc, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Po, Po, Po, Po,
  681|       |};
  682|       |
  683|       |static const uint8_t categories_001C00[256] =
  684|       |{
  685|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  686|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  687|       |	/* 20 */ Lo, Lo, Lo, Lo, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mn, Mn, Mn, Mn,
  688|       |	/* 30 */ Mn, Mn, Mn, Mn, Mc, Mc, Mn, Mn, Cn, Cn, Cn, Po, Po, Po, Po, Po,
  689|       |	/* 40 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Lo, Lo, Lo,
  690|       |	/* 50 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Lo, Lo, Lo, Lo, Lo, Lo,
  691|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  692|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lm, Lm, Lm, Lm, Lm, Lm, Po, Po,
  693|       |	/* 80 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  694|       |	/* 90 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  695|       |	/* A0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  696|       |	/* B0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Cn, Cn, Lu, Lu, Lu,
  697|       |	/* C0 */ Po, Po, Po, Po, Po, Po, Po, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  698|       |	/* D0 */ Mn, Mn, Mn, Po, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  699|       |	/* E0 */ Mn, Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Lo, Lo, Lo, Lo, Mn, Lo, Lo,
  700|       |	/* F0 */ Lo, Lo, Mc, Mc, Mn, Lo, Lo, Mc, Mn, Mn, Cn, Cn, Cn, Cn, Cn, Cn,
  701|       |};
  702|       |
  703|       |static const uint8_t categories_001D00[256] =
  704|       |{
  705|       |	/* 00 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  706|       |	/* 10 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  707|       |	/* 20 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lm, Lm, Lm, Lm,
  708|       |	/* 30 */ Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm,
  709|       |	/* 40 */ Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm,
  710|       |	/* 50 */ Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm,
  711|       |	/* 60 */ Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Ll, Ll, Ll, Ll, Ll,
  712|       |	/* 70 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lm, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  713|       |	/* 80 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  714|       |	/* 90 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lm, Lm, Lm, Lm, Lm,
  715|       |	/* A0 */ Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm,
  716|       |	/* B0 */ Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm,
  717|       |	/* C0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  718|       |	/* D0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  719|       |	/* E0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  720|       |	/* F0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Mn, Mn, Mn, Mn, Mn,
  721|       |};
  722|       |
  723|       |static const uint8_t categories_001E00[256] =
  724|       |{
  725|       |	/* 00 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  726|       |	/* 10 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  727|       |	/* 20 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  728|       |	/* 30 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  729|       |	/* 40 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  730|       |	/* 50 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  731|       |	/* 60 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  732|       |	/* 70 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  733|       |	/* 80 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  734|       |	/* 90 */ Lu, Ll, Lu, Ll, Lu, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Ll,
  735|       |	/* A0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  736|       |	/* B0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  737|       |	/* C0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  738|       |	/* D0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  739|       |	/* E0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  740|       |	/* F0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  741|       |};
  742|       |
  743|       |static const uint8_t categories_001F00[256] =
  744|       |{
  745|       |	/* 00 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  746|       |	/* 10 */ Ll, Ll, Ll, Ll, Ll, Ll, Cn, Cn, Lu, Lu, Lu, Lu, Lu, Lu, Cn, Cn,
  747|       |	/* 20 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  748|       |	/* 30 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  749|       |	/* 40 */ Ll, Ll, Ll, Ll, Ll, Ll, Cn, Cn, Lu, Lu, Lu, Lu, Lu, Lu, Cn, Cn,
  750|       |	/* 50 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Cn, Lu, Cn, Lu, Cn, Lu, Cn, Lu,
  751|       |	/* 60 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  752|       |	/* 70 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Cn, Cn,
  753|       |	/* 80 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt,
  754|       |	/* 90 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt,
  755|       |	/* A0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt,
  756|       |	/* B0 */ Ll, Ll, Ll, Ll, Ll, Cn, Ll, Ll, Lu, Lu, Lu, Lu, Lt, Sk, Ll, Sk,
  757|       |	/* C0 */ Sk, Sk, Ll, Ll, Ll, Cn, Ll, Ll, Lu, Lu, Lu, Lu, Lt, Sk, Sk, Sk,
  758|       |	/* D0 */ Ll, Ll, Ll, Ll, Cn, Cn, Ll, Ll, Lu, Lu, Lu, Lu, Cn, Sk, Sk, Sk,
  759|       |	/* E0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu, Lu, Sk, Sk, Sk,
  760|       |	/* F0 */ Cn, Cn, Ll, Ll, Ll, Cn, Ll, Ll, Lu, Lu, Lu, Lu, Lt, Sk, Sk, Cn,
  761|       |};
  762|       |
  763|       |static const uint8_t categories_002000[256] =
  764|       |{
  765|       |	/* 00 */ Zs, Zs, Zs, Zs, Zs, Zs, Zs, Zs, Zs, Zs, Zs, Cf, Cf, Cf, Cf, Cf,
  766|       |	/* 10 */ Pd, Pd, Pd, Pd, Pd, Pd, Po, Po, Pi, Pf, Ps, Pi, Pi, Pf, Ps, Pi,
  767|       |	/* 20 */ Po, Po, Po, Po, Po, Po, Po, Po, Zl, Zp, Cf, Cf, Cf, Cf, Cf, Zs,
  768|       |	/* 30 */ Po, Po, Po, Po, Po, Po, Po, Po, Po, Pi, Pf, Po, Po, Po, Po, Pc,
  769|       |	/* 40 */ Pc, Po, Po, Po, Sm, Ps, Pe, Po, Po, Po, Po, Po, Po, Po, Po, Po,
  770|       |	/* 50 */ Po, Po, Sm, Po, Pc, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Zs,
  771|       |	/* 60 */ Cf, Cf, Cf, Cf, Cf, Cn, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf,
  772|       |	/* 70 */ No, Lm, Cn, Cn, No, No, No, No, No, No, Sm, Sm, Sm, Ps, Pe, Lm,
  773|       |	/* 80 */ No, No, No, No, No, No, No, No, No, No, Sm, Sm, Sm, Ps, Pe, Cn,
  774|       |	/* 90 */ Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Cn, Cn, Cn,
  775|       |	/* A0 */ Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc,
  776|       |	/* B0 */ Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc, Sc,
  777|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  778|       |	/* D0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Me, Me, Me,
  779|       |	/* E0 */ Me, Mn, Me, Me, Me, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  780|       |	/* F0 */ Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  781|       |};
  782|       |
  783|       |static const uint8_t categories_002100[256] =
  784|       |{
  785|       |	/* 00 */ So, So, Lu, So, So, So, So, Lu, So, So, Ll, Lu, Lu, Lu, Ll, Ll,
  786|       |	/* 10 */ Lu, Lu, Lu, Ll, So, Lu, So, So, Sm, Lu, Lu, Lu, Lu, Lu, So, So,
  787|       |	/* 20 */ So, So, So, So, Lu, So, Lu, So, Lu, So, Lu, Lu, Lu, Lu, So, Ll,
  788|       |	/* 30 */ Lu, Lu, Lu, Lu, Ll, Lo, Lo, Lo, Lo, Ll, So, So, Ll, Ll, Lu, Lu,
  789|       |	/* 40 */ Sm, Sm, Sm, Sm, Sm, Lu, Ll, Ll, Ll, Ll, So, Sm, So, So, Ll, So,
  790|       |	/* 50 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
  791|       |	/* 60 */ Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl,
  792|       |	/* 70 */ Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl,
  793|       |	/* 80 */ Nl, Nl, Nl, Lu, Ll, Nl, Nl, Nl, Nl, No, So, So, Cn, Cn, Cn, Cn,
  794|       |	/* 90 */ Sm, Sm, Sm, Sm, Sm, So, So, So, So, So, Sm, Sm, So, So, So, So,
  795|       |	/* A0 */ Sm, So, So, Sm, So, So, Sm, So, So, So, So, So, So, So, Sm, So,
  796|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  797|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, Sm, Sm,
  798|       |	/* D0 */ So, So, Sm, So, Sm, So, So, So, So, So, So, So, So, So, So, So,
  799|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  800|       |	/* F0 */ So, So, So, So, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  801|       |};
  802|       |
  803|       |static const uint8_t categories_002300[256] =
  804|       |{
  805|       |	/* 00 */ So, So, So, So, So, So, So, So, Ps, Pe, Ps, Pe, So, So, So, So,
  806|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  807|       |	/* 20 */ Sm, Sm, So, So, So, So, So, So, So, Ps, Pe, So, So, So, So, So,
  808|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  809|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  810|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  811|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  812|       |	/* 70 */ So, So, So, So, So, So, So, So, So, So, So, So, Sm, So, So, So,
  813|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  814|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, Sm, Sm, Sm, Sm, Sm,
  815|       |	/* A0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  816|       |	/* B0 */ Sm, Sm, Sm, Sm, So, So, So, So, So, So, So, So, So, So, So, So,
  817|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  818|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, Sm, Sm, Sm, Sm,
  819|       |	/* E0 */ Sm, Sm, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  820|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  821|       |};
  822|       |
  823|       |static const uint8_t categories_002400[256] =
  824|       |{
  825|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  826|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  827|       |	/* 20 */ So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  828|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  829|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn,
  830|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  831|       |	/* 60 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
  832|       |	/* 70 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
  833|       |	/* 80 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
  834|       |	/* 90 */ No, No, No, No, No, No, No, No, No, No, No, No, So, So, So, So,
  835|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  836|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  837|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  838|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  839|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, No, No, No, No, No, No,
  840|       |	/* F0 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
  841|       |};
  842|       |
  843|       |static const uint8_t categories_002500[256] =
  844|       |{
  845|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  846|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  847|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  848|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  849|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  850|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  851|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  852|       |	/* 70 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  853|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  854|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  855|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  856|       |	/* B0 */ So, So, So, So, So, So, So, Sm, So, So, So, So, So, So, So, So,
  857|       |	/* C0 */ So, Sm, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  858|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  859|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  860|       |	/* F0 */ So, So, So, So, So, So, So, So, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  861|       |};
  862|       |
  863|       |static const uint8_t categories_002600[256] =
  864|       |{
  865|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  866|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  867|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  868|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  869|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  870|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  871|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, Sm,
  872|       |	/* 70 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  873|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  874|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  875|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  876|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  877|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  878|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  879|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  880|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  881|       |};
  882|       |
  883|       |static const uint8_t categories_002700[256] =
  884|       |{
  885|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  886|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  887|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  888|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  889|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  890|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  891|       |	/* 60 */ So, So, So, So, So, So, So, So, Ps, Pe, Ps, Pe, Ps, Pe, Ps, Pe,
  892|       |	/* 70 */ Ps, Pe, Ps, Pe, Ps, Pe, No, No, No, No, No, No, No, No, No, No,
  893|       |	/* 80 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
  894|       |	/* 90 */ No, No, No, No, So, So, So, So, So, So, So, So, So, So, So, So,
  895|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  896|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  897|       |	/* C0 */ Sm, Sm, Sm, Sm, Sm, Ps, Pe, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  898|       |	/* D0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  899|       |	/* E0 */ Sm, Sm, Sm, Sm, Sm, Sm, Ps, Pe, Ps, Pe, Ps, Pe, Ps, Pe, Ps, Pe,
  900|       |	/* F0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  901|       |};
  902|       |
  903|       |static const uint8_t categories_002900[256] =
  904|       |{
  905|       |	/* 00 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  906|       |	/* 10 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  907|       |	/* 20 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  908|       |	/* 30 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  909|       |	/* 40 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  910|       |	/* 50 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  911|       |	/* 60 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  912|       |	/* 70 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  913|       |	/* 80 */ Sm, Sm, Sm, Ps, Pe, Ps, Pe, Ps, Pe, Ps, Pe, Ps, Pe, Ps, Pe, Ps,
  914|       |	/* 90 */ Pe, Ps, Pe, Ps, Pe, Ps, Pe, Ps, Pe, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  915|       |	/* A0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  916|       |	/* B0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  917|       |	/* C0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  918|       |	/* D0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Ps, Pe, Ps, Pe, Sm, Sm, Sm, Sm,
  919|       |	/* E0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  920|       |	/* F0 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Ps, Pe, Sm, Sm,
  921|       |};
  922|       |
  923|       |static const uint8_t categories_002B00[256] =
  924|       |{
  925|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  926|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  927|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  928|       |	/* 30 */ Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm, Sm,
  929|       |	/* 40 */ Sm, Sm, Sm, Sm, Sm, So, So, Sm, Sm, Sm, Sm, Sm, Sm, So, So, So,
  930|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  931|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  932|       |	/* 70 */ So, So, So, So, Cn, Cn, So, So, So, So, So, So, So, So, So, So,
  933|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  934|       |	/* 90 */ So, So, So, So, So, So, Cn, Cn, So, So, So, So, So, So, So, So,
  935|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  936|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  937|       |	/* C0 */ So, So, So, So, So, So, So, So, So, Cn, So, So, So, So, So, So,
  938|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  939|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  940|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, Cn,
  941|       |};
  942|       |
  943|       |static const uint8_t categories_002C00[256] =
  944|       |{
  945|       |	/* 00 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  946|       |	/* 10 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
  947|       |	/* 20 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Cn,
  948|       |	/* 30 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  949|       |	/* 40 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  950|       |	/* 50 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Cn,
  951|       |	/* 60 */ Lu, Ll, Lu, Lu, Lu, Ll, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Lu, Lu,
  952|       |	/* 70 */ Lu, Ll, Lu, Ll, Ll, Lu, Ll, Ll, Ll, Ll, Ll, Ll, Lm, Lm, Lu, Lu,
  953|       |	/* 80 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  954|       |	/* 90 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  955|       |	/* A0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  956|       |	/* B0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  957|       |	/* C0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  958|       |	/* D0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
  959|       |	/* E0 */ Lu, Ll, Lu, Ll, Ll, So, So, So, So, So, So, Lu, Ll, Lu, Ll, Mn,
  960|       |	/* F0 */ Mn, Mn, Lu, Ll, Cn, Cn, Cn, Cn, Cn, Po, Po, Po, Po, No, Po, Po,
  961|       |};
  962|       |
  963|       |static const uint8_t categories_002D00[256] =
  964|       |{
  965|       |	/* 00 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  966|       |	/* 10 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
  967|       |	/* 20 */ Ll, Ll, Ll, Ll, Ll, Ll, Cn, Ll, Cn, Cn, Cn, Cn, Cn, Ll, Cn, Cn,
  968|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  969|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  970|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  971|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Lm,
  972|       |	/* 70 */ Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Mn,
  973|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
  974|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  975|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
  976|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
  977|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
  978|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
  979|       |	/* E0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  980|       |	/* F0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
  981|       |};
  982|       |
  983|       |static const uint8_t categories_002E00[256] =
  984|       |{
  985|       |	/* 00 */ Po, Po, Pi, Pf, Pi, Pf, Po, Po, Po, Pi, Pf, Po, Pi, Pf, Po, Po,
  986|       |	/* 10 */ Po, Po, Po, Po, Po, Po, Po, Pd, Po, Po, Pd, Po, Pi, Pf, Po, Po,
  987|       |	/* 20 */ Pi, Pf, Ps, Pe, Ps, Pe, Ps, Pe, Ps, Pe, Po, Po, Po, Po, Po, Lm,
  988|       |	/* 30 */ Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Pd, Pd, Po, Po, Po, Po,
  989|       |	/* 40 */ Pd, Po, Ps, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Cn,
  990|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  991|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  992|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
  993|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  994|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, Cn, So, So, So, So, So,
  995|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  996|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  997|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  998|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
  999|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1000|       |	/* F0 */ So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1001|       |};
 1002|       |
 1003|       |static const uint8_t categories_002F00[256] =
 1004|       |{
 1005|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1006|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1007|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1008|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1009|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1010|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1011|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1012|       |	/* 70 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1013|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1014|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1015|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1016|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1017|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1018|       |	/* D0 */ So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1019|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1020|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn,
 1021|       |};
 1022|       |
 1023|       |static const uint8_t categories_003000[256] =
 1024|       |{
 1025|       |	/* 00 */ Zs, Po, Po, Po, So, Lm, Lo, Nl, Ps, Pe, Ps, Pe, Ps, Pe, Ps, Pe,
 1026|       |	/* 10 */ Ps, Pe, So, So, Ps, Pe, Ps, Pe, Ps, Pe, Ps, Pe, Pd, Ps, Pe, Pe,
 1027|       |	/* 20 */ So, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Mn, Mn, Mn, Mn, Mc, Mc,
 1028|       |	/* 30 */ Pd, Lm, Lm, Lm, Lm, Lm, So, So, Nl, Nl, Nl, Lm, Lo, Po, So, So,
 1029|       |	/* 40 */ Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1030|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1031|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1032|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1033|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1034|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Mn, Mn, Sk, Sk, Lm, Lm, Lo,
 1035|       |	/* A0 */ Pd, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1036|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1037|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1038|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1039|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1040|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Po, Lm, Lm, Lm, Lo,
 1041|       |};
 1042|       |
 1043|       |static const uint8_t categories_003100[256] =
 1044|       |{
 1045|       |	/* 00 */ Cn, Cn, Cn, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1046|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1047|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1048|       |	/* 30 */ Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1049|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1050|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1051|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1052|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1053|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
 1054|       |	/* 90 */ So, So, No, No, No, No, So, So, So, So, So, So, So, So, So, So,
 1055|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1056|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn,
 1057|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1058|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1059|       |	/* E0 */ So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1060|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1061|       |};
 1062|       |
 1063|       |static const uint8_t categories_003200[256] =
 1064|       |{
 1065|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1066|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, Cn,
 1067|       |	/* 20 */ No, No, No, No, No, No, No, No, No, No, So, So, So, So, So, So,
 1068|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1069|       |	/* 40 */ So, So, So, So, So, So, So, So, No, No, No, No, No, No, No, No,
 1070|       |	/* 50 */ So, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 1071|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1072|       |	/* 70 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1073|       |	/* 80 */ No, No, No, No, No, No, No, No, No, No, So, So, So, So, So, So,
 1074|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1075|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1076|       |	/* B0 */ So, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 1077|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1078|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1079|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1080|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, Cn,
 1081|       |};
 1082|       |
 1083|       |static const uint8_t categories_004D00[256] =
 1084|       |{
 1085|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1086|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1087|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1088|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1089|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1090|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1091|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1092|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1093|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1094|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1095|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1096|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1097|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1098|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1099|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1100|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1101|       |};
 1102|       |
 1103|       |static const uint8_t categories_009F00[256] =
 1104|       |{
 1105|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1106|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1107|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1108|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1109|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1110|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1111|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1112|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1113|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1114|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1115|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1116|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1117|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1118|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1119|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1120|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1121|       |};
 1122|       |
 1123|       |static const uint8_t categories_00A000[256] =
 1124|       |{
 1125|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1126|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lm, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1127|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1128|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1129|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1130|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1131|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1132|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1133|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1134|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1135|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1136|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1137|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1138|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1139|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1140|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1141|       |};
 1142|       |
 1143|       |static const uint8_t categories_00A400[256] =
 1144|       |{
 1145|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1146|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1147|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1148|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1149|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1150|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1151|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1152|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1153|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn,
 1154|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1155|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1156|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1157|       |	/* C0 */ So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1158|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1159|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1160|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lm, Lm, Lm, Lm, Lm, Lm, Po, Po,
 1161|       |};
 1162|       |
 1163|       |static const uint8_t categories_00A600[256] =
 1164|       |{
 1165|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lm, Po, Po, Po,
 1166|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1167|       |	/* 20 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Lo, Lo, Cn, Cn, Cn, Cn,
 1168|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1169|       |	/* 40 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
 1170|       |	/* 50 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
 1171|       |	/* 60 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lo, Mn,
 1172|       |	/* 70 */ Me, Me, Me, Po, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Po, Lm,
 1173|       |	/* 80 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
 1174|       |	/* 90 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lm, Lm, Mn, Mn,
 1175|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1176|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1177|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1178|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1179|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl,
 1180|       |	/* F0 */ Mn, Mn, Po, Po, Po, Po, Po, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1181|       |};
 1182|       |
 1183|       |static const uint8_t categories_00A700[256] =
 1184|       |{
 1185|       |	/* 00 */ Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk,
 1186|       |	/* 10 */ Sk, Sk, Sk, Sk, Sk, Sk, Sk, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm,
 1187|       |	/* 20 */ Sk, Sk, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
 1188|       |	/* 30 */ Ll, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
 1189|       |	/* 40 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
 1190|       |	/* 50 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
 1191|       |	/* 60 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
 1192|       |	/* 70 */ Lm, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Ll, Lu, Ll, Lu, Lu, Ll,
 1193|       |	/* 80 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lm, Sk, Sk, Lu, Ll, Lu, Ll, Lo,
 1194|       |	/* 90 */ Lu, Ll, Lu, Ll, Ll, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll,
 1195|       |	/* A0 */ Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Ll, Lu, Lu, Lu, Lu, Lu, Ll,
 1196|       |	/* B0 */ Lu, Lu, Lu, Lu, Lu, Ll, Lu, Ll, Lu, Ll, Cn, Cn, Cn, Cn, Cn, Cn,
 1197|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1198|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1199|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1200|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Lo, Lm, Lm, Ll, Lo, Lo, Lo, Lo, Lo,
 1201|       |};
 1202|       |
 1203|       |static const uint8_t categories_00A800[256] =
 1204|       |{
 1205|       |	/* 00 */ Lo, Lo, Mn, Lo, Lo, Lo, Mn, Lo, Lo, Lo, Lo, Mn, Lo, Lo, Lo, Lo,
 1206|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1207|       |	/* 20 */ Lo, Lo, Lo, Mc, Mc, Mn, Mn, Mc, So, So, So, So, Cn, Cn, Cn, Cn,
 1208|       |	/* 30 */ No, No, No, No, No, No, So, So, Sc, So, Cn, Cn, Cn, Cn, Cn, Cn,
 1209|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1210|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1211|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1212|       |	/* 70 */ Lo, Lo, Lo, Lo, Po, Po, Po, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1213|       |	/* 80 */ Mc, Mc, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1214|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1215|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1216|       |	/* B0 */ Lo, Lo, Lo, Lo, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc,
 1217|       |	/* C0 */ Mc, Mc, Mc, Mc, Mn, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Po, Po,
 1218|       |	/* D0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
 1219|       |	/* E0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 1220|       |	/* F0 */ Mn, Mn, Lo, Lo, Lo, Lo, Lo, Lo, Po, Po, Po, Lo, Po, Lo, Lo, Mn,
 1221|       |};
 1222|       |
 1223|       |static const uint8_t categories_00A900[256] =
 1224|       |{
 1225|       |	/* 00 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Lo, Lo, Lo, Lo, Lo, Lo,
 1226|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1227|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Po, Po,
 1228|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1229|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 1230|       |	/* 50 */ Mn, Mn, Mc, Mc, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Po,
 1231|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1232|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn,
 1233|       |	/* 80 */ Mn, Mn, Mn, Mc, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1234|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1235|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1236|       |	/* B0 */ Lo, Lo, Lo, Mn, Mc, Mc, Mn, Mn, Mn, Mn, Mc, Mc, Mn, Mc, Mc, Mc,
 1237|       |	/* C0 */ Mc, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Cn, Lm,
 1238|       |	/* D0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Po, Po,
 1239|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Mn, Lm, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1240|       |	/* F0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Lo, Lo, Lo, Lo, Lo, Cn,
 1241|       |};
 1242|       |
 1243|       |static const uint8_t categories_00AA00[256] =
 1244|       |{
 1245|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1246|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1247|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Mn, Mn, Mc,
 1248|       |	/* 30 */ Mc, Mn, Mn, Mc, Mc, Mn, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1249|       |	/* 40 */ Lo, Lo, Lo, Mn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mc, Cn, Cn,
 1250|       |	/* 50 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Po, Po, Po, Po,
 1251|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1252|       |	/* 70 */ Lm, Lo, Lo, Lo, Lo, Lo, Lo, So, So, So, Lo, Mc, Mn, Mc, Lo, Lo,
 1253|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1254|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1255|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1256|       |	/* B0 */ Mn, Lo, Mn, Mn, Mn, Lo, Lo, Mn, Mn, Lo, Lo, Lo, Lo, Lo, Mn, Mn,
 1257|       |	/* C0 */ Lo, Mn, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1258|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Lo, Lo, Lm, Po, Po,
 1259|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mc, Mn, Mn, Mc, Mc,
 1260|       |	/* F0 */ Po, Po, Lo, Lm, Lm, Mc, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1261|       |};
 1262|       |
 1263|       |static const uint8_t categories_00AB00[256] =
 1264|       |{
 1265|       |	/* 00 */ Cn, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
 1266|       |	/* 10 */ Cn, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1267|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
 1268|       |	/* 30 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1269|       |	/* 40 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1270|       |	/* 50 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Sk, Lm, Lm, Lm, Lm,
 1271|       |	/* 60 */ Ll, Ll, Ll, Ll, Ll, Ll, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1272|       |	/* 70 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1273|       |	/* 80 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1274|       |	/* 90 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1275|       |	/* A0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1276|       |	/* B0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1277|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1278|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1279|       |	/* E0 */ Lo, Lo, Lo, Mc, Mc, Mn, Mc, Mc, Mn, Mc, Mc, Po, Mc, Mn, Cn, Cn,
 1280|       |	/* F0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
 1281|       |};
 1282|       |
 1283|       |static const uint8_t categories_00D700[256] =
 1284|       |{
 1285|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1286|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1287|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1288|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1289|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1290|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1291|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1292|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1293|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1294|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1295|       |	/* A0 */ Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1296|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1297|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Lo, Lo, Lo, Lo, Lo,
 1298|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1299|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1300|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn,
 1301|       |};
 1302|       |
 1303|       |static const uint8_t categories_00FA00[256] =
 1304|       |{
 1305|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1306|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1307|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1308|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1309|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1310|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1311|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn,
 1312|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1313|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1314|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1315|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1316|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1317|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1318|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn,
 1319|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1320|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1321|       |};
 1322|       |
 1323|       |static const uint8_t categories_00FB00[256] =
 1324|       |{
 1325|       |	/* 00 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1326|       |	/* 10 */ Cn, Cn, Cn, Ll, Ll, Ll, Ll, Ll, Cn, Cn, Cn, Cn, Cn, Lo, Mn, Lo,
 1327|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Sm, Lo, Lo, Lo, Lo, Lo, Lo,
 1328|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Cn,
 1329|       |	/* 40 */ Lo, Lo, Cn, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1330|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1331|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1332|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1333|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1334|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1335|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1336|       |	/* B0 */ Lo, Lo, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk, Sk,
 1337|       |	/* C0 */ Sk, Sk, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1338|       |	/* D0 */ Cn, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1339|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1340|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1341|       |};
 1342|       |
 1343|       |static const uint8_t categories_00FD00[256] =
 1344|       |{
 1345|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1346|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1347|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1348|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Pe, Ps,
 1349|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1350|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1351|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1352|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1353|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1354|       |	/* 90 */ Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1355|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1356|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1357|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1358|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1359|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1360|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Sc, So, Cn, Cn,
 1361|       |};
 1362|       |
 1363|       |static const uint8_t categories_00FE00[256] =
 1364|       |{
 1365|       |	/* 00 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 1366|       |	/* 10 */ Po, Po, Po, Po, Po, Po, Po, Ps, Pe, Po, Cn, Cn, Cn, Cn, Cn, Cn,
 1367|       |	/* 20 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 1368|       |	/* 30 */ Po, Pd, Pd, Pc, Pc, Ps, Pe, Ps, Pe, Ps, Pe, Ps, Pe, Ps, Pe, Ps,
 1369|       |	/* 40 */ Pe, Ps, Pe, Ps, Pe, Po, Po, Ps, Pe, Po, Po, Po, Po, Pc, Pc, Pc,
 1370|       |	/* 50 */ Po, Po, Po, Cn, Po, Po, Po, Po, Pd, Ps, Pe, Ps, Pe, Ps, Pe, Po,
 1371|       |	/* 60 */ Po, Po, Sm, Pd, Sm, Sm, Sm, Cn, Po, Sc, Po, Po, Cn, Cn, Cn, Cn,
 1372|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1373|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1374|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1375|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1376|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1377|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1378|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1379|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1380|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cf,
 1381|       |};
 1382|       |
 1383|       |static const uint8_t categories_00FF00[256] =
 1384|       |{
 1385|       |	/* 00 */ Cn, Po, Po, Po, Sc, Po, Po, Po, Ps, Pe, Po, Sm, Po, Pd, Po, Po,
 1386|       |	/* 10 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Po, Po, Sm, Sm, Sm, Po,
 1387|       |	/* 20 */ Po, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 1388|       |	/* 30 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Ps, Po, Pe, Sk, Pc,
 1389|       |	/* 40 */ Sk, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1390|       |	/* 50 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ps, Sm, Pe, Sm, Ps,
 1391|       |	/* 60 */ Pe, Po, Ps, Pe, Po, Po, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1392|       |	/* 70 */ Lm, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1393|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1394|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lm, Lm,
 1395|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1396|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
 1397|       |	/* C0 */ Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo,
 1398|       |	/* D0 */ Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Lo, Lo, Lo, Cn, Cn, Cn,
 1399|       |	/* E0 */ Sc, Sc, Sm, Sk, So, Sc, Sc, Cn, So, Sm, Sm, Sm, Sm, So, So, Cn,
 1400|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cf, Cf, Cf, So, So, Cn, Cn,
 1401|       |};
 1402|       |
 1403|       |static const uint8_t categories_010000[256] =
 1404|       |{
 1405|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo,
 1406|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1407|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1408|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Cn, Lo,
 1409|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn,
 1410|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn,
 1411|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1412|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1413|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1414|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1415|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1416|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1417|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1418|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1419|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1420|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn,
 1421|       |};
 1422|       |
 1423|       |static const uint8_t categories_010100[256] =
 1424|       |{
 1425|       |	/* 00 */ Po, Po, Po, Cn, Cn, Cn, Cn, No, No, No, No, No, No, No, No, No,
 1426|       |	/* 10 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 1427|       |	/* 20 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 1428|       |	/* 30 */ No, No, No, No, Cn, Cn, Cn, So, So, So, So, So, So, So, So, So,
 1429|       |	/* 40 */ Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl,
 1430|       |	/* 50 */ Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl,
 1431|       |	/* 60 */ Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl,
 1432|       |	/* 70 */ Nl, Nl, Nl, Nl, Nl, No, No, No, No, So, So, So, So, So, So, So,
 1433|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, No, No, So, So, So, Cn,
 1434|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn,
 1435|       |	/* A0 */ So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1436|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1437|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1438|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1439|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 1440|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, Mn, Cn, Cn,
 1441|       |};
 1442|       |
 1443|       |static const uint8_t categories_010200[256] =
 1444|       |{
 1445|       |	/* 00 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1446|       |	/* 10 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1447|       |	/* 20 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1448|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1449|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1450|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1451|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1452|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1453|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1454|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn,
 1455|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1456|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1457|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1458|       |	/* D0 */ Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1459|       |	/* E0 */ Mn, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 1460|       |	/* F0 */ No, No, No, No, No, No, No, No, No, No, No, No, Cn, Cn, Cn, Cn,
 1461|       |};
 1462|       |
 1463|       |static const uint8_t categories_010300[256] =
 1464|       |{
 1465|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1466|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1467|       |	/* 20 */ No, No, No, No, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Lo, Lo, Lo,
 1468|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1469|       |	/* 40 */ Lo, Nl, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Nl, Cn, Cn, Cn, Cn, Cn,
 1470|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1471|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1472|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Mn, Cn, Cn, Cn, Cn, Cn,
 1473|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1474|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Po,
 1475|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1476|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1477|       |	/* C0 */ Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1478|       |	/* D0 */ Po, Nl, Nl, Nl, Nl, Nl, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1479|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1480|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1481|       |};
 1482|       |
 1483|       |static const uint8_t categories_010400[256] =
 1484|       |{
 1485|       |	/* 00 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 1486|       |	/* 10 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 1487|       |	/* 20 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1488|       |	/* 30 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1489|       |	/* 40 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1490|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1491|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1492|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1493|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1494|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn,
 1495|       |	/* A0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
 1496|       |	/* B0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 1497|       |	/* C0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 1498|       |	/* D0 */ Lu, Lu, Lu, Lu, Cn, Cn, Cn, Cn, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1499|       |	/* E0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1500|       |	/* F0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Cn, Cn, Cn, Cn,
 1501|       |};
 1502|       |
 1503|       |static const uint8_t categories_010500[256] =
 1504|       |{
 1505|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1506|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1507|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1508|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1509|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1510|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1511|       |	/* 60 */ Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Po,
 1512|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1513|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1514|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1515|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1516|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1517|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1518|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1519|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1520|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1521|       |};
 1522|       |
 1523|       |static const uint8_t categories_010700[256] =
 1524|       |{
 1525|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1526|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1527|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1528|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1529|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1530|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1531|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1532|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1533|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1534|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1535|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1536|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1537|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1538|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1539|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1540|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1541|       |};
 1542|       |
 1543|       |static const uint8_t categories_010800[256] =
 1544|       |{
 1545|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo,
 1546|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1547|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1548|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Cn, Cn, Cn, Lo, Cn, Cn, Lo,
 1549|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1550|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Cn, Po, No, No, No, No, No, No, No, No,
 1551|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1552|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, So, So, No, No, No, No, No, No, No,
 1553|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1554|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
 1555|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, No, No, No, No, No, No, No, No, No,
 1556|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1557|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1558|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1559|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1560|       |	/* F0 */ Lo, Lo, Lo, Cn, Lo, Lo, Cn, Cn, Cn, Cn, Cn, No, No, No, No, No,
 1561|       |};
 1562|       |
 1563|       |static const uint8_t categories_010900[256] =
 1564|       |{
 1565|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1566|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, No, No, No, No, No, No, Cn, Cn, Cn, Po,
 1567|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1568|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Po,
 1569|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1570|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1571|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1572|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1573|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1574|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1575|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1576|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, No, No, Lo, Lo,
 1577|       |	/* C0 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 1578|       |	/* D0 */ Cn, Cn, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 1579|       |	/* E0 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 1580|       |	/* F0 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 1581|       |};
 1582|       |
 1583|       |static const uint8_t categories_010A00[256] =
 1584|       |{
 1585|       |	/* 00 */ Lo, Mn, Mn, Mn, Cn, Mn, Mn, Cn, Cn, Cn, Cn, Cn, Mn, Mn, Mn, Mn,
 1586|       |	/* 10 */ Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1587|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1588|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Mn, Mn, Mn, Cn, Cn, Cn, Cn, Mn,
 1589|       |	/* 40 */ No, No, No, No, No, No, No, No, No, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1590|       |	/* 50 */ Po, Po, Po, Po, Po, Po, Po, Po, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1591|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1592|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, No, No, Po,
 1593|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1594|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, No, No, No,
 1595|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1596|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1597|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, So, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1598|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1599|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Mn, Mn, Cn, Cn, Cn, Cn, No, No, No, No, No,
 1600|       |	/* F0 */ Po, Po, Po, Po, Po, Po, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1601|       |};
 1602|       |
 1603|       |static const uint8_t categories_010B00[256] =
 1604|       |{
 1605|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1606|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1607|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1608|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Po, Po, Po, Po, Po, Po, Po,
 1609|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1610|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, No, No, No, No, No, No, No, No,
 1611|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1612|       |	/* 70 */ Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, No, No, No, No, No, No, No, No,
 1613|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1614|       |	/* 90 */ Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Po, Po, Po, Po, Cn, Cn, Cn,
 1615|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, No, No, No, No, No, No, No,
 1616|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1617|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1618|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1619|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1620|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1621|       |};
 1622|       |
 1623|       |static const uint8_t categories_010C00[256] =
 1624|       |{
 1625|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1626|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1627|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1628|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1629|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1630|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1631|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1632|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1633|       |	/* 80 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 1634|       |	/* 90 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 1635|       |	/* A0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 1636|       |	/* B0 */ Lu, Lu, Lu, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1637|       |	/* C0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1638|       |	/* D0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1639|       |	/* E0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1640|       |	/* F0 */ Ll, Ll, Ll, Cn, Cn, Cn, Cn, Cn, Cn, Cn, No, No, No, No, No, No,
 1641|       |};
 1642|       |
 1643|       |static const uint8_t categories_010D00[256] =
 1644|       |{
 1645|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1646|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1647|       |	/* 20 */ Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1648|       |	/* 30 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
 1649|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1650|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1651|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1652|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1653|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1654|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1655|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1656|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1657|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1658|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1659|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1660|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1661|       |};
 1662|       |
 1663|       |static const uint8_t categories_010E00[256] =
 1664|       |{
 1665|       |	/* 00 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1666|       |	/* 10 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1667|       |	/* 20 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1668|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1669|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1670|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1671|       |	/* 60 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 1672|       |	/* 70 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, Cn,
 1673|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1674|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1675|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1676|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1677|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1678|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1679|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1680|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1681|       |};
 1682|       |
 1683|       |static const uint8_t categories_010F00[256] =
 1684|       |{
 1685|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1686|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, No, No, No,
 1687|       |	/* 20 */ No, No, No, No, No, No, No, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1688|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1689|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 1690|       |	/* 50 */ Mn, No, No, No, No, Po, Po, Po, Po, Po, Cn, Cn, Cn, Cn, Cn, Cn,
 1691|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1692|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1693|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1694|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1695|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1696|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1697|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1698|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1699|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1700|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1701|       |};
 1702|       |
 1703|       |static const uint8_t categories_011000[256] =
 1704|       |{
 1705|       |	/* 00 */ Mc, Mn, Mc, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1706|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1707|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1708|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 1709|       |	/* 40 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Po, Po, Po, Po, Po, Po, Po, Cn, Cn,
 1710|       |	/* 50 */ Cn, Cn, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 1711|       |	/* 60 */ No, No, No, No, No, No, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
 1712|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Mn,
 1713|       |	/* 80 */ Mn, Mn, Mc, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1714|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1715|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1716|       |	/* B0 */ Mc, Mc, Mc, Mn, Mn, Mn, Mn, Mc, Mc, Mn, Mn, Po, Po, Cf, Po, Po,
 1717|       |	/* C0 */ Po, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cf, Cn, Cn,
 1718|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1719|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1720|       |	/* F0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
 1721|       |};
 1722|       |
 1723|       |static const uint8_t categories_011100[256] =
 1724|       |{
 1725|       |	/* 00 */ Mn, Mn, Mn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1726|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1727|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Mn, Mc, Mn, Mn, Mn,
 1728|       |	/* 30 */ Mn, Mn, Mn, Mn, Mn, Cn, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
 1729|       |	/* 40 */ Po, Po, Po, Po, Lo, Mc, Mc, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1730|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1731|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1732|       |	/* 70 */ Lo, Lo, Lo, Mn, Po, Po, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1733|       |	/* 80 */ Mn, Mn, Mc, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1734|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1735|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1736|       |	/* B0 */ Lo, Lo, Lo, Mc, Mc, Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mc,
 1737|       |	/* C0 */ Mc, Lo, Lo, Lo, Lo, Po, Po, Po, Po, Mn, Mn, Mn, Mn, Po, Cn, Cn,
 1738|       |	/* D0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Lo, Po, Lo, Po, Po, Po,
 1739|       |	/* E0 */ Cn, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 1740|       |	/* F0 */ No, No, No, No, No, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1741|       |};
 1742|       |
 1743|       |static const uint8_t categories_011200[256] =
 1744|       |{
 1745|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1746|       |	/* 10 */ Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1747|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mc, Mc, Mc, Mn,
 1748|       |	/* 30 */ Mn, Mn, Mc, Mc, Mn, Mc, Mn, Mn, Po, Po, Po, Po, Po, Po, Mn, Cn,
 1749|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1750|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1751|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1752|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1753|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Cn, Lo, Lo, Lo, Lo, Cn, Lo,
 1754|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo,
 1755|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Po, Cn, Cn, Cn, Cn, Cn, Cn,
 1756|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1757|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1758|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn,
 1759|       |	/* E0 */ Mc, Mc, Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Cn, Cn, Cn, Cn,
 1760|       |	/* F0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
 1761|       |};
 1762|       |
 1763|       |static const uint8_t categories_011300[256] =
 1764|       |{
 1765|       |	/* 00 */ Mn, Mn, Mc, Mc, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Lo,
 1766|       |	/* 10 */ Lo, Cn, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1767|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo,
 1768|       |	/* 30 */ Lo, Cn, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Cn, Mn, Mn, Lo, Mc, Mc,
 1769|       |	/* 40 */ Mn, Mc, Mc, Mc, Mc, Cn, Cn, Mc, Mc, Cn, Cn, Mc, Mc, Mc, Cn, Cn,
 1770|       |	/* 50 */ Lo, Cn, Cn, Cn, Cn, Cn, Cn, Mc, Cn, Cn, Cn, Cn, Cn, Lo, Lo, Lo,
 1771|       |	/* 60 */ Lo, Lo, Mc, Mc, Cn, Cn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Cn, Cn,
 1772|       |	/* 70 */ Mn, Mn, Mn, Mn, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1773|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1774|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1775|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1776|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1777|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1778|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1779|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1780|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1781|       |};
 1782|       |
 1783|       |static const uint8_t categories_011400[256] =
 1784|       |{
 1785|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1786|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1787|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1788|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Mc, Mc, Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 1789|       |	/* 40 */ Mc, Mc, Mn, Mn, Mn, Mc, Mn, Lo, Lo, Lo, Lo, Po, Po, Po, Po, Po,
 1790|       |	/* 50 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Po, Cn, Po, Mn, Cn,
 1791|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1792|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1793|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1794|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1795|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1796|       |	/* B0 */ Mc, Mc, Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mc, Mn, Mc, Mc, Mc, Mc, Mn,
 1797|       |	/* C0 */ Mn, Mc, Mn, Mn, Lo, Lo, Po, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1798|       |	/* D0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
 1799|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1800|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1801|       |};
 1802|       |
 1803|       |static const uint8_t categories_011500[256] =
 1804|       |{
 1805|       |	/* 00 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1806|       |	/* 10 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1807|       |	/* 20 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1808|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1809|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1810|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1811|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1812|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1813|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1814|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1815|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mc,
 1816|       |	/* B0 */ Mc, Mc, Mn, Mn, Mn, Mn, Cn, Cn, Mc, Mc, Mc, Mc, Mn, Mn, Mc, Mn,
 1817|       |	/* C0 */ Mn, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po,
 1818|       |	/* D0 */ Po, Po, Po, Po, Po, Po, Po, Po, Lo, Lo, Lo, Lo, Mn, Mn, Cn, Cn,
 1819|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1820|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1821|       |};
 1822|       |
 1823|       |static const uint8_t categories_011600[256] =
 1824|       |{
 1825|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1826|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1827|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1828|       |	/* 30 */ Mc, Mc, Mc, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mc, Mc, Mn, Mc, Mn,
 1829|       |	/* 40 */ Mn, Po, Po, Po, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1830|       |	/* 50 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
 1831|       |	/* 60 */ Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Po, Cn, Cn, Cn,
 1832|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1833|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1834|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1835|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mn, Mc, Mn, Mc, Mc,
 1836|       |	/* B0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mc, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1837|       |	/* C0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
 1838|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1839|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1840|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1841|       |};
 1842|       |
 1843|       |static const uint8_t categories_011700[256] =
 1844|       |{
 1845|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1846|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Mn, Mn, Mn,
 1847|       |	/* 20 */ Mc, Mc, Mn, Mn, Mn, Mn, Mc, Mn, Mn, Mn, Mn, Mn, Cn, Cn, Cn, Cn,
 1848|       |	/* 30 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, No, No, Po, Po, Po, So,
 1849|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1850|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1851|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1852|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1853|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1854|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1855|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1856|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1857|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1858|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1859|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1860|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1861|       |};
 1862|       |
 1863|       |static const uint8_t categories_011800[256] =
 1864|       |{
 1865|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1866|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1867|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mc, Mc, Mc, Mn,
 1868|       |	/* 30 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mc, Mn, Mn, Po, Cn, Cn, Cn, Cn,
 1869|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1870|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1871|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1872|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1873|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1874|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1875|       |	/* A0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 1876|       |	/* B0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 1877|       |	/* C0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1878|       |	/* D0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 1879|       |	/* E0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, No, No, No, No, No, No,
 1880|       |	/* F0 */ No, No, No, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Lo,
 1881|       |};
 1882|       |
 1883|       |static const uint8_t categories_011A00[256] =
 1884|       |{
 1885|       |	/* 00 */ Lo, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Lo, Lo, Lo, Lo, Lo,
 1886|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1887|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1888|       |	/* 30 */ Lo, Lo, Lo, Mn, Mn, Mn, Mn, Mn, Mn, Mc, Lo, Mn, Mn, Mn, Mn, Po,
 1889|       |	/* 40 */ Po, Po, Po, Po, Po, Po, Po, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1890|       |	/* 50 */ Lo, Mn, Mn, Mn, Mn, Mn, Mn, Mc, Mc, Mn, Mn, Mn, Lo, Lo, Lo, Lo,
 1891|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1892|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1893|       |	/* 80 */ Lo, Lo, Lo, Lo, Cn, Cn, Lo, Lo, Lo, Lo, Mn, Mn, Mn, Mn, Mn, Mn,
 1894|       |	/* 90 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mc, Mn, Mn, Po, Po, Po, Lo, Po, Po,
 1895|       |	/* A0 */ Po, Po, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1896|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1897|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1898|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1899|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1900|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1901|       |};
 1902|       |
 1903|       |static const uint8_t categories_011C00[256] =
 1904|       |{
 1905|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo,
 1906|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1907|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mc,
 1908|       |	/* 30 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Mn, Mn, Mn, Mn, Mn, Mn, Mc, Mn,
 1909|       |	/* 40 */ Lo, Po, Po, Po, Po, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1910|       |	/* 50 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, No, No, No, No, No, No,
 1911|       |	/* 60 */ No, No, No, No, No, No, No, No, No, No, No, No, No, Cn, Cn, Cn,
 1912|       |	/* 70 */ Po, Po, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1913|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1914|       |	/* 90 */ Cn, Cn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 1915|       |	/* A0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Mc, Mn, Mn, Mn, Mn, Mn, Mn,
 1916|       |	/* B0 */ Mn, Mc, Mn, Mn, Mc, Mn, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1917|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1918|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1919|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1920|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1921|       |};
 1922|       |
 1923|       |static const uint8_t categories_011D00[256] =
 1924|       |{
 1925|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo,
 1926|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1927|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1928|       |	/* 30 */ Lo, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Cn, Cn, Mn, Cn, Mn, Mn, Cn, Mn,
 1929|       |	/* 40 */ Mn, Mn, Mn, Mn, Mn, Mn, Lo, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1930|       |	/* 50 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
 1931|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo,
 1932|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1933|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Mc, Mc, Mc, Mc, Mc, Cn,
 1934|       |	/* 90 */ Mn, Mn, Cn, Mc, Mc, Mn, Mc, Mn, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1935|       |	/* A0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Cn, Cn,
 1936|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1937|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1938|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1939|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1940|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1941|       |};
 1942|       |
 1943|       |static const uint8_t categories_011E00[256] =
 1944|       |{
 1945|       |	/* 00 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1946|       |	/* 10 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1947|       |	/* 20 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1948|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1949|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1950|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1951|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1952|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1953|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1954|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1955|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1956|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1957|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1958|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1959|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1960|       |	/* F0 */ Lo, Lo, Lo, Mn, Mn, Mc, Mc, Po, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1961|       |};
 1962|       |
 1963|       |static const uint8_t categories_012300[256] =
 1964|       |{
 1965|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1966|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1967|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1968|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1969|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1970|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1971|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1972|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1973|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1974|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn,
 1975|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1976|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1977|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1978|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1979|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1980|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1981|       |};
 1982|       |
 1983|       |static const uint8_t categories_012400[256] =
 1984|       |{
 1985|       |	/* 00 */ Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl,
 1986|       |	/* 10 */ Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl,
 1987|       |	/* 20 */ Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl,
 1988|       |	/* 30 */ Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl,
 1989|       |	/* 40 */ Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl,
 1990|       |	/* 50 */ Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl,
 1991|       |	/* 60 */ Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Nl, Cn,
 1992|       |	/* 70 */ Po, Po, Po, Po, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 1993|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1994|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1995|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1996|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1997|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1998|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 1999|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2000|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2001|       |};
 2002|       |
 2003|       |static const uint8_t categories_012500[256] =
 2004|       |{
 2005|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2006|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2007|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2008|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2009|       |	/* 40 */ Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2010|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2011|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2012|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2013|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2014|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2015|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2016|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2017|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2018|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2019|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2020|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2021|       |};
 2022|       |
 2023|       |static const uint8_t categories_013400[256] =
 2024|       |{
 2025|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2026|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2027|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
 2028|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2029|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2030|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2031|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2032|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2033|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2034|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2035|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2036|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2037|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2038|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2039|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2040|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2041|       |};
 2042|       |
 2043|       |static const uint8_t categories_014600[256] =
 2044|       |{
 2045|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2046|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2047|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2048|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2049|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2050|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2051|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2052|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2053|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2054|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2055|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2056|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2057|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2058|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2059|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2060|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2061|       |};
 2062|       |
 2063|       |static const uint8_t categories_016A00[256] =
 2064|       |{
 2065|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2066|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2067|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2068|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2069|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2070|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
 2071|       |	/* 60 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Po, Po,
 2072|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2073|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2074|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2075|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2076|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2077|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2078|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2079|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn,
 2080|       |	/* F0 */ Mn, Mn, Mn, Mn, Mn, Po, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2081|       |};
 2082|       |
 2083|       |static const uint8_t categories_016B00[256] =
 2084|       |{
 2085|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2086|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2087|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2088|       |	/* 30 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Po, Po, Po, Po, Po, So, So, So, So,
 2089|       |	/* 40 */ Lm, Lm, Lm, Lm, Po, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2090|       |	/* 50 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, No, No, No, No, No,
 2091|       |	/* 60 */ No, No, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2092|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Lo, Lo, Lo,
 2093|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2094|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2095|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2096|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2097|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2098|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2099|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2100|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2101|       |};
 2102|       |
 2103|       |static const uint8_t categories_016E00[256] =
 2104|       |{
 2105|       |	/* 00 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2106|       |	/* 10 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2107|       |	/* 20 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2108|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2109|       |	/* 40 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2110|       |	/* 50 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2111|       |	/* 60 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2112|       |	/* 70 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2113|       |	/* 80 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 2114|       |	/* 90 */ No, No, No, No, No, No, No, Po, Po, Po, Po, Cn, Cn, Cn, Cn, Cn,
 2115|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2116|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2117|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2118|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2119|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2120|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2121|       |};
 2122|       |
 2123|       |static const uint8_t categories_016F00[256] =
 2124|       |{
 2125|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2126|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2127|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2128|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2129|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2130|       |	/* 50 */ Lo, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc,
 2131|       |	/* 60 */ Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc,
 2132|       |	/* 70 */ Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Mc, Cn,
 2133|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Mn,
 2134|       |	/* 90 */ Mn, Mn, Mn, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm, Lm,
 2135|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2136|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2137|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2138|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2139|       |	/* E0 */ Lm, Lm, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2140|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2141|       |};
 2142|       |
 2143|       |static const uint8_t categories_018700[256] =
 2144|       |{
 2145|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2146|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2147|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2148|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2149|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2150|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2151|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2152|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2153|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2154|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2155|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2156|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2157|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2158|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2159|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2160|       |	/* F0 */ Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2161|       |};
 2162|       |
 2163|       |static const uint8_t categories_018A00[256] =
 2164|       |{
 2165|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2166|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2167|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2168|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2169|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2170|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2171|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2172|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2173|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2174|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2175|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2176|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2177|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2178|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2179|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2180|       |	/* F0 */ Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2181|       |};
 2182|       |
 2183|       |static const uint8_t categories_01B100[256] =
 2184|       |{
 2185|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2186|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn,
 2187|       |	/* 20 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2188|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2189|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2190|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2191|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2192|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2193|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2194|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2195|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2196|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2197|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2198|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2199|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2200|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2201|       |};
 2202|       |
 2203|       |static const uint8_t categories_01B200[256] =
 2204|       |{
 2205|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2206|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2207|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2208|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2209|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2210|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2211|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2212|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2213|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2214|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2215|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2216|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2217|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2218|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2219|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2220|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn,
 2221|       |};
 2222|       |
 2223|       |static const uint8_t categories_01BC00[256] =
 2224|       |{
 2225|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2226|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2227|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2228|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2229|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2230|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2231|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn,
 2232|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn,
 2233|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2234|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, So, Mn, Mn, Po,
 2235|       |	/* A0 */ Cf, Cf, Cf, Cf, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2236|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2237|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2238|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2239|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2240|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2241|       |};
 2242|       |
 2243|       |static const uint8_t categories_01D000[256] =
 2244|       |{
 2245|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2246|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2247|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2248|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2249|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2250|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2251|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2252|       |	/* 70 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2253|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2254|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2255|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2256|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2257|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2258|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2259|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2260|       |	/* F0 */ So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2261|       |};
 2262|       |
 2263|       |static const uint8_t categories_01D100[256] =
 2264|       |{
 2265|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2266|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2267|       |	/* 20 */ So, So, So, So, So, So, So, Cn, Cn, So, So, So, So, So, So, So,
 2268|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2269|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2270|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2271|       |	/* 60 */ So, So, So, So, So, Mc, Mc, Mn, Mn, Mn, So, So, So, Mc, Mc, Mc,
 2272|       |	/* 70 */ Mc, Mc, Mc, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Mn, Mn, Mn, Mn, Mn,
 2273|       |	/* 80 */ Mn, Mn, Mn, So, So, Mn, Mn, Mn, Mn, Mn, Mn, Mn, So, So, So, So,
 2274|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2275|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, Mn, Mn, Mn, Mn, So, So,
 2276|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2277|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2278|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2279|       |	/* E0 */ So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2280|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2281|       |};
 2282|       |
 2283|       |static const uint8_t categories_01D200[256] =
 2284|       |{
 2285|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2286|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2287|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2288|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2289|       |	/* 40 */ So, So, Mn, Mn, Mn, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2290|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2291|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2292|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2293|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2294|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2295|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2296|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2297|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2298|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2299|       |	/* E0 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 2300|       |	/* F0 */ No, No, No, No, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2301|       |};
 2302|       |
 2303|       |static const uint8_t categories_01D300[256] =
 2304|       |{
 2305|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2306|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2307|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2308|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2309|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2310|       |	/* 50 */ So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2311|       |	/* 60 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 2312|       |	/* 70 */ No, No, No, No, No, No, No, No, No, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2313|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2314|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2315|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2316|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2317|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2318|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2319|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2320|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2321|       |};
 2322|       |
 2323|       |static const uint8_t categories_01D400[256] =
 2324|       |{
 2325|       |	/* 00 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2326|       |	/* 10 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Ll, Ll, Ll, Ll, Ll, Ll,
 2327|       |	/* 20 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2328|       |	/* 30 */ Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2329|       |	/* 40 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Ll, Ll,
 2330|       |	/* 50 */ Ll, Ll, Ll, Ll, Ll, Cn, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2331|       |	/* 60 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2332|       |	/* 70 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2333|       |	/* 80 */ Lu, Lu, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2334|       |	/* 90 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Cn, Lu, Lu,
 2335|       |	/* A0 */ Cn, Cn, Lu, Cn, Cn, Lu, Lu, Cn, Cn, Lu, Lu, Lu, Lu, Cn, Lu, Lu,
 2336|       |	/* B0 */ Lu, Lu, Lu, Lu, Lu, Lu, Ll, Ll, Ll, Ll, Cn, Ll, Cn, Ll, Ll, Ll,
 2337|       |	/* C0 */ Ll, Ll, Ll, Ll, Cn, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2338|       |	/* D0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2339|       |	/* E0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Ll, Ll, Ll, Ll, Ll, Ll,
 2340|       |	/* F0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2341|       |};
 2342|       |
 2343|       |static const uint8_t categories_01D500[256] =
 2344|       |{
 2345|       |	/* 00 */ Ll, Ll, Ll, Ll, Lu, Lu, Cn, Lu, Lu, Lu, Lu, Cn, Cn, Lu, Lu, Lu,
 2346|       |	/* 10 */ Lu, Lu, Lu, Lu, Lu, Cn, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Cn, Ll, Ll,
 2347|       |	/* 20 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2348|       |	/* 30 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Cn, Lu, Lu, Lu, Lu, Cn,
 2349|       |	/* 40 */ Lu, Lu, Lu, Lu, Lu, Cn, Lu, Cn, Cn, Cn, Lu, Lu, Lu, Lu, Lu, Lu,
 2350|       |	/* 50 */ Lu, Cn, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2351|       |	/* 60 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu,
 2352|       |	/* 70 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2353|       |	/* 80 */ Lu, Lu, Lu, Lu, Lu, Lu, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2354|       |	/* 90 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2355|       |	/* A0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2356|       |	/* B0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Ll, Ll, Ll, Ll, Ll, Ll,
 2357|       |	/* C0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2358|       |	/* D0 */ Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2359|       |	/* E0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Ll, Ll,
 2360|       |	/* F0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2361|       |};
 2362|       |
 2363|       |static const uint8_t categories_01D600[256] =
 2364|       |{
 2365|       |	/* 00 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2366|       |	/* 10 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2367|       |	/* 20 */ Lu, Lu, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2368|       |	/* 30 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu,
 2369|       |	/* 40 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2370|       |	/* 50 */ Lu, Lu, Lu, Lu, Lu, Lu, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2371|       |	/* 60 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2372|       |	/* 70 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2373|       |	/* 80 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Ll, Ll, Ll, Ll, Ll, Ll,
 2374|       |	/* 90 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2375|       |	/* A0 */ Ll, Ll, Ll, Ll, Ll, Ll, Cn, Cn, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2376|       |	/* B0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2377|       |	/* C0 */ Lu, Sm, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2378|       |	/* D0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Sm, Ll, Ll, Ll, Ll,
 2379|       |	/* E0 */ Ll, Ll, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2380|       |	/* F0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Sm, Ll, Ll, Ll, Ll,
 2381|       |};
 2382|       |
 2383|       |static const uint8_t categories_01D700[256] =
 2384|       |{
 2385|       |	/* 00 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2386|       |	/* 10 */ Ll, Ll, Ll, Ll, Ll, Sm, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu,
 2387|       |	/* 20 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2388|       |	/* 30 */ Lu, Lu, Lu, Lu, Lu, Sm, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2389|       |	/* 40 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Sm,
 2390|       |	/* 50 */ Ll, Ll, Ll, Ll, Ll, Ll, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2391|       |	/* 60 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Sm,
 2392|       |	/* 70 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2393|       |	/* 80 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Sm, Ll, Ll, Ll, Ll, Ll, Ll,
 2394|       |	/* 90 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2395|       |	/* A0 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Sm, Ll, Ll, Ll, Ll, Ll, Ll,
 2396|       |	/* B0 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2397|       |	/* C0 */ Ll, Ll, Ll, Sm, Ll, Ll, Ll, Ll, Ll, Ll, Lu, Ll, Cn, Cn, Nd, Nd,
 2398|       |	/* D0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
 2399|       |	/* E0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
 2400|       |	/* F0 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd,
 2401|       |};
 2402|       |
 2403|       |static const uint8_t categories_01DA00[256] =
 2404|       |{
 2405|       |	/* 00 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2406|       |	/* 10 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2407|       |	/* 20 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2408|       |	/* 30 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, So, So, So, So, Mn, Mn, Mn, Mn, Mn,
 2409|       |	/* 40 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2410|       |	/* 50 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2411|       |	/* 60 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, So, So, So,
 2412|       |	/* 70 */ So, So, So, So, So, Mn, So, So, So, So, So, So, So, So, So, So,
 2413|       |	/* 80 */ So, So, So, So, Mn, So, So, Po, Po, Po, Po, Po, Cn, Cn, Cn, Cn,
 2414|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Mn, Mn, Mn, Mn, Mn,
 2415|       |	/* A0 */ Cn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2416|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2417|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2418|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2419|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2420|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2421|       |};
 2422|       |
 2423|       |static const uint8_t categories_01E000[256] =
 2424|       |{
 2425|       |	/* 00 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2426|       |	/* 10 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Cn, Mn, Mn, Mn, Mn, Mn,
 2427|       |	/* 20 */ Mn, Mn, Cn, Mn, Mn, Cn, Mn, Mn, Mn, Mn, Mn, Cn, Cn, Cn, Cn, Cn,
 2428|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2429|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2430|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2431|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2432|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2433|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2434|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2435|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2436|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2437|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2438|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2439|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2440|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2441|       |};
 2442|       |
 2443|       |static const uint8_t categories_01E800[256] =
 2444|       |{
 2445|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2446|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2447|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2448|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2449|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2450|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2451|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2452|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2453|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2454|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2455|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2456|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2457|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Cn, Cn, No, No, No, No, No, No, No, No, No,
 2458|       |	/* D0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2459|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2460|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2461|       |};
 2462|       |
 2463|       |static const uint8_t categories_01E900[256] =
 2464|       |{
 2465|       |	/* 00 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2466|       |	/* 10 */ Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu, Lu,
 2467|       |	/* 20 */ Lu, Lu, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2468|       |	/* 30 */ Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll, Ll,
 2469|       |	/* 40 */ Ll, Ll, Ll, Ll, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Cn, Cn, Cn, Cn, Cn,
 2470|       |	/* 50 */ Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Nd, Cn, Cn, Cn, Cn, Po, Po,
 2471|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2472|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2473|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2474|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2475|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2476|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2477|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2478|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2479|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2480|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2481|       |};
 2482|       |
 2483|       |static const uint8_t categories_01EC00[256] =
 2484|       |{
 2485|       |	/* 00 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2486|       |	/* 10 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2487|       |	/* 20 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2488|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2489|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2490|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2491|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2492|       |	/* 70 */ Cn, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 2493|       |	/* 80 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 2494|       |	/* 90 */ No, No, No, No, No, No, No, No, No, No, No, No, No, No, No, No,
 2495|       |	/* A0 */ No, No, No, No, No, No, No, No, No, No, No, No, So, No, No, No,
 2496|       |	/* B0 */ Sc, No, No, No, No, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2497|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2498|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2499|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2500|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2501|       |};
 2502|       |
 2503|       |static const uint8_t categories_01EE00[256] =
 2504|       |{
 2505|       |	/* 00 */ Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2506|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2507|       |	/* 20 */ Cn, Lo, Lo, Cn, Lo, Cn, Cn, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2508|       |	/* 30 */ Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Cn, Lo, Cn, Lo, Cn, Cn, Cn, Cn,
 2509|       |	/* 40 */ Cn, Cn, Lo, Cn, Cn, Cn, Cn, Lo, Cn, Lo, Cn, Lo, Cn, Lo, Lo, Lo,
 2510|       |	/* 50 */ Cn, Lo, Lo, Cn, Lo, Cn, Cn, Lo, Cn, Lo, Cn, Lo, Cn, Lo, Cn, Lo,
 2511|       |	/* 60 */ Cn, Lo, Lo, Cn, Lo, Cn, Cn, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo,
 2512|       |	/* 70 */ Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Cn, Lo, Cn,
 2513|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo,
 2514|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn,
 2515|       |	/* A0 */ Cn, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo, Cn, Lo, Lo, Lo, Lo, Lo,
 2516|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn,
 2517|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2518|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2519|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2520|       |	/* F0 */ Sm, Sm, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2521|       |};
 2522|       |
 2523|       |static const uint8_t categories_01F000[256] =
 2524|       |{
 2525|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2526|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2527|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn,
 2528|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2529|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2530|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2531|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2532|       |	/* 70 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2533|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2534|       |	/* 90 */ So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2535|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, Cn,
 2536|       |	/* B0 */ Cn, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2537|       |	/* C0 */ Cn, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2538|       |	/* D0 */ Cn, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2539|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2540|       |	/* F0 */ So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2541|       |};
 2542|       |
 2543|       |static const uint8_t categories_01F100[256] =
 2544|       |{
 2545|       |	/* 00 */ No, No, No, No, No, No, No, No, No, No, No, No, No, Cn, Cn, Cn,
 2546|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2547|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2548|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2549|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2550|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2551|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn,
 2552|       |	/* 70 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2553|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2554|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2555|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn,
 2556|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2557|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2558|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2559|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, So, So, So, So, So, So, So, So, So, So,
 2560|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2561|       |};
 2562|       |
 2563|       |static const uint8_t categories_01F200[256] =
 2564|       |{
 2565|       |	/* 00 */ So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2566|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2567|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2568|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn,
 2569|       |	/* 40 */ So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2570|       |	/* 50 */ So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2571|       |	/* 60 */ So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2572|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2573|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2574|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2575|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2576|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2577|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2578|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2579|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2580|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2581|       |};
 2582|       |
 2583|       |static const uint8_t categories_01F300[256] =
 2584|       |{
 2585|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2586|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2587|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2588|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2589|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2590|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2591|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2592|       |	/* 70 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2593|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2594|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2595|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2596|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2597|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2598|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2599|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2600|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, So, Sk, Sk, Sk, Sk, Sk,
 2601|       |};
 2602|       |
 2603|       |static const uint8_t categories_01F600[256] =
 2604|       |{
 2605|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2606|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2607|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2608|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2609|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2610|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2611|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2612|       |	/* 70 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2613|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2614|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2615|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2616|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2617|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2618|       |	/* D0 */ So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2619|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn,
 2620|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn,
 2621|       |};
 2622|       |
 2623|       |static const uint8_t categories_01F700[256] =
 2624|       |{
 2625|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2626|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2627|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2628|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2629|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2630|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2631|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2632|       |	/* 70 */ So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2633|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2634|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2635|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2636|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2637|       |	/* C0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2638|       |	/* D0 */ So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2639|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2640|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2641|       |};
 2642|       |
 2643|       |static const uint8_t categories_01F800[256] =
 2644|       |{
 2645|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn,
 2646|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2647|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2648|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2649|       |	/* 40 */ So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2650|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn,
 2651|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2652|       |	/* 70 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2653|       |	/* 80 */ So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2654|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2655|       |	/* A0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, Cn, Cn,
 2656|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2657|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2658|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2659|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2660|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2661|       |};
 2662|       |
 2663|       |static const uint8_t categories_01F900[256] =
 2664|       |{
 2665|       |	/* 00 */ So, So, So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn,
 2666|       |	/* 10 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2667|       |	/* 20 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2668|       |	/* 30 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, Cn,
 2669|       |	/* 40 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2670|       |	/* 50 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2671|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2672|       |	/* 70 */ So, Cn, Cn, So, So, So, So, Cn, Cn, Cn, So, Cn, So, So, So, So,
 2673|       |	/* 80 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2674|       |	/* 90 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2675|       |	/* A0 */ So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2676|       |	/* B0 */ So, So, So, So, So, So, So, So, So, So, Cn, Cn, Cn, Cn, Cn, Cn,
 2677|       |	/* C0 */ So, So, So, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2678|       |	/* D0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2679|       |	/* E0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2680|       |	/* F0 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, So, So,
 2681|       |};
 2682|       |
 2683|       |static const uint8_t categories_01FA00[256] =
 2684|       |{
 2685|       |	/* 00 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2686|       |	/* 10 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2687|       |	/* 20 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2688|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2689|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2690|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2691|       |	/* 60 */ So, So, So, So, So, So, So, So, So, So, So, So, So, So, Cn, Cn,
 2692|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2693|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2694|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2695|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2696|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2697|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2698|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2699|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2700|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2701|       |};
 2702|       |
 2703|       |static const uint8_t categories_02A600[256] =
 2704|       |{
 2705|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2706|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2707|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2708|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2709|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2710|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2711|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2712|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2713|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2714|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2715|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2716|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2717|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2718|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2719|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2720|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2721|       |};
 2722|       |
 2723|       |static const uint8_t categories_02B700[256] =
 2724|       |{
 2725|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2726|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2727|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2728|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2729|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2730|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2731|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2732|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2733|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2734|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2735|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2736|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2737|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2738|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2739|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2740|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2741|       |};
 2742|       |
 2743|       |static const uint8_t categories_02B800[256] =
 2744|       |{
 2745|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2746|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn,
 2747|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2748|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2749|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2750|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2751|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2752|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2753|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2754|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2755|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2756|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2757|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2758|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2759|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2760|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2761|       |};
 2762|       |
 2763|       |static const uint8_t categories_02CE00[256] =
 2764|       |{
 2765|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2766|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2767|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2768|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2769|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2770|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2771|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2772|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2773|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2774|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2775|       |	/* A0 */ Lo, Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2776|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2777|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2778|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2779|       |	/* E0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2780|       |	/* F0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2781|       |};
 2782|       |
 2783|       |static const uint8_t categories_02EB00[256] =
 2784|       |{
 2785|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2786|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2787|       |	/* 20 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2788|       |	/* 30 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2789|       |	/* 40 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2790|       |	/* 50 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2791|       |	/* 60 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2792|       |	/* 70 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2793|       |	/* 80 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2794|       |	/* 90 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2795|       |	/* A0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2796|       |	/* B0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2797|       |	/* C0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2798|       |	/* D0 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2799|       |	/* E0 */ Lo, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2800|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2801|       |};
 2802|       |
 2803|       |static const uint8_t categories_02FA00[256] =
 2804|       |{
 2805|       |	/* 00 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo,
 2806|       |	/* 10 */ Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Lo, Cn, Cn,
 2807|       |	/* 20 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2808|       |	/* 30 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2809|       |	/* 40 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2810|       |	/* 50 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2811|       |	/* 60 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2812|       |	/* 70 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2813|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2814|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2815|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2816|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2817|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2818|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2819|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2820|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2821|       |};
 2822|       |
 2823|       |static const uint8_t categories_0E0000[256] =
 2824|       |{
 2825|       |	/* 00 */ Cn, Cf, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2826|       |	/* 10 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2827|       |	/* 20 */ Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf,
 2828|       |	/* 30 */ Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf,
 2829|       |	/* 40 */ Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf,
 2830|       |	/* 50 */ Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf,
 2831|       |	/* 60 */ Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf,
 2832|       |	/* 70 */ Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf, Cf,
 2833|       |	/* 80 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2834|       |	/* 90 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2835|       |	/* A0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2836|       |	/* B0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2837|       |	/* C0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2838|       |	/* D0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2839|       |	/* E0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2840|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2841|       |};
 2842|       |
 2843|       |static const uint8_t categories_0E0100[256] =
 2844|       |{
 2845|       |	/* 00 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2846|       |	/* 10 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2847|       |	/* 20 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2848|       |	/* 30 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2849|       |	/* 40 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2850|       |	/* 50 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2851|       |	/* 60 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2852|       |	/* 70 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2853|       |	/* 80 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2854|       |	/* 90 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2855|       |	/* A0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2856|       |	/* B0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2857|       |	/* C0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2858|       |	/* D0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2859|       |	/* E0 */ Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn, Mn,
 2860|       |	/* F0 */ Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn, Cn,
 2861|       |};
 2862|       |
 2863|       |static const uint8_t *categories_000000_00D7FF[] =
 2864|       |{
 2865|       |	categories_000000,
 2866|       |	categories_000100,
 2867|       |	categories_000200,
 2868|       |	categories_000300,
 2869|       |	categories_000400,
 2870|       |	categories_000500,
 2871|       |	categories_000600,
 2872|       |	categories_000700,
 2873|       |	categories_000800,
 2874|       |	categories_000900,
 2875|       |	categories_000A00,
 2876|       |	categories_000B00,
 2877|       |	categories_000C00,
 2878|       |	categories_000D00,
 2879|       |	categories_000E00,
 2880|       |	categories_000F00,
 2881|       |	categories_001000,
 2882|       |	categories_Lo, /* 001100 */
 2883|       |	categories_001200,
 2884|       |	categories_001300,
 2885|       |	categories_001400,
 2886|       |	categories_Lo, /* 001500 */
 2887|       |	categories_001600,
 2888|       |	categories_001700,
 2889|       |	categories_001800,
 2890|       |	categories_001900,
 2891|       |	categories_001A00,
 2892|       |	categories_001B00,
 2893|       |	categories_001C00,
 2894|       |	categories_001D00,
 2895|       |	categories_001E00,
 2896|       |	categories_001F00,
 2897|       |	categories_002000,
 2898|       |	categories_002100,
 2899|       |	categories_Sm, /* 002200 */
 2900|       |	categories_002300,
 2901|       |	categories_002400,
 2902|       |	categories_002500,
 2903|       |	categories_002600,
 2904|       |	categories_002700,
 2905|       |	categories_So, /* 002800 */
 2906|       |	categories_002900,
 2907|       |	categories_Sm, /* 002A00 */
 2908|       |	categories_002B00,
 2909|       |	categories_002C00,
 2910|       |	categories_002D00,
 2911|       |	categories_002E00,
 2912|       |	categories_002F00,
 2913|       |	categories_003000,
 2914|       |	categories_003100,
 2915|       |	categories_003200,
 2916|       |	categories_So, /* 003300 */
 2917|       |	categories_Lo, /* 003400 */
 2918|       |	categories_Lo, /* 003500 */
 2919|       |	categories_Lo, /* 003600 */
 2920|       |	categories_Lo, /* 003700 */
 2921|       |	categories_Lo, /* 003800 */
 2922|       |	categories_Lo, /* 003900 */
 2923|       |	categories_Lo, /* 003A00 */
 2924|       |	categories_Lo, /* 003B00 */
 2925|       |	categories_Lo, /* 003C00 */
 2926|       |	categories_Lo, /* 003D00 */
 2927|       |	categories_Lo, /* 003E00 */
 2928|       |	categories_Lo, /* 003F00 */
 2929|       |	categories_Lo, /* 004000 */
 2930|       |	categories_Lo, /* 004100 */
 2931|       |	categories_Lo, /* 004200 */
 2932|       |	categories_Lo, /* 004300 */
 2933|       |	categories_Lo, /* 004400 */
 2934|       |	categories_Lo, /* 004500 */
 2935|       |	categories_Lo, /* 004600 */
 2936|       |	categories_Lo, /* 004700 */
 2937|       |	categories_Lo, /* 004800 */
 2938|       |	categories_Lo, /* 004900 */
 2939|       |	categories_Lo, /* 004A00 */
 2940|       |	categories_Lo, /* 004B00 */
 2941|       |	categories_Lo, /* 004C00 */
 2942|       |	categories_004D00,
 2943|       |	categories_Lo, /* 004E00 */
 2944|       |	categories_Lo, /* 004F00 */
 2945|       |	categories_Lo, /* 005000 */
 2946|       |	categories_Lo, /* 005100 */
 2947|       |	categories_Lo, /* 005200 */
 2948|       |	categories_Lo, /* 005300 */
 2949|       |	categories_Lo, /* 005400 */
 2950|       |	categories_Lo, /* 005500 */
 2951|       |	categories_Lo, /* 005600 */
 2952|       |	categories_Lo, /* 005700 */
 2953|       |	categories_Lo, /* 005800 */
 2954|       |	categories_Lo, /* 005900 */
 2955|       |	categories_Lo, /* 005A00 */
 2956|       |	categories_Lo, /* 005B00 */
 2957|       |	categories_Lo, /* 005C00 */
 2958|       |	categories_Lo, /* 005D00 */
 2959|       |	categories_Lo, /* 005E00 */
 2960|       |	categories_Lo, /* 005F00 */
 2961|       |	categories_Lo, /* 006000 */
 2962|       |	categories_Lo, /* 006100 */
 2963|       |	categories_Lo, /* 006200 */
 2964|       |	categories_Lo, /* 006300 */
 2965|       |	categories_Lo, /* 006400 */
 2966|       |	categories_Lo, /* 006500 */
 2967|       |	categories_Lo, /* 006600 */
 2968|       |	categories_Lo, /* 006700 */
 2969|       |	categories_Lo, /* 006800 */
 2970|       |	categories_Lo, /* 006900 */
 2971|       |	categories_Lo, /* 006A00 */
 2972|       |	categories_Lo, /* 006B00 */
 2973|       |	categories_Lo, /* 006C00 */
 2974|       |	categories_Lo, /* 006D00 */
 2975|       |	categories_Lo, /* 006E00 */
 2976|       |	categories_Lo, /* 006F00 */
 2977|       |	categories_Lo, /* 007000 */
 2978|       |	categories_Lo, /* 007100 */
 2979|       |	categories_Lo, /* 007200 */
 2980|       |	categories_Lo, /* 007300 */
 2981|       |	categories_Lo, /* 007400 */
 2982|       |	categories_Lo, /* 007500 */
 2983|       |	categories_Lo, /* 007600 */
 2984|       |	categories_Lo, /* 007700 */
 2985|       |	categories_Lo, /* 007800 */
 2986|       |	categories_Lo, /* 007900 */
 2987|       |	categories_Lo, /* 007A00 */
 2988|       |	categories_Lo, /* 007B00 */
 2989|       |	categories_Lo, /* 007C00 */
 2990|       |	categories_Lo, /* 007D00 */
 2991|       |	categories_Lo, /* 007E00 */
 2992|       |	categories_Lo, /* 007F00 */
 2993|       |	categories_Lo, /* 008000 */
 2994|       |	categories_Lo, /* 008100 */
 2995|       |	categories_Lo, /* 008200 */
 2996|       |	categories_Lo, /* 008300 */
 2997|       |	categories_Lo, /* 008400 */
 2998|       |	categories_Lo, /* 008500 */
 2999|       |	categories_Lo, /* 008600 */
 3000|       |	categories_Lo, /* 008700 */
 3001|       |	categories_Lo, /* 008800 */
 3002|       |	categories_Lo, /* 008900 */
 3003|       |	categories_Lo, /* 008A00 */
 3004|       |	categories_Lo, /* 008B00 */
 3005|       |	categories_Lo, /* 008C00 */
 3006|       |	categories_Lo, /* 008D00 */
 3007|       |	categories_Lo, /* 008E00 */
 3008|       |	categories_Lo, /* 008F00 */
 3009|       |	categories_Lo, /* 009000 */
 3010|       |	categories_Lo, /* 009100 */
 3011|       |	categories_Lo, /* 009200 */
 3012|       |	categories_Lo, /* 009300 */
 3013|       |	categories_Lo, /* 009400 */
 3014|       |	categories_Lo, /* 009500 */
 3015|       |	categories_Lo, /* 009600 */
 3016|       |	categories_Lo, /* 009700 */
 3017|       |	categories_Lo, /* 009800 */
 3018|       |	categories_Lo, /* 009900 */
 3019|       |	categories_Lo, /* 009A00 */
 3020|       |	categories_Lo, /* 009B00 */
 3021|       |	categories_Lo, /* 009C00 */
 3022|       |	categories_Lo, /* 009D00 */
 3023|       |	categories_Lo, /* 009E00 */
 3024|       |	categories_009F00,
 3025|       |	categories_00A000,
 3026|       |	categories_Lo, /* 00A100 */
 3027|       |	categories_Lo, /* 00A200 */
 3028|       |	categories_Lo, /* 00A300 */
 3029|       |	categories_00A400,
 3030|       |	categories_Lo, /* 00A500 */
 3031|       |	categories_00A600,
 3032|       |	categories_00A700,
 3033|       |	categories_00A800,
 3034|       |	categories_00A900,
 3035|       |	categories_00AA00,
 3036|       |	categories_00AB00,
 3037|       |	categories_Lo, /* 00AC00 */
 3038|       |	categories_Lo, /* 00AD00 */
 3039|       |	categories_Lo, /* 00AE00 */
 3040|       |	categories_Lo, /* 00AF00 */
 3041|       |	categories_Lo, /* 00B000 */
 3042|       |	categories_Lo, /* 00B100 */
 3043|       |	categories_Lo, /* 00B200 */
 3044|       |	categories_Lo, /* 00B300 */
 3045|       |	categories_Lo, /* 00B400 */
 3046|       |	categories_Lo, /* 00B500 */
 3047|       |	categories_Lo, /* 00B600 */
 3048|       |	categories_Lo, /* 00B700 */
 3049|       |	categories_Lo, /* 00B800 */
 3050|       |	categories_Lo, /* 00B900 */
 3051|       |	categories_Lo, /* 00BA00 */
 3052|       |	categories_Lo, /* 00BB00 */
 3053|       |	categories_Lo, /* 00BC00 */
 3054|       |	categories_Lo, /* 00BD00 */
 3055|       |	categories_Lo, /* 00BE00 */
 3056|       |	categories_Lo, /* 00BF00 */
 3057|       |	categories_Lo, /* 00C000 */
 3058|       |	categories_Lo, /* 00C100 */
 3059|       |	categories_Lo, /* 00C200 */
 3060|       |	categories_Lo, /* 00C300 */
 3061|       |	categories_Lo, /* 00C400 */
 3062|       |	categories_Lo, /* 00C500 */
 3063|       |	categories_Lo, /* 00C600 */
 3064|       |	categories_Lo, /* 00C700 */
 3065|       |	categories_Lo, /* 00C800 */
 3066|       |	categories_Lo, /* 00C900 */
 3067|       |	categories_Lo, /* 00CA00 */
 3068|       |	categories_Lo, /* 00CB00 */
 3069|       |	categories_Lo, /* 00CC00 */
 3070|       |	categories_Lo, /* 00CD00 */
 3071|       |	categories_Lo, /* 00CE00 */
 3072|       |	categories_Lo, /* 00CF00 */
 3073|       |	categories_Lo, /* 00D000 */
 3074|       |	categories_Lo, /* 00D100 */
 3075|       |	categories_Lo, /* 00D200 */
 3076|       |	categories_Lo, /* 00D300 */
 3077|       |	categories_Lo, /* 00D400 */
 3078|       |	categories_Lo, /* 00D500 */
 3079|       |	categories_Lo, /* 00D600 */
 3080|       |	categories_00D700,
 3081|       |};
 3082|       |
 3083|       |static const uint8_t *categories_00F800_02FAFF[] =
 3084|       |{
 3085|       |	categories_Co, /* 00F800 */
 3086|       |	categories_Lo, /* 00F900 */
 3087|       |	categories_00FA00,
 3088|       |	categories_00FB00,
 3089|       |	categories_Lo, /* 00FC00 */
 3090|       |	categories_00FD00,
 3091|       |	categories_00FE00,
 3092|       |	categories_00FF00,
 3093|       |	categories_010000,
 3094|       |	categories_010100,
 3095|       |	categories_010200,
 3096|       |	categories_010300,
 3097|       |	categories_010400,
 3098|       |	categories_010500,
 3099|       |	categories_Lo, /* 010600 */
 3100|       |	categories_010700,
 3101|       |	categories_010800,
 3102|       |	categories_010900,
 3103|       |	categories_010A00,
 3104|       |	categories_010B00,
 3105|       |	categories_010C00,
 3106|       |	categories_010D00,
 3107|       |	categories_010E00,
 3108|       |	categories_010F00,
 3109|       |	categories_011000,
 3110|       |	categories_011100,
 3111|       |	categories_011200,
 3112|       |	categories_011300,
 3113|       |	categories_011400,
 3114|       |	categories_011500,
 3115|       |	categories_011600,
 3116|       |	categories_011700,
 3117|       |	categories_011800,
 3118|       |	categories_Cn, /* 011900 */
 3119|       |	categories_011A00,
 3120|       |	categories_Cn, /* 011B00 */
 3121|       |	categories_011C00,
 3122|       |	categories_011D00,
 3123|       |	categories_011E00,
 3124|       |	categories_Cn, /* 011F00 */
 3125|       |	categories_Lo, /* 012000 */
 3126|       |	categories_Lo, /* 012100 */
 3127|       |	categories_Lo, /* 012200 */
 3128|       |	categories_012300,
 3129|       |	categories_012400,
 3130|       |	categories_012500,
 3131|       |	categories_Cn, /* 012600 */
 3132|       |	categories_Cn, /* 012700 */
 3133|       |	categories_Cn, /* 012800 */
 3134|       |	categories_Cn, /* 012900 */
 3135|       |	categories_Cn, /* 012A00 */
 3136|       |	categories_Cn, /* 012B00 */
 3137|       |	categories_Cn, /* 012C00 */
 3138|       |	categories_Cn, /* 012D00 */
 3139|       |	categories_Cn, /* 012E00 */
 3140|       |	categories_Cn, /* 012F00 */
 3141|       |	categories_Lo, /* 013000 */
 3142|       |	categories_Lo, /* 013100 */
 3143|       |	categories_Lo, /* 013200 */
 3144|       |	categories_Lo, /* 013300 */
 3145|       |	categories_013400,
 3146|       |	categories_Cn, /* 013500 */
 3147|       |	categories_Cn, /* 013600 */
 3148|       |	categories_Cn, /* 013700 */
 3149|       |	categories_Cn, /* 013800 */
 3150|       |	categories_Cn, /* 013900 */
 3151|       |	categories_Cn, /* 013A00 */
 3152|       |	categories_Cn, /* 013B00 */
 3153|       |	categories_Cn, /* 013C00 */
 3154|       |	categories_Cn, /* 013D00 */
 3155|       |	categories_Cn, /* 013E00 */
 3156|       |	categories_Cn, /* 013F00 */
 3157|       |	categories_Cn, /* 014000 */
 3158|       |	categories_Cn, /* 014100 */
 3159|       |	categories_Cn, /* 014200 */
 3160|       |	categories_Cn, /* 014300 */
 3161|       |	categories_Lo, /* 014400 */
 3162|       |	categories_Lo, /* 014500 */
 3163|       |	categories_014600,
 3164|       |	categories_Cn, /* 014700 */
 3165|       |	categories_Cn, /* 014800 */
 3166|       |	categories_Cn, /* 014900 */
 3167|       |	categories_Cn, /* 014A00 */
 3168|       |	categories_Cn, /* 014B00 */
 3169|       |	categories_Cn, /* 014C00 */
 3170|       |	categories_Cn, /* 014D00 */
 3171|       |	categories_Cn, /* 014E00 */
 3172|       |	categories_Cn, /* 014F00 */
 3173|       |	categories_Cn, /* 015000 */
 3174|       |	categories_Cn, /* 015100 */
 3175|       |	categories_Cn, /* 015200 */
 3176|       |	categories_Cn, /* 015300 */
 3177|       |	categories_Cn, /* 015400 */
 3178|       |	categories_Cn, /* 015500 */
 3179|       |	categories_Cn, /* 015600 */
 3180|       |	categories_Cn, /* 015700 */
 3181|       |	categories_Cn, /* 015800 */
 3182|       |	categories_Cn, /* 015900 */
 3183|       |	categories_Cn, /* 015A00 */
 3184|       |	categories_Cn, /* 015B00 */
 3185|       |	categories_Cn, /* 015C00 */
 3186|       |	categories_Cn, /* 015D00 */
 3187|       |	categories_Cn, /* 015E00 */
 3188|       |	categories_Cn, /* 015F00 */
 3189|       |	categories_Cn, /* 016000 */
 3190|       |	categories_Cn, /* 016100 */
 3191|       |	categories_Cn, /* 016200 */
 3192|       |	categories_Cn, /* 016300 */
 3193|       |	categories_Cn, /* 016400 */
 3194|       |	categories_Cn, /* 016500 */
 3195|       |	categories_Cn, /* 016600 */
 3196|       |	categories_Cn, /* 016700 */
 3197|       |	categories_Lo, /* 016800 */
 3198|       |	categories_Lo, /* 016900 */
 3199|       |	categories_016A00,
 3200|       |	categories_016B00,
 3201|       |	categories_Cn, /* 016C00 */
 3202|       |	categories_Cn, /* 016D00 */
 3203|       |	categories_016E00,
 3204|       |	categories_016F00,
 3205|       |	categories_Lo, /* 017000 */
 3206|       |	categories_Lo, /* 017100 */
 3207|       |	categories_Lo, /* 017200 */
 3208|       |	categories_Lo, /* 017300 */
 3209|       |	categories_Lo, /* 017400 */
 3210|       |	categories_Lo, /* 017500 */
 3211|       |	categories_Lo, /* 017600 */
 3212|       |	categories_Lo, /* 017700 */
 3213|       |	categories_Lo, /* 017800 */
 3214|       |	categories_Lo, /* 017900 */
 3215|       |	categories_Lo, /* 017A00 */
 3216|       |	categories_Lo, /* 017B00 */
 3217|       |	categories_Lo, /* 017C00 */
 3218|       |	categories_Lo, /* 017D00 */
 3219|       |	categories_Lo, /* 017E00 */
 3220|       |	categories_Lo, /* 017F00 */
 3221|       |	categories_Lo, /* 018000 */
 3222|       |	categories_Lo, /* 018100 */
 3223|       |	categories_Lo, /* 018200 */
 3224|       |	categories_Lo, /* 018300 */
 3225|       |	categories_Lo, /* 018400 */
 3226|       |	categories_Lo, /* 018500 */
 3227|       |	categories_Lo, /* 018600 */
 3228|       |	categories_018700,
 3229|       |	categories_Lo, /* 018800 */
 3230|       |	categories_Lo, /* 018900 */
 3231|       |	categories_018A00,
 3232|       |	categories_Cn, /* 018B00 */
 3233|       |	categories_Cn, /* 018C00 */
 3234|       |	categories_Cn, /* 018D00 */
 3235|       |	categories_Cn, /* 018E00 */
 3236|       |	categories_Cn, /* 018F00 */
 3237|       |	categories_Cn, /* 019000 */
 3238|       |	categories_Cn, /* 019100 */
 3239|       |	categories_Cn, /* 019200 */
 3240|       |	categories_Cn, /* 019300 */
 3241|       |	categories_Cn, /* 019400 */
 3242|       |	categories_Cn, /* 019500 */
 3243|       |	categories_Cn, /* 019600 */
 3244|       |	categories_Cn, /* 019700 */
 3245|       |	categories_Cn, /* 019800 */
 3246|       |	categories_Cn, /* 019900 */
 3247|       |	categories_Cn, /* 019A00 */
 3248|       |	categories_Cn, /* 019B00 */
 3249|       |	categories_Cn, /* 019C00 */
 3250|       |	categories_Cn, /* 019D00 */
 3251|       |	categories_Cn, /* 019E00 */
 3252|       |	categories_Cn, /* 019F00 */
 3253|       |	categories_Cn, /* 01A000 */
 3254|       |	categories_Cn, /* 01A100 */
 3255|       |	categories_Cn, /* 01A200 */
 3256|       |	categories_Cn, /* 01A300 */
 3257|       |	categories_Cn, /* 01A400 */
 3258|       |	categories_Cn, /* 01A500 */
 3259|       |	categories_Cn, /* 01A600 */
 3260|       |	categories_Cn, /* 01A700 */
 3261|       |	categories_Cn, /* 01A800 */
 3262|       |	categories_Cn, /* 01A900 */
 3263|       |	categories_Cn, /* 01AA00 */
 3264|       |	categories_Cn, /* 01AB00 */
 3265|       |	categories_Cn, /* 01AC00 */
 3266|       |	categories_Cn, /* 01AD00 */
 3267|       |	categories_Cn, /* 01AE00 */
 3268|       |	categories_Cn, /* 01AF00 */
 3269|       |	categories_Lo, /* 01B000 */
 3270|       |	categories_01B100,
 3271|       |	categories_01B200,
 3272|       |	categories_Cn, /* 01B300 */
 3273|       |	categories_Cn, /* 01B400 */
 3274|       |	categories_Cn, /* 01B500 */
 3275|       |	categories_Cn, /* 01B600 */
 3276|       |	categories_Cn, /* 01B700 */
 3277|       |	categories_Cn, /* 01B800 */
 3278|       |	categories_Cn, /* 01B900 */
 3279|       |	categories_Cn, /* 01BA00 */
 3280|       |	categories_Cn, /* 01BB00 */
 3281|       |	categories_01BC00,
 3282|       |	categories_Cn, /* 01BD00 */
 3283|       |	categories_Cn, /* 01BE00 */
 3284|       |	categories_Cn, /* 01BF00 */
 3285|       |	categories_Cn, /* 01C000 */
 3286|       |	categories_Cn, /* 01C100 */
 3287|       |	categories_Cn, /* 01C200 */
 3288|       |	categories_Cn, /* 01C300 */
 3289|       |	categories_Cn, /* 01C400 */
 3290|       |	categories_Cn, /* 01C500 */
 3291|       |	categories_Cn, /* 01C600 */
 3292|       |	categories_Cn, /* 01C700 */
 3293|       |	categories_Cn, /* 01C800 */
 3294|       |	categories_Cn, /* 01C900 */
 3295|       |	categories_Cn, /* 01CA00 */
 3296|       |	categories_Cn, /* 01CB00 */
 3297|       |	categories_Cn, /* 01CC00 */
 3298|       |	categories_Cn, /* 01CD00 */
 3299|       |	categories_Cn, /* 01CE00 */
 3300|       |	categories_Cn, /* 01CF00 */
 3301|       |	categories_01D000,
 3302|       |	categories_01D100,
 3303|       |	categories_01D200,
 3304|       |	categories_01D300,
 3305|       |	categories_01D400,
 3306|       |	categories_01D500,
 3307|       |	categories_01D600,
 3308|       |	categories_01D700,
 3309|       |	categories_So, /* 01D800 */
 3310|       |	categories_So, /* 01D900 */
 3311|       |	categories_01DA00,
 3312|       |	categories_Cn, /* 01DB00 */
 3313|       |	categories_Cn, /* 01DC00 */
 3314|       |	categories_Cn, /* 01DD00 */
 3315|       |	categories_Cn, /* 01DE00 */
 3316|       |	categories_Cn, /* 01DF00 */
 3317|       |	categories_01E000,
 3318|       |	categories_Cn, /* 01E100 */
 3319|       |	categories_Cn, /* 01E200 */
 3320|       |	categories_Cn, /* 01E300 */
 3321|       |	categories_Cn, /* 01E400 */
 3322|       |	categories_Cn, /* 01E500 */
 3323|       |	categories_Cn, /* 01E600 */
 3324|       |	categories_Cn, /* 01E700 */
 3325|       |	categories_01E800,
 3326|       |	categories_01E900,
 3327|       |	categories_Cn, /* 01EA00 */
 3328|       |	categories_Cn, /* 01EB00 */
 3329|       |	categories_01EC00,
 3330|       |	categories_Cn, /* 01ED00 */
 3331|       |	categories_01EE00,
 3332|       |	categories_Cn, /* 01EF00 */
 3333|       |	categories_01F000,
 3334|       |	categories_01F100,
 3335|       |	categories_01F200,
 3336|       |	categories_01F300,
 3337|       |	categories_So, /* 01F400 */
 3338|       |	categories_So, /* 01F500 */
 3339|       |	categories_01F600,
 3340|       |	categories_01F700,
 3341|       |	categories_01F800,
 3342|       |	categories_01F900,
 3343|       |	categories_01FA00,
 3344|       |	categories_Cn, /* 01FB00 */
 3345|       |	categories_Cn, /* 01FC00 */
 3346|       |	categories_Cn, /* 01FD00 */
 3347|       |	categories_Cn, /* 01FE00 */
 3348|       |	categories_Cn, /* 01FF00 */
 3349|       |	categories_Lo, /* 020000 */
 3350|       |	categories_Lo, /* 020100 */
 3351|       |	categories_Lo, /* 020200 */
 3352|       |	categories_Lo, /* 020300 */
 3353|       |	categories_Lo, /* 020400 */
 3354|       |	categories_Lo, /* 020500 */
 3355|       |	categories_Lo, /* 020600 */
 3356|       |	categories_Lo, /* 020700 */
 3357|       |	categories_Lo, /* 020800 */
 3358|       |	categories_Lo, /* 020900 */
 3359|       |	categories_Lo, /* 020A00 */
 3360|       |	categories_Lo, /* 020B00 */
 3361|       |	categories_Lo, /* 020C00 */
 3362|       |	categories_Lo, /* 020D00 */
 3363|       |	categories_Lo, /* 020E00 */
 3364|       |	categories_Lo, /* 020F00 */
 3365|       |	categories_Lo, /* 021000 */
 3366|       |	categories_Lo, /* 021100 */
 3367|       |	categories_Lo, /* 021200 */
 3368|       |	categories_Lo, /* 021300 */
 3369|       |	categories_Lo, /* 021400 */
 3370|       |	categories_Lo, /* 021500 */
 3371|       |	categories_Lo, /* 021600 */
 3372|       |	categories_Lo, /* 021700 */
 3373|       |	categories_Lo, /* 021800 */
 3374|       |	categories_Lo, /* 021900 */
 3375|       |	categories_Lo, /* 021A00 */
 3376|       |	categories_Lo, /* 021B00 */
 3377|       |	categories_Lo, /* 021C00 */
 3378|       |	categories_Lo, /* 021D00 */
 3379|       |	categories_Lo, /* 021E00 */
 3380|       |	categories_Lo, /* 021F00 */
 3381|       |	categories_Lo, /* 022000 */
 3382|       |	categories_Lo, /* 022100 */
 3383|       |	categories_Lo, /* 022200 */
 3384|       |	categories_Lo, /* 022300 */
 3385|       |	categories_Lo, /* 022400 */
 3386|       |	categories_Lo, /* 022500 */
 3387|       |	categories_Lo, /* 022600 */
 3388|       |	categories_Lo, /* 022700 */
 3389|       |	categories_Lo, /* 022800 */
 3390|       |	categories_Lo, /* 022900 */
 3391|       |	categories_Lo, /* 022A00 */
 3392|       |	categories_Lo, /* 022B00 */
 3393|       |	categories_Lo, /* 022C00 */
 3394|       |	categories_Lo, /* 022D00 */
 3395|       |	categories_Lo, /* 022E00 */
 3396|       |	categories_Lo, /* 022F00 */
 3397|       |	categories_Lo, /* 023000 */
 3398|       |	categories_Lo, /* 023100 */
 3399|       |	categories_Lo, /* 023200 */
 3400|       |	categories_Lo, /* 023300 */
 3401|       |	categories_Lo, /* 023400 */
 3402|       |	categories_Lo, /* 023500 */
 3403|       |	categories_Lo, /* 023600 */
 3404|       |	categories_Lo, /* 023700 */
 3405|       |	categories_Lo, /* 023800 */
 3406|       |	categories_Lo, /* 023900 */
 3407|       |	categories_Lo, /* 023A00 */
 3408|       |	categories_Lo, /* 023B00 */
 3409|       |	categories_Lo, /* 023C00 */
 3410|       |	categories_Lo, /* 023D00 */
 3411|       |	categories_Lo, /* 023E00 */
 3412|       |	categories_Lo, /* 023F00 */
 3413|       |	categories_Lo, /* 024000 */
 3414|       |	categories_Lo, /* 024100 */
 3415|       |	categories_Lo, /* 024200 */
 3416|       |	categories_Lo, /* 024300 */
 3417|       |	categories_Lo, /* 024400 */
 3418|       |	categories_Lo, /* 024500 */
 3419|       |	categories_Lo, /* 024600 */
 3420|       |	categories_Lo, /* 024700 */
 3421|       |	categories_Lo, /* 024800 */
 3422|       |	categories_Lo, /* 024900 */
 3423|       |	categories_Lo, /* 024A00 */
 3424|       |	categories_Lo, /* 024B00 */
 3425|       |	categories_Lo, /* 024C00 */
 3426|       |	categories_Lo, /* 024D00 */
 3427|       |	categories_Lo, /* 024E00 */
 3428|       |	categories_Lo, /* 024F00 */
 3429|       |	categories_Lo, /* 025000 */
 3430|       |	categories_Lo, /* 025100 */
 3431|       |	categories_Lo, /* 025200 */
 3432|       |	categories_Lo, /* 025300 */
 3433|       |	categories_Lo, /* 025400 */
 3434|       |	categories_Lo, /* 025500 */
 3435|       |	categories_Lo, /* 025600 */
 3436|       |	categories_Lo, /* 025700 */
 3437|       |	categories_Lo, /* 025800 */
 3438|       |	categories_Lo, /* 025900 */
 3439|       |	categories_Lo, /* 025A00 */
 3440|       |	categories_Lo, /* 025B00 */
 3441|       |	categories_Lo, /* 025C00 */
 3442|       |	categories_Lo, /* 025D00 */
 3443|       |	categories_Lo, /* 025E00 */
 3444|       |	categories_Lo, /* 025F00 */
 3445|       |	categories_Lo, /* 026000 */
 3446|       |	categories_Lo, /* 026100 */
 3447|       |	categories_Lo, /* 026200 */
 3448|       |	categories_Lo, /* 026300 */
 3449|       |	categories_Lo, /* 026400 */
 3450|       |	categories_Lo, /* 026500 */
 3451|       |	categories_Lo, /* 026600 */
 3452|       |	categories_Lo, /* 026700 */
 3453|       |	categories_Lo, /* 026800 */
 3454|       |	categories_Lo, /* 026900 */
 3455|       |	categories_Lo, /* 026A00 */
 3456|       |	categories_Lo, /* 026B00 */
 3457|       |	categories_Lo, /* 026C00 */
 3458|       |	categories_Lo, /* 026D00 */
 3459|       |	categories_Lo, /* 026E00 */
 3460|       |	categories_Lo, /* 026F00 */
 3461|       |	categories_Lo, /* 027000 */
 3462|       |	categories_Lo, /* 027100 */
 3463|       |	categories_Lo, /* 027200 */
 3464|       |	categories_Lo, /* 027300 */
 3465|       |	categories_Lo, /* 027400 */
 3466|       |	categories_Lo, /* 027500 */
 3467|       |	categories_Lo, /* 027600 */
 3468|       |	categories_Lo, /* 027700 */
 3469|       |	categories_Lo, /* 027800 */
 3470|       |	categories_Lo, /* 027900 */
 3471|       |	categories_Lo, /* 027A00 */
 3472|       |	categories_Lo, /* 027B00 */
 3473|       |	categories_Lo, /* 027C00 */
 3474|       |	categories_Lo, /* 027D00 */
 3475|       |	categories_Lo, /* 027E00 */
 3476|       |	categories_Lo, /* 027F00 */
 3477|       |	categories_Lo, /* 028000 */
 3478|       |	categories_Lo, /* 028100 */
 3479|       |	categories_Lo, /* 028200 */
 3480|       |	categories_Lo, /* 028300 */
 3481|       |	categories_Lo, /* 028400 */
 3482|       |	categories_Lo, /* 028500 */
 3483|       |	categories_Lo, /* 028600 */
 3484|       |	categories_Lo, /* 028700 */
 3485|       |	categories_Lo, /* 028800 */
 3486|       |	categories_Lo, /* 028900 */
 3487|       |	categories_Lo, /* 028A00 */
 3488|       |	categories_Lo, /* 028B00 */
 3489|       |	categories_Lo, /* 028C00 */
 3490|       |	categories_Lo, /* 028D00 */
 3491|       |	categories_Lo, /* 028E00 */
 3492|       |	categories_Lo, /* 028F00 */
 3493|       |	categories_Lo, /* 029000 */
 3494|       |	categories_Lo, /* 029100 */
 3495|       |	categories_Lo, /* 029200 */
 3496|       |	categories_Lo, /* 029300 */
 3497|       |	categories_Lo, /* 029400 */
 3498|       |	categories_Lo, /* 029500 */
 3499|       |	categories_Lo, /* 029600 */
 3500|       |	categories_Lo, /* 029700 */
 3501|       |	categories_Lo, /* 029800 */
 3502|       |	categories_Lo, /* 029900 */
 3503|       |	categories_Lo, /* 029A00 */
 3504|       |	categories_Lo, /* 029B00 */
 3505|       |	categories_Lo, /* 029C00 */
 3506|       |	categories_Lo, /* 029D00 */
 3507|       |	categories_Lo, /* 029E00 */
 3508|       |	categories_Lo, /* 029F00 */
 3509|       |	categories_Lo, /* 02A000 */
 3510|       |	categories_Lo, /* 02A100 */
 3511|       |	categories_Lo, /* 02A200 */
 3512|       |	categories_Lo, /* 02A300 */
 3513|       |	categories_Lo, /* 02A400 */
 3514|       |	categories_Lo, /* 02A500 */
 3515|       |	categories_02A600,
 3516|       |	categories_Lo, /* 02A700 */
 3517|       |	categories_Lo, /* 02A800 */
 3518|       |	categories_Lo, /* 02A900 */
 3519|       |	categories_Lo, /* 02AA00 */
 3520|       |	categories_Lo, /* 02AB00 */
 3521|       |	categories_Lo, /* 02AC00 */
 3522|       |	categories_Lo, /* 02AD00 */
 3523|       |	categories_Lo, /* 02AE00 */
 3524|       |	categories_Lo, /* 02AF00 */
 3525|       |	categories_Lo, /* 02B000 */
 3526|       |	categories_Lo, /* 02B100 */
 3527|       |	categories_Lo, /* 02B200 */
 3528|       |	categories_Lo, /* 02B300 */
 3529|       |	categories_Lo, /* 02B400 */
 3530|       |	categories_Lo, /* 02B500 */
 3531|       |	categories_Lo, /* 02B600 */
 3532|       |	categories_02B700,
 3533|       |	categories_02B800,
 3534|       |	categories_Lo, /* 02B900 */
 3535|       |	categories_Lo, /* 02BA00 */
 3536|       |	categories_Lo, /* 02BB00 */
 3537|       |	categories_Lo, /* 02BC00 */
 3538|       |	categories_Lo, /* 02BD00 */
 3539|       |	categories_Lo, /* 02BE00 */
 3540|       |	categories_Lo, /* 02BF00 */
 3541|       |	categories_Lo, /* 02C000 */
 3542|       |	categories_Lo, /* 02C100 */
 3543|       |	categories_Lo, /* 02C200 */
 3544|       |	categories_Lo, /* 02C300 */
 3545|       |	categories_Lo, /* 02C400 */
 3546|       |	categories_Lo, /* 02C500 */
 3547|       |	categories_Lo, /* 02C600 */
 3548|       |	categories_Lo, /* 02C700 */
 3549|       |	categories_Lo, /* 02C800 */
 3550|       |	categories_Lo, /* 02C900 */
 3551|       |	categories_Lo, /* 02CA00 */
 3552|       |	categories_Lo, /* 02CB00 */
 3553|       |	categories_Lo, /* 02CC00 */
 3554|       |	categories_Lo, /* 02CD00 */
 3555|       |	categories_02CE00,
 3556|       |	categories_Lo, /* 02CF00 */
 3557|       |	categories_Lo, /* 02D000 */
 3558|       |	categories_Lo, /* 02D100 */
 3559|       |	categories_Lo, /* 02D200 */
 3560|       |	categories_Lo, /* 02D300 */
 3561|       |	categories_Lo, /* 02D400 */
 3562|       |	categories_Lo, /* 02D500 */
 3563|       |	categories_Lo, /* 02D600 */
 3564|       |	categories_Lo, /* 02D700 */
 3565|       |	categories_Lo, /* 02D800 */
 3566|       |	categories_Lo, /* 02D900 */
 3567|       |	categories_Lo, /* 02DA00 */
 3568|       |	categories_Lo, /* 02DB00 */
 3569|       |	categories_Lo, /* 02DC00 */
 3570|       |	categories_Lo, /* 02DD00 */
 3571|       |	categories_Lo, /* 02DE00 */
 3572|       |	categories_Lo, /* 02DF00 */
 3573|       |	categories_Lo, /* 02E000 */
 3574|       |	categories_Lo, /* 02E100 */
 3575|       |	categories_Lo, /* 02E200 */
 3576|       |	categories_Lo, /* 02E300 */
 3577|       |	categories_Lo, /* 02E400 */
 3578|       |	categories_Lo, /* 02E500 */
 3579|       |	categories_Lo, /* 02E600 */
 3580|       |	categories_Lo, /* 02E700 */
 3581|       |	categories_Lo, /* 02E800 */
 3582|       |	categories_Lo, /* 02E900 */
 3583|       |	categories_Lo, /* 02EA00 */
 3584|       |	categories_02EB00,
 3585|       |	categories_Cn, /* 02EC00 */
 3586|       |	categories_Cn, /* 02ED00 */
 3587|       |	categories_Cn, /* 02EE00 */
 3588|       |	categories_Cn, /* 02EF00 */
 3589|       |	categories_Cn, /* 02F000 */
 3590|       |	categories_Cn, /* 02F100 */
 3591|       |	categories_Cn, /* 02F200 */
 3592|       |	categories_Cn, /* 02F300 */
 3593|       |	categories_Cn, /* 02F400 */
 3594|       |	categories_Cn, /* 02F500 */
 3595|       |	categories_Cn, /* 02F600 */
 3596|       |	categories_Cn, /* 02F700 */
 3597|       |	categories_Lo, /* 02F800 */
 3598|       |	categories_Lo, /* 02F900 */
 3599|       |	categories_02FA00,
 3600|       |};
 3601|       |
 3602|       |static const uint8_t *categories_0E0000_0E01FF[] =
 3603|       |{
 3604|       |	categories_0E0000,
 3605|       |	categories_0E0100,
 3606|       |};
 3607|       |
 3608|       |ucd_category ucd_lookup_category(codepoint_t c)
 3609|      0|{
 3610|      0|	if (c <= 0x00D7FF) /* 000000..00D7FF */
 3611|      0|	{
 3612|      0|		const uint8_t *table = categories_000000_00D7FF[(c - 0x000000) / 256];
 3613|      0|		return (ucd_category)table[c % 256];
 3614|      0|	}
 3615|      0|	if (c <= 0x00DFFF) return Cs; /* 00D800..00DFFF : Surrogates */
 3616|      0|	if (c <= 0x00F7FF) return Co; /* 00E000..00F7FF : Private Use Area */
 3617|      0|	if (c <= 0x02FAFF) /* 00F800..02FAFF */
 3618|      0|	{
 3619|      0|		const uint8_t *table = categories_00F800_02FAFF[(c - 0x00F800) / 256];
 3620|      0|		return (ucd_category)table[c % 256];
 3621|      0|	}
 3622|      0|	if (c <= 0x0DFFFF) return Cn; /* 02FB00..0DFFFF : Unassigned */
 3623|      0|	if (c <= 0x0E01FF) /* 0E0000..0E01FF */
 3624|      0|	{
 3625|      0|		const uint8_t *table = categories_0E0000_0E01FF[(c - 0x0E0000) / 256];
 3626|      0|		return (ucd_category)table[c % 256];
 3627|      0|	}
 3628|      0|	if (c <= 0x0EFFFF) return Cn; /* 0E0200..0EFFFF : Unassigned */
 3629|      0|	if (c <= 0x0FFFFD) return Co; /* 0F0000..0FFFFD : Plane 15 Private Use */
 3630|      0|	if (c <= 0x0FFFFF) return Cn; /* 0FFFFE..0FFFFF : Plane 15 Private Use */
 3631|      0|	if (c <= 0x10FFFD) return Co; /* 100000..10FFFD : Plane 16 Private Use */
 3632|      0|	if (c <= 0x10FFFF) return Cn; /* 10FFFE..10FFFF : Plane 16 Private Use */
 3633|      0|	return Ii; /* Invalid Unicode Codepoint */
 3634|      0|}
 3635|       |
 3636|       |ucd_category_group ucd_get_category_group_for_category(ucd_category c)
 3637|      0|{
 3638|      0|	switch (c)
 3639|      0|	{
 3640|      0|	case Cc: case Cf: case Cn: case Co: case Cs:
 3641|      0|		return UCD_CATEGORY_GROUP_C;
 3642|      0|	case Ll: case Lm: case Lo: case Lt: case Lu:
 3643|      0|		return UCD_CATEGORY_GROUP_L;
 3644|      0|	case Mc: case Me: case Mn:
 3645|      0|		return UCD_CATEGORY_GROUP_M;
 3646|      0|	case Nd: case Nl: case No:
 3647|      0|		return UCD_CATEGORY_GROUP_N;
 3648|      0|	case Pc: case Pd: case Pe: case Pf: case Pi: case Po: case Ps:
 3649|      0|		return UCD_CATEGORY_GROUP_P;
 3650|      0|	case Sc: case Sk: case Sm: case So:
 3651|      0|		return UCD_CATEGORY_GROUP_S;
 3652|      0|	case Zl: case Zp: case Zs:
 3653|      0|		return UCD_CATEGORY_GROUP_Z;
 3654|      0|	case Ii:
 3655|      0|	default:
 3656|      0|		return UCD_CATEGORY_GROUP_I;
 3657|      0|	}
 3658|      0|}
 3659|       |
 3660|       |ucd_category_group ucd_lookup_category_group(codepoint_t c)
 3661|      0|{
 3662|      0|	return (ucd_category_group)ucd_get_category_group_for_category(ucd_lookup_category(c));
 3663|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/ucd-tools/src/ctype.c:
    1|       |/* ctype-style APIs.
    2|       | *
    3|       | * Copyright (C) 2012-2018 Reece H. Dunn
    4|       | *
    5|       | * This file is part of ucd-tools.
    6|       | *
    7|       | * ucd-tools is free software: you can redistribute it and/or modify
    8|       | * it under the terms of the GNU General Public License as published by
    9|       | * the Free Software Foundation, either version 3 of the License, or
   10|       | * (at your option) any later version.
   11|       | *
   12|       | * ucd-tools is distributed in the hope that it will be useful,
   13|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   14|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   15|       | * GNU General Public License for more details.
   16|       | *
   17|       | * You should have received a copy of the GNU General Public License
   18|       | * along with ucd-tools.  If not, see <http://www.gnu.org/licenses/>.
   19|       | */
   20|       |
   21|       |#include "ucd/ucd.h"
   22|       |
   23|       |int ucd_isalnum(codepoint_t c)
   24|      0|{
   25|      0|	ucd_category cat = ucd_lookup_category(c);
   26|      0|	switch (cat)
   27|      0|	{
   28|      0|	case UCD_CATEGORY_Lu:
   29|      0|	case UCD_CATEGORY_Ll:
   30|      0|	case UCD_CATEGORY_Lt:
   31|      0|	case UCD_CATEGORY_Lm:
   32|      0|	case UCD_CATEGORY_Lo:
   33|      0|	case UCD_CATEGORY_Nl:
   34|      0|	case UCD_CATEGORY_Nd:
   35|      0|	case UCD_CATEGORY_No:
   36|      0|		return 1;
   37|      0|	case UCD_CATEGORY_Mn:
   38|      0|	case UCD_CATEGORY_Mc:
   39|      0|	case UCD_CATEGORY_So:
   40|      0|		return (ucd_properties(c, cat) & UCD_PROPERTY_OTHER_ALPHABETIC) == UCD_PROPERTY_OTHER_ALPHABETIC;
   41|      0|	default:
   42|      0|		return 0;
   43|      0|	}
   44|      0|}
   45|       |
   46|       |int ucd_isalpha(codepoint_t c)
   47|      0|{
   48|      0|	ucd_category cat = ucd_lookup_category(c);
   49|      0|	switch (cat)
   50|      0|	{
   51|      0|	case UCD_CATEGORY_Lu:
   52|      0|	case UCD_CATEGORY_Ll:
   53|      0|	case UCD_CATEGORY_Lt:
   54|      0|	case UCD_CATEGORY_Lm:
   55|      0|	case UCD_CATEGORY_Lo:
   56|      0|	case UCD_CATEGORY_Nl:
   57|      0|		return 1;
   58|      0|	case UCD_CATEGORY_Mn:
   59|      0|	case UCD_CATEGORY_Mc:
   60|      0|	case UCD_CATEGORY_So:
   61|      0|		return (ucd_properties(c, cat) & UCD_PROPERTY_OTHER_ALPHABETIC) == UCD_PROPERTY_OTHER_ALPHABETIC;
   62|      0|	default:
   63|      0|		return 0;
   64|      0|	}
   65|      0|}
   66|       |
   67|       |int ucd_isblank(codepoint_t c)
   68|      0|{
   69|      0|	switch (ucd_lookup_category(c))
   70|      0|	{
   71|      0|	case UCD_CATEGORY_Zs:
   72|      0|		switch (c) /* Exclude characters with the <noBreak> DispositionType */
   73|      0|		{
   74|      0|		case 0x00A0: /* U+00A0 : NO-BREAK SPACE */
   75|      0|		case 0x2007: /* U+2007 : FIGURE SPACE */
   76|      0|		case 0x202F: /* U+202F : NARROW NO-BREAK SPACE */
   77|      0|			return 0;
   78|      0|		}
   79|      0|		return 1;
   80|      0|	case UCD_CATEGORY_Cc:
   81|      0|		return c == 0x09; /* U+0009 : CHARACTER TABULATION */
   82|      0|	default:
   83|      0|		return 0;
   84|      0|	}
   85|      0|}
   86|       |
   87|       |int ucd_iscntrl(codepoint_t c)
   88|      0|{
   89|      0|	return ucd_lookup_category(c) == UCD_CATEGORY_Cc;
   90|      0|}
   91|       |
   92|       |int ucd_isdigit(codepoint_t c)
   93|      0|{
   94|      0|	return (c >= 0x30 && c <= 0x39); /* [0-9] */
   95|      0|}
   96|       |
   97|       |int ucd_isgraph(codepoint_t c)
   98|       |{
   99|       |	switch (ucd_lookup_category(c))
  100|       |	{
  101|       |	case UCD_CATEGORY_Cc:
  102|       |	case UCD_CATEGORY_Cf:
  103|       |	case UCD_CATEGORY_Cn:
  104|       |	case UCD_CATEGORY_Co:
  105|       |	case UCD_CATEGORY_Cs:
  106|       |	case UCD_CATEGORY_Zl:
  107|       |	case UCD_CATEGORY_Zp:
  108|       |	case UCD_CATEGORY_Zs:
  109|       |	case UCD_CATEGORY_Ii:
  110|       |		return 0;
  111|       |	default:
  112|       |		return 1;
  113|       |	}
  114|       |}
  115|       |
  116|       |int ucd_islower(codepoint_t c)
  117|      0|{
  118|      0|	ucd_category cat = ucd_lookup_category(c);
  119|      0|	switch (cat)
  120|      0|	{
  121|      0|	case UCD_CATEGORY_Ll:
  122|      0|		return 1;
  123|      0|	case UCD_CATEGORY_Lt:
  124|      0|		return ucd_toupper(c) != c;
  125|      0|	case UCD_CATEGORY_Lm:
  126|      0|	case UCD_CATEGORY_Lo:
  127|      0|	case UCD_CATEGORY_Mn:
  128|      0|	case UCD_CATEGORY_Nl:
  129|      0|	case UCD_CATEGORY_So:
  130|      0|		return (ucd_properties(c, cat) & UCD_PROPERTY_OTHER_LOWERCASE) == UCD_PROPERTY_OTHER_LOWERCASE;
  131|      0|	default:
  132|      0|		return 0;
  133|      0|	}
  134|      0|}
  135|       |
  136|       |int ucd_isprint(codepoint_t c)
  137|       |{
  138|       |	switch (ucd_lookup_category(c))
  139|       |	{
  140|       |	case UCD_CATEGORY_Cc:
  141|       |	case UCD_CATEGORY_Cf:
  142|       |	case UCD_CATEGORY_Cn:
  143|       |	case UCD_CATEGORY_Co:
  144|       |	case UCD_CATEGORY_Cs:
  145|       |	case UCD_CATEGORY_Ii:
  146|       |		return 0;
  147|       |	default:
  148|       |		return 1;
  149|       |	}
  150|       |}
  151|       |
  152|       |int ucd_ispunct(codepoint_t c)
  153|      0|{
  154|      0|	return ucd_isgraph(c) && !ucd_isalnum(c);
  155|      0|}
  156|       |
  157|       |int ucd_isspace(codepoint_t c)
  158|      0|{
  159|      0|	switch (ucd_lookup_category(c))
  160|      0|	{
  161|      0|	case UCD_CATEGORY_Zl:
  162|      0|	case UCD_CATEGORY_Zp:
  163|      0|		return 1;
  164|      0|	case UCD_CATEGORY_Zs:
  165|      0|		switch (c) /* Exclude characters with the <noBreak> DispositionType */
  166|      0|		{
  167|      0|		case 0x00A0: /* U+00A0 : NO-BREAK SPACE */
  168|      0|		case 0x2007: /* U+2007 : FIGURE SPACE */
  169|      0|		case 0x202F: /* U+202F : NARROW NO-BREAK SPACE */
  170|      0|			return 0;
  171|      0|		}
  172|      0|		return 1;
  173|      0|	case UCD_CATEGORY_Cc:
  174|      0|		switch (c) /* Include control characters marked as White_Space */
  175|      0|		{
  176|      0|		case 0x09: /* U+0009 : CHARACTER TABULATION */
  177|      0|		case 0x0A: /* U+000A : LINE FEED */
  178|      0|		case 0x0B: /* U+000B : LINE TABULATION */
  179|      0|		case 0x0C: /* U+000C : FORM FEED */
  180|      0|		case 0x0D: /* U+000D : CARRIAGE RETURN */
  181|      0|		case 0x85: /* U+0085 : NEXT LINE */
  182|      0|			return 1;
  183|      0|		}
  184|      0|	default:
  185|      0|		return 0;
  186|      0|	}
  187|      0|}
  188|       |
  189|       |int ucd_isupper(codepoint_t c)
  190|      0|{
  191|      0|	ucd_category cat = ucd_lookup_category(c);
  192|      0|	switch (cat)
  193|      0|	{
  194|      0|	case UCD_CATEGORY_Lu:
  195|      0|		return 1;
  196|      0|	case UCD_CATEGORY_Lt:
  197|      0|		return ucd_tolower(c) != c;
  198|      0|	case UCD_CATEGORY_Nl:
  199|      0|	case UCD_CATEGORY_So:
  200|      0|		return (ucd_properties(c, cat) & UCD_PROPERTY_OTHER_UPPERCASE) == UCD_PROPERTY_OTHER_UPPERCASE;
  201|      0|	default:
  202|      0|		return 0;
  203|      0|	}
  204|      0|}
  205|       |
  206|       |int ucd_isxdigit(codepoint_t c)
  207|      0|{
  208|      0|	return (c >= 0x30 && c <= 0x39)  /* [0-9] */
  209|      0|	    || (c >= 0x41 && c <= 0x46)  /* [A-Z] */
  210|      0|	    || (c >= 0x61 && c <= 0x66); /* [a-z] */
  211|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/ucd-tools/src/include/ucd/ucd.h:
    1|       |/* Unicode Character Database API
    2|       | *
    3|       | * Copyright (C) 2012-2018 Reece H. Dunn
    4|       | *
    5|       | * This file is part of ucd-tools.
    6|       | *
    7|       | * ucd-tools is free software: you can redistribute it and/or modify
    8|       | * it under the terms of the GNU General Public License as published by
    9|       | * the Free Software Foundation, either version 3 of the License, or
   10|       | * (at your option) any later version.
   11|       | *
   12|       | * ucd-tools is distributed in the hope that it will be useful,
   13|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   14|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   15|       | * GNU General Public License for more details.
   16|       | *
   17|       | * You should have received a copy of the GNU General Public License
   18|       | * along with ucd-tools.  If not, see <http://www.gnu.org/licenses/>.
   19|       | */
   20|       |
   21|       |#ifndef UNICODE_CHARACTER_DATA_H
   22|       |#define UNICODE_CHARACTER_DATA_H
   23|       |
   24|       |#include <stdint.h>
   25|       |
   26|       |#ifdef __cplusplus
   27|       |extern "C"
   28|       |{
   29|       |#endif
   30|       |
   31|       |/** @brief Represents a Unicode codepoint.
   32|       |  */
   33|       |typedef uint32_t codepoint_t;
   34|       |
   35|       |/** @brief Unicode General Category Groups
   36|       |  * @see   http://www.unicode.org/reports/tr44/
   37|       |  */
   38|       |typedef enum ucd_category_group_
   39|       |{
   40|       |	UCD_CATEGORY_GROUP_C, /**< @brief Other */
   41|       |	UCD_CATEGORY_GROUP_I, /**< @brief Invalid */
   42|       |	UCD_CATEGORY_GROUP_L, /**< @brief Letter */
   43|       |	UCD_CATEGORY_GROUP_M, /**< @brief Mark */
   44|       |	UCD_CATEGORY_GROUP_N, /**< @brief Number */
   45|       |	UCD_CATEGORY_GROUP_P, /**< @brief Punctuation */
   46|       |	UCD_CATEGORY_GROUP_S, /**< @brief Symbol */
   47|       |	UCD_CATEGORY_GROUP_Z, /**< @brief Separator */
   48|       |} ucd_category_group;
   49|       |
   50|       |/** @brief Get a string representation of the category_group enumeration value.
   51|       |  *
   52|       |  * @param c The value to get the string representation for.
   53|       |  *
   54|       |  * @return The string representation, or "-" if the value is not recognized.
   55|       |  */
   56|       |const char *ucd_get_category_group_string(ucd_category_group c);
   57|       |
   58|       |/** @brief Unicode General Category Values
   59|       |  * @see   http://www.unicode.org/reports/tr44/
   60|       |  */
   61|       |typedef enum ucd_category_
   62|       |{
   63|       |	UCD_CATEGORY_Cc, /**< @brief Control Character */
   64|       |	UCD_CATEGORY_Cf, /**< @brief Format Control Character */
   65|       |	UCD_CATEGORY_Cn, /**< @brief Unassigned */
   66|       |	UCD_CATEGORY_Co, /**< @brief Private Use */
   67|       |	UCD_CATEGORY_Cs, /**< @brief Surrogate Code Point */
   68|       |
   69|       |	UCD_CATEGORY_Ii, /**< @brief Invalid Unicode Codepoint */
   70|       |
   71|       |	UCD_CATEGORY_Ll, /**< @brief Lower Case Letter */
   72|       |	UCD_CATEGORY_Lm, /**< @brief Letter Modifier */
   73|       |	UCD_CATEGORY_Lo, /**< @brief Other Letter */
   74|       |	UCD_CATEGORY_Lt, /**< @brief Title Case Letter */
   75|       |	UCD_CATEGORY_Lu, /**< @brief Upper Case Letter */
   76|       |
   77|       |	UCD_CATEGORY_Mc, /**< @brief Spacing Mark */
   78|       |	UCD_CATEGORY_Me, /**< @brief Enclosing Mark */
   79|       |	UCD_CATEGORY_Mn, /**< @brief Non-Spacing Mark */
   80|       |
   81|       |	UCD_CATEGORY_Nd, /**< @brief Decimal Digit */
   82|       |	UCD_CATEGORY_Nl, /**< @brief Letter-Like Number */
   83|       |	UCD_CATEGORY_No, /**< @brief Other Number */
   84|       |
   85|       |	UCD_CATEGORY_Pc, /**< @brief Connector */
   86|       |	UCD_CATEGORY_Pd, /**< @brief Dash/Hyphen */
   87|       |	UCD_CATEGORY_Pe, /**< @brief Close Punctuation Mark */
   88|       |	UCD_CATEGORY_Pf, /**< @brief Final Quotation Mark */
   89|       |	UCD_CATEGORY_Pi, /**< @brief Initial Quotation Mark */
   90|       |	UCD_CATEGORY_Po, /**< @brief Other */
   91|       |	UCD_CATEGORY_Ps, /**< @brief Open Punctuation Mark */
   92|       |
   93|       |	UCD_CATEGORY_Sc, /**< @brief Currency Symbol */
   94|       |	UCD_CATEGORY_Sk, /**< @brief Modifier Symbol */
   95|       |	UCD_CATEGORY_Sm, /**< @brief Math Symbol */
   96|       |	UCD_CATEGORY_So, /**< @brief Other Symbol */
   97|       |
   98|       |	UCD_CATEGORY_Zl, /**< @brief Line Separator */
   99|       |	UCD_CATEGORY_Zp, /**< @brief Paragraph Separator */
  100|       |	UCD_CATEGORY_Zs, /**< @brief Space Separator */
  101|       |} ucd_category;
  102|       |
  103|       |/** @brief Get a string representation of the category enumeration value.
  104|       |  *
  105|       |  * @param c The value to get the string representation for.
  106|       |  *
  107|       |  * @return The string representation, or "--" if the value is not recognized.
  108|       |  */
  109|       |const char *ucd_get_category_string(ucd_category c);
  110|       |
  111|       |/** @brief Lookup the General Category Group for a General Category.
  112|       |  *
  113|       |  * @param c The General Category to lookup.
  114|       |  * @return  The General Category Group of the General Category.
  115|       |  */
  116|       |ucd_category_group ucd_get_category_group_for_category(ucd_category c);
  117|       |
  118|       |/** @brief Lookup the General Category Group for a Unicode codepoint.
  119|       |  *
  120|       |  * @param c The Unicode codepoint to lookup.
  121|       |  * @return  The General Category Group of the Unicode codepoint.
  122|       |  */
  123|       |ucd_category_group ucd_lookup_category_group(codepoint_t c);
  124|       |
  125|       |/** @brief Lookup the General Category for a Unicode codepoint.
  126|       |  *
  127|       |  * @param c The Unicode codepoint to lookup.
  128|       |  * @return  The General Category of the Unicode codepoint.
  129|       |  */
  130|       |ucd_category ucd_lookup_category(codepoint_t c);
  131|       |
  132|       |/** @brief Unicode Script
  133|       |  * @see   http://www.iana.org/assignments/language-subtag-registry
  134|       |  * @see   http://www.unicode.org/iso15924/iso15924-codes.html
  135|       |  */
  136|       |typedef enum ucd_script_
  137|       |{
  138|       |	UCD_SCRIPT_Adlm, /**< @brief Adlam Script */
  139|       |	UCD_SCRIPT_Afak, /**< @brief Afaka Script */
  140|       |	UCD_SCRIPT_Aghb, /**< @brief Caucasian Albanian Script */
  141|       |	UCD_SCRIPT_Ahom, /**< @brief Tai Ahom Script */
  142|       |	UCD_SCRIPT_Arab, /**< @brief Arabic Script */
  143|       |	UCD_SCRIPT_Armi, /**< @brief Imperial Aramaic Script */
  144|       |	UCD_SCRIPT_Armn, /**< @brief Armenian Script */
  145|       |	UCD_SCRIPT_Avst, /**< @brief Avestan Script */
  146|       |	UCD_SCRIPT_Bali, /**< @brief Balinese Script */
  147|       |	UCD_SCRIPT_Bamu, /**< @brief Bamum Script */
  148|       |	UCD_SCRIPT_Bass, /**< @brief Bassa Vah Script */
  149|       |	UCD_SCRIPT_Batk, /**< @brief Batak Script */
  150|       |	UCD_SCRIPT_Beng, /**< @brief Bengali Script */
  151|       |	UCD_SCRIPT_Bhks, /**< @brief Bhaiksuki Script */
  152|       |	UCD_SCRIPT_Blis, /**< @brief Blissymbols Script */
  153|       |	UCD_SCRIPT_Bopo, /**< @brief Bopomofo Script */
  154|       |	UCD_SCRIPT_Brah, /**< @brief Brahmi Script */
  155|       |	UCD_SCRIPT_Brai, /**< @brief Braille Script */
  156|       |	UCD_SCRIPT_Bugi, /**< @brief Buginese Script */
  157|       |	UCD_SCRIPT_Buhd, /**< @brief Buhid Script */
  158|       |	UCD_SCRIPT_Cakm, /**< @brief Chakma Script */
  159|       |	UCD_SCRIPT_Cans, /**< @brief Unified Canadian Aboriginal Syllabics */
  160|       |	UCD_SCRIPT_Cari, /**< @brief Carian Script */
  161|       |	UCD_SCRIPT_Cham, /**< @brief Cham Script */
  162|       |	UCD_SCRIPT_Cher, /**< @brief Cherokee Script */
  163|       |	UCD_SCRIPT_Cirt, /**< @brief Cirth Script */
  164|       |	UCD_SCRIPT_Copt, /**< @brief Coptic Script */
  165|       |	UCD_SCRIPT_Cprt, /**< @brief Cypriot Script */
  166|       |	UCD_SCRIPT_Cyrl, /**< @brief Cyrillic Script */
  167|       |	UCD_SCRIPT_Cyrs, /**< @brief Cyrillic (Old Church Slavonic variant) Script */
  168|       |	UCD_SCRIPT_Deva, /**< @brief Devanagari Script */
  169|       |	UCD_SCRIPT_Dogr, /**< @brief Dogra Script */
  170|       |	UCD_SCRIPT_Dsrt, /**< @brief Deseret Script */
  171|       |	UCD_SCRIPT_Dupl, /**< @brief Duployan Shorthand Script */
  172|       |	UCD_SCRIPT_Egyd, /**< @brief Egyptian Demotic Script */
  173|       |	UCD_SCRIPT_Egyh, /**< @brief Egyptian Hieratic Script */
  174|       |	UCD_SCRIPT_Egyp, /**< @brief Egyptian Hiegoglyphs */
  175|       |	UCD_SCRIPT_Elba, /**< @brief Elbasan Script */
  176|       |	UCD_SCRIPT_Ethi, /**< @brief Ethiopic Script */
  177|       |	UCD_SCRIPT_Geok, /**< @brief Khutsuri Script */
  178|       |	UCD_SCRIPT_Geor, /**< @brief Geirgian Script */
  179|       |	UCD_SCRIPT_Glag, /**< @brief Glagolitic Script */
  180|       |	UCD_SCRIPT_Gong, /**< @brief Gunjala Gondi */
  181|       |	UCD_SCRIPT_Gonm, /**< @brief Masaram Gondi */
  182|       |	UCD_SCRIPT_Goth, /**< @brief Gothic Script */
  183|       |	UCD_SCRIPT_Gran, /**< @brief Grantha Script */
  184|       |	UCD_SCRIPT_Grek, /**< @brief Greek Script */
  185|       |	UCD_SCRIPT_Gujr, /**< @brief Gujarati Script */
  186|       |	UCD_SCRIPT_Guru, /**< @brief Gurmukhi Script */
  187|       |	UCD_SCRIPT_Hang, /**< @brief Hangul Script */
  188|       |	UCD_SCRIPT_Hani, /**< @brief Han (Hanzi, Kanji, Hanja) Script */
  189|       |	UCD_SCRIPT_Hano, /**< @brief Hanunoo Script */
  190|       |	UCD_SCRIPT_Hans, /**< @brief Han (Simplified) Script */
  191|       |	UCD_SCRIPT_Hant, /**< @brief Han (Traditional) Script */
  192|       |	UCD_SCRIPT_Hatr, /**< @brief Hatran Script */
  193|       |	UCD_SCRIPT_Hebr, /**< @brief Hebrew Script */
  194|       |	UCD_SCRIPT_Hira, /**< @brief Hiragana Script */
  195|       |	UCD_SCRIPT_Hluw, /**< @brief Anatolian Hieroglyphs */
  196|       |	UCD_SCRIPT_Hmng, /**< @brief Pahawh Hmong Script */
  197|       |	UCD_SCRIPT_Hrkt, /**< @brief Japanese Syllabaries */
  198|       |	UCD_SCRIPT_Hung, /**< @brief Old Hungarian Script */
  199|       |	UCD_SCRIPT_Inds, /**< @brief Indus Script */
  200|       |	UCD_SCRIPT_Ital, /**< @brief Old Italic Script */
  201|       |	UCD_SCRIPT_Java, /**< @brief Javanese Script */
  202|       |	UCD_SCRIPT_Jpan, /**< @brief Japanese (Han + Hiragana + Katakana) Scripts */
  203|       |	UCD_SCRIPT_Jurc, /**< @brief Jurchen Script */
  204|       |	UCD_SCRIPT_Kali, /**< @brief Kayah Li Script */
  205|       |	UCD_SCRIPT_Kana, /**< @brief Katakana Script */
  206|       |	UCD_SCRIPT_Khar, /**< @brief Kharoshthi Script */
  207|       |	UCD_SCRIPT_Khmr, /**< @brief Khmer Script */
  208|       |	UCD_SCRIPT_Khoj, /**< @brief Khojki Script */
  209|       |	UCD_SCRIPT_Knda, /**< @brief Kannada Script */
  210|       |	UCD_SCRIPT_Kore, /**< @brief Korean (Hangul + Han) Scripts */
  211|       |	UCD_SCRIPT_Kpel, /**< @brief Kpelle Script */
  212|       |	UCD_SCRIPT_Kthi, /**< @brief Kaithi Script */
  213|       |	UCD_SCRIPT_Lana, /**< @brief Tai Tham Script */
  214|       |	UCD_SCRIPT_Laoo, /**< @brief Lao Script */
  215|       |	UCD_SCRIPT_Latf, /**< @brief Latin Script (Fractur Variant) */
  216|       |	UCD_SCRIPT_Latg, /**< @brief Latin Script (Gaelic Variant) */
  217|       |	UCD_SCRIPT_Latn, /**< @brief Latin Script */
  218|       |	UCD_SCRIPT_Lepc, /**< @brief Lepcha Script */
  219|       |	UCD_SCRIPT_Limb, /**< @brief Limbu Script */
  220|       |	UCD_SCRIPT_Lina, /**< @brief Linear A Script */
  221|       |	UCD_SCRIPT_Linb, /**< @brief Linear B Script */
  222|       |	UCD_SCRIPT_Lisu, /**< @brief Lisu Script */
  223|       |	UCD_SCRIPT_Loma, /**< @brief Loma Script */
  224|       |	UCD_SCRIPT_Lyci, /**< @brief Lycian Script */
  225|       |	UCD_SCRIPT_Lydi, /**< @brief Lydian Script */
  226|       |	UCD_SCRIPT_Mahj, /**< @brief Mahajani Script */
  227|       |	UCD_SCRIPT_Maka, /**< @brief Makasar Script */
  228|       |	UCD_SCRIPT_Mand, /**< @brief Mandaic Script */
  229|       |	UCD_SCRIPT_Mani, /**< @brief Manichaean Script */
  230|       |	UCD_SCRIPT_Marc, /**< @brief Marchen Script */
  231|       |	UCD_SCRIPT_Maya, /**< @brief Mayan Hieroglyphs */
  232|       |	UCD_SCRIPT_Medf, /**< @brief Medefaidrin (Oberi Okaime) Script */
  233|       |	UCD_SCRIPT_Mend, /**< @brief Mende Kikakui Script */
  234|       |	UCD_SCRIPT_Merc, /**< @brief Meroitic Cursive Script */
  235|       |	UCD_SCRIPT_Mero, /**< @brief Meroitic Hieroglyphs */
  236|       |	UCD_SCRIPT_Mlym, /**< @brief Malayalam Script */
  237|       |	UCD_SCRIPT_Modi, /**< @brief Modi Script */
  238|       |	UCD_SCRIPT_Mong, /**< @brief Mongolian Script */
  239|       |	UCD_SCRIPT_Moon, /**< @brief Moon Script */
  240|       |	UCD_SCRIPT_Mroo, /**< @brief Mro Script */
  241|       |	UCD_SCRIPT_Mtei, /**< @brief Meitei Mayek Script */
  242|       |	UCD_SCRIPT_Mult, /**< @brief Multani Script */
  243|       |	UCD_SCRIPT_Mymr, /**< @brief Myanmar (Burmese) Script */
  244|       |	UCD_SCRIPT_Narb, /**< @brief Old North Arabian Script */
  245|       |	UCD_SCRIPT_Nbat, /**< @brief Nabataean Script */
  246|       |	UCD_SCRIPT_Newa, /**< @brief Newa Script */
  247|       |	UCD_SCRIPT_Nkgb, /**< @brief Nakhi Geba Script */
  248|       |	UCD_SCRIPT_Nkoo, /**< @brief N'Ko Script */
  249|       |	UCD_SCRIPT_Nshu, /**< @brief Nushu Script */
  250|       |	UCD_SCRIPT_Ogam, /**< @brief Ogham Script */
  251|       |	UCD_SCRIPT_Olck, /**< @brief Ol Chiki Script */
  252|       |	UCD_SCRIPT_Orkh, /**< @brief Old Turkic Script */
  253|       |	UCD_SCRIPT_Orya, /**< @brief Oriya Script */
  254|       |	UCD_SCRIPT_Osge, /**< @brief Osage Script */
  255|       |	UCD_SCRIPT_Osma, /**< @brief Osmanya Script */
  256|       |	UCD_SCRIPT_Palm, /**< @brief Palmyrene Script */
  257|       |	UCD_SCRIPT_Pauc, /**< @brief Pau Cin Hau Script */
  258|       |	UCD_SCRIPT_Perm, /**< @brief Old Permic */
  259|       |	UCD_SCRIPT_Phag, /**< @brief Phags-Pa Script */
  260|       |	UCD_SCRIPT_Phli, /**< @brief Inscriptional Pahlavi Script */
  261|       |	UCD_SCRIPT_Phlp, /**< @brief Psalter Pahlavi Script */
  262|       |	UCD_SCRIPT_Phlv, /**< @brief Book Pahlavi Script */
  263|       |	UCD_SCRIPT_Phnx, /**< @brief Phoenician Script */
  264|       |	UCD_SCRIPT_Plrd, /**< @brief Miao Script */
  265|       |	UCD_SCRIPT_Prti, /**< @brief Inscriptional Parthian Script */
  266|       |	UCD_SCRIPT_Qaak, /**< @brief Klingon Script (Private Use) */
  267|       |	UCD_SCRIPT_Rjng, /**< @brief Rejang Script */
  268|       |	UCD_SCRIPT_Rohg, /**< @brief Hanifi Rohingya Script */
  269|       |	UCD_SCRIPT_Roro, /**< @brief Rongorongo Script */
  270|       |	UCD_SCRIPT_Runr, /**< @brief Runic Script */
  271|       |	UCD_SCRIPT_Samr, /**< @brief Samaritan Script */
  272|       |	UCD_SCRIPT_Sara, /**< @brief Sarati Script */
  273|       |	UCD_SCRIPT_Sarb, /**< @brief Old South Arabian Script */
  274|       |	UCD_SCRIPT_Saur, /**< @brief Saurashtra Script */
  275|       |	UCD_SCRIPT_Sgnw, /**< @brief Sign Writing */
  276|       |	UCD_SCRIPT_Shaw, /**< @brief Shavian Script */
  277|       |	UCD_SCRIPT_Shrd, /**< @brief Sharada Script */
  278|       |	UCD_SCRIPT_Sidd, /**< @brief Siddham Script */
  279|       |	UCD_SCRIPT_Sind, /**< @brief Sindhi Script */
  280|       |	UCD_SCRIPT_Sinh, /**< @brief Sinhala Script */
  281|       |	UCD_SCRIPT_Sogd, /**< @brief Sogdian Script */
  282|       |	UCD_SCRIPT_Sogo, /**< @brief Old Sogdian Script */
  283|       |	UCD_SCRIPT_Sora, /**< @brief Sora Sompeng Script */
  284|       |	UCD_SCRIPT_Soyo, /**< @brief Soyombo */
  285|       |	UCD_SCRIPT_Sund, /**< @brief Sundanese Script */
  286|       |	UCD_SCRIPT_Sylo, /**< @brief Syloti Nagri Script */
  287|       |	UCD_SCRIPT_Syrc, /**< @brief Syriac Script */
  288|       |	UCD_SCRIPT_Syre, /**< @brief Syriac Script (Estrangelo Variant) */
  289|       |	UCD_SCRIPT_Syrj, /**< @brief Syriac Script (Western Variant) */
  290|       |	UCD_SCRIPT_Syrn, /**< @brief Syriac Script (Eastern Variant) */
  291|       |	UCD_SCRIPT_Tagb, /**< @brief Tagbanwa Script */
  292|       |	UCD_SCRIPT_Takr, /**< @brief Takri Script */
  293|       |	UCD_SCRIPT_Tale, /**< @brief Tai Le Script */
  294|       |	UCD_SCRIPT_Talu, /**< @brief New Tai Lue Script */
  295|       |	UCD_SCRIPT_Taml, /**< @brief Tamil Script */
  296|       |	UCD_SCRIPT_Tang, /**< @brief Tangut Script */
  297|       |	UCD_SCRIPT_Tavt, /**< @brief Tai Viet Script */
  298|       |	UCD_SCRIPT_Telu, /**< @brief Telugu Script */
  299|       |	UCD_SCRIPT_Teng, /**< @brief Tengwar Script */
  300|       |	UCD_SCRIPT_Tfng, /**< @brief Tifinagh Script */
  301|       |	UCD_SCRIPT_Tglg, /**< @brief Tagalog Script */
  302|       |	UCD_SCRIPT_Thaa, /**< @brief Thaana Script */
  303|       |	UCD_SCRIPT_Thai, /**< @brief Thai Script */
  304|       |	UCD_SCRIPT_Tibt, /**< @brief Tibetan Script */
  305|       |	UCD_SCRIPT_Tirh, /**< @brief Tirhuta Script */
  306|       |	UCD_SCRIPT_Ugar, /**< @brief Ugaritic Script */
  307|       |	UCD_SCRIPT_Vaii, /**< @brief Vai Script */
  308|       |	UCD_SCRIPT_Visp, /**< @brief Visible Speech Script */
  309|       |	UCD_SCRIPT_Wara, /**< @brief Warang Citi Script */
  310|       |	UCD_SCRIPT_Wole, /**< @brief Woleai Script */
  311|       |	UCD_SCRIPT_Xpeo, /**< @brief Old Persian Script */
  312|       |	UCD_SCRIPT_Xsux, /**< @brief Cuneiform Script */
  313|       |	UCD_SCRIPT_Yiii, /**< @brief Yi Script */
  314|       |	UCD_SCRIPT_Zanb, /**< @brief Zanabazar Square */
  315|       |	UCD_SCRIPT_Zinh, /**< @brief Inherited Script */
  316|       |	UCD_SCRIPT_Zmth, /**< @brief Mathematical Notation */
  317|       |	UCD_SCRIPT_Zsym, /**< @brief Symbols */
  318|       |	UCD_SCRIPT_Zxxx, /**< @brief Unwritten Documents */
  319|       |	UCD_SCRIPT_Zyyy, /**< @brief Undetermined Script */
  320|       |	UCD_SCRIPT_Zzzz, /**< @brief Uncoded Script */
  321|       |} ucd_script;
  322|       |
  323|       |/** @brief Get a string representation of the script enumeration value.
  324|       |  *
  325|       |  * @param s The value to get the string representation for.
  326|       |  *
  327|       |  * @return The string representation, or "----" if the value is not recognized.
  328|       |  */
  329|       |const char *ucd_get_script_string(ucd_script s);
  330|       |
  331|       |/** @brief Lookup the Script for a Unicode codepoint.
  332|       |  *
  333|       |  * @param c The Unicode codepoint to lookup.
  334|       |  * @return  The Script of the Unicode codepoint.
  335|       |  */
  336|       |ucd_script ucd_lookup_script(codepoint_t c);
  337|       |
  338|       |/** @brief Properties
  339|       | */
  340|       |typedef uint64_t ucd_property;
  341|       |
  342|      0|#define UCD_PROPERTY_WHITE_SPACE                        0x0000000000000001ull /**< @brief White_Space */
  343|      0|#define UCD_PROPERTY_BIDI_CONTROL                       0x0000000000000002ull /**< @brief Bidi_Control */
  344|      0|#define UCD_PROPERTY_JOIN_CONTROL                       0x0000000000000004ull /**< @brief Join_Control */
  345|      0|#define UCD_PROPERTY_DASH                               0x0000000000000008ull /**< @brief Dash */
  346|      0|#define UCD_PROPERTY_HYPHEN                             0x0000000000000010ull /**< @brief Hyphen */
  347|      0|#define UCD_PROPERTY_QUOTATION_MARK                     0x0000000000000020ull /**< @brief Quotation_Mark */
  348|      0|#define UCD_PROPERTY_TERMINAL_PUNCTUATION               0x0000000000000040ull /**< @brief Terminal_Punctuation */
  349|      0|#define UCD_PROPERTY_OTHER_MATH                         0x0000000000000080ull /**< @brief Other_Math */
  350|      0|#define UCD_PROPERTY_HEX_DIGIT                          0x0000000000000100ull /**< @brief Hex_Digit */
  351|      0|#define UCD_PROPERTY_ASCII_HEX_DIGIT                    0x0000000000000200ull /**< @brief ASCII_Hex_Digit */
  352|      0|#define UCD_PROPERTY_OTHER_ALPHABETIC                   0x0000000000000400ull /**< @brief Other_Alphabetic */
  353|      0|#define UCD_PROPERTY_IDEOGRAPHIC                        0x0000000000000800ull /**< @brief Ideographic */
  354|      0|#define UCD_PROPERTY_DIACRITIC                          0x0000000000001000ull /**< @brief Diacritic */
  355|      0|#define UCD_PROPERTY_EXTENDER                           0x0000000000002000ull /**< @brief Extender */
  356|      0|#define UCD_PROPERTY_OTHER_LOWERCASE                    0x0000000000004000ull /**< @brief Other_Lowercase */
  357|      0|#define UCD_PROPERTY_OTHER_UPPERCASE                    0x0000000000008000ull /**< @brief Other_Uppercase */
  358|      0|#define UCD_PROPERTY_NONCHARACTER_CODE_POINT            0x0000000000010000ull /**< @brief Noncharacter_Code_Point */
  359|      0|#define UCD_PROPERTY_OTHER_GRAPHEME_EXTEND              0x0000000000020000ull /**< @brief Other_Grapheme_Extend */
  360|      0|#define UCD_PROPERTY_IDS_BINARY_OPERATOR                0x0000000000040000ull /**< @brief IDS_Binary_Operator */
  361|      0|#define UCD_PROPERTY_IDS_TRINARY_OPERATOR               0x0000000000080000ull /**< @brief IDS_Trinary_Operator */
  362|      0|#define UCD_PROPERTY_RADICAL                            0x0000000000100000ull /**< @brief Radical */
  363|      0|#define UCD_PROPERTY_UNIFIED_IDEOGRAPH                  0x0000000000200000ull /**< @brief Unified_Ideograph */
  364|      0|#define UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT 0x0000000000400000ull /**< @brief Other_Default_Ignorable_Code_Point */
  365|      0|#define UCD_PROPERTY_DEPRECATED                         0x0000000000800000ull /**< @brief Deprecated */
  366|      0|#define UCD_PROPERTY_SOFT_DOTTED                        0x0000000001000000ull /**< @brief Soft_Dotted */
  367|      0|#define UCD_PROPERTY_LOGICAL_ORDER_EXCEPTION            0x0000000002000000ull /**< @brief Logical_Order_Exception */
  368|      0|#define UCD_PROPERTY_OTHER_ID_START                     0x0000000004000000ull /**< @brief Other_ID_Start */
  369|      0|#define UCD_PROPERTY_OTHER_ID_CONTINUE                  0x0000000008000000ull /**< @brief Other_ID_Continue */
  370|      0|#define UCD_PROPERTY_SENTENCE_TERMINAL                  0x0000000010000000ull /**< @brief Sentence_Terminal */
  371|      0|#define UCD_PROPERTY_VARIATION_SELECTOR                 0x0000000020000000ull /**< @brief Variation_Selector */
  372|      0|#define UCD_PROPERTY_PATTERN_WHITE_SPACE                0x0000000040000000ull /**< @brief Pattern_White_Space */
  373|      0|#define UCD_PROPERTY_PATTERN_SYNTAX                     0x0000000080000000ull /**< @brief Pattern_Syntax */
  374|      0|#define UCD_PROPERTY_PREPENDED_CONCATENATION_MARK       0x0000000100000000ull /**< @brief Prepended_Concatenation_Mark */
  375|      0|#define UCD_PROPERTY_EMOJI                              0x0000000200000000ull /**< @brief Emoji */
  376|      0|#define UCD_PROPERTY_EMOJI_PRESENTATION                 0x0000000400000000ull /**< @brief Emoji_Presentation */
  377|      0|#define UCD_PROPERTY_EMOJI_MODIFIER                     0x0000000800000000ull /**< @brief Emoji_Modifier */
  378|      0|#define UCD_PROPERTY_EMOJI_MODIFIER_BASE                0x0000001000000000ull /**< @brief Emoji_Modifier_Base */
  379|      0|#define UCD_PROPERTY_REGIONAL_INDICATOR                 0x0000002000000000ull /**< @brief Regional_Indicator */
  380|      0|#define UCD_PROPERTY_EMOJI_COMPONENT                    0x0000004000000000ull /**< @brief Emoji_Component */
  381|      0|#define UCD_PROPERTY_EXTENDED_PICTOGRAPHIC              0x0000008000000000ull /**< @brief Extended_Pictographic */
  382|       |
  383|       |// eSpeak NG extended properties:
  384|      0|#define ESPEAKNG_PROPERTY_INVERTED_TERMINAL_PUNCTUATION 0x0010000000000000ull /**< @brief Inverted_Terminal_Punctuation */
  385|      0|#define ESPEAKNG_PROPERTY_PUNCTUATION_IN_WORD           0x0020000000000000ull /**< @brief Punctuation_In_Word */
  386|      0|#define ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER          0x0040000000000000ull /**< @brief Optional_Space_After */
  387|      0|#define ESPEAKNG_PROPERTY_EXTENDED_DASH                 0x0080000000000000ull /**< @brief Extended_Dash */
  388|      0|#define ESPEAKNG_PROPERTY_PARAGRAPH_SEPARATOR           0x0100000000000000ull /**< @brief Paragraph_Separator */
  389|      0|#define ESPEAKNG_PROPERTY_ELLIPSIS                      0x0200000000000000ull /**< @brief Ellipsis */
  390|      0|#define ESPEAKNG_PROPERTY_SEMI_COLON                    0x0400000000000000ull /**< @brief Semi_Colon */
  391|      0|#define ESPEAKNG_PROPERTY_COLON                         0x0800000000000000ull /**< @brief Colon */
  392|      0|#define ESPEAKNG_PROPERTY_COMMA                         0x1000000000000000ull /**< @brief Comma */
  393|      0|#define ESPEAKNG_PROPERTY_EXCLAMATION_MARK              0x2000000000000000ull /**< @brief Exclamation_Mark */
  394|      0|#define ESPEAKNG_PROPERTY_QUESTION_MARK                 0x4000000000000000ull /**< @brief Question_Mark */
  395|      0|#define ESPEAKNG_PROPERTY_FULL_STOP                     0x8000000000000000ull /**< @brief Full_Stop */
  396|       |
  397|       |/** @brief Return the properties of the specified codepoint.
  398|       | *
  399|       | * @param c        The Unicode codepoint to lookup.
  400|       | * @param category The General Category of the codepoint.
  401|       | * @return         The properties associated with the codepoint.
  402|       | */
  403|       |ucd_property ucd_properties(codepoint_t c, ucd_category category);
  404|       |
  405|       |/** @brief Is the codepoint in the 'alnum' class?
  406|       |  *
  407|       |  * @param c The Unicode codepoint to check.
  408|       |  * @return  Non-zero if the codepoint is in the 'alnum' class, zero otherwise.
  409|       |  */
  410|       |int ucd_isalnum(codepoint_t c);
  411|       |
  412|       |/** @brief Is the codepoint in the 'alpha' class?
  413|       |  *
  414|       |  * @param c The Unicode codepoint to check.
  415|       |  * @return  Non-zero if the codepoint is in the 'alpha' class, zero otherwise.
  416|       |  */
  417|       |int ucd_isalpha(codepoint_t c);
  418|       |
  419|       |/** @brief Is the codepoint in the 'blank' class?
  420|       |  *
  421|       |  * @param c The Unicode codepoint to check.
  422|       |  * @return  Non-zero if the codepoint is in the 'blank' class, zero otherwise.
  423|       |  */
  424|       |int ucd_isblank(codepoint_t c);
  425|       |
  426|       |/** @brief Is the codepoint in the 'cntrl' class?
  427|       |  *
  428|       |  * @param c The Unicode codepoint to check.
  429|       |  * @return  Non-zero if the codepoint is in the 'cntrl' class, zero otherwise.
  430|       |  */
  431|       |int ucd_iscntrl(codepoint_t c);
  432|       |
  433|       |/** @brief Is the codepoint in the 'digit' class?
  434|       |  *
  435|       |  * @param c The Unicode codepoint to check.
  436|       |  * @return  Non-zero if the codepoint is in the 'digit' class, zero otherwise.
  437|       |  */
  438|       |int ucd_isdigit(codepoint_t c);
  439|       |
  440|       |/** @brief Is the codepoint in the 'graph' class?
  441|       |  *
  442|       |  * @param c The Unicode codepoint to check.
  443|       |  * @return  Non-zero if the codepoint is in the 'graph' class, zero otherwise.
  444|       |  */
  445|       |int ucd_isgraph(codepoint_t c);
  446|       |
  447|       |/** @brief Is the codepoint in the 'lower' class?
  448|       |  *
  449|       |  * @param c The Unicode codepoint to check.
  450|       |  * @return  Non-zero if the codepoint is in the 'lower' class, zero otherwise.
  451|       |  */
  452|       |int ucd_islower(codepoint_t c);
  453|       |
  454|       |/** @brief Is the codepoint in the 'print' class?
  455|       |  *
  456|       |  * @param c The Unicode codepoint to check.
  457|       |  * @return  Non-zero if the codepoint is in the 'print' class, zero otherwise.
  458|       |  */
  459|       |int ucd_isprint(codepoint_t c);
  460|       |
  461|       |/** @brief Is the codepoint in the 'punct' class?
  462|       |  *
  463|       |  * @param c The Unicode codepoint to check.
  464|       |  * @return  Non-zero if the codepoint is in the 'punct' class, zero otherwise.
  465|       |  */
  466|       |int ucd_ispunct(codepoint_t c);
  467|       |
  468|       |/** @brief Is the codepoint in the 'space' class?
  469|       |  *
  470|       |  * @param c The Unicode codepoint to check.
  471|       |  * @return  Non-zero if the codepoint is in the 'space' class, zero otherwise.
  472|       |  */
  473|       |int ucd_isspace(codepoint_t c);
  474|       |
  475|       |/** @brief Is the codepoint in the 'upper' class?
  476|       |  *
  477|       |  * @param c The Unicode codepoint to check.
  478|       |  * @return  Non-zero if the codepoint is in the 'upper' class, zero otherwise.
  479|       |  */
  480|       |int ucd_isupper(codepoint_t c);
  481|       |
  482|       |/** @brief Is the codepoint in the 'xdigit' class?
  483|       |  *
  484|       |  * @param c The Unicode codepoint to check.
  485|       |  * @return  Non-zero if the codepoint is in the 'xdigit' class, zero otherwise.
  486|       |  */
  487|       |int ucd_isxdigit(codepoint_t c);
  488|       |
  489|       |/** @brief Convert the Unicode codepoint to upper-case.
  490|       |  *
  491|       |  * This function only uses the simple case mapping present in the
  492|       |  * UnicodeData file. The data in SpecialCasing requires Unicode
  493|       |  * codepoints to be mapped to multiple codepoints.
  494|       |  *
  495|       |  * @param c The Unicode codepoint to convert.
  496|       |  * @return  The upper-case Unicode codepoint for this codepoint, or
  497|       |  *          this codepoint if there is no upper-case codepoint.
  498|       |  */
  499|       |codepoint_t ucd_toupper(codepoint_t c);
  500|       |
  501|       |/** @brief Convert the Unicode codepoint to lower-case.
  502|       |  *
  503|       |  * This function only uses the simple case mapping present in the
  504|       |  * UnicodeData file. The data in SpecialCasing requires Unicode
  505|       |  * codepoints to be mapped to multiple codepoints.
  506|       |  *
  507|       |  * @param c The Unicode codepoint to convert.
  508|       |  * @return  The lower-case Unicode codepoint for this codepoint, or
  509|       |  *          this codepoint if there is no upper-case codepoint.
  510|       |  */
  511|       |codepoint_t ucd_tolower(codepoint_t c);
  512|       |
  513|       |/** @brief Convert the Unicode codepoint to title-case.
  514|       |  *
  515|       |  * This function only uses the simple case mapping present in the
  516|       |  * UnicodeData file. The data in SpecialCasing requires Unicode
  517|       |  * codepoints to be mapped to multiple codepoints.
  518|       |  *
  519|       |  * @param c The Unicode codepoint to convert.
  520|       |  * @return  The title-case Unicode codepoint for this codepoint, or
  521|       |  *          this codepoint if there is no upper-case codepoint.
  522|       |  */
  523|       |codepoint_t ucd_totitle(codepoint_t c);
  524|       |
  525|       |#ifdef __cplusplus
  526|       |}
  527|       |
  528|       |/** @brief Unicode Character Database
  529|       |  */
  530|       |namespace ucd
  531|       |{
  532|       |	/** @brief Represents a Unicode codepoint.
  533|       |	  */
  534|       |	using ::codepoint_t;
  535|       |
  536|       |	/** @brief Unicode General Category Groups
  537|       |	  * @see   http://www.unicode.org/reports/tr44/
  538|       |	  */
  539|       |	enum category_group
  540|       |	{
  541|       |		C = UCD_CATEGORY_GROUP_C, /**< @brief Other */
  542|       |		I = UCD_CATEGORY_GROUP_I, /**< @brief Invalid */
  543|       |		L = UCD_CATEGORY_GROUP_L, /**< @brief Letter */
  544|       |		M = UCD_CATEGORY_GROUP_M, /**< @brief Mark */
  545|       |		N = UCD_CATEGORY_GROUP_N, /**< @brief Number */
  546|       |		P = UCD_CATEGORY_GROUP_P, /**< @brief Punctuation */
  547|       |		S = UCD_CATEGORY_GROUP_S, /**< @brief Symbol */
  548|       |		Z = UCD_CATEGORY_GROUP_Z, /**< @brief Separator */
  549|       |	};
  550|       |
  551|       |	/** @brief Get a string representation of the category_group enumeration value.
  552|       |	  *
  553|       |	  * @param c The value to get the string representation for.
  554|       |	  *
  555|       |	  * @return The string representation, or "-" if the value is not recognized.
  556|       |	  */
  557|       |	inline const char *get_category_group_string(category_group c)
  558|       |	{
  559|       |		return ucd_get_category_group_string((ucd_category_group)c);
  560|       |	}
  561|       |
  562|       |	/** @brief Unicode General Category Values
  563|       |	  * @see   http://www.unicode.org/reports/tr44/
  564|       |	  */
  565|       |	enum category
  566|       |	{
  567|       |		Cc = UCD_CATEGORY_Cc, /**< @brief Control Character */
  568|       |		Cf = UCD_CATEGORY_Cf, /**< @brief Format Control Character */
  569|       |		Cn = UCD_CATEGORY_Cn, /**< @brief Unassigned */
  570|       |		Co = UCD_CATEGORY_Co, /**< @brief Private Use */
  571|       |		Cs = UCD_CATEGORY_Cs, /**< @brief Surrogate Code Point */
  572|       |
  573|       |		Ii = UCD_CATEGORY_Ii, /**< @brief Invalid Unicode Codepoint */
  574|       |
  575|       |		Ll = UCD_CATEGORY_Ll, /**< @brief Lower Case Letter */
  576|       |		Lm = UCD_CATEGORY_Lm, /**< @brief Letter Modifier */
  577|       |		Lo = UCD_CATEGORY_Lo, /**< @brief Other Letter */
  578|       |		Lt = UCD_CATEGORY_Lt, /**< @brief Title Case Letter */
  579|       |		Lu = UCD_CATEGORY_Lu, /**< @brief Upper Case Letter */
  580|       |
  581|       |		Mc = UCD_CATEGORY_Mc, /**< @brief Spacing Mark */
  582|       |		Me = UCD_CATEGORY_Me, /**< @brief Enclosing Mark */
  583|       |		Mn = UCD_CATEGORY_Mn, /**< @brief Non-Spacing Mark */
  584|       |
  585|       |		Nd = UCD_CATEGORY_Nd, /**< @brief Decimal Digit */
  586|       |		Nl = UCD_CATEGORY_Nl, /**< @brief Letter-Like Number */
  587|       |		No = UCD_CATEGORY_No, /**< @brief Other Number */
  588|       |
  589|       |		Pc = UCD_CATEGORY_Pc, /**< @brief Connector */
  590|       |		Pd = UCD_CATEGORY_Pd, /**< @brief Dash/Hyphen */
  591|       |		Pe = UCD_CATEGORY_Pe, /**< @brief Close Punctuation Mark */
  592|       |		Pf = UCD_CATEGORY_Pf, /**< @brief Final Quotation Mark */
  593|       |		Pi = UCD_CATEGORY_Pi, /**< @brief Initial Quotation Mark */
  594|       |		Po = UCD_CATEGORY_Po, /**< @brief Other */
  595|       |		Ps = UCD_CATEGORY_Ps, /**< @brief Open Punctuation Mark */
  596|       |
  597|       |		Sc = UCD_CATEGORY_Sc, /**< @brief Currency Symbol */
  598|       |		Sk = UCD_CATEGORY_Sk, /**< @brief Modifier Symbol */
  599|       |		Sm = UCD_CATEGORY_Sm, /**< @brief Math Symbol */
  600|       |		So = UCD_CATEGORY_So, /**< @brief Other Symbol */
  601|       |
  602|       |		Zl = UCD_CATEGORY_Zl, /**< @brief Line Separator */
  603|       |		Zp = UCD_CATEGORY_Zp, /**< @brief Paragraph Separator */
  604|       |		Zs = UCD_CATEGORY_Zs, /**< @brief Space Separator */
  605|       |	};
  606|       |
  607|       |	/** @brief Get a string representation of the category enumeration value.
  608|       |	  *
  609|       |	  * @param c The value to get the string representation for.
  610|       |	  *
  611|       |	  * @return The string representation, or "--" if the value is not recognized.
  612|       |	  */
  613|       |	inline const char *get_category_string(category c)
  614|       |	{
  615|       |		return ucd_get_category_string((ucd_category)c);
  616|       |	}
  617|       |
  618|       |	/** @brief Lookup the General Category Group for a General Category.
  619|       |	  *
  620|       |	  * @param c The General Category to lookup.
  621|       |	  * @return  The General Category Group of the General Category.
  622|       |	  */
  623|       |	inline category_group lookup_category_group(category c)
  624|       |	{
  625|       |		return (category_group)ucd_get_category_group_for_category((ucd_category)c);
  626|       |	}
  627|       |
  628|       |	/** @brief Lookup the General Category Group for a Unicode codepoint.
  629|       |	  *
  630|       |	  * @param c The Unicode codepoint to lookup.
  631|       |	  * @return  The General Category Group of the Unicode codepoint.
  632|       |	  */
  633|       |	inline category_group lookup_category_group(codepoint_t c)
  634|       |	{
  635|       |		return (category_group)ucd_lookup_category_group(c);
  636|       |	}
  637|       |
  638|       |	/** @brief Lookup the General Category for a Unicode codepoint.
  639|       |	  *
  640|       |	  * @param c The Unicode codepoint to lookup.
  641|       |	  * @return  The General Category of the Unicode codepoint.
  642|       |	  */
  643|       |	inline category lookup_category(codepoint_t c)
  644|       |	{
  645|       |		return (category)ucd_lookup_category(c);
  646|       |	}
  647|       |
  648|       |	/** @brief Unicode Script
  649|       |	  * @see   http://www.iana.org/assignments/language-subtag-registry
  650|       |	  * @see   http://www.unicode.org/iso15924/iso15924-codes.html
  651|       |	  */
  652|       |	enum script
  653|       |	{
  654|       |		Adlm = UCD_SCRIPT_Adlm, /**< @brief Adlam Script */
  655|       |		Afak = UCD_SCRIPT_Afak, /**< @brief Afaka Script */
  656|       |		Aghb = UCD_SCRIPT_Aghb, /**< @brief Caucasian Albanian Script */
  657|       |		Ahom = UCD_SCRIPT_Ahom, /**< @brief Tai Ahom Script */
  658|       |		Arab = UCD_SCRIPT_Arab, /**< @brief Arabic Script */
  659|       |		Armi = UCD_SCRIPT_Armi, /**< @brief Imperial Aramaic Script */
  660|       |		Armn = UCD_SCRIPT_Armn, /**< @brief Armenian Script */
  661|       |		Avst = UCD_SCRIPT_Avst, /**< @brief Avestan Script */
  662|       |		Bali = UCD_SCRIPT_Bali, /**< @brief Balinese Script */
  663|       |		Bamu = UCD_SCRIPT_Bamu, /**< @brief Bamum Script */
  664|       |		Bass = UCD_SCRIPT_Bass, /**< @brief Bassa Vah Script */
  665|       |		Batk = UCD_SCRIPT_Batk, /**< @brief Batak Script */
  666|       |		Beng = UCD_SCRIPT_Beng, /**< @brief Bengali Script */
  667|       |		Bhks = UCD_SCRIPT_Bhks, /**< @brief Bhaiksuki Script */
  668|       |		Blis = UCD_SCRIPT_Blis, /**< @brief Blissymbols Script */
  669|       |		Bopo = UCD_SCRIPT_Bopo, /**< @brief Bopomofo Script */
  670|       |		Brah = UCD_SCRIPT_Brah, /**< @brief Brahmi Script */
  671|       |		Brai = UCD_SCRIPT_Brai, /**< @brief Braille Script */
  672|       |		Bugi = UCD_SCRIPT_Bugi, /**< @brief Buginese Script */
  673|       |		Buhd = UCD_SCRIPT_Buhd, /**< @brief Buhid Script */
  674|       |		Cakm = UCD_SCRIPT_Cakm, /**< @brief Chakma Script */
  675|       |		Cans = UCD_SCRIPT_Cans, /**< @brief Unified Canadian Aboriginal Syllabics */
  676|       |		Cari = UCD_SCRIPT_Cari, /**< @brief Carian Script */
  677|       |		Cham = UCD_SCRIPT_Cham, /**< @brief Cham Script */
  678|       |		Cher = UCD_SCRIPT_Cher, /**< @brief Cherokee Script */
  679|       |		Cirt = UCD_SCRIPT_Cirt, /**< @brief Cirth Script */
  680|       |		Copt = UCD_SCRIPT_Copt, /**< @brief Coptic Script */
  681|       |		Cprt = UCD_SCRIPT_Cprt, /**< @brief Cypriot Script */
  682|       |		Cyrl = UCD_SCRIPT_Cyrl, /**< @brief Cyrillic Script */
  683|       |		Cyrs = UCD_SCRIPT_Cyrs, /**< @brief Cyrillic (Old Church Slavonic variant) Script */
  684|       |		Deva = UCD_SCRIPT_Deva, /**< @brief Devanagari Script */
  685|       |		Dogr = UCD_SCRIPT_Dogr, /**< @brief Dogra Script */
  686|       |		Dsrt = UCD_SCRIPT_Dsrt, /**< @brief Deseret Script */
  687|       |		Dupl = UCD_SCRIPT_Dupl, /**< @brief Duployan Shorthand Script */
  688|       |		Egyd = UCD_SCRIPT_Egyd, /**< @brief Egyptian Demotic Script */
  689|       |		Egyh = UCD_SCRIPT_Egyh, /**< @brief Egyptian Hieratic Script */
  690|       |		Egyp = UCD_SCRIPT_Egyp, /**< @brief Egyptian Hiegoglyphs */
  691|       |		Elba = UCD_SCRIPT_Elba, /**< @brief Elbasan Script */
  692|       |		Ethi = UCD_SCRIPT_Ethi, /**< @brief Ethiopic Script */
  693|       |		Geok = UCD_SCRIPT_Geok, /**< @brief Khutsuri Script */
  694|       |		Geor = UCD_SCRIPT_Geor, /**< @brief Geirgian Script */
  695|       |		Glag = UCD_SCRIPT_Glag, /**< @brief Glagolitic Script */
  696|       |		Gong = UCD_SCRIPT_Gong, /**< @brief Gunjala Gondi */
  697|       |		Gonm = UCD_SCRIPT_Gonm, /**< @brief Masaram Gondi */
  698|       |		Goth = UCD_SCRIPT_Goth, /**< @brief Gothic Script */
  699|       |		Gran = UCD_SCRIPT_Gran, /**< @brief Grantha Script */
  700|       |		Grek = UCD_SCRIPT_Grek, /**< @brief Greek Script */
  701|       |		Gujr = UCD_SCRIPT_Gujr, /**< @brief Gujarati Script */
  702|       |		Guru = UCD_SCRIPT_Guru, /**< @brief Gurmukhi Script */
  703|       |		Hang = UCD_SCRIPT_Hang, /**< @brief Hangul Script */
  704|       |		Hani = UCD_SCRIPT_Hani, /**< @brief Han (Hanzi, Kanji, Hanja) Script */
  705|       |		Hano = UCD_SCRIPT_Hano, /**< @brief Hanunoo Script */
  706|       |		Hans = UCD_SCRIPT_Hans, /**< @brief Han (Simplified) Script */
  707|       |		Hant = UCD_SCRIPT_Hant, /**< @brief Han (Traditional) Script */
  708|       |		Hatr = UCD_SCRIPT_Hatr, /**< @brief Hatran Script */
  709|       |		Hebr = UCD_SCRIPT_Hebr, /**< @brief Hebrew Script */
  710|       |		Hira = UCD_SCRIPT_Hira, /**< @brief Hiragana Script */
  711|       |		Hluw = UCD_SCRIPT_Hluw, /**< @brief Anatolian Hieroglyphs */
  712|       |		Hmng = UCD_SCRIPT_Hmng, /**< @brief Pahawh Hmong Script */
  713|       |		Hrkt = UCD_SCRIPT_Hrkt, /**< @brief Japanese Syllabaries */
  714|       |		Hung = UCD_SCRIPT_Hung, /**< @brief Old Hungarian Script */
  715|       |		Inds = UCD_SCRIPT_Inds, /**< @brief Indus Script */
  716|       |		Ital = UCD_SCRIPT_Ital, /**< @brief Old Italic Script */
  717|       |		Java = UCD_SCRIPT_Java, /**< @brief Javanese Script */
  718|       |		Jpan = UCD_SCRIPT_Jpan, /**< @brief Japanese (Han + Hiragana + Katakana) Scripts */
  719|       |		Jurc = UCD_SCRIPT_Jurc, /**< @brief Jurchen Script */
  720|       |		Kali = UCD_SCRIPT_Kali, /**< @brief Kayah Li Script */
  721|       |		Kana = UCD_SCRIPT_Kana, /**< @brief Katakana Script */
  722|       |		Khar = UCD_SCRIPT_Khar, /**< @brief Kharoshthi Script */
  723|       |		Khmr = UCD_SCRIPT_Khmr, /**< @brief Khmer Script */
  724|       |		Khoj = UCD_SCRIPT_Khoj, /**< @brief Khojki Script */
  725|       |		Knda = UCD_SCRIPT_Knda, /**< @brief Kannada Script */
  726|       |		Kore = UCD_SCRIPT_Kore, /**< @brief Korean (Hangul + Han) Scripts */
  727|       |		Kpel = UCD_SCRIPT_Kpel, /**< @brief Kpelle Script */
  728|       |		Kthi = UCD_SCRIPT_Kthi, /**< @brief Kaithi Script */
  729|       |		Lana = UCD_SCRIPT_Lana, /**< @brief Tai Tham Script */
  730|       |		Laoo = UCD_SCRIPT_Laoo, /**< @brief Lao Script */
  731|       |		Latf = UCD_SCRIPT_Latf, /**< @brief Latin Script (Fractur Variant) */
  732|       |		Latg = UCD_SCRIPT_Latg, /**< @brief Latin Script (Gaelic Variant) */
  733|       |		Latn = UCD_SCRIPT_Latn, /**< @brief Latin Script */
  734|       |		Lepc = UCD_SCRIPT_Lepc, /**< @brief Lepcha Script */
  735|       |		Limb = UCD_SCRIPT_Limb, /**< @brief Limbu Script */
  736|       |		Lina = UCD_SCRIPT_Lina, /**< @brief Linear A Script */
  737|       |		Linb = UCD_SCRIPT_Linb, /**< @brief Linear B Script */
  738|       |		Lisu = UCD_SCRIPT_Lisu, /**< @brief Lisu Script */
  739|       |		Loma = UCD_SCRIPT_Loma, /**< @brief Loma Script */
  740|       |		Lyci = UCD_SCRIPT_Lyci, /**< @brief Lycian Script */
  741|       |		Lydi = UCD_SCRIPT_Lydi, /**< @brief Lydian Script */
  742|       |		Mahj = UCD_SCRIPT_Mahj, /**< @brief Mahajani Script */
  743|       |		Maka = UCD_SCRIPT_Maka, /**< @brief Mahajani Script */
  744|       |		Mand = UCD_SCRIPT_Mand, /**< @brief Mandaic Script */
  745|       |		Mani = UCD_SCRIPT_Mani, /**< @brief Manichaean Script */
  746|       |		Marc = UCD_SCRIPT_Marc, /**< @brief Marchen Script */
  747|       |		Maya = UCD_SCRIPT_Maya, /**< @brief Mayan Hieroglyphs */
  748|       |		Medf = UCD_SCRIPT_Medf, /**< @brief Medefaidrin (Oberi Okaime) Script */
  749|       |		Mend = UCD_SCRIPT_Mend, /**< @brief Mende Kikakui Script */
  750|       |		Merc = UCD_SCRIPT_Merc, /**< @brief Meroitic Cursive Script */
  751|       |		Mero = UCD_SCRIPT_Mero, /**< @brief Meroitic Hieroglyphs */
  752|       |		Mlym = UCD_SCRIPT_Mlym, /**< @brief Malayalam Script */
  753|       |		Modi = UCD_SCRIPT_Modi, /**< @brief Modi Script */
  754|       |		Mong = UCD_SCRIPT_Mong, /**< @brief Mongolian Script */
  755|       |		Moon = UCD_SCRIPT_Moon, /**< @brief Moon Script */
  756|       |		Mroo = UCD_SCRIPT_Mroo, /**< @brief Mro Script */
  757|       |		Mtei = UCD_SCRIPT_Mtei, /**< @brief Meitei Mayek Script */
  758|       |		Mult = UCD_SCRIPT_Mult, /**< @brief Multani Script */
  759|       |		Mymr = UCD_SCRIPT_Mymr, /**< @brief Myanmar (Burmese) Script */
  760|       |		Narb = UCD_SCRIPT_Narb, /**< @brief Old North Arabian Script */
  761|       |		Nbat = UCD_SCRIPT_Nbat, /**< @brief Nabataean Script */
  762|       |		Newa = UCD_SCRIPT_Newa, /**< @brief Newa Script */
  763|       |		Nkgb = UCD_SCRIPT_Nkgb, /**< @brief Nakhi Geba Script */
  764|       |		Nkoo = UCD_SCRIPT_Nkoo, /**< @brief N'Ko Script */
  765|       |		Nshu = UCD_SCRIPT_Nshu, /**< @brief Nushu Script */
  766|       |		Ogam = UCD_SCRIPT_Ogam, /**< @brief Ogham Script */
  767|       |		Olck = UCD_SCRIPT_Olck, /**< @brief Ol Chiki Script */
  768|       |		Orkh = UCD_SCRIPT_Orkh, /**< @brief Old Turkic Script */
  769|       |		Orya = UCD_SCRIPT_Orya, /**< @brief Oriya Script */
  770|       |		Osge = UCD_SCRIPT_Osge, /**< @brief Osage Script */
  771|       |		Osma = UCD_SCRIPT_Osma, /**< @brief Osmanya Script */
  772|       |		Palm = UCD_SCRIPT_Palm, /**< @brief Palmyrene Script */
  773|       |		Pauc = UCD_SCRIPT_Pauc, /**< @brief Pau Cin Hau Script */
  774|       |		Perm = UCD_SCRIPT_Perm, /**< @brief Old Permic */
  775|       |		Phag = UCD_SCRIPT_Phag, /**< @brief Phags-Pa Script */
  776|       |		Phli = UCD_SCRIPT_Phli, /**< @brief Inscriptional Pahlavi Script */
  777|       |		Phlp = UCD_SCRIPT_Phlp, /**< @brief Psalter Pahlavi Script */
  778|       |		Phlv = UCD_SCRIPT_Phlv, /**< @brief Book Pahlavi Script */
  779|       |		Phnx = UCD_SCRIPT_Phnx, /**< @brief Phoenician Script */
  780|       |		Plrd = UCD_SCRIPT_Plrd, /**< @brief Miao Script */
  781|       |		Prti = UCD_SCRIPT_Prti, /**< @brief Inscriptional Parthian Script */
  782|       |		Qaak = UCD_SCRIPT_Qaak, /**< @brief Klingon Script (Private Use) */
  783|       |		Rjng = UCD_SCRIPT_Rjng, /**< @brief Rejang Script */
  784|       |		Rohg = UCD_SCRIPT_Rohg, /**< @brief Hanifi Rohingya Script */
  785|       |		Roro = UCD_SCRIPT_Roro, /**< @brief Rongorongo Script */
  786|       |		Runr = UCD_SCRIPT_Runr, /**< @brief Runic Script */
  787|       |		Samr = UCD_SCRIPT_Samr, /**< @brief Samaritan Script */
  788|       |		Sara = UCD_SCRIPT_Sara, /**< @brief Sarati Script */
  789|       |		Sarb = UCD_SCRIPT_Sarb, /**< @brief Old South Arabian Script */
  790|       |		Saur = UCD_SCRIPT_Saur, /**< @brief Saurashtra Script */
  791|       |		Sgnw = UCD_SCRIPT_Sgnw, /**< @brief Sign Writing */
  792|       |		Shaw = UCD_SCRIPT_Shaw, /**< @brief Shavian Script */
  793|       |		Shrd = UCD_SCRIPT_Shrd, /**< @brief Sharada Script */
  794|       |		Sidd = UCD_SCRIPT_Sidd, /**< @brief Siddham Script */
  795|       |		Sind = UCD_SCRIPT_Sind, /**< @brief Sindhi Script */
  796|       |		Sinh = UCD_SCRIPT_Sinh, /**< @brief Sinhala Script */
  797|       |		Sogd = UCD_SCRIPT_Sogd, /**< @brief Sogdian Script */
  798|       |		Sogo = UCD_SCRIPT_Sogo, /**< @brief Old Sogdian Script */
  799|       |		Sora = UCD_SCRIPT_Sora, /**< @brief Sora Sompeng Script */
  800|       |		Soyo = UCD_SCRIPT_Soyo, /**< @brief Soyombo */
  801|       |		Sund = UCD_SCRIPT_Sund, /**< @brief Sundanese Script */
  802|       |		Sylo = UCD_SCRIPT_Sylo, /**< @brief Syloti Nagri Script */
  803|       |		Syrc = UCD_SCRIPT_Syrc, /**< @brief Syriac Script */
  804|       |		Syre = UCD_SCRIPT_Syre, /**< @brief Syriac Script (Estrangelo Variant) */
  805|       |		Syrj = UCD_SCRIPT_Syrj, /**< @brief Syriac Script (Western Variant) */
  806|       |		Syrn = UCD_SCRIPT_Syrn, /**< @brief Syriac Script (Eastern Variant) */
  807|       |		Tagb = UCD_SCRIPT_Tagb, /**< @brief Tagbanwa Script */
  808|       |		Takr = UCD_SCRIPT_Takr, /**< @brief Takri Script */
  809|       |		Tale = UCD_SCRIPT_Tale, /**< @brief Tai Le Script */
  810|       |		Talu = UCD_SCRIPT_Talu, /**< @brief New Tai Lue Script */
  811|       |		Taml = UCD_SCRIPT_Taml, /**< @brief Tamil Script */
  812|       |		Tang = UCD_SCRIPT_Tang, /**< @brief Tangut Script */
  813|       |		Tavt = UCD_SCRIPT_Tavt, /**< @brief Tai Viet Script */
  814|       |		Telu = UCD_SCRIPT_Telu, /**< @brief Telugu Script */
  815|       |		Teng = UCD_SCRIPT_Teng, /**< @brief Tengwar Script */
  816|       |		Tfng = UCD_SCRIPT_Tfng, /**< @brief Tifinagh Script */
  817|       |		Tglg = UCD_SCRIPT_Tglg, /**< @brief Tagalog Script */
  818|       |		Thaa = UCD_SCRIPT_Thaa, /**< @brief Thaana Script */
  819|       |		Thai = UCD_SCRIPT_Thai, /**< @brief Thai Script */
  820|       |		Tibt = UCD_SCRIPT_Tibt, /**< @brief Tibetan Script */
  821|       |		Tirh = UCD_SCRIPT_Tirh, /**< @brief Tirhuta Script */
  822|       |		Ugar = UCD_SCRIPT_Ugar, /**< @brief Ugaritic Script */
  823|       |		Vaii = UCD_SCRIPT_Vaii, /**< @brief Vai Script */
  824|       |		Visp = UCD_SCRIPT_Visp, /**< @brief Visible Speech Script */
  825|       |		Wara = UCD_SCRIPT_Wara, /**< @brief Warang Citi Script */
  826|       |		Wole = UCD_SCRIPT_Wole, /**< @brief Woleai Script */
  827|       |		Xpeo = UCD_SCRIPT_Xpeo, /**< @brief Old Persian Script */
  828|       |		Xsux = UCD_SCRIPT_Xsux, /**< @brief Cuneiform Script */
  829|       |		Yiii = UCD_SCRIPT_Yiii, /**< @brief Yi Script */
  830|       |		Zanb = UCD_SCRIPT_Zanb, /**< @brief Zanabazar Square */
  831|       |		Zinh = UCD_SCRIPT_Zinh, /**< @brief Inherited Script */
  832|       |		Zmth = UCD_SCRIPT_Zmth, /**< @brief Mathematical Notation */
  833|       |		Zsym = UCD_SCRIPT_Zsym, /**< @brief Symbols */
  834|       |		Zxxx = UCD_SCRIPT_Zxxx, /**< @brief Unwritten Documents */
  835|       |		Zyyy = UCD_SCRIPT_Zyyy, /**< @brief Undetermined Script */
  836|       |		Zzzz = UCD_SCRIPT_Zzzz, /**< @brief Uncoded Script */
  837|       |	};
  838|       |
  839|       |	/** @brief Get a string representation of the script enumeration value.
  840|       |	  *
  841|       |	  * @param s The value to get the string representation for.
  842|       |	  *
  843|       |	  * @return The string representation, or "----" if the value is not recognized.
  844|       |	  */
  845|       |	inline const char *get_script_string(script s)
  846|       |	{
  847|       |		return ucd_get_script_string((ucd_script)s);
  848|       |	}
  849|       |
  850|       |	/** @brief Lookup the Script for a Unicode codepoint.
  851|       |	  *
  852|       |	  * @param c The Unicode codepoint to lookup.
  853|       |	  * @return  The Script of the Unicode codepoint.
  854|       |	  */
  855|       |	inline script lookup_script(codepoint_t c)
  856|       |	{
  857|       |		return (script)ucd_lookup_script(c);
  858|       |	}
  859|       |
  860|       |	/** @brief Properties
  861|       |	 */
  862|       |	typedef ucd_property property;
  863|       |	enum
  864|       |	{
  865|       |		White_Space = UCD_PROPERTY_WHITE_SPACE, /**< @brief White_Space */
  866|       |		Bidi_Control = UCD_PROPERTY_BIDI_CONTROL, /**< @brief Bidi_Control */
  867|       |		Join_Control = UCD_PROPERTY_JOIN_CONTROL, /**< @brief Join_Control */
  868|       |		Dash = UCD_PROPERTY_DASH, /**< @brief Dash */
  869|       |		Hyphen = UCD_PROPERTY_HYPHEN, /**< @brief Hyphen */
  870|       |		Quotation_Mark = UCD_PROPERTY_QUOTATION_MARK, /**< @brief Quotation_Mark */
  871|       |		Terminal_Punctuation = UCD_PROPERTY_TERMINAL_PUNCTUATION, /**< @brief Terminal_Punctuation */
  872|       |		Other_Math = UCD_PROPERTY_OTHER_MATH, /**< @brief Other_Math */
  873|       |		Hex_Digit = UCD_PROPERTY_HEX_DIGIT, /**< @brief Hex_Digit */
  874|       |		ASCII_Hex_Digit = UCD_PROPERTY_ASCII_HEX_DIGIT, /**< @brief ASCII_Hex_Digit */
  875|       |		Other_Alphabetic = UCD_PROPERTY_OTHER_ALPHABETIC, /**< @brief Other_Alphabetic */
  876|       |		Ideographic = UCD_PROPERTY_IDEOGRAPHIC, /**< @brief Ideographic */
  877|       |		Diacritic = UCD_PROPERTY_DIACRITIC, /**< @brief Diacritic */
  878|       |		Extender = UCD_PROPERTY_EXTENDER, /**< @brief Extender */
  879|       |		Other_Lowercase = UCD_PROPERTY_OTHER_LOWERCASE, /**< @brief Other_Lowercase */
  880|       |		Other_Uppercase = UCD_PROPERTY_OTHER_UPPERCASE, /**< @brief Other_Uppercase */
  881|       |		Noncharacter_Code_Point = UCD_PROPERTY_NONCHARACTER_CODE_POINT, /**< @brief Noncharacter_Code_Point */
  882|       |		Other_Grapheme_Extend = UCD_PROPERTY_OTHER_GRAPHEME_EXTEND, /**< @brief Other_Grapheme_Extend */
  883|       |		IDS_Binary_Operator = UCD_PROPERTY_IDS_BINARY_OPERATOR, /**< @brief IDS_Binary_Operator */
  884|       |		IDS_Trinary_Operator = UCD_PROPERTY_IDS_TRINARY_OPERATOR, /**< @brief IDS_Trinary_Operator */
  885|       |		Radical = UCD_PROPERTY_RADICAL, /**< @brief Radical */
  886|       |		Unified_Ideograph = UCD_PROPERTY_UNIFIED_IDEOGRAPH, /**< @brief Unified_Ideograph */
  887|       |		Other_Default_Ignorable_Code_Point = UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT, /**< @brief Other_Default_Ignorable_Code_Point */
  888|       |		Deprecated = UCD_PROPERTY_DEPRECATED, /**< @brief Deprecated */
  889|       |		Soft_Dotted = UCD_PROPERTY_SOFT_DOTTED, /**< @brief Soft_Dotted */
  890|       |		Logical_Order_Exception = UCD_PROPERTY_LOGICAL_ORDER_EXCEPTION, /**< @brief Logical_Order_Exception */
  891|       |		Other_ID_Start = UCD_PROPERTY_OTHER_ID_START, /**< @brief Other_ID_Start */
  892|       |		Other_ID_Continue = UCD_PROPERTY_OTHER_ID_CONTINUE, /**< @brief Other_ID_Continue */
  893|       |		Sentence_Terminal = UCD_PROPERTY_SENTENCE_TERMINAL, /**< @brief Sentence_Terminal */
  894|       |		Variation_Selector = UCD_PROPERTY_VARIATION_SELECTOR, /**< @brief Variation_Selector */
  895|       |		Pattern_White_Space = UCD_PROPERTY_PATTERN_WHITE_SPACE, /**< @brief Pattern_White_Space */
  896|       |		Pattern_Syntax = UCD_PROPERTY_PATTERN_SYNTAX, /**< @brief Pattern_Syntax */
  897|       |		Prepended_Concatenation_Mark = UCD_PROPERTY_PREPENDED_CONCATENATION_MARK, /**< @brief Prepended_Concatenation_Mark */
  898|       |		Emoji = UCD_PROPERTY_EMOJI, /**< @brief Emoji */
  899|       |		Emoji_Presentation = UCD_PROPERTY_EMOJI_PRESENTATION, /**< @brief Emoji_Presentation */
  900|       |		Emoji_Modifier = UCD_PROPERTY_EMOJI_MODIFIER, /**< @brief Emoji_Modifier */
  901|       |		Emoji_Modifier_Base = UCD_PROPERTY_EMOJI_MODIFIER_BASE, /**< @brief Emoji_Modifier_Base */
  902|       |		Regional_Indicator = UCD_PROPERTY_REGIONAL_INDICATOR, /**< @brief Regional_Indicator */
  903|       |		Emoji_Component = UCD_PROPERTY_EMOJI_COMPONENT, /**< @brief Emoji_Component */
  904|       |		Extended_Pictographic = UCD_PROPERTY_EXTENDED_PICTOGRAPHIC, /**< @brief Extended_Pictographic */
  905|       |	};
  906|       |
  907|       |	/** @brief Return the properties of the specified codepoint.
  908|       |	 *
  909|       |	 * @param c   The Unicode codepoint to lookup.
  910|       |	 * @param cat The General Category of the codepoint.
  911|       |	 * @return    The properties associated with the codepoint.
  912|       |	 */
  913|       |	inline property properties(codepoint_t c, category cat)
  914|       |	{
  915|       |		return (property)ucd_properties(c, (ucd_category)cat);
  916|       |	}
  917|       |
  918|       |	/** @brief Is the codepoint in the 'alnum' class?
  919|       |	  *
  920|       |	  * @param c The Unicode codepoint to check.
  921|       |	  * @return  Non-zero if the codepoint is in the 'alnum' class, zero otherwise.
  922|       |	  */
  923|       |	inline int isalnum(codepoint_t c)
  924|       |	{
  925|       |		return ucd_isalnum(c);
  926|       |	}
  927|       |
  928|       |	/** @brief Is the codepoint in the 'alpha' class?
  929|       |	  *
  930|       |	  * @param c The Unicode codepoint to check.
  931|       |	  * @return  Non-zero if the codepoint is in the 'alpha' class, zero otherwise.
  932|       |	  */
  933|       |	inline int isalpha(codepoint_t c)
  934|       |	{
  935|       |		return ucd_isalpha(c);
  936|       |	}
  937|       |
  938|       |	/** @brief Is the codepoint in the 'blank' class?
  939|       |	  *
  940|       |	  * @param c The Unicode codepoint to check.
  941|       |	  * @return  Non-zero if the codepoint is in the 'blank' class, zero otherwise.
  942|       |	  */
  943|       |	inline int isblank(codepoint_t c)
  944|       |	{
  945|       |		return ucd_isblank(c);
  946|       |	}
  947|       |
  948|       |	/** @brief Is the codepoint in the 'cntrl' class?
  949|       |	  *
  950|       |	  * @param c The Unicode codepoint to check.
  951|       |	  * @return  Non-zero if the codepoint is in the 'cntrl' class, zero otherwise.
  952|       |	  */
  953|       |	inline int iscntrl(codepoint_t c)
  954|       |	{
  955|       |		return ucd_iscntrl(c);
  956|       |	}
  957|       |
  958|       |	/** @brief Is the codepoint in the 'digit' class?
  959|       |	  *
  960|       |	  * @param c The Unicode codepoint to check.
  961|       |	  * @return  Non-zero if the codepoint is in the 'digit' class, zero otherwise.
  962|       |	  */
  963|       |	inline int isdigit(codepoint_t c)
  964|       |	{
  965|       |		return ucd_isdigit(c);
  966|       |	}
  967|       |
  968|       |	/** @brief Is the codepoint in the 'graph' class?
  969|       |	  *
  970|       |	  * @param c The Unicode codepoint to check.
  971|       |	  * @return  Non-zero if the codepoint is in the 'graph' class, zero otherwise.
  972|       |	  */
  973|       |	inline int isgraph(codepoint_t c)
  974|       |	{
  975|       |		return ucd_isgraph(c);
  976|       |	}
  977|       |
  978|       |	/** @brief Is the codepoint in the 'lower' class?
  979|       |	  *
  980|       |	  * @param c The Unicode codepoint to check.
  981|       |	  * @return  Non-zero if the codepoint is in the 'lower' class, zero otherwise.
  982|       |	  */
  983|       |	inline int islower(codepoint_t c)
  984|       |	{
  985|       |		return ucd_islower(c);
  986|       |	}
  987|       |
  988|       |	/** @brief Is the codepoint in the 'print' class?
  989|       |	  *
  990|       |	  * @param c The Unicode codepoint to check.
  991|       |	  * @return  Non-zero if the codepoint is in the 'print' class, zero otherwise.
  992|       |	  */
  993|       |	inline int isprint(codepoint_t c)
  994|       |	{
  995|       |		return ucd_isprint(c);
  996|       |	}
  997|       |
  998|       |	/** @brief Is the codepoint in the 'punct' class?
  999|       |	  *
 1000|       |	  * @param c The Unicode codepoint to check.
 1001|       |	  * @return  Non-zero if the codepoint is in the 'punct' class, zero otherwise.
 1002|       |	  */
 1003|       |	inline int ispunct(codepoint_t c)
 1004|       |	{
 1005|       |		return ucd_ispunct(c);
 1006|       |	}
 1007|       |
 1008|       |	/** @brief Is the codepoint in the 'space' class?
 1009|       |	  *
 1010|       |	  * @param c The Unicode codepoint to check.
 1011|       |	  * @return  Non-zero if the codepoint is in the 'space' class, zero otherwise.
 1012|       |	  */
 1013|       |	inline int isspace(codepoint_t c)
 1014|       |	{
 1015|       |		return ucd_isspace(c);
 1016|       |	}
 1017|       |
 1018|       |	/** @brief Is the codepoint in the 'upper' class?
 1019|       |	  *
 1020|       |	  * @param c The Unicode codepoint to check.
 1021|       |	  * @return  Non-zero if the codepoint is in the 'upper' class, zero otherwise.
 1022|       |	  */
 1023|       |	inline int isupper(codepoint_t c)
 1024|       |	{
 1025|       |		return ucd_isupper(c);
 1026|       |	}
 1027|       |
 1028|       |	/** @brief Is the codepoint in the 'xdigit' class?
 1029|       |	  *
 1030|       |	  * @param c The Unicode codepoint to check.
 1031|       |	  * @return  Non-zero if the codepoint is in the 'xdigit' class, zero otherwise.
 1032|       |	  */
 1033|       |	inline int isxdigit(codepoint_t c)
 1034|       |	{
 1035|       |		return ucd_isxdigit(c);
 1036|       |	}
 1037|       |
 1038|       |	/** @brief Convert the Unicode codepoint to upper-case.
 1039|       |	  *
 1040|       |	  * This function only uses the simple case mapping present in the
 1041|       |	  * UnicodeData file. The data in SpecialCasing requires Unicode
 1042|       |	  * codepoints to be mapped to multiple codepoints.
 1043|       |	  *
 1044|       |	  * @param c The Unicode codepoint to convert.
 1045|       |	  * @return  The upper-case Unicode codepoint for this codepoint, or
 1046|       |	  *          this codepoint if there is no upper-case codepoint.
 1047|       |	  */
 1048|       |	inline codepoint_t toupper(codepoint_t c)
 1049|       |	{
 1050|       |		return ucd_toupper(c);
 1051|       |	}
 1052|       |
 1053|       |	/** @brief Convert the Unicode codepoint to lower-case.
 1054|       |	  *
 1055|       |	  * This function only uses the simple case mapping present in the
 1056|       |	  * UnicodeData file. The data in SpecialCasing requires Unicode
 1057|       |	  * codepoints to be mapped to multiple codepoints.
 1058|       |	  *
 1059|       |	  * @param c The Unicode codepoint to convert.
 1060|       |	  * @return  The lower-case Unicode codepoint for this codepoint, or
 1061|       |	  *          this codepoint if there is no upper-case codepoint.
 1062|       |	  */
 1063|       |	inline codepoint_t tolower(codepoint_t c)
 1064|       |	{
 1065|       |		return ucd_tolower(c);
 1066|       |	}
 1067|       |
 1068|       |	/** @brief Convert the Unicode codepoint to title-case.
 1069|       |	  *
 1070|       |	  * This function only uses the simple case mapping present in the
 1071|       |	  * UnicodeData file. The data in SpecialCasing requires Unicode
 1072|       |	  * codepoints to be mapped to multiple codepoints.
 1073|       |	  *
 1074|       |	  * @param c The Unicode codepoint to convert.
 1075|       |	  * @return  The title-case Unicode codepoint for this codepoint, or
 1076|       |	  *          this codepoint if there is no upper-case codepoint.
 1077|       |	  */
 1078|       |	inline codepoint_t totitle(codepoint_t c)
 1079|       |	{
 1080|       |		return ucd_totitle(c);
 1081|       |	}
 1082|       |}
 1083|       |#endif
 1084|       |
 1085|       |#endif

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/src/ucd-tools/src/proplist.c:
    1|       |/* PropList APIs.
    2|       | *
    3|       | * Copyright (C) 2017-2018 Reece H. Dunn
    4|       | *
    5|       | * This file is part of ucd-tools.
    6|       | *
    7|       | * ucd-tools is free software: you can redistribute it and/or modify
    8|       | * it under the terms of the GNU General Public License as published by
    9|       | * the Free Software Foundation, either version 3 of the License, or
   10|       | * (at your option) any later version.
   11|       | *
   12|       | * ucd-tools is distributed in the hope that it will be useful,
   13|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   14|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   15|       | * GNU General Public License for more details.
   16|       | *
   17|       | * You should have received a copy of the GNU General Public License
   18|       | * along with ucd-tools.  If not, see <http://www.gnu.org/licenses/>.
   19|       | */
   20|       |
   21|       |#include "ucd/ucd.h"
   22|       |
   23|       |static ucd_property properties_Cc(codepoint_t c)
   24|      0|{
   25|      0|	if (c >= 0x0009 && c <= 0x000D) return UCD_PROPERTY_WHITE_SPACE | UCD_PROPERTY_PATTERN_WHITE_SPACE;
   26|      0|	if (c == 0x0085)                return UCD_PROPERTY_WHITE_SPACE | UCD_PROPERTY_PATTERN_WHITE_SPACE;
   27|      0|	return 0;
   28|      0|}
   29|       |
   30|       |static ucd_property properties_Cf(codepoint_t c)
   31|      0|{
   32|      0|	switch (c & 0xFFFFFF00)
   33|      0|	{
   34|      0|	case 0x0000:
   35|      0|		if (c == 0x00AD)                return UCD_PROPERTY_HYPHEN;
   36|      0|		break;
   37|      0|	case 0x0600:
   38|      0|		if (c >= 0x0600 && c <= 0x0605) return UCD_PROPERTY_PREPENDED_CONCATENATION_MARK;
   39|      0|		if (c == 0x061C)                return UCD_PROPERTY_BIDI_CONTROL;
   40|      0|		if (c == 0x06DD)                return UCD_PROPERTY_PREPENDED_CONCATENATION_MARK;
   41|      0|		break;
   42|      0|	case 0x0700:
   43|      0|		if (c == 0x070F)                return UCD_PROPERTY_PREPENDED_CONCATENATION_MARK;
   44|      0|		break;
   45|      0|	case 0x0800:
   46|      0|		if (c == 0x08E2)                return UCD_PROPERTY_PREPENDED_CONCATENATION_MARK;
   47|      0|		break;
   48|      0|	case 0x2000:
   49|      0|		if (c == 0x200C)                return UCD_PROPERTY_JOIN_CONTROL | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
   50|      0|		if (c == 0x200D)                return UCD_PROPERTY_JOIN_CONTROL | UCD_PROPERTY_EMOJI_COMPONENT;
   51|      0|		if (c >= 0x200E && c <= 0x200F) return UCD_PROPERTY_BIDI_CONTROL | UCD_PROPERTY_PATTERN_WHITE_SPACE;
   52|      0|		if (c >= 0x202A && c <= 0x202E) return UCD_PROPERTY_BIDI_CONTROL;
   53|      0|		if (c >= 0x2061 && c <= 0x2064) return UCD_PROPERTY_OTHER_MATH;
   54|      0|		if (c >= 0x2066 && c <= 0x2069) return UCD_PROPERTY_BIDI_CONTROL;
   55|      0|		if (c >= 0x206A && c <= 0x206F) return UCD_PROPERTY_DEPRECATED;
   56|      0|		break;
   57|      0|	case 0x011000:
   58|      0|		if (c == 0x0110BD)                  return UCD_PROPERTY_PREPENDED_CONCATENATION_MARK;
   59|      0|		if (c == 0x0110CD)                  return UCD_PROPERTY_PREPENDED_CONCATENATION_MARK;
   60|      0|		break;
   61|      0|	case 0x0E0000:
   62|      0|		if (c == 0x0E0001)                  return UCD_PROPERTY_DEPRECATED;
   63|      0|		if (c == 0x0E0021)                  return UCD_PROPERTY_OTHER_GRAPHEME_EXTEND | UCD_PROPERTY_EMOJI_COMPONENT | ESPEAKNG_PROPERTY_EXCLAMATION_MARK;
   64|      0|		if (c == 0x0E002C)                  return UCD_PROPERTY_OTHER_GRAPHEME_EXTEND | UCD_PROPERTY_EMOJI_COMPONENT | ESPEAKNG_PROPERTY_COMMA;
   65|      0|		if (c == 0x0E002E)                  return UCD_PROPERTY_OTHER_GRAPHEME_EXTEND | UCD_PROPERTY_EMOJI_COMPONENT | ESPEAKNG_PROPERTY_FULL_STOP;
   66|      0|		if (c == 0x0E003A)                  return UCD_PROPERTY_OTHER_GRAPHEME_EXTEND | UCD_PROPERTY_EMOJI_COMPONENT | ESPEAKNG_PROPERTY_COLON;
   67|      0|		if (c == 0x0E003B)                  return UCD_PROPERTY_OTHER_GRAPHEME_EXTEND | UCD_PROPERTY_EMOJI_COMPONENT | ESPEAKNG_PROPERTY_SEMI_COLON;
   68|      0|		if (c == 0x0E003F)                  return UCD_PROPERTY_OTHER_GRAPHEME_EXTEND | UCD_PROPERTY_EMOJI_COMPONENT | ESPEAKNG_PROPERTY_QUESTION_MARK;
   69|      0|		if (c >= 0x0E0020 && c <= 0x0E007F) return UCD_PROPERTY_OTHER_GRAPHEME_EXTEND | UCD_PROPERTY_EMOJI_COMPONENT;
   70|      0|		break;
   71|      0|	}
   72|      0|	return 0;
   73|      0|}
   74|       |
   75|       |static ucd_property properties_Cn(codepoint_t c)
   76|      0|{
   77|      0|	switch (c & 0xFFFFFF00)
   78|      0|	{
   79|      0|	case 0x2000:
   80|      0|		if (c == 0x2065)                return UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;
   81|      0|		break;
   82|      0|	case 0x2400:
   83|      0|		if (c >= 0x2427 && c <= 0x243F) return UCD_PROPERTY_PATTERN_SYNTAX;
   84|      0|		if (c >= 0x244B && c <= 0x245F) return UCD_PROPERTY_PATTERN_SYNTAX;
   85|      0|		break;
   86|      0|	case 0x2B00:
   87|      0|		if (c >= 0x2B74 && c <= 0x2B75) return UCD_PROPERTY_PATTERN_SYNTAX;
   88|      0|		if (c >= 0x2B96 && c <= 0x2B97) return UCD_PROPERTY_PATTERN_SYNTAX;
   89|      0|		if (c >= 0x2BBA && c <= 0x2BBC) return UCD_PROPERTY_PATTERN_SYNTAX;
   90|      0|		if (c == 0x2BC9)                return UCD_PROPERTY_PATTERN_SYNTAX;
   91|      0|		if (c >= 0x2BD3 && c <= 0x2BEB) return UCD_PROPERTY_PATTERN_SYNTAX;
   92|      0|		if (c >= 0x2BF0 && c <= 0x2BFF) return UCD_PROPERTY_PATTERN_SYNTAX;
   93|      0|		break;
   94|      0|	case 0x2E00:
   95|      0|		if (c >= 0x2E45 && c <= 0x2E7F) return UCD_PROPERTY_PATTERN_SYNTAX;
   96|      0|		break;
   97|      0|	case 0xFD00:
   98|      0|		if (c >= 0xFDD0 && c <= 0xFDEF) return UCD_PROPERTY_NONCHARACTER_CODE_POINT;
   99|      0|		break;
  100|      0|	case 0xFF00:
  101|      0|		if (c >= 0xFFF0 && c <= 0xFFF8) return UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;
  102|      0|		break;
  103|      0|	case 0x1F000:
  104|      0|	case 0x1F100:
  105|      0|	case 0x1F200:
  106|      0|	case 0x1F300:
  107|      0|	case 0x1F400:
  108|      0|	case 0x1F500:
  109|      0|	case 0x1F600:
  110|      0|	case 0x1F700:
  111|      0|	case 0x1F800:
  112|      0|	case 0x1F900:
  113|      0|	case 0x1FA00:
  114|      0|	case 0x1FB00:
  115|      0|	case 0x1FC00:
  116|      0|	case 0x1FD00:
  117|      0|	case 0x1FE00:
  118|      0|	case 0x1FF00:
  119|      0|		if (c >= 0x1FFFE)               return UCD_PROPERTY_NONCHARACTER_CODE_POINT;
  120|      0|		return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
  121|      0|	case 0x0E0000:
  122|      0|		if (c == 0xE0000)                 return UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;
  123|      0|		if (c >= 0xE0002 && c <= 0xE001F) return UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;
  124|      0|		if (c >= 0xE0080 && c <= 0xE00FF) return UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;
  125|      0|		break;
  126|      0|	case 0x0E0100:
  127|      0|		if (c >= 0xE01F0)                 return UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;
  128|      0|		break;
  129|      0|	case 0x0E0200:
  130|      0|	case 0x0E0300:
  131|      0|	case 0x0E0400:
  132|      0|	case 0x0E0500:
  133|      0|	case 0x0E0600:
  134|      0|	case 0x0E0700:
  135|      0|	case 0x0E0800:
  136|      0|	case 0x0E0900:
  137|      0|	case 0x0E0A00:
  138|      0|	case 0x0E0B00:
  139|      0|	case 0x0E0C00:
  140|      0|	case 0x0E0D00:
  141|      0|	case 0x0E0E00:
  142|      0|	case 0x0E0F00:
  143|      0|		return UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;
  144|      0|	}
  145|      0|	if ((c & 0x0000FFFF) >= 0xFFFE) return UCD_PROPERTY_NONCHARACTER_CODE_POINT;
  146|      0|	return 0;
  147|      0|}
  148|       |
  149|       |static ucd_property properties_Ll(codepoint_t c)
  150|      0|{
  151|      0|	switch (c & 0xFFFFFF00)
  152|      0|	{
  153|      0|	case 0x0000:
  154|      0|		if (c >= 0x0061 && c <= 0x0066) return UCD_PROPERTY_HEX_DIGIT | UCD_PROPERTY_ASCII_HEX_DIGIT;
  155|      0|		if (c >= 0x0069 && c <= 0x006A) return UCD_PROPERTY_SOFT_DOTTED;
  156|      0|		break;
  157|      0|	case 0x0100:
  158|      0|		if (c == 0x012F)                return UCD_PROPERTY_SOFT_DOTTED;
  159|      0|		if (c == 0x0149)                return UCD_PROPERTY_DEPRECATED;
  160|      0|		break;
  161|      0|	case 0x0200:
  162|      0|		if (c == 0x0249)                return UCD_PROPERTY_SOFT_DOTTED;
  163|      0|		if (c == 0x0268)                return UCD_PROPERTY_SOFT_DOTTED;
  164|      0|		if (c == 0x029D)                return UCD_PROPERTY_SOFT_DOTTED;
  165|      0|		break;
  166|      0|	case 0x0300:
  167|      0|		if (c >= 0x03D0 && c <= 0x03D2) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  168|      0|		if (c == 0x03D5)                return UCD_PROPERTY_OTHER_MATH;
  169|      0|		if (c >= 0x03F0 && c <= 0x03F1) return UCD_PROPERTY_OTHER_MATH;
  170|      0|		if (c == 0x03F3)                return UCD_PROPERTY_SOFT_DOTTED;
  171|      0|		if (c >= 0x03F4 && c <= 0x03F5) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  172|      0|		break;
  173|      0|	case 0x0400:
  174|      0|		if (c == 0x0456)                return UCD_PROPERTY_SOFT_DOTTED;
  175|      0|		if (c == 0x0458)                return UCD_PROPERTY_SOFT_DOTTED;
  176|      0|		break;
  177|      0|	case 0x1D00:
  178|      0|		if (c == 0x1D96)                return UCD_PROPERTY_SOFT_DOTTED;
  179|      0|		break;
  180|      0|	case 0x1E00:
  181|      0|		if (c == 0x1E2D)                return UCD_PROPERTY_SOFT_DOTTED;
  182|      0|		if (c == 0x1ECB)                return UCD_PROPERTY_SOFT_DOTTED;
  183|      0|		break;
  184|      0|	case 0x2100:
  185|      0|		if (c >= 0x210A && c <= 0x2113) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  186|      0|		if (c >= 0x212F && c <= 0x2131) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  187|      0|		if (c >= 0x2133 && c <= 0x2134) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  188|      0|		if (c == 0x2139)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
  189|      0|		if (c >= 0x213C && c <= 0x213F) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  190|      0|		if (c >= 0x2145 && c <= 0x2147) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  191|      0|		if (c >= 0x2148 && c <= 0x2149) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  192|      0|		break;
  193|      0|	case 0xFF00:
  194|      0|		if (c >= 0xFF41 && c <= 0xFF46) return UCD_PROPERTY_HEX_DIGIT;
  195|      0|		break;
  196|      0|	case 0x01D400:
  197|      0|		if (c >= 0x01D422 && c <= 0x01D423) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  198|      0|		if (c >= 0x01D400 && c <= 0x01D454) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  199|      0|		if (c >= 0x01D456 && c <= 0x01D457) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  200|      0|		if (c >= 0x01D48A && c <= 0x01D48B) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  201|      0|		if (c >= 0x01D458 && c <= 0x01D49C) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  202|      0|		if (c >= 0x01D4AE && c <= 0x01D4B9) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  203|      0|		if (c == 0x01D4BB)                  return UCD_PROPERTY_OTHER_MATH;
  204|      0|		if (c >= 0x01D4BE && c <= 0x01D4BF) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  205|      0|		if (c >= 0x01D4BD && c <= 0x01D4C3) return UCD_PROPERTY_OTHER_MATH;
  206|      0|		if (c >= 0x01D4F2 && c <= 0x01D4F3) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  207|      0|		if (c >= 0x01D4C5)                  return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  208|      0|		break;
  209|      0|	case 0x01D500:
  210|      0|		if                  (c <= 0x01D505) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  211|      0|		if (c >= 0x01D526 && c <= 0x01D527) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  212|      0|		if (c >= 0x01D51E && c <= 0x01D539) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  213|      0|		if (c >= 0x01D55A && c <= 0x01D55B) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  214|      0|		if (c >= 0x01D58E && c <= 0x01D58F) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  215|      0|		if (c >= 0x01D5C2 && c <= 0x01D5C3) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  216|      0|		if (c >= 0x01D5F6 && c <= 0x01D5F7) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  217|      0|		if (c >= 0x01D552)                  return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  218|      0|		break;
  219|      0|	case 0x01D600:
  220|      0|		if (c >= 0x01D62A && c <= 0x01D62B) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  221|      0|		if (c >= 0x01D65E && c <= 0x01D65F) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  222|      0|		if (c >= 0x01D692 && c <= 0x01D693) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_SOFT_DOTTED;
  223|      0|		if                  (c <= 0x01D6A5) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  224|      0|		if (c >= 0x01D6C2 && c <= 0x01D6DA) return UCD_PROPERTY_OTHER_MATH;
  225|      0|		if (c >= 0x01D6DC && c <= 0x01D6FA) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  226|      0|		if (c >= 0x01D6FC)                  return UCD_PROPERTY_OTHER_MATH;
  227|      0|		break;
  228|      0|	case 0x01D700:
  229|      0|		if                  (c <= 0x01D714) return UCD_PROPERTY_OTHER_MATH;
  230|      0|		if (c >= 0x01D716 && c <= 0x01D734) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  231|      0|		if (c >= 0x01D736 && c <= 0x01D74E) return UCD_PROPERTY_OTHER_MATH;
  232|      0|		if (c >= 0x01D750 && c <= 0x01D76E) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  233|      0|		if (c >= 0x01D770 && c <= 0x01D788) return UCD_PROPERTY_OTHER_MATH;
  234|      0|		if (c >= 0x01D78A && c <= 0x01D7A8) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  235|      0|		if (c >= 0x01D7AA && c <= 0x01D7C2) return UCD_PROPERTY_OTHER_MATH;
  236|      0|		if (c >= 0x01D7C4 && c <= 0x01D7CB) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  237|      0|		break;
  238|      0|	}
  239|      0|	return 0;
  240|      0|}
  241|       |
  242|       |static ucd_property properties_Lm(codepoint_t c)
  243|      0|{
  244|      0|	switch (c & 0xFFFFFF00)
  245|      0|	{
  246|      0|	case 0x0200:
  247|      0|		if (c == 0x02B2)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_LOWERCASE | UCD_PROPERTY_SOFT_DOTTED;
  248|      0|		if (c >= 0x02B0 && c <= 0x02B8) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_LOWERCASE;
  249|      0|		if (c >= 0x02B9 && c <= 0x02BF) return UCD_PROPERTY_DIACRITIC;
  250|      0|		if (c >= 0x02C0 && c <= 0x02C1) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_LOWERCASE;
  251|      0|		if (c >= 0x02C6 && c <= 0x02CF) return UCD_PROPERTY_DIACRITIC;
  252|      0|		if (c >= 0x02D0 && c <= 0x02D1) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_EXTENDER;
  253|      0|		if (c >= 0x02E0 && c <= 0x02E4) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_LOWERCASE;
  254|      0|		if (c == 0x02EC)                return UCD_PROPERTY_DIACRITIC;
  255|      0|		if (c == 0x02EE)                return UCD_PROPERTY_DIACRITIC;
  256|      0|		break;
  257|      0|	case 0x0300:
  258|      0|		if (c == 0x0374)                return UCD_PROPERTY_DIACRITIC;
  259|      0|		if (c == 0x037A)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_LOWERCASE;
  260|      0|		break;
  261|      0|	case 0x0500:
  262|      0|		if (c == 0x0559)                return UCD_PROPERTY_DIACRITIC;
  263|      0|		break;
  264|      0|	case 0x0600:
  265|      0|		if (c == 0x0640)                return UCD_PROPERTY_EXTENDER;
  266|      0|		if (c >= 0x06E5 && c <= 0x06E6) return UCD_PROPERTY_DIACRITIC;
  267|      0|		break;
  268|      0|	case 0x0700:
  269|      0|		if (c >= 0x07F4 && c <= 0x07F5) return UCD_PROPERTY_DIACRITIC;
  270|      0|		if (c == 0x07FA)                return UCD_PROPERTY_EXTENDER;
  271|      0|		break;
  272|      0|	case 0x0900:
  273|      0|		if (c == 0x0971)                return UCD_PROPERTY_DIACRITIC;
  274|      0|		break;
  275|      0|	case 0x0E00:
  276|      0|		if (c == 0x0E46)                return UCD_PROPERTY_EXTENDER;
  277|      0|		if (c == 0x0EC6)                return UCD_PROPERTY_EXTENDER;
  278|      0|		break;
  279|      0|	case 0x1800:
  280|      0|		if (c == 0x1843)                return UCD_PROPERTY_EXTENDER;
  281|      0|		break;
  282|      0|	case 0x1A00:
  283|      0|		if (c == 0x1AA7)                return UCD_PROPERTY_EXTENDER;
  284|      0|		break;
  285|      0|	case 0x1C00:
  286|      0|		if (c == 0x1C7B)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_EXTENDER;
  287|      0|		if (c >= 0x1C78 && c <= 0x1C7D) return UCD_PROPERTY_DIACRITIC;
  288|      0|		break;
  289|      0|	case 0x1D00:
  290|      0|		if (c == 0x1D62)                return UCD_PROPERTY_OTHER_LOWERCASE | UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_SOFT_DOTTED;
  291|      0|		if (c >= 0x1D2C && c <= 0x1D6A) return UCD_PROPERTY_OTHER_LOWERCASE | UCD_PROPERTY_DIACRITIC;
  292|      0|		if (c == 0x1D78)                return UCD_PROPERTY_OTHER_LOWERCASE;
  293|      0|		if (c == 0x1DA4)                return UCD_PROPERTY_OTHER_LOWERCASE | UCD_PROPERTY_SOFT_DOTTED;
  294|      0|		if (c == 0x1DA8)                return UCD_PROPERTY_OTHER_LOWERCASE | UCD_PROPERTY_SOFT_DOTTED;
  295|      0|		if (c >= 0x1D9B && c <= 0x1DBF) return UCD_PROPERTY_OTHER_LOWERCASE;
  296|      0|		break;
  297|      0|	case 0x2000:
  298|      0|		if (c == 0x2071)                return UCD_PROPERTY_OTHER_LOWERCASE | UCD_PROPERTY_SOFT_DOTTED;
  299|      0|		if (c == 0x207F)                return UCD_PROPERTY_OTHER_LOWERCASE;
  300|      0|		if (c >= 0x2090 && c <= 0x209C) return UCD_PROPERTY_OTHER_LOWERCASE;
  301|      0|		break;
  302|      0|	case 0x2C00:
  303|      0|		if (c == 0x2C7C)                return UCD_PROPERTY_OTHER_LOWERCASE | UCD_PROPERTY_SOFT_DOTTED;
  304|      0|		if (c == 0x2C7D)                return UCD_PROPERTY_OTHER_LOWERCASE;
  305|      0|		break;
  306|      0|	case 0x2E00:
  307|      0|		if (c == 0x2E2F)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_PATTERN_SYNTAX;
  308|      0|		break;
  309|      0|	case 0x3000:
  310|      0|		if (c == 0x3005)                return UCD_PROPERTY_EXTENDER;
  311|      0|		if (c >= 0x3031 && c <= 0x3035) return UCD_PROPERTY_EXTENDER;
  312|      0|		if (c >= 0x309D && c <= 0x309E) return UCD_PROPERTY_EXTENDER;
  313|      0|		if (c == 0x30FC)                return UCD_PROPERTY_EXTENDER | UCD_PROPERTY_DIACRITIC;
  314|      0|		if (c >= 0x30FD && c <= 0x30FE) return UCD_PROPERTY_EXTENDER;
  315|      0|		break;
  316|      0|	case 0xA000:
  317|      0|		if (c == 0xA015)                return UCD_PROPERTY_EXTENDER;
  318|      0|		break;
  319|      0|	case 0xA600:
  320|      0|		if (c == 0xA60C)                return UCD_PROPERTY_EXTENDER;
  321|      0|		if (c == 0xA67F)                return UCD_PROPERTY_DIACRITIC;
  322|      0|		if (c >= 0xA69C && c <= 0xA69D) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_LOWERCASE;
  323|      0|		break;
  324|      0|	case 0xA700:
  325|      0|		if (c >= 0xA717 && c <= 0xA71F) return UCD_PROPERTY_DIACRITIC;
  326|      0|		if (c == 0xA770)                return UCD_PROPERTY_OTHER_LOWERCASE;
  327|      0|		if (c == 0xA788)                return UCD_PROPERTY_DIACRITIC;
  328|      0|		if (c >= 0xA7F8 && c <= 0xA7F9) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_LOWERCASE;
  329|      0|		break;
  330|      0|	case 0xA900:
  331|      0|		if (c == 0xA9CF)                return UCD_PROPERTY_EXTENDER;
  332|      0|		if (c == 0xA9E6)                return UCD_PROPERTY_EXTENDER;
  333|      0|		break;
  334|      0|	case 0xAA00:
  335|      0|		if (c == 0xAA70)                return UCD_PROPERTY_EXTENDER;
  336|      0|		if (c == 0xAADD)                return UCD_PROPERTY_EXTENDER;
  337|      0|		if (c >= 0xAAF3 && c <= 0xAAF4) return UCD_PROPERTY_EXTENDER;
  338|      0|		break;
  339|      0|	case 0xAB00:
  340|      0|		if (c >= 0xAB5C && c <= 0xAB5F) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_LOWERCASE;
  341|      0|		break;
  342|      0|	case 0xFF00:
  343|      0|		if (c == 0xFF70)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_EXTENDER;
  344|      0|		if (c >= 0xFF9E && c <= 0xFF9F) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  345|      0|		break;
  346|      0|	case 0x016B00:
  347|      0|		if (c >= 0x016B42 && c <= 0x016B43) return UCD_PROPERTY_EXTENDER;
  348|      0|		break;
  349|      0|	case 0x016F00:
  350|      0|		if (c >= 0x016F93 && c <= 0x016F9F) return UCD_PROPERTY_DIACRITIC;
  351|      0|		if (c >= 0x016FE0 && c <= 0x016FE1) return UCD_PROPERTY_EXTENDER;
  352|      0|		break;
  353|      0|	}
  354|      0|	return 0;
  355|      0|}
  356|       |
  357|       |static ucd_property properties_Lo(codepoint_t c)
  358|      0|{
  359|      0|	switch (c & 0xFFFFFF00)
  360|      0|	{
  361|      0|	case 0x0000:
  362|      0|		if (c == 0x00AA)                return UCD_PROPERTY_OTHER_LOWERCASE;
  363|      0|		if (c == 0x00BA)                return UCD_PROPERTY_OTHER_LOWERCASE;
  364|      0|		break;
  365|      0|	case 0x0600:
  366|      0|		if (c == 0x0673)                return UCD_PROPERTY_DEPRECATED;
  367|      0|		break;
  368|      0|	case 0x0E00:
  369|      0|		if (c >= 0x0E40 && c <= 0x0E44) return UCD_PROPERTY_LOGICAL_ORDER_EXCEPTION;
  370|      0|		if (c == 0x0EAF)                return ESPEAKNG_PROPERTY_ELLIPSIS;
  371|      0|		if (c >= 0x0EC0 && c <= 0x0EC4) return UCD_PROPERTY_LOGICAL_ORDER_EXCEPTION;
  372|      0|		break;
  373|      0|	case 0x1100:
  374|      0|		if (c >= 0x115F && c <= 0x1160) return UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;
  375|      0|		break;
  376|      0|	case 0x1700:
  377|      0|		if (c >= 0x17A3 && c <= 0x17A4) return UCD_PROPERTY_DEPRECATED;
  378|      0|		break;
  379|      0|	case 0x1900:
  380|      0|		if (c >= 0x19B5 && c <= 0x19B7) return UCD_PROPERTY_LOGICAL_ORDER_EXCEPTION;
  381|      0|		if (c == 0x19BA)                return UCD_PROPERTY_LOGICAL_ORDER_EXCEPTION;
  382|      0|		break;
  383|      0|	case 0x2100:
  384|      0|		if (c >= 0x2135 && c <= 0x2138) return UCD_PROPERTY_OTHER_MATH;
  385|      0|		break;
  386|      0|	case 0x3000:
  387|      0|		if (c == 0x3006)                return UCD_PROPERTY_IDEOGRAPHIC;
  388|      0|		break;
  389|      0|	case 0x3100:
  390|      0|		if (c == 0x3164)                return UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;
  391|      0|		break;
  392|      0|	case 0xAA00:
  393|      0|		if (c >= 0xAAB5 && c <= 0xAAB6) return UCD_PROPERTY_LOGICAL_ORDER_EXCEPTION;
  394|      0|		if (c == 0xAAB9)                return UCD_PROPERTY_LOGICAL_ORDER_EXCEPTION;
  395|      0|		if (c >= 0xAABB && c <= 0xAABC) return UCD_PROPERTY_LOGICAL_ORDER_EXCEPTION;
  396|      0|		if (c == 0xAAC0)                return UCD_PROPERTY_DIACRITIC;
  397|      0|		if (c == 0xAAC2)                return UCD_PROPERTY_DIACRITIC;
  398|      0|		break;
  399|      0|	case 0xFA00:
  400|      0|		if (c >= 0xFA0E && c <= 0xFA0F) return UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  401|      0|		if (c == 0xFA11)                return UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  402|      0|		if (c >= 0xFA13 && c <= 0xFA14) return UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  403|      0|		if (c == 0xFA1F)                return UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  404|      0|		if (c == 0xFA21)                return UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  405|      0|		if (c >= 0xFA23 && c <= 0xFA24) return UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  406|      0|		if (c >= 0xFA27 && c <= 0xFA29) return UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  407|      0|		break;
  408|      0|	case 0xFF00:
  409|      0|		if (c == 0xFFA0)                return UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;
  410|      0|		break;
  411|      0|	case 0x10D00:
  412|      0|		if (c == 0x10D22)               return UCD_PROPERTY_DIACRITIC;
  413|      0|		if (c == 0x10D23)               return UCD_PROPERTY_DIACRITIC;
  414|      0|		break;
  415|      0|	case 0x18700:
  416|      0|		if (c >= 0x187ED && c <= 0x187F1) return UCD_PROPERTY_IDEOGRAPHIC;
  417|      0|		break;
  418|      0|	case 0x11300:
  419|      0|		if (c == 0x1135D)               return UCD_PROPERTY_EXTENDER;
  420|      0|		break;
  421|      0|	case 0x1EE00:
  422|      0|		return UCD_PROPERTY_OTHER_MATH;
  423|      0|	}
  424|      0|	return 0;
  425|      0|}
  426|       |
  427|       |static ucd_property properties_Lo_ideographic(codepoint_t c)
  428|      0|{
  429|      0|	switch (c & 0xFFFF0000)
  430|      0|	{
  431|      0|	case 0x000000:
  432|      0|		if (c >= 0x3400 && c <= 0x4DB5) return UCD_PROPERTY_IDEOGRAPHIC | UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  433|      0|		if (c >= 0x4E00 && c <= 0x9FEF) return UCD_PROPERTY_IDEOGRAPHIC | UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  434|      0|		if (c >= 0xF900 && c <= 0xFA6D) return UCD_PROPERTY_IDEOGRAPHIC;
  435|      0|		if (c >= 0xFA70 && c <= 0xFAD9) return UCD_PROPERTY_IDEOGRAPHIC;
  436|      0|		break;
  437|      0|	case 0x010000:
  438|      0|		if (c >= 0x017000 && c <= 0x0187EC) return UCD_PROPERTY_IDEOGRAPHIC;
  439|      0|		if (c >= 0x018800 && c <= 0x018AF2) return UCD_PROPERTY_IDEOGRAPHIC;
  440|      0|		if (c >= 0x01B170 && c <= 0x01B2FB) return UCD_PROPERTY_IDEOGRAPHIC;
  441|      0|		break;
  442|      0|	case 0x020000:
  443|      0|		if (c >= 0x020000 && c <= 0x02A6D6) return UCD_PROPERTY_IDEOGRAPHIC | UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  444|      0|		if (c >= 0x02A700 && c <= 0x02B734) return UCD_PROPERTY_IDEOGRAPHIC | UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  445|      0|		if (c >= 0x02B740 && c <= 0x02B81D) return UCD_PROPERTY_IDEOGRAPHIC | UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  446|      0|		if (c >= 0x02B820 && c <= 0x02CEA1) return UCD_PROPERTY_IDEOGRAPHIC | UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  447|      0|		if (c >= 0x02CEB0 && c <= 0x02EBE0) return UCD_PROPERTY_IDEOGRAPHIC | UCD_PROPERTY_UNIFIED_IDEOGRAPH;
  448|      0|		if (c >= 0x02F800 && c <= 0x02FA1D) return UCD_PROPERTY_IDEOGRAPHIC;
  449|      0|		break;
  450|      0|	}
  451|      0|	return 0;
  452|      0|}
  453|       |
  454|       |static ucd_property properties_Lu(codepoint_t c)
  455|      0|{
  456|      0|	switch (c & 0xFFFFFF00)
  457|      0|	{
  458|      0|	case 0x0000:
  459|      0|		if (c >= 0x0041 && c <= 0x0046) return UCD_PROPERTY_HEX_DIGIT | UCD_PROPERTY_ASCII_HEX_DIGIT;
  460|      0|		break;
  461|      0|	case 0x0300:
  462|      0|		if (c >= 0x03D0 && c <= 0x03D2) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  463|      0|		if (c >= 0x03F4 && c <= 0x03F5) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  464|      0|		break;
  465|      0|	case 0xFF00:
  466|      0|		if (c >= 0xFF21 && c <= 0xFF26) return UCD_PROPERTY_HEX_DIGIT;
  467|      0|		break;
  468|      0|	case 0x2100:
  469|      0|		if (c == 0x2102)                return UCD_PROPERTY_OTHER_MATH;
  470|      0|		if (c == 0x2107)                return UCD_PROPERTY_OTHER_MATH;
  471|      0|		if (c >= 0x210A && c <= 0x2113) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  472|      0|		if (c == 0x2115)                return UCD_PROPERTY_OTHER_MATH;
  473|      0|		if (c >= 0x2119 && c <= 0x211D) return UCD_PROPERTY_OTHER_MATH;
  474|      0|		if (c == 0x2124)                return UCD_PROPERTY_OTHER_MATH;
  475|      0|		if (c == 0x2128)                return UCD_PROPERTY_OTHER_MATH;
  476|      0|		if (c >= 0x212C && c <= 0x212D) return UCD_PROPERTY_OTHER_MATH;
  477|      0|		if (c >= 0x212F && c <= 0x2131) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  478|      0|		if (c >= 0x2133 && c <= 0x2134) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  479|      0|		if (c >= 0x213C && c <= 0x213F) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  480|      0|		if (c >= 0x2145 && c <= 0x2149) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  481|      0|		break;
  482|      0|	case 0x01D400:
  483|      0|		if (c >= 0x01D400 && c <= 0x01D454) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  484|      0|		if (c >= 0x01D456 && c <= 0x01D49C) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  485|      0|		if (c >= 0x01D49E && c <= 0x01D49F) return UCD_PROPERTY_OTHER_MATH;
  486|      0|		if (c == 0x01D4A2)                  return UCD_PROPERTY_OTHER_MATH;
  487|      0|		if (c >= 0x01D4A5 && c <= 0x01D4A6) return UCD_PROPERTY_OTHER_MATH;
  488|      0|		if (c >= 0x01D4A9 && c <= 0x01D4AC) return UCD_PROPERTY_OTHER_MATH;
  489|      0|		if (c >= 0x01D4AE && c <= 0x01D4B9) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  490|      0|		if (c >= 0x01D4C5)                  return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  491|      0|		break;
  492|      0|	case 0x01D500:
  493|      0|		if                  (c <= 0x01D505) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  494|      0|		if (c >= 0x01D507 && c <= 0x01D50A) return UCD_PROPERTY_OTHER_MATH;
  495|      0|		if (c >= 0x01D50D && c <= 0x01D514) return UCD_PROPERTY_OTHER_MATH;
  496|      0|		if (c >= 0x01D516 && c <= 0x01D51C) return UCD_PROPERTY_OTHER_MATH;
  497|      0|		if (c >= 0x01D51E && c <= 0x01D539) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  498|      0|		if (c >= 0x01D53B && c <= 0x01D53E) return UCD_PROPERTY_OTHER_MATH;
  499|      0|		if (c >= 0x01D540 && c <= 0x01D544) return UCD_PROPERTY_OTHER_MATH;
  500|      0|		if (c == 0x01D546)                  return UCD_PROPERTY_OTHER_MATH;
  501|      0|		if (c >= 0x01D54A && c <= 0x01D550) return UCD_PROPERTY_OTHER_MATH;
  502|      0|		if (c >= 0x01D552)                  return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  503|      0|		break;
  504|      0|	case 0x01D600:
  505|      0|		if                  (c <= 0x01D6A5) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  506|      0|		if (c >= 0x01D6A8 && c <= 0x01D6C0) return UCD_PROPERTY_OTHER_MATH;
  507|      0|		if (c >= 0x01D6DC && c <= 0x01D6FA) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  508|      0|		break;
  509|      0|	case 0x01D700:
  510|      0|		if (c >= 0x01D716 && c <= 0x01D734) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  511|      0|		if (c >= 0x01D750 && c <= 0x01D76E) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  512|      0|		if (c >= 0x01D78A && c <= 0x01D7A8) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  513|      0|		if (c >= 0x01D7C4 && c <= 0x01D7CB) return UCD_PROPERTY_OTHER_MATH; /* Ll|Lu */
  514|      0|		break;
  515|      0|	}
  516|      0|	return 0;
  517|      0|}
  518|       |
  519|       |static ucd_property properties_Mc(codepoint_t c)
  520|      0|{
  521|      0|	switch (c & 0xFFFFFF00)
  522|      0|	{
  523|      0|	case 0x0900:
  524|      0|		if (c == 0x09BE)                return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  525|      0|		if (c == 0x09D7)                return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  526|      0|		break;
  527|      0|	case 0x0B00:
  528|      0|		if (c == 0x0B3E)                return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  529|      0|		if (c == 0x0B57)                return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  530|      0|		if (c == 0x0BBE)                return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  531|      0|		if (c == 0x0BD7)                return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  532|      0|		break;
  533|      0|	case 0x0C00:
  534|      0|		if (c == 0x0CC2)                return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  535|      0|		if (c >= 0x0CD5 && c <= 0x0CD6) return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  536|      0|		break;
  537|      0|	case 0x0D00:
  538|      0|		if (c == 0x0D3E)                return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  539|      0|		if (c == 0x0D57)                return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  540|      0|		if (c == 0x0DCF)                return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  541|      0|		if (c == 0x0DDF)                return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  542|      0|		break;
  543|      0|	case 0x0F00:
  544|      0|		if (c >= 0x0F3E && c <= 0x0F3F) return UCD_PROPERTY_DIACRITIC;
  545|      0|		break;
  546|      0|	case 0x1000:
  547|      0|		if (c >= 0x102B && c <= 0x102C) return UCD_PROPERTY_OTHER_ALPHABETIC;
  548|      0|		if (c == 0x1031)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  549|      0|		if (c == 0x1038)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  550|      0|		if (c >= 0x103B && c <= 0x103C) return UCD_PROPERTY_OTHER_ALPHABETIC;
  551|      0|		if (c >= 0x1056 && c <= 0x1057) return UCD_PROPERTY_OTHER_ALPHABETIC;
  552|      0|		if (c == 0x1062)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  553|      0|		if (c >= 0x1067 && c <= 0x1068) return UCD_PROPERTY_OTHER_ALPHABETIC;
  554|      0|		if (c >= 0x1083 && c <= 0x1084) return UCD_PROPERTY_OTHER_ALPHABETIC;
  555|      0|		if (c >= 0x1087 && c <= 0x108C) return UCD_PROPERTY_DIACRITIC;
  556|      0|		if (c == 0x108F)                return UCD_PROPERTY_DIACRITIC;
  557|      0|		if (c >= 0x109A && c <= 0x109B) return UCD_PROPERTY_DIACRITIC;
  558|      0|		if (c == 0x109C)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  559|      0|		return 0;
  560|      0|	case 0x1B00:
  561|      0|		if (c == 0x1B04)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  562|      0|		if (c == 0x1B35)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  563|      0|		if (c == 0x1B3B)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  564|      0|		if (c >= 0x1B3D && c <= 0x1B41) return UCD_PROPERTY_OTHER_ALPHABETIC;
  565|      0|		if (c == 0x1B43)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  566|      0|		if (c == 0x1B44)                return UCD_PROPERTY_DIACRITIC;
  567|      0|		if (c == 0x1B82)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  568|      0|		if (c == 0x1BA1)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  569|      0|		if (c >= 0x1BA6 && c <= 0x1BA7) return UCD_PROPERTY_OTHER_ALPHABETIC;
  570|      0|		if (c == 0x1BAA)                return UCD_PROPERTY_DIACRITIC;
  571|      0|		if (c == 0x1BE7)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  572|      0|		if (c >= 0x1BEA && c <= 0x1BEC) return UCD_PROPERTY_OTHER_ALPHABETIC;
  573|      0|		if (c == 0x1BEE)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  574|      0|		return 0;
  575|      0|	case 0x1C00:
  576|      0|		if (c == 0x1CE1)                return UCD_PROPERTY_DIACRITIC;
  577|      0|		if (c == 0x1CF7)                return UCD_PROPERTY_DIACRITIC;
  578|      0|		break;
  579|      0|	case 0x3000:
  580|      0|		if (c >= 0x302E && c <= 0x302F) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  581|      0|		break;
  582|      0|	case 0xA900:
  583|      0|		if (c == 0xA953)                return UCD_PROPERTY_DIACRITIC;
  584|      0|		if (c == 0xA9C0)                return UCD_PROPERTY_DIACRITIC;
  585|      0|		break;
  586|      0|	case 0xAA00:
  587|      0|		if (c == 0xAA7B)                return UCD_PROPERTY_DIACRITIC;
  588|      0|		if (c == 0xAA7D)                return UCD_PROPERTY_DIACRITIC;
  589|      0|		break;
  590|      0|	case 0xAB00:
  591|      0|		if (c == 0xABEC)                return UCD_PROPERTY_DIACRITIC;
  592|      0|		break;
  593|      0|	case 0x011100:
  594|      0|		if (c == 0x0111C0)                  return UCD_PROPERTY_DIACRITIC;
  595|      0|		break;
  596|      0|	case 0x011200:
  597|      0|		if (c == 0x011235)                  return UCD_PROPERTY_DIACRITIC;
  598|      0|		break;
  599|      0|	case 0x011300:
  600|      0|		if (c == 0x01133E)                  return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  601|      0|		if (c == 0x01134D)                  return UCD_PROPERTY_DIACRITIC;
  602|      0|		if (c == 0x011357)                  return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  603|      0|		break;
  604|      0|	case 0x011400:
  605|      0|		if (c == 0x0114B0)                  return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  606|      0|		if (c == 0x0114BD)                  return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  607|      0|		break;
  608|      0|	case 0x011500:
  609|      0|		if (c == 0x0115AF)                  return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  610|      0|		break;
  611|      0|	case 0x011600:
  612|      0|		if (c == 0x0116B6)                  return UCD_PROPERTY_DIACRITIC;
  613|      0|		break;
  614|      0|	case 0x01D100:
  615|      0|		if (c == 0x01D165)                  return UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  616|      0|		if (c == 0x01D166)                  return 0;
  617|      0|		if (c == 0x01D16D)                  return UCD_PROPERTY_DIACRITIC;
  618|      0|		if (c >= 0x01D16E && c <= 0x01D172) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_GRAPHEME_EXTEND;
  619|      0|		break;
  620|      0|	}
  621|      0|	return UCD_PROPERTY_OTHER_ALPHABETIC;
  622|      0|}
  623|       |
  624|       |static ucd_property properties_Me(codepoint_t c)
  625|      0|{
  626|      0|	if (c == 0x20E3) return UCD_PROPERTY_EMOJI_COMPONENT;
  627|      0|	return 0;
  628|      0|}
  629|       |
  630|       |static ucd_property properties_Mn(codepoint_t c)
  631|      0|{
  632|      0|	switch (c & 0xFFFFFF00)
  633|      0|	{
  634|      0|	case 0x0300:
  635|      0|		if (c >= 0x0300 && c <= 0x0344) return UCD_PROPERTY_DIACRITIC;
  636|      0|		if (c == 0x0345)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_LOWERCASE;
  637|      0|		if (c >= 0x0346 && c <= 0x034E) return UCD_PROPERTY_DIACRITIC;
  638|      0|		if (c == 0x034F)                return UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;
  639|      0|		if (c >= 0x0350 && c <= 0x0357) return UCD_PROPERTY_DIACRITIC;
  640|      0|		if (c >= 0x035D && c <= 0x0362) return UCD_PROPERTY_DIACRITIC;
  641|      0|		break;
  642|      0|	case 0x0400:
  643|      0|		if (c >= 0x0483 && c <= 0x0487) return UCD_PROPERTY_DIACRITIC;
  644|      0|		break;
  645|      0|	case 0x0500:
  646|      0|		if (c >= 0x0591 && c <= 0x05A1) return UCD_PROPERTY_DIACRITIC;
  647|      0|		if (c >= 0x05A3 && c <= 0x05AF) return UCD_PROPERTY_DIACRITIC;
  648|      0|		if (c >= 0x05B0 && c <= 0x05BD) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC;
  649|      0|		if (c == 0x05BF)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC;
  650|      0|		if (c >= 0x05C1 && c <= 0x05C2) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC;
  651|      0|		if (c == 0x05C4)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC;
  652|      0|		if (c == 0x05C5)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  653|      0|		if (c == 0x05C7)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  654|      0|		break;
  655|      0|	case 0x0600:
  656|      0|		if (c >= 0x0610 && c <= 0x061A) return UCD_PROPERTY_OTHER_ALPHABETIC;
  657|      0|		if (c >= 0x064B && c <= 0x0652) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC;
  658|      0|		if (c >= 0x0653 && c <= 0x0656) return UCD_PROPERTY_OTHER_ALPHABETIC;
  659|      0|		if (c == 0x0657)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC;
  660|      0|		if (c == 0x0658)                return UCD_PROPERTY_DIACRITIC;
  661|      0|		if (c >= 0x0659 && c <= 0x065F) return UCD_PROPERTY_OTHER_ALPHABETIC;
  662|      0|		if (c == 0x0670)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  663|      0|		if (c >= 0x06D6 && c <= 0x06DC) return UCD_PROPERTY_OTHER_ALPHABETIC;
  664|      0|		if (c >= 0x06DF && c <= 0x06E0) return UCD_PROPERTY_DIACRITIC;
  665|      0|		if (c >= 0x06E1 && c <= 0x06E4) return UCD_PROPERTY_OTHER_ALPHABETIC;
  666|      0|		if (c >= 0x06E7 && c <= 0x06E8) return UCD_PROPERTY_OTHER_ALPHABETIC;
  667|      0|		if (c >= 0x06EA && c <= 0x06EC) return UCD_PROPERTY_DIACRITIC;
  668|      0|		if (c == 0x06ED)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  669|      0|		break;
  670|      0|	case 0x0700:
  671|      0|		if (c == 0x0711)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  672|      0|		if (c >= 0x0730 && c <= 0x073F) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC;
  673|      0|		if (c >= 0x0740 && c <= 0x074A) return UCD_PROPERTY_DIACRITIC;
  674|      0|		if (c >= 0x07A6 && c <= 0x07B0) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC;
  675|      0|		if (c >= 0x07EB && c <= 0x07F3) return UCD_PROPERTY_DIACRITIC;
  676|      0|		break;
  677|      0|	case 0x0800:
  678|      0|		if (c >= 0x0816 && c <= 0x0817) return UCD_PROPERTY_OTHER_ALPHABETIC;
  679|      0|		if (c >= 0x0818 && c <= 0x0819) return UCD_PROPERTY_DIACRITIC;
  680|      0|		if (c >= 0x081B && c <= 0x0823) return UCD_PROPERTY_OTHER_ALPHABETIC;
  681|      0|		if (c >= 0x0825 && c <= 0x0827) return UCD_PROPERTY_OTHER_ALPHABETIC;
  682|      0|		if (c >= 0x0829 && c <= 0x082C) return UCD_PROPERTY_OTHER_ALPHABETIC;
  683|      0|		if (c >= 0x08D4 && c <= 0x08DF) return UCD_PROPERTY_OTHER_ALPHABETIC;
  684|      0|		if (c >= 0x08E3 && c <= 0x08E9) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC;
  685|      0|		if (c >= 0x08EA && c <= 0x08EF) return UCD_PROPERTY_DIACRITIC;
  686|      0|		if (c >= 0x08F0 && c <= 0x08FE) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC;
  687|      0|		if (c == 0x08FF)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  688|      0|		break;
  689|      0|	case 0x0900:
  690|      0|		if                (c <= 0x0902) return UCD_PROPERTY_OTHER_ALPHABETIC;
  691|      0|		if (c == 0x093A)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  692|      0|		if (c == 0x093C)                return UCD_PROPERTY_DIACRITIC;
  693|      0|		if (c >= 0x0941 && c <= 0x0948) return UCD_PROPERTY_OTHER_ALPHABETIC;
  694|      0|		if (c == 0x094D)                return UCD_PROPERTY_DIACRITIC;
  695|      0|		if (c >= 0x0951 && c <= 0x0954) return UCD_PROPERTY_DIACRITIC;
  696|      0|		if (c >= 0x0955 && c <= 0x0957) return UCD_PROPERTY_OTHER_ALPHABETIC;
  697|      0|		if (c >= 0x0962 && c <= 0x0963) return UCD_PROPERTY_OTHER_ALPHABETIC;
  698|      0|		if (c == 0x0981)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  699|      0|		if (c == 0x09BC)                return UCD_PROPERTY_DIACRITIC;
  700|      0|		if (c >= 0x09C1 && c <= 0x09C4) return UCD_PROPERTY_OTHER_ALPHABETIC;
  701|      0|		if (c == 0x09CD)                return UCD_PROPERTY_DIACRITIC;
  702|      0|		if (c >= 0x09E2 && c <= 0x09E3) return UCD_PROPERTY_OTHER_ALPHABETIC;
  703|      0|		break;
  704|      0|	case 0x0A00:
  705|      0|		if (c >= 0x0A01 && c <= 0x0A02) return UCD_PROPERTY_OTHER_ALPHABETIC;
  706|      0|		if (c == 0x0A3C)                return UCD_PROPERTY_DIACRITIC;
  707|      0|		if (c >= 0x0A41 && c <= 0x0A42) return UCD_PROPERTY_OTHER_ALPHABETIC;
  708|      0|		if (c >= 0x0A47 && c <= 0x0A48) return UCD_PROPERTY_OTHER_ALPHABETIC;
  709|      0|		if (c >= 0x0A4B && c <= 0x0A4C) return UCD_PROPERTY_OTHER_ALPHABETIC;
  710|      0|		if (c == 0x0A4D)                return UCD_PROPERTY_DIACRITIC;
  711|      0|		if (c == 0x0A51)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  712|      0|		if (c >= 0x0A70 && c <= 0x0A71) return UCD_PROPERTY_OTHER_ALPHABETIC;
  713|      0|		if (c == 0x0A75)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  714|      0|		if (c >= 0x0A81 && c <= 0x0A82) return UCD_PROPERTY_OTHER_ALPHABETIC;
  715|      0|		if (c == 0x0ABC)                return UCD_PROPERTY_DIACRITIC;
  716|      0|		if (c >= 0x0AC1 && c <= 0x0AC5) return UCD_PROPERTY_OTHER_ALPHABETIC;
  717|      0|		if (c >= 0x0AC7 && c <= 0x0AC8) return UCD_PROPERTY_OTHER_ALPHABETIC;
  718|      0|		if (c == 0x0ACD)                return UCD_PROPERTY_DIACRITIC;
  719|      0|		if (c >= 0x0AE2 && c <= 0x0AE3) return UCD_PROPERTY_OTHER_ALPHABETIC;
  720|      0|		if (c >= 0x0AFA && c <= 0x0AFC) return UCD_PROPERTY_OTHER_ALPHABETIC;
  721|      0|		if (c >= 0x0AFD && c <= 0x0AFF) return UCD_PROPERTY_DIACRITIC;
  722|      0|		break;
  723|      0|	case 0x0B00:
  724|      0|		if (c == 0x0B01)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  725|      0|		if (c == 0x0B3C)                return UCD_PROPERTY_DIACRITIC;
  726|      0|		if (c == 0x0B3F)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  727|      0|		if (c >= 0x0B41 && c <= 0x0B44) return UCD_PROPERTY_OTHER_ALPHABETIC;
  728|      0|		if (c == 0x0B4D)                return UCD_PROPERTY_DIACRITIC;
  729|      0|		if (c == 0x0B56)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  730|      0|		if (c >= 0x0B62 && c <= 0x0B63) return UCD_PROPERTY_OTHER_ALPHABETIC;
  731|      0|		if (c == 0x0B82)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  732|      0|		if (c == 0x0BC0)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  733|      0|		if (c == 0x0BCD)                return UCD_PROPERTY_DIACRITIC;
  734|      0|		break;
  735|      0|	case 0x0C00:
  736|      0|		if (c == 0x0C00)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  737|      0|		if (c >= 0x0C3E && c <= 0x0C40) return UCD_PROPERTY_OTHER_ALPHABETIC;
  738|      0|		if (c >= 0x0C46 && c <= 0x0C48) return UCD_PROPERTY_OTHER_ALPHABETIC;
  739|      0|		if (c >= 0x0C4A && c <= 0x0C4C) return UCD_PROPERTY_OTHER_ALPHABETIC;
  740|      0|		if (c == 0x0C4D)                return UCD_PROPERTY_DIACRITIC;
  741|      0|		if (c >= 0x0C55 && c <= 0x0C56) return UCD_PROPERTY_OTHER_ALPHABETIC;
  742|      0|		if (c >= 0x0C62 && c <= 0x0C63) return UCD_PROPERTY_OTHER_ALPHABETIC;
  743|      0|		if (c == 0x0C81)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  744|      0|		if (c == 0x0CBC)                return UCD_PROPERTY_DIACRITIC;
  745|      0|		if (c == 0x0CBF)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  746|      0|		if (c == 0x0CC6)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  747|      0|		if (c == 0x0CCC)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  748|      0|		if (c == 0x0CCD)                return UCD_PROPERTY_DIACRITIC;
  749|      0|		if (c >= 0x0CE2 && c <= 0x0CE3) return UCD_PROPERTY_OTHER_ALPHABETIC;
  750|      0|		break;
  751|      0|	case 0x0D00:
  752|      0|		if (c >= 0x0D00 && c <= 0x0D01) return UCD_PROPERTY_OTHER_ALPHABETIC;
  753|      0|		if (c >= 0x0D3B && c <= 0x0D3C) return UCD_PROPERTY_DIACRITIC;
  754|      0|		if (c >= 0x0D41 && c <= 0x0D44) return UCD_PROPERTY_OTHER_ALPHABETIC;
  755|      0|		if (c == 0x0D4D)                return UCD_PROPERTY_DIACRITIC;
  756|      0|		if (c >= 0x0D62 && c <= 0x0D63) return UCD_PROPERTY_OTHER_ALPHABETIC;
  757|      0|		if (c == 0x0DCA)                return UCD_PROPERTY_DIACRITIC;
  758|      0|		if (c >= 0x0DD2 && c <= 0x0DD4) return UCD_PROPERTY_OTHER_ALPHABETIC;
  759|      0|		if (c == 0x0DD6)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  760|      0|		break;
  761|      0|	case 0x0E00:
  762|      0|		if (c == 0x0E31)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  763|      0|		if (c >= 0x0E34 && c <= 0x0E3A) return UCD_PROPERTY_OTHER_ALPHABETIC;
  764|      0|		if (c >= 0x0E47 && c <= 0x0E4C) return UCD_PROPERTY_DIACRITIC;
  765|      0|		if (c == 0x0E4D)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  766|      0|		if (c == 0x0E4E)                return UCD_PROPERTY_DIACRITIC;
  767|      0|		if (c == 0x0EB1)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  768|      0|		if (c >= 0x0EB4 && c <= 0x0EB9) return UCD_PROPERTY_OTHER_ALPHABETIC;
  769|      0|		if (c >= 0x0EBB && c <= 0x0EBC) return UCD_PROPERTY_OTHER_ALPHABETIC;
  770|      0|		if (c >= 0x0EC8 && c <= 0x0ECC) return UCD_PROPERTY_DIACRITIC;
  771|      0|		if (c == 0x0ECD)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  772|      0|		break;
  773|      0|	case 0x0F00:
  774|      0|		if (c >= 0x0F18 && c <= 0x0F19) return UCD_PROPERTY_DIACRITIC;
  775|      0|		if (c == 0x0F35)                return UCD_PROPERTY_DIACRITIC;
  776|      0|		if (c == 0x0F37)                return UCD_PROPERTY_DIACRITIC;
  777|      0|		if (c == 0x0F39)                return UCD_PROPERTY_DIACRITIC;
  778|      0|		if (c == 0x0F77)                return UCD_PROPERTY_DEPRECATED | UCD_PROPERTY_OTHER_ALPHABETIC;
  779|      0|		if (c == 0x0F79)                return UCD_PROPERTY_DEPRECATED | UCD_PROPERTY_OTHER_ALPHABETIC;
  780|      0|		if (c >= 0x0F71 && c <= 0x0F7E) return UCD_PROPERTY_OTHER_ALPHABETIC;
  781|      0|		if (c >= 0x0F80 && c <= 0x0F81) return UCD_PROPERTY_OTHER_ALPHABETIC;
  782|      0|		if (c >= 0x0F82 && c <= 0x0F84) return UCD_PROPERTY_DIACRITIC;
  783|      0|		if (c >= 0x0F86 && c <= 0x0F87) return UCD_PROPERTY_DIACRITIC;
  784|      0|		if (c >= 0x0F8D && c <= 0x0F97) return UCD_PROPERTY_OTHER_ALPHABETIC;
  785|      0|		if (c >= 0x0F99 && c <= 0x0FBC) return UCD_PROPERTY_OTHER_ALPHABETIC;
  786|      0|		if (c == 0x0FC6)                return UCD_PROPERTY_DIACRITIC;
  787|      0|		break;
  788|      0|	case 0x1000:
  789|      0|		if (c >= 0x102D && c <= 0x1030) return UCD_PROPERTY_OTHER_ALPHABETIC;
  790|      0|		if (c >= 0x1032 && c <= 0x1036) return UCD_PROPERTY_OTHER_ALPHABETIC;
  791|      0|		if (c == 0x1037)                return UCD_PROPERTY_DIACRITIC;
  792|      0|		if (c >= 0x1039 && c <= 0x103A) return UCD_PROPERTY_DIACRITIC;
  793|      0|		if (c >= 0x103D && c <= 0x103E) return UCD_PROPERTY_OTHER_ALPHABETIC;
  794|      0|		if (c >= 0x1058 && c <= 0x1059) return UCD_PROPERTY_OTHER_ALPHABETIC;
  795|      0|		if (c >= 0x105E && c <= 0x1060) return UCD_PROPERTY_OTHER_ALPHABETIC;
  796|      0|		if (c >= 0x1071 && c <= 0x1074) return UCD_PROPERTY_OTHER_ALPHABETIC;
  797|      0|		if (c == 0x1082)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  798|      0|		if (c >= 0x1085 && c <= 0x1086) return UCD_PROPERTY_OTHER_ALPHABETIC;
  799|      0|		if (c == 0x108D)                return UCD_PROPERTY_DIACRITIC;
  800|      0|		if (c == 0x109D)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  801|      0|		break;
  802|      0|	case 0x1300:
  803|      0|		if (c == 0x135F)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  804|      0|		break;
  805|      0|	case 0x1700:
  806|      0|		if (c >= 0x1712 && c <= 0x1713) return UCD_PROPERTY_OTHER_ALPHABETIC;
  807|      0|		if (c >= 0x1732 && c <= 0x1733) return UCD_PROPERTY_OTHER_ALPHABETIC;
  808|      0|		if (c >= 0x1752 && c <= 0x1753) return UCD_PROPERTY_OTHER_ALPHABETIC;
  809|      0|		if (c >= 0x1772 && c <= 0x1773) return UCD_PROPERTY_OTHER_ALPHABETIC;
  810|      0|		if (c >= 0x17B4 && c <= 0x17B5) return UCD_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;
  811|      0|		if (c >= 0x17B7 && c <= 0x17BD) return UCD_PROPERTY_OTHER_ALPHABETIC;
  812|      0|		if (c == 0x17C6)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  813|      0|		if (c >= 0x17C9 && c <= 0x17D3) return UCD_PROPERTY_DIACRITIC;
  814|      0|		if (c == 0x17DD)                return UCD_PROPERTY_DIACRITIC;
  815|      0|		break;
  816|      0|	case 0x1800:
  817|      0|		if (c >= 0x180B && c <= 0x180D) return UCD_PROPERTY_VARIATION_SELECTOR;
  818|      0|		if (c >= 0x1885 && c <= 0x1886) return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_ID_START;
  819|      0|		if (c == 0x18A9)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  820|      0|		break;
  821|      0|	case 0x1900:
  822|      0|		if (c >= 0x1920 && c <= 0x1922) return UCD_PROPERTY_OTHER_ALPHABETIC;
  823|      0|		if (c >= 0x1927 && c <= 0x1928) return UCD_PROPERTY_OTHER_ALPHABETIC;
  824|      0|		if (c == 0x1932)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  825|      0|		if (c >= 0x1939 && c <= 0x193B) return UCD_PROPERTY_DIACRITIC;
  826|      0|		break;
  827|      0|	case 0x1A00:
  828|      0|		if (c >= 0x1A17 && c <= 0x1A18) return UCD_PROPERTY_OTHER_ALPHABETIC;
  829|      0|		if (c == 0x1A1B)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  830|      0|		if (c == 0x1A56)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  831|      0|		if (c >= 0x1A58 && c <= 0x1A5E) return UCD_PROPERTY_OTHER_ALPHABETIC;
  832|      0|		if (c == 0x1A62)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  833|      0|		if (c >= 0x1A65 && c <= 0x1A6C) return UCD_PROPERTY_OTHER_ALPHABETIC;
  834|      0|		if (c >= 0x1A73 && c <= 0x1A74) return UCD_PROPERTY_OTHER_ALPHABETIC;
  835|      0|		if (c >= 0x1A75 && c <= 0x1A7C) return UCD_PROPERTY_DIACRITIC;
  836|      0|		if (c == 0x1A7F)                return UCD_PROPERTY_DIACRITIC;
  837|      0|		if (c >= 0x1AB0 && c <= 0x1ABD) return UCD_PROPERTY_DIACRITIC;
  838|      0|		break;
  839|      0|	case 0x1B00:
  840|      0|		if (c >= 0x1B00 && c <= 0x1B03) return UCD_PROPERTY_OTHER_ALPHABETIC;
  841|      0|		if (c == 0x1B34)                return UCD_PROPERTY_DIACRITIC;
  842|      0|		if (c >= 0x1B36 && c <= 0x1B3A) return UCD_PROPERTY_OTHER_ALPHABETIC;
  843|      0|		if (c == 0x1B3C)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  844|      0|		if (c == 0x1B42)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  845|      0|		if (c >= 0x1B6B && c <= 0x1B73) return UCD_PROPERTY_DIACRITIC;
  846|      0|		if (c >= 0x1B80 && c <= 0x1B81) return UCD_PROPERTY_OTHER_ALPHABETIC;
  847|      0|		if (c >= 0x1BA2 && c <= 0x1BA5) return UCD_PROPERTY_OTHER_ALPHABETIC;
  848|      0|		if (c >= 0x1BA8 && c <= 0x1BA9) return UCD_PROPERTY_OTHER_ALPHABETIC;
  849|      0|		if (c == 0x1BAB)                return UCD_PROPERTY_DIACRITIC;
  850|      0|		if (c >= 0x1BAC && c <= 0x1BAD) return UCD_PROPERTY_OTHER_ALPHABETIC;
  851|      0|		if (c >= 0x1BE8 && c <= 0x1BE9) return UCD_PROPERTY_OTHER_ALPHABETIC;
  852|      0|		if (c == 0x1BED)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  853|      0|		if (c >= 0x1BEF && c <= 0x1BF1) return UCD_PROPERTY_OTHER_ALPHABETIC;
  854|      0|		break;
  855|      0|	case 0x1C00:
  856|      0|		if (c >= 0x1C2C && c <= 0x1C33) return UCD_PROPERTY_OTHER_ALPHABETIC;
  857|      0|		if (c == 0x1C36)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_EXTENDER;
  858|      0|		if (c == 0x1C37)                return UCD_PROPERTY_DIACRITIC;
  859|      0|		if (c >= 0x1CD0 && c <= 0x1CD2) return UCD_PROPERTY_DIACRITIC;
  860|      0|		if (c >= 0x1CD4 && c <= 0x1CE0) return UCD_PROPERTY_DIACRITIC;
  861|      0|		if (c >= 0x1CE2 && c <= 0x1CE8) return UCD_PROPERTY_DIACRITIC;
  862|      0|		if (c == 0x1CED)                return UCD_PROPERTY_DIACRITIC;
  863|      0|		if (c == 0x1CF4)                return UCD_PROPERTY_DIACRITIC;
  864|      0|		if (c >= 0x1CF8 && c <= 0x1CF9) return UCD_PROPERTY_DIACRITIC;
  865|      0|		break;
  866|      0|	case 0x1D00:
  867|      0|		if (c >= 0x1DC4 && c <= 0x1DCF) return UCD_PROPERTY_DIACRITIC;
  868|      0|		if (c >= 0x1DE7 && c <= 0x1DF4) return UCD_PROPERTY_OTHER_ALPHABETIC;
  869|      0|		if (c >= 0x1DF5 && c <= 0x1DF9) return UCD_PROPERTY_DIACRITIC;
  870|      0|		if (c >= 0x1DFD && c <= 0x1DFF) return UCD_PROPERTY_DIACRITIC;
  871|      0|		break;
  872|      0|	case 0x2000:
  873|      0|		if (c >= 0x20D0 && c <= 0x20DC) return UCD_PROPERTY_OTHER_MATH;
  874|      0|		if (c == 0x20E1)                return UCD_PROPERTY_OTHER_MATH;
  875|      0|		if (c >= 0x20E5 && c <= 0x20E6) return UCD_PROPERTY_OTHER_MATH;
  876|      0|		if (c >= 0x20EB && c <= 0x20EF) return UCD_PROPERTY_OTHER_MATH;
  877|      0|		break;
  878|      0|	case 0x2C00:
  879|      0|		if (c >= 0x2CEF && c <= 0x2CF1) return UCD_PROPERTY_DIACRITIC;
  880|      0|		break;
  881|      0|	case 0x2D00:
  882|      0|		if (c >= 0x2DE0 && c <= 0x2DFF) return UCD_PROPERTY_OTHER_ALPHABETIC;
  883|      0|		break;
  884|      0|	case 0x3000:
  885|      0|		if (c >= 0x302A && c <= 0x302D) return UCD_PROPERTY_DIACRITIC;
  886|      0|		if (c >= 0x3099 && c <= 0x309A) return UCD_PROPERTY_DIACRITIC;
  887|      0|		break;
  888|      0|	case 0xA600:
  889|      0|		if (c == 0xA66F)                return UCD_PROPERTY_DIACRITIC;
  890|      0|		if (c >= 0xA674 && c <= 0xA67B) return UCD_PROPERTY_OTHER_ALPHABETIC;
  891|      0|		if (c >= 0xA67C && c <= 0xA67D) return UCD_PROPERTY_DIACRITIC;
  892|      0|		if (c >= 0xA69E && c <= 0xA69F) return UCD_PROPERTY_OTHER_ALPHABETIC;
  893|      0|		if (c >= 0xA6F0 && c <= 0xA6F1) return UCD_PROPERTY_DIACRITIC;
  894|      0|		break;
  895|      0|	case 0xA800:
  896|      0|		if (c >= 0xA825 && c <= 0xA826) return UCD_PROPERTY_OTHER_ALPHABETIC;
  897|      0|		if (c == 0xA8C4)                return UCD_PROPERTY_DIACRITIC;
  898|      0|		if (c == 0xA8C5)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  899|      0|		if (c >= 0xA8E0 && c <= 0xA8F1) return UCD_PROPERTY_DIACRITIC;
  900|      0|		break;
  901|      0|	case 0xA900:
  902|      0|		if (c >= 0xA926 && c <= 0xA92A) return UCD_PROPERTY_OTHER_ALPHABETIC;
  903|      0|		if (c >= 0xA92B && c <= 0xA92D) return UCD_PROPERTY_DIACRITIC;
  904|      0|		if (c >= 0xA947 && c <= 0xA951) return UCD_PROPERTY_OTHER_ALPHABETIC;
  905|      0|		if (c >= 0xA980 && c <= 0xA982) return UCD_PROPERTY_OTHER_ALPHABETIC;
  906|      0|		if (c == 0xA9B3)                return UCD_PROPERTY_DIACRITIC;
  907|      0|		if (c >= 0xA9B6 && c <= 0xA9B9) return UCD_PROPERTY_OTHER_ALPHABETIC;
  908|      0|		if (c == 0xA9BC)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  909|      0|		if (c == 0xA9E5)                return UCD_PROPERTY_DIACRITIC;
  910|      0|		break;
  911|      0|	case 0xAA00:
  912|      0|		if (c >= 0xAA29 && c <= 0xAA2E) return UCD_PROPERTY_OTHER_ALPHABETIC;
  913|      0|		if (c >= 0xAA31 && c <= 0xAA32) return UCD_PROPERTY_OTHER_ALPHABETIC;
  914|      0|		if (c >= 0xAA35 && c <= 0xAA36) return UCD_PROPERTY_OTHER_ALPHABETIC;
  915|      0|		if (c == 0xAA43)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  916|      0|		if (c == 0xAA4C)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  917|      0|		if (c == 0xAA7C)                return UCD_PROPERTY_DIACRITIC;
  918|      0|		if (c == 0xAAB0)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  919|      0|		if (c >= 0xAAB2 && c <= 0xAAB4) return UCD_PROPERTY_OTHER_ALPHABETIC;
  920|      0|		if (c >= 0xAAB7 && c <= 0xAAB8) return UCD_PROPERTY_OTHER_ALPHABETIC;
  921|      0|		if (c == 0xAABE)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  922|      0|		if (c == 0xAABF)                return UCD_PROPERTY_DIACRITIC;
  923|      0|		if (c == 0xAAC1)                return UCD_PROPERTY_DIACRITIC;
  924|      0|		if (c >= 0xAAEC && c <= 0xAAED) return UCD_PROPERTY_OTHER_ALPHABETIC;
  925|      0|		if (c == 0xAAF6)                return UCD_PROPERTY_DIACRITIC;
  926|      0|		break;
  927|      0|	case 0xAB00:
  928|      0|		if (c == 0xABE5)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  929|      0|		if (c == 0xABE8)                return UCD_PROPERTY_OTHER_ALPHABETIC;
  930|      0|		if (c == 0xABED)                return UCD_PROPERTY_DIACRITIC;
  931|      0|		break;
  932|      0|	case 0xFB00:
  933|      0|		if (c == 0xFB1E)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC;
  934|      0|		break;
  935|      0|	case 0xFE00:
  936|      0|		if (c >= 0xFE00 && c <= 0xFE0E) return UCD_PROPERTY_VARIATION_SELECTOR;
  937|      0|		if (c == 0xFE0F)                return UCD_PROPERTY_VARIATION_SELECTOR | UCD_PROPERTY_EMOJI_COMPONENT;
  938|      0|		if (c >= 0xFE20 && c <= 0xFE2F) return UCD_PROPERTY_DIACRITIC;
  939|      0|		break;
  940|      0|	case 0x010200:
  941|      0|		if (c == 0x0102E0)                  return UCD_PROPERTY_DIACRITIC;
  942|      0|		break;
  943|      0|	case 0x010300:
  944|      0|		if (c >= 0x010376 && c <= 0x01037A) return UCD_PROPERTY_OTHER_ALPHABETIC;
  945|      0|		break;
  946|      0|	case 0x010A00:
  947|      0|		if (c >= 0x010A01 && c <= 0x010A03) return UCD_PROPERTY_OTHER_ALPHABETIC;
  948|      0|		if (c >= 0x010A05 && c <= 0x010A06) return UCD_PROPERTY_OTHER_ALPHABETIC;
  949|      0|		if (c >= 0x010A0C && c <= 0x010A0F) return UCD_PROPERTY_OTHER_ALPHABETIC;
  950|      0|		if (c >= 0x010AE5 && c <= 0x010AE6) return UCD_PROPERTY_DIACRITIC;
  951|      0|		break;
  952|      0|	case 0x010D00:
  953|      0|		if (c >= 0x010D24 && c <= 0x010D27) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ALPHABETIC;
  954|      0|		break;
  955|      0|	case 0x010F00:
  956|      0|		if (c >= 0x010F46 && c <= 0x010F50) return UCD_PROPERTY_DIACRITIC;
  957|      0|		break;
  958|      0|	case 0x011000:
  959|      0|		if (c == 0x011001)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
  960|      0|		if (c >= 0x011038 && c <= 0x011045) return UCD_PROPERTY_OTHER_ALPHABETIC;
  961|      0|		if (c >= 0x0110B3 && c <= 0x0110B6) return UCD_PROPERTY_OTHER_ALPHABETIC;
  962|      0|		if (c >= 0x0110B9 && c <= 0x0110BA) return UCD_PROPERTY_DIACRITIC;
  963|      0|		break;
  964|      0|	case 0x011100:
  965|      0|		if (c >= 0x011100 && c <= 0x011102) return UCD_PROPERTY_OTHER_ALPHABETIC;
  966|      0|		if (c >= 0x011127 && c <= 0x01112B) return UCD_PROPERTY_OTHER_ALPHABETIC;
  967|      0|		if (c >= 0x01112D && c <= 0x011132) return UCD_PROPERTY_OTHER_ALPHABETIC;
  968|      0|		if (c >= 0x011133 && c <= 0x011134) return UCD_PROPERTY_DIACRITIC;
  969|      0|		if (c == 0x011173)                  return UCD_PROPERTY_DIACRITIC;
  970|      0|		if (c >= 0x011180 && c <= 0x011181) return UCD_PROPERTY_OTHER_ALPHABETIC;
  971|      0|		if (c >= 0x0111B6 && c <= 0x0111BE) return UCD_PROPERTY_OTHER_ALPHABETIC;
  972|      0|		if (c >= 0x0111CA && c <= 0x0111CC) return UCD_PROPERTY_DIACRITIC;
  973|      0|		break;
  974|      0|	case 0x011200:
  975|      0|		if (c >= 0x01122F && c <= 0x011231) return UCD_PROPERTY_OTHER_ALPHABETIC;
  976|      0|		if (c == 0x011234)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
  977|      0|		if (c == 0x011236)                  return UCD_PROPERTY_DIACRITIC;
  978|      0|		if (c == 0x011237)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
  979|      0|		if (c == 0x01123E)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
  980|      0|		if (c == 0x0112DF)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
  981|      0|		if (c >= 0x0112E3 && c <= 0x0112E8) return UCD_PROPERTY_OTHER_ALPHABETIC;
  982|      0|		if (c >= 0x0112E9 && c <= 0x0112EA) return UCD_PROPERTY_DIACRITIC;
  983|      0|		break;
  984|      0|	case 0x011300:
  985|      0|		if (c >= 0x011300 && c <= 0x011301) return UCD_PROPERTY_OTHER_ALPHABETIC;
  986|      0|		if (c == 0x01133C)                  return UCD_PROPERTY_DIACRITIC;
  987|      0|		if (c == 0x011340)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
  988|      0|		if (c >= 0x011366 && c <= 0x01136C) return UCD_PROPERTY_DIACRITIC;
  989|      0|		if (c >= 0x011370 && c <= 0x011374) return UCD_PROPERTY_DIACRITIC;
  990|      0|		break;
  991|      0|	case 0x011400:
  992|      0|		if (c >= 0x011438 && c <= 0x01143F) return UCD_PROPERTY_OTHER_ALPHABETIC;
  993|      0|		if (c == 0x011442)                  return UCD_PROPERTY_DIACRITIC;
  994|      0|		if (c >= 0x011443 && c <= 0x011444) return UCD_PROPERTY_OTHER_ALPHABETIC;
  995|      0|		if (c == 0x011446)                  return UCD_PROPERTY_DIACRITIC;
  996|      0|		if (c >= 0x0114B3 && c <= 0x0114B8) return UCD_PROPERTY_OTHER_ALPHABETIC;
  997|      0|		if (c == 0x0114BA)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
  998|      0|		if (c >= 0x0114BF && c <= 0x0114C0) return UCD_PROPERTY_OTHER_ALPHABETIC;
  999|      0|		if (c >= 0x0114C2 && c <= 0x0114C3) return UCD_PROPERTY_DIACRITIC;
 1000|      0|		break;
 1001|      0|	case 0x011500:
 1002|      0|		if (c >= 0x0115B2 && c <= 0x0115B5) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1003|      0|		if (c >= 0x0115BC && c <= 0x0115BD) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1004|      0|		if (c >= 0x0115BF && c <= 0x0115C0) return UCD_PROPERTY_DIACRITIC;
 1005|      0|		if (c >= 0x0115DC && c <= 0x0115DD) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1006|      0|		break;
 1007|      0|	case 0x011600:
 1008|      0|		if (c >= 0x011633 && c <= 0x01163A) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1009|      0|		if (c == 0x01163D)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1010|      0|		if (c == 0x01163F)                  return UCD_PROPERTY_DIACRITIC;
 1011|      0|		if (c == 0x011640)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1012|      0|		if (c == 0x0116AB)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1013|      0|		if (c == 0x0116AD)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1014|      0|		if (c >= 0x0116B0 && c <= 0x0116B5) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1015|      0|		if (c == 0x0116B7)                  return UCD_PROPERTY_DIACRITIC;
 1016|      0|		break;
 1017|      0|	case 0x011700:
 1018|      0|		if (c >= 0x01171D && c <= 0x01171F) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1019|      0|		if (c >= 0x011722 && c <= 0x011725) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1020|      0|		if (c >= 0x011727 && c <= 0x01172A) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1021|      0|		if (c == 0x01172B)                  return UCD_PROPERTY_DIACRITIC;
 1022|      0|		break;
 1023|      0|	case 0x011800:
 1024|      0|		if (c >= 0x01182F && c <= 0x011838) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1025|      0|		if (c >= 0x011839 && c <= 0x01183A) return UCD_PROPERTY_DIACRITIC;
 1026|      0|		break;
 1027|      0|	case 0x011A00:
 1028|      0|		if (c >= 0x011A01 && c <= 0x011A0A) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1029|      0|		if (c == 0x011A34)                  return UCD_PROPERTY_DIACRITIC;
 1030|      0|		if (c >= 0x011A35 && c <= 0x011A3E) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1031|      0|		if (c == 0x011A47)                  return UCD_PROPERTY_DIACRITIC;
 1032|      0|		if (c >= 0x011A51 && c <= 0x011A5B) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1033|      0|		if (c >= 0x011A8A && c <= 0x011A96) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1034|      0|		if (c == 0x011A98)                  return UCD_PROPERTY_EXTENDER;
 1035|      0|		if (c == 0x011A99)                  return UCD_PROPERTY_DIACRITIC;
 1036|      0|		break;
 1037|      0|	case 0x011C00:
 1038|      0|		if (c >= 0x011C30 && c <= 0x011C36) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1039|      0|		if (c >= 0x011C38 && c <= 0x011C3D) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1040|      0|		if (c == 0x011C3F)                  return UCD_PROPERTY_DIACRITIC;
 1041|      0|		if (c >= 0x011C92 && c <= 0x011CA7) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1042|      0|		if (c >= 0x011CAA && c <= 0x011CB0) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1043|      0|		if (c >= 0x011CB2 && c <= 0x011CB3) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1044|      0|		if (c >= 0x011CB5 && c <= 0x011CB6) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1045|      0|		break;
 1046|      0|	case 0x011D00:
 1047|      0|		if (c >= 0x011D31 && c <= 0x011D36) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1048|      0|		if (c == 0x011D3A)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1049|      0|		if (c >= 0x011D3C && c <= 0x011D3D) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1050|      0|		if (c >= 0x011D3F && c <= 0x011D41) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1051|      0|		if (c == 0x011D42)                  return UCD_PROPERTY_DIACRITIC;
 1052|      0|		if (c == 0x011D43)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1053|      0|		if (c >= 0x011D44 && c <= 0x011D45) return UCD_PROPERTY_DIACRITIC;
 1054|      0|		if (c == 0x011D47)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1055|      0|		if (c == 0x011D90)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1056|      0|		if (c == 0x011D91)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1057|      0|		if (c == 0x011D95)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1058|      0|		if (c == 0x011D97)                  return UCD_PROPERTY_DIACRITIC;
 1059|      0|		break;
 1060|      0|	case 0x011E00:
 1061|      0|		if (c == 0x011EF3)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1062|      0|		if (c == 0x011EF4)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1063|      0|		break;
 1064|      0|	case 0x016A00:
 1065|      0|		if (c >= 0x016AF0 && c <= 0x016AF4) return UCD_PROPERTY_DIACRITIC;
 1066|      0|		break;
 1067|      0|	case 0x016B00:
 1068|      0|		if (c >= 0x016B30 && c <= 0x016B36) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1069|      0|		break;
 1070|      0|	case 0x016F00:
 1071|      0|		if (c >= 0x016F8F && c <= 0x016F92) return UCD_PROPERTY_DIACRITIC;
 1072|      0|		break;
 1073|      0|	case 0x01BC00:
 1074|      0|		if (c == 0x01BC9E)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1075|      0|		break;
 1076|      0|	case 0x01D100:
 1077|      0|		if (c >= 0x01D167 && c <= 0x01D169) return UCD_PROPERTY_DIACRITIC;
 1078|      0|		if (c >= 0x01D17B && c <= 0x01D182) return UCD_PROPERTY_DIACRITIC;
 1079|      0|		if (c >= 0x01D185 && c <= 0x01D18B) return UCD_PROPERTY_DIACRITIC;
 1080|      0|		if (c >= 0x01D1AA && c <= 0x01D1AD) return UCD_PROPERTY_DIACRITIC;
 1081|      0|		break;
 1082|      0|	case 0x01E000:
 1083|      0|		if (c >= 0x01E000 && c <= 0x01E006) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1084|      0|		if (c >= 0x01E008 && c <= 0x01E018) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1085|      0|		if (c >= 0x01E01B && c <= 0x01E021) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1086|      0|		if (c >= 0x01E023 && c <= 0x01E024) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1087|      0|		if (c >= 0x01E026 && c <= 0x01E02A) return UCD_PROPERTY_OTHER_ALPHABETIC;
 1088|      0|		break;
 1089|      0|	case 0x01E800:
 1090|      0|		if (c >= 0x01E8D0 && c <= 0x01E8D6) return UCD_PROPERTY_DIACRITIC;
 1091|      0|		break;
 1092|      0|	case 0x01E900:
 1093|      0|		if (c >= 0x01E944 && c <= 0x01E946) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_EXTENDER;
 1094|      0|		if (c == 0x01E947)                  return UCD_PROPERTY_OTHER_ALPHABETIC;
 1095|      0|		if (c >= 0x01E948 && c <= 0x01E94A) return UCD_PROPERTY_DIACRITIC;
 1096|      0|		break;
 1097|      0|	case 0x0E0100:
 1098|      0|		if (c >= 0x0E0100 && c <= 0x0E01EF) return UCD_PROPERTY_VARIATION_SELECTOR;
 1099|      0|		break;
 1100|      0|	}
 1101|      0|	return 0;
 1102|      0|}
 1103|       |
 1104|       |static ucd_property properties_Nd(codepoint_t c)
 1105|      0|{
 1106|      0|	switch (c & 0xFFFFFF00)
 1107|      0|	{
 1108|      0|	case 0x0000:
 1109|      0|		if (c >= 0x0030 && c <= 0x0039) return UCD_PROPERTY_HEX_DIGIT | UCD_PROPERTY_ASCII_HEX_DIGIT | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EMOJI_COMPONENT;
 1110|      0|		break;
 1111|      0|	case 0xFF00:
 1112|      0|		if (c >= 0xFF10 && c <= 0xFF19) return UCD_PROPERTY_HEX_DIGIT;
 1113|      0|		break;
 1114|      0|	case 0x01D700:
 1115|      0|		if (c >= 0x01D7CE && c <= 0x01D7FF) return UCD_PROPERTY_OTHER_MATH;
 1116|      0|		break;
 1117|      0|	}
 1118|      0|	return 0;
 1119|      0|}
 1120|       |
 1121|       |static ucd_property properties_Nl(codepoint_t c)
 1122|      0|{
 1123|      0|	switch (c & 0xFFFFFF00)
 1124|      0|	{
 1125|      0|	case 0x2100:
 1126|      0|		if (c >= 0x2160 && c <= 0x216F) return UCD_PROPERTY_OTHER_UPPERCASE;
 1127|      0|		if (c >= 0x2170 && c <= 0x217F) return UCD_PROPERTY_OTHER_LOWERCASE;
 1128|      0|		break;
 1129|      0|	case 0x3000:
 1130|      0|		if (c == 0x3007)                return UCD_PROPERTY_IDEOGRAPHIC;
 1131|      0|		if (c >= 0x3021 && c <= 0x3029) return UCD_PROPERTY_IDEOGRAPHIC;
 1132|      0|		if (c >= 0x3038 && c <= 0x303A) return UCD_PROPERTY_IDEOGRAPHIC;
 1133|      0|		break;
 1134|      0|	}
 1135|      0|	return 0;
 1136|      0|}
 1137|       |
 1138|       |static ucd_property properties_No(codepoint_t c)
 1139|      0|{
 1140|      0|	switch (c & 0xFFFFFF00)
 1141|      0|	{
 1142|      0|	case 0x1300:
 1143|      0|		if (c >= 0x1369 && c <= 0x1371) return UCD_PROPERTY_OTHER_ID_CONTINUE;
 1144|      0|		break;
 1145|      0|	case 0x1900:
 1146|      0|		if (c == 0x19DA)                return UCD_PROPERTY_OTHER_ID_CONTINUE;
 1147|      0|		break;
 1148|      0|	case 0x2400:
 1149|      0|		if (c >= 0x2488 && c <= 0x249B) return ESPEAKNG_PROPERTY_FULL_STOP;
 1150|      0|		break;
 1151|      0|	case 0x01F100:
 1152|      0|		if (c == 0x01F100)                  return ESPEAKNG_PROPERTY_FULL_STOP;
 1153|      0|		if (c >= 0x01F101 && c <= 0x01F10A) return ESPEAKNG_PROPERTY_COMMA;
 1154|      0|		break;
 1155|      0|	}
 1156|      0|	return 0;
 1157|      0|}
 1158|       |
 1159|       |static ucd_property properties_Pc(codepoint_t c)
 1160|      0|{
 1161|      0|	switch (c & 0xFFFFFF00)
 1162|      0|	{
 1163|      0|	case 0x2000:
 1164|      0|		if (c == 0x2040)                return UCD_PROPERTY_OTHER_MATH;
 1165|      0|		break;
 1166|      0|	}
 1167|      0|	return 0;
 1168|      0|}
 1169|       |
 1170|       |static ucd_property properties_Pd(codepoint_t c)
 1171|      0|{
 1172|      0|	switch (c & 0xFFFFFF00)
 1173|      0|	{
 1174|      0|	case 0x0000:
 1175|      0|		return UCD_PROPERTY_DASH | UCD_PROPERTY_HYPHEN | UCD_PROPERTY_PATTERN_SYNTAX;
 1176|      0|	case 0x0500:
 1177|      0|		if (c == 0x058A)                return UCD_PROPERTY_DASH | UCD_PROPERTY_HYPHEN;
 1178|      0|		break;
 1179|      0|	case 0x1800:
 1180|      0|		if (c == 0x1806)                return UCD_PROPERTY_DASH | UCD_PROPERTY_HYPHEN;
 1181|      0|		break;
 1182|      0|	case 0x2000:
 1183|      0|		if (c >= 0x2010 && c <= 0x2011) return UCD_PROPERTY_DASH | UCD_PROPERTY_HYPHEN | UCD_PROPERTY_PATTERN_SYNTAX;
 1184|      0|		if (c >= 0x2013 && c <= 0x2014) return UCD_PROPERTY_DASH | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_EXTENDED_DASH;
 1185|      0|		return UCD_PROPERTY_DASH | UCD_PROPERTY_PATTERN_SYNTAX;
 1186|      0|	case 0x2E00:
 1187|      0|		if (c == 0x2E17)                return UCD_PROPERTY_DASH | UCD_PROPERTY_HYPHEN | UCD_PROPERTY_PATTERN_SYNTAX;
 1188|      0|		if (c >= 0x2E3A && c <= 0x2E3B) return UCD_PROPERTY_DASH | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_EXTENDED_DASH;
 1189|      0|		return UCD_PROPERTY_DASH | UCD_PROPERTY_PATTERN_SYNTAX;
 1190|      0|	case 0x3000:
 1191|      0|		if (c == 0x301C)                return UCD_PROPERTY_DASH | UCD_PROPERTY_PATTERN_SYNTAX;
 1192|      0|		if (c == 0x3030)                return UCD_PROPERTY_DASH | UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1193|      0|		break;
 1194|      0|	case 0xFE00:
 1195|      0|		if (c >= 0xFE31 && c <= 0xFE32) return UCD_PROPERTY_DASH | ESPEAKNG_PROPERTY_EXTENDED_DASH;
 1196|      0|		if (c == 0xFE63)                return UCD_PROPERTY_DASH | UCD_PROPERTY_HYPHEN | UCD_PROPERTY_OTHER_MATH;
 1197|      0|		break;
 1198|      0|	case 0xFF00:
 1199|      0|		if (c == 0xFF0D)                return UCD_PROPERTY_DASH | UCD_PROPERTY_HYPHEN;
 1200|      0|		break;
 1201|      0|	}
 1202|      0|	return UCD_PROPERTY_DASH;
 1203|      0|}
 1204|       |
 1205|       |static ucd_property properties_Pe(codepoint_t c)
 1206|      0|{
 1207|      0|	switch (c & 0xFFFFFF00)
 1208|      0|	{
 1209|      0|	case 0x0000:
 1210|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1211|      0|	case 0x2000:
 1212|      0|		if (c == 0x2046)                return UCD_PROPERTY_PATTERN_SYNTAX;
 1213|      0|		if (c == 0x207E)                return UCD_PROPERTY_OTHER_MATH;
 1214|      0|		if (c == 0x208E)                return UCD_PROPERTY_OTHER_MATH;
 1215|      0|		break;
 1216|      0|	case 0x2300:
 1217|      0|		if (c == 0x2309)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1218|      0|		if (c == 0x230B)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1219|      0|		if (c == 0x232A)                return UCD_PROPERTY_DEPRECATED | UCD_PROPERTY_PATTERN_SYNTAX;
 1220|      0|		break;
 1221|      0|	case 0x2700:
 1222|      0|		if (c == 0x27C6)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1223|      0|		if (c >= 0x27E6 && c <= 0x27EF) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX; /* Pe|Ps */
 1224|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1225|      0|	case 0x2900:
 1226|      0|		return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX; /* Pe|Ps */
 1227|      0|	case 0x2E00:
 1228|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1229|      0|	case 0x3000:
 1230|      0|		if (c == 0x300D)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_QUOTATION_MARK;
 1231|      0|		if (c == 0x300F)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_QUOTATION_MARK;
 1232|      0|		if (c >= 0x301E && c <= 0x301F) return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_QUOTATION_MARK;
 1233|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1234|      0|	case 0xFD00:
 1235|      0|		if (c == 0xFD3E)                return UCD_PROPERTY_PATTERN_SYNTAX;
 1236|      0|		break;
 1237|      0|	case 0xFE00:
 1238|      0|		if (c == 0xFE42)                return UCD_PROPERTY_QUOTATION_MARK;
 1239|      0|		if (c == 0xFE44)                return UCD_PROPERTY_QUOTATION_MARK;
 1240|      0|		break;
 1241|      0|	case 0xFF00:
 1242|      0|		if (c == 0xFF63)                return UCD_PROPERTY_QUOTATION_MARK;
 1243|      0|		break;
 1244|      0|	}
 1245|      0|	return 0;
 1246|      0|}
 1247|       |
 1248|       |static ucd_property properties_Pf(codepoint_t c)
 1249|      0|{
 1250|      0|	switch (c & 0xFFFFFF00)
 1251|      0|	{
 1252|      0|	case 0x0000:
 1253|      0|	case 0x2000:
 1254|      0|		return UCD_PROPERTY_QUOTATION_MARK | UCD_PROPERTY_PATTERN_SYNTAX;
 1255|      0|	case 0x2E00:
 1256|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1257|      0|	}
 1258|      0|	return 0;
 1259|      0|}
 1260|       |
 1261|       |static ucd_property properties_Pi(codepoint_t c)
 1262|      0|{
 1263|      0|	switch (c & 0xFFFFFF00)
 1264|      0|	{
 1265|      0|	case 0x0000:
 1266|      0|	case 0x2000:
 1267|      0|		return UCD_PROPERTY_QUOTATION_MARK | UCD_PROPERTY_PATTERN_SYNTAX;
 1268|      0|	case 0x2E00:
 1269|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1270|      0|	}
 1271|      0|	return 0;
 1272|      0|}
 1273|       |
 1274|       |static ucd_property properties_Po(codepoint_t c)
 1275|      0|{
 1276|      0|	switch (c & 0xFFFFFF00)
 1277|      0|	{
 1278|      0|	case 0x0000:
 1279|      0|		if (c == 0x0021)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_EXCLAMATION_MARK;
 1280|      0|		if (c == 0x0022)                return UCD_PROPERTY_QUOTATION_MARK | UCD_PROPERTY_PATTERN_SYNTAX;
 1281|      0|		if (c == 0x0023)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI_COMPONENT;
 1282|      0|		if (c == 0x0027)                return UCD_PROPERTY_QUOTATION_MARK | UCD_PROPERTY_PATTERN_SYNTAX;
 1283|      0|		if (c == 0x002A)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI_COMPONENT;
 1284|      0|		if (c == 0x002C)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_COMMA;
 1285|      0|		if (c == 0x002E)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_FULL_STOP;
 1286|      0|		if (c == 0x003A)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_COLON;
 1287|      0|		if (c == 0x003B)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_SEMI_COLON;
 1288|      0|		if (c == 0x003F)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_QUESTION_MARK;
 1289|      0|		if (c == 0x00A1)                return UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_EXCLAMATION_MARK | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER | ESPEAKNG_PROPERTY_INVERTED_TERMINAL_PUNCTUATION;
 1290|      0|		if (c == 0x00B7)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_EXTENDER | UCD_PROPERTY_OTHER_ID_CONTINUE;
 1291|      0|		if (c == 0x00BF)                return UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_QUESTION_MARK | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER | ESPEAKNG_PROPERTY_INVERTED_TERMINAL_PUNCTUATION;
 1292|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1293|      0|	case 0x0300:
 1294|      0|		if (c == 0x037E)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_QUESTION_MARK;
 1295|      0|		if (c == 0x0387)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_OTHER_ID_CONTINUE | ESPEAKNG_PROPERTY_SEMI_COLON;
 1296|      0|		break;
 1297|      0|	case 0x0500:
 1298|      0|		if (c >= 0x055B && c <= 0x055C) return ESPEAKNG_PROPERTY_EXCLAMATION_MARK | ESPEAKNG_PROPERTY_PUNCTUATION_IN_WORD;
 1299|      0|		if (c == 0x055D)                return ESPEAKNG_PROPERTY_COMMA;
 1300|      0|		if (c == 0x055E)                return ESPEAKNG_PROPERTY_QUESTION_MARK | ESPEAKNG_PROPERTY_PUNCTUATION_IN_WORD;
 1301|      0|		if (c == 0x0589)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER;
 1302|      0|		if (c == 0x05C3)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1303|      0|		break;
 1304|      0|	case 0x0600:
 1305|      0|		if (c == 0x060C)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA;
 1306|      0|		if (c == 0x061B)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_SEMI_COLON;
 1307|      0|		if (c == 0x061E)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1308|      0|		if (c == 0x061F)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_QUESTION_MARK;
 1309|      0|		if (c == 0x06D4)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1310|      0|		break;
 1311|      0|	case 0x0700:
 1312|      0|		if (c == 0x0700)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_PARAGRAPH_SEPARATOR;
 1313|      0|		if (c == 0x0701)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1314|      0|		if (c == 0x0702)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_COMMA;
 1315|      0|		if (c == 0x0703)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_EXCLAMATION_MARK;
 1316|      0|		if (c == 0x0704)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_FULL_STOP;
 1317|      0|		if (c == 0x0705)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1318|      0|		if (c >= 0x0706 && c <= 0x0707) return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COLON;
 1319|      0|		if (c == 0x0708)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_SEMI_COLON;
 1320|      0|		if (c == 0x0709)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_QUESTION_MARK;
 1321|      0|		if (c == 0x070A)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1322|      0|		if (c == 0x070C)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1323|      0|		if (c == 0x07F8)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA;
 1324|      0|		if (c == 0x07F9)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_EXCLAMATION_MARK;
 1325|      0|		break;
 1326|      0|	case 0x0800:
 1327|      0|		if (c == 0x0837)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1328|      0|		if (c == 0x0839)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1329|      0|		if (c == 0x083D)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1330|      0|		if (c == 0x083E)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1331|      0|		if (c >= 0x0830 && c <= 0x083E) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1332|      0|		if (c == 0x085E)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1333|      0|		break;
 1334|      0|	case 0x0900:
 1335|      0|		if (c == 0x0964)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER;
 1336|      0|		if (c == 0x0965)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_PARAGRAPH_SEPARATOR;
 1337|      0|		break;
 1338|      0|	case 0x0D00:
 1339|      0|		if (c == 0x0DF4)                return ESPEAKNG_PROPERTY_FULL_STOP | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER;
 1340|      0|		break;
 1341|      0|	case 0x0E00:
 1342|      0|		if (c >= 0x0E5A && c <= 0x0E5B) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1343|      0|		break;
 1344|      0|	case 0x0F00:
 1345|      0|		if (c == 0x0F08)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1346|      0|		if (c == 0x0F0D)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_FULL_STOP | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER;
 1347|      0|		if (c == 0x0F0E)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_PARAGRAPH_SEPARATOR;
 1348|      0|		if (c >= 0x0F0E && c <= 0x0F12) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1349|      0|		if (c == 0x0F14)                return ESPEAKNG_PROPERTY_COMMA;
 1350|      0|		break;
 1351|      0|	case 0x1000:
 1352|      0|		if (c >= 0x104A && c <= 0x104B) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1353|      0|		if (c == 0x10FB)                return ESPEAKNG_PROPERTY_PARAGRAPH_SEPARATOR;
 1354|      0|		break;
 1355|      0|	case 0x1300:
 1356|      0|		if (c == 0x1361)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1357|      0|		if (c == 0x1362)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1358|      0|		if (c == 0x1363)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA;
 1359|      0|		if (c == 0x1364)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_SEMI_COLON;
 1360|      0|		if (c >= 0x1365 && c <= 0x1366) return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COLON;
 1361|      0|		if (c == 0x1367)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_QUESTION_MARK;
 1362|      0|		if (c == 0x1368)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_PARAGRAPH_SEPARATOR;
 1363|      0|		break;
 1364|      0|	case 0x1600:
 1365|      0|		if (c == 0x166D)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1366|      0|		if (c == 0x166E)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1367|      0|		if (c >= 0x16EB && c <= 0x16ED) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1368|      0|		break;
 1369|      0|	case 0x1700:
 1370|      0|		if (c >= 0x1735 && c <= 0x1736) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1371|      0|		if (c >= 0x17D4 && c <= 0x17D6) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1372|      0|		if (c == 0x17DA)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1373|      0|		break;
 1374|      0|	case 0x1800:
 1375|      0|		if (c == 0x1801)                return ESPEAKNG_PROPERTY_ELLIPSIS;
 1376|      0|		if (c == 0x1802)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA;
 1377|      0|		if (c == 0x1803)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1378|      0|		if (c == 0x1804)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COLON;
 1379|      0|		if (c == 0x1805)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1380|      0|		if (c == 0x1808)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA;
 1381|      0|		if (c == 0x1809)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1382|      0|		if (c == 0x180A)                return UCD_PROPERTY_EXTENDER;
 1383|      0|		break;
 1384|      0|	case 0x1900:
 1385|      0|		if (c == 0x1944)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_EXCLAMATION_MARK;
 1386|      0|		if (c == 0x1945)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_QUESTION_MARK;
 1387|      0|		break;
 1388|      0|	case 0x1A00:
 1389|      0|		if (c >= 0x1AA8 && c <= 0x1AAB) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1390|      0|		break;
 1391|      0|	case 0x1B00:
 1392|      0|		if (c >= 0x1B5A && c <= 0x1B5B) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1393|      0|		if (c == 0x1B5D)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1394|      0|		if (c >= 0x1B5E && c <= 0x1B5F) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1395|      0|		break;
 1396|      0|	case 0x1C00:
 1397|      0|		if (c >= 0x1C3B && c <= 0x1C3C) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1398|      0|		if (c >= 0x1C3D && c <= 0x1C3F) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1399|      0|		if (c >= 0x1C7E && c <= 0x1C7F) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1400|      0|		if (c == 0x1CD3)                return UCD_PROPERTY_DIACRITIC;
 1401|      0|		break;
 1402|      0|	case 0x2000:
 1403|      0|		if (c == 0x2016)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1404|      0|		if (c == 0x2017)                return UCD_PROPERTY_PATTERN_SYNTAX;
 1405|      0|		if (c == 0x2026)                return UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_ELLIPSIS;
 1406|      0|		if (c >= 0x2020 && c <= 0x2027) return UCD_PROPERTY_PATTERN_SYNTAX;
 1407|      0|		if (c >= 0x2032 && c <= 0x2034) return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_OTHER_MATH;
 1408|      0|		if (c >= 0x2030 && c <= 0x2038) return UCD_PROPERTY_PATTERN_SYNTAX;
 1409|      0|		if (c == 0x203C)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_EXCLAMATION_MARK | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1410|      0|		if (c == 0x203D)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | UCD_PROPERTY_PATTERN_SYNTAX;
 1411|      0|		if (c >= 0x203B && c <= 0x203E) return UCD_PROPERTY_PATTERN_SYNTAX;
 1412|      0|		if (c >= 0x2041 && c <= 0x2043) return UCD_PROPERTY_PATTERN_SYNTAX;
 1413|      0|		if (c == 0x2047)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_QUESTION_MARK;
 1414|      0|		if (c == 0x2048)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_QUESTION_MARK | ESPEAKNG_PROPERTY_EXCLAMATION_MARK;
 1415|      0|		if (c == 0x2049)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_QUESTION_MARK | ESPEAKNG_PROPERTY_EXCLAMATION_MARK | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1416|      0|		if (c == 0x204F)                return UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_SEMI_COLON;
 1417|      0|		if (c >= 0x204A && c <= 0x2051) return UCD_PROPERTY_PATTERN_SYNTAX;
 1418|      0|		if (c == 0x2053)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_DASH;
 1419|      0|		if (c >= 0x2055 && c <= 0x205E) return UCD_PROPERTY_PATTERN_SYNTAX;
 1420|      0|		break;
 1421|      0|	case 0x2C00:
 1422|      0|		if (c == 0x2CF9)                return ESPEAKNG_PROPERTY_FULL_STOP;
 1423|      0|		if (c >= 0x2CFA && c <= 0x2CFB) return ESPEAKNG_PROPERTY_QUESTION_MARK;
 1424|      0|		if (c == 0x2CFE)                return ESPEAKNG_PROPERTY_FULL_STOP;
 1425|      0|		break;
 1426|      0|	case 0x2E00:
 1427|      0|		if (c == 0x2E2E)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | UCD_PROPERTY_PATTERN_SYNTAX;
 1428|      0|		if (c == 0x2E32)                return UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_COMMA;
 1429|      0|		if (c == 0x2E33)                return UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_FULL_STOP;
 1430|      0|		if (c == 0x2E34)                return UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_COMMA;
 1431|      0|		if (c == 0x2E35)                return UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_SEMI_COLON;
 1432|      0|		if (c == 0x2E3C)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_FULL_STOP;
 1433|      0|		if (c == 0x2E41)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_COMMA;
 1434|      0|		if (c == 0x2E4C)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_PATTERN_SYNTAX;
 1435|      0|		if (c == 0x2E4E)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_PATTERN_SYNTAX;
 1436|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1437|      0|	case 0x3000:
 1438|      0|		if (c == 0x3001)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_COMMA | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER;
 1439|      0|		if (c == 0x3002)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_FULL_STOP | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER;
 1440|      0|		if (c == 0x3003)                return UCD_PROPERTY_PATTERN_SYNTAX;
 1441|      0|		if (c == 0x303D)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1442|      0|		if (c == 0x30FB)                return UCD_PROPERTY_HYPHEN;
 1443|      0|		break;
 1444|      0|	case 0xA400:
 1445|      0|		if (c == 0xA4FE)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA;
 1446|      0|		if (c == 0xA4FF)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1447|      0|		break;
 1448|      0|	case 0xA600:
 1449|      0|		if (c == 0xA60D)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA;
 1450|      0|		if (c == 0xA60E)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1451|      0|		if (c == 0xA60F)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_QUESTION_MARK;
 1452|      0|		if (c == 0xA6F3)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1453|      0|		if (c == 0xA6F4)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COLON;
 1454|      0|		if (c == 0xA6F5)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA;
 1455|      0|		if (c == 0xA6F6)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_SEMI_COLON;
 1456|      0|		if (c == 0xA6F7)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_QUESTION_MARK;
 1457|      0|		break;
 1458|      0|	case 0xA800:
 1459|      0|		if (c >= 0xA876 && c <= 0xA877) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1460|      0|		if (c >= 0xA8CE && c <= 0xA8CF) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1461|      0|		break;
 1462|      0|	case 0xA900:
 1463|      0|		if (c == 0xA92E)                return UCD_PROPERTY_DIACRITIC;
 1464|      0|		if (c == 0xA92F)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1465|      0|		if (c == 0xA9C7)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1466|      0|		if (c >= 0xA9C8 && c <= 0xA9C9) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1467|      0|		break;
 1468|      0|	case 0xAA00:
 1469|      0|		if (c >= 0xAA5D && c <= 0xAA5F) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1470|      0|		if (c == 0xAADF)                return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1471|      0|		if (c >= 0xAAF0 && c <= 0xAAF1) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1472|      0|		break;
 1473|      0|	case 0xAB00:
 1474|      0|		if (c == 0xABEB)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1475|      0|		break;
 1476|      0|	case 0xFE00:
 1477|      0|		if (c >= 0xFE10 && c <= 0xFE11) return ESPEAKNG_PROPERTY_COMMA;
 1478|      0|		if (c == 0xFE12)                return ESPEAKNG_PROPERTY_FULL_STOP;
 1479|      0|		if (c == 0xFE13)                return ESPEAKNG_PROPERTY_COLON;
 1480|      0|		if (c == 0xFE14)                return ESPEAKNG_PROPERTY_SEMI_COLON;
 1481|      0|		if (c == 0xFE15)                return ESPEAKNG_PROPERTY_EXCLAMATION_MARK;
 1482|      0|		if (c == 0xFE16)                return ESPEAKNG_PROPERTY_QUESTION_MARK;
 1483|      0|		if (c == 0xFE19)                return ESPEAKNG_PROPERTY_ELLIPSIS;
 1484|      0|		if (c >= 0xFE45 && c <= 0xFE46) return UCD_PROPERTY_PATTERN_SYNTAX;
 1485|      0|		if (c >= 0xFE50 && c <= 0xFE51) return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA;
 1486|      0|		if (c == 0xFE52)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1487|      0|		if (c == 0xFE54)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_SEMI_COLON;
 1488|      0|		if (c == 0xFE55)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COLON;
 1489|      0|		if (c == 0xFE56)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_QUESTION_MARK;
 1490|      0|		if (c == 0xFE57)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_EXCLAMATION_MARK;
 1491|      0|		if (c == 0xFE61)                return UCD_PROPERTY_OTHER_MATH;
 1492|      0|		if (c == 0xFE68)                return UCD_PROPERTY_OTHER_MATH;
 1493|      0|		break;
 1494|      0|	case 0xFF00:
 1495|      0|		if (c == 0xFF01)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_EXCLAMATION_MARK | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER;
 1496|      0|		if (c == 0xFF02)                return UCD_PROPERTY_QUOTATION_MARK;
 1497|      0|		if (c == 0xFF07)                return UCD_PROPERTY_QUOTATION_MARK;
 1498|      0|		if (c == 0xFF0C)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER;
 1499|      0|		if (c == 0xFF0E)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER;
 1500|      0|		if (c == 0xFF3C)                return UCD_PROPERTY_OTHER_MATH;
 1501|      0|		if (c == 0xFF65)                return UCD_PROPERTY_HYPHEN;
 1502|      0|		if (c == 0xFF1A)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COLON | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER;
 1503|      0|		if (c == 0xFF1B)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_SEMI_COLON | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER;
 1504|      0|		if (c == 0xFF1F)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_QUESTION_MARK | ESPEAKNG_PROPERTY_OPTIONAL_SPACE_AFTER;
 1505|      0|		if (c == 0xFF61)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1506|      0|		if (c == 0xFF64)                return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA;
 1507|      0|		break;
 1508|      0|	case 0x10300:
 1509|      0|		if (c == 0x01039F)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1510|      0|		if (c == 0x0103D0)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1511|      0|		break;
 1512|      0|	case 0x10800:
 1513|      0|		if (c == 0x010857)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1514|      0|		break;
 1515|      0|	case 0x10900:
 1516|      0|		if (c == 0x01091F)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1517|      0|		break;
 1518|      0|	case 0x10A00:
 1519|      0|		if (c >= 0x010A56 && c <= 0x010A57) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1520|      0|		if (c >= 0x010AF0 && c <= 0x010AF5) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1521|      0|		break;
 1522|      0|	case 0x10B00:
 1523|      0|		if (c >= 0x010B3A && c <= 0x010B3F) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1524|      0|		if (c >= 0x010B99 && c <= 0x010B9C) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1525|      0|		break;
 1526|      0|	case 0x10F00:
 1527|      0|		if (c >= 0x10F55 && c <= 0x10F59)   return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1528|      0|		break;
 1529|      0|	case 0x11000:
 1530|      0|		if (c >= 0x011047 && c <= 0x011048) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1531|      0|		if (c >= 0x011049 && c <= 0x01104D) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1532|      0|		if (c >= 0x0110BE && c <= 0x0110C1) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1533|      0|		break;
 1534|      0|	case 0x11100:
 1535|      0|		if (c >= 0x011141 && c <= 0x011142) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1536|      0|		if (c == 0x011143)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_QUESTION_MARK;
 1537|      0|		if (c >= 0x0111C5 && c <= 0x0111C6) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1538|      0|		if (c == 0x0111CD)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1539|      0|		if (c >= 0x0111DE && c <= 0x0111DF) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1540|      0|		break;
 1541|      0|	case 0x11200:
 1542|      0|		if (c == 0x01123A)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1543|      0|		if (c >= 0x011238 && c <= 0x01123C) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1544|      0|		if (c == 0x0112A9)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1545|      0|		break;
 1546|      0|	case 0x11400:
 1547|      0|		if (c >= 0x01144B && c <= 0x01144C) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1548|      0|		if (c == 0x01144D)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA;
 1549|      0|		if (c == 0x01145B)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1550|      0|		break;
 1551|      0|	case 0x11500:
 1552|      0|		if (c >= 0x0115C2 && c <= 0x0115C3) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1553|      0|		if (c >= 0x0115C4 && c <= 0x0115C5) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1554|      0|		if (c >= 0x0115C6 && c <= 0x0115C8) return UCD_PROPERTY_EXTENDER;
 1555|      0|		if (c >= 0x0115C9 && c <= 0x0115D7) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1556|      0|		break;
 1557|      0|	case 0x11600:
 1558|      0|		if (c >= 0x011641 && c <= 0x011642) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1559|      0|		break;
 1560|      0|	case 0x11700:
 1561|      0|		if (c >= 0x01173C && c <= 0x01173E) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1562|      0|		break;
 1563|      0|	case 0x11A00:
 1564|      0|		if (c >= 0x011A42 && c <= 0x011A43) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1565|      0|		if (c >= 0x011A9B && c <= 0x011A9C) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1566|      0|		if (c >= 0x011AA1 && c <= 0x011AA2) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1567|      0|		break;
 1568|      0|	case 0x11C00:
 1569|      0|		if (c >= 0x011C41 && c <= 0x011C42) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1570|      0|		if (c == 0x011C43)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1571|      0|		if (c == 0x011C71)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1572|      0|		break;
 1573|      0|	case 0x11E00:
 1574|      0|		if (c >= 0x11EF7 && c <= 0x11EF8)   return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1575|      0|		break;
 1576|      0|	case 0x12400:
 1577|      0|		if (c >= 0x012471 && c <= 0x012472) return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COLON;
 1578|      0|		if (c >= 0x012470 && c <= 0x012474) return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1579|      0|		break;
 1580|      0|	case 0x16E00:
 1581|      0|		if (c == 0x016E97)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1582|      0|		if (c == 0x016E98)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1583|      0|		break;
 1584|      0|	case 0x16A00:
 1585|      0|		if (c >= 0x016A6E && c <= 0x016A6F) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1586|      0|		if (c == 0x016AF5)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1587|      0|		break;
 1588|      0|	case 0x16B00:
 1589|      0|		if (c >= 0x016B37 && c <= 0x016B38) return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1590|      0|		if (c == 0x016B39)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION;
 1591|      0|		if (c == 0x016B44)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL;
 1592|      0|		break;
 1593|      0|	case 0x1BC00:
 1594|      0|		if (c == 0x01BC9F)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1595|      0|		break;
 1596|      0|	case 0x1DA00:
 1597|      0|		if (c == 0x01DA87)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COMMA;
 1598|      0|		if (c == 0x01DA88)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION | UCD_PROPERTY_SENTENCE_TERMINAL | ESPEAKNG_PROPERTY_FULL_STOP;
 1599|      0|		if (c == 0x01DA89)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_SEMI_COLON;
 1600|      0|		if (c == 0x01DA8A)                  return UCD_PROPERTY_TERMINAL_PUNCTUATION | ESPEAKNG_PROPERTY_COLON;
 1601|      0|		break;
 1602|      0|	case 0x1E900:
 1603|      0|		if (c == 0x01E95E)              return ESPEAKNG_PROPERTY_EXCLAMATION_MARK;
 1604|      0|		if (c == 0x01E95F)              return ESPEAKNG_PROPERTY_QUESTION_MARK;
 1605|      0|		break;
 1606|      0|	}
 1607|      0|	return 0;
 1608|      0|}
 1609|       |
 1610|       |static ucd_property properties_Ps(codepoint_t c)
 1611|      0|{
 1612|      0|	switch (c & 0xFFFFFF00)
 1613|      0|	{
 1614|      0|	case 0x0000:
 1615|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1616|      0|	case 0x2000:
 1617|      0|		if (c == 0x201A)                return UCD_PROPERTY_QUOTATION_MARK | UCD_PROPERTY_PATTERN_SYNTAX;
 1618|      0|		if (c == 0x201E)                return UCD_PROPERTY_QUOTATION_MARK | UCD_PROPERTY_PATTERN_SYNTAX;
 1619|      0|		if (c == 0x2045)                return UCD_PROPERTY_PATTERN_SYNTAX;
 1620|      0|		if (c == 0x207D)                return UCD_PROPERTY_OTHER_MATH;
 1621|      0|		if (c == 0x208D)                return UCD_PROPERTY_OTHER_MATH;
 1622|      0|		break;
 1623|      0|	case 0x2300:
 1624|      0|		if (c == 0x2308)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1625|      0|		if (c == 0x230A)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1626|      0|		if (c == 0x2329)                return UCD_PROPERTY_DEPRECATED | UCD_PROPERTY_PATTERN_SYNTAX;
 1627|      0|		break;
 1628|      0|	case 0x2700:
 1629|      0|		if (c == 0x27C5)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1630|      0|		if (c >= 0x27E6 && c <= 0x27EF) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX; /* Pe|Ps */
 1631|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1632|      0|	case 0x2900:
 1633|      0|		return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1634|      0|	case 0x2E00:
 1635|      0|		if (c == 0x2E42)                return UCD_PROPERTY_QUOTATION_MARK | UCD_PROPERTY_PATTERN_SYNTAX;
 1636|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1637|      0|	case 0x3000:
 1638|      0|		if (c == 0x300C)                return UCD_PROPERTY_QUOTATION_MARK | UCD_PROPERTY_PATTERN_SYNTAX;
 1639|      0|		if (c == 0x300E)                return UCD_PROPERTY_QUOTATION_MARK | UCD_PROPERTY_PATTERN_SYNTAX;
 1640|      0|		if (c == 0x301D)                return UCD_PROPERTY_QUOTATION_MARK | UCD_PROPERTY_PATTERN_SYNTAX;
 1641|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1642|      0|	case 0xFD00:
 1643|      0|		if (c == 0xFD3F)                return UCD_PROPERTY_PATTERN_SYNTAX;
 1644|      0|		break;
 1645|      0|	case 0xFE00:
 1646|      0|		if (c == 0xFE41)                return UCD_PROPERTY_QUOTATION_MARK;
 1647|      0|		if (c == 0xFE43)                return UCD_PROPERTY_QUOTATION_MARK;
 1648|      0|		break;
 1649|      0|	case 0xFF00:
 1650|      0|		if (c == 0xFF62)                return UCD_PROPERTY_QUOTATION_MARK;
 1651|      0|		break;
 1652|      0|	}
 1653|      0|	return 0;
 1654|      0|}
 1655|       |
 1656|       |static ucd_property properties_Sc(codepoint_t c)
 1657|      0|{
 1658|      0|	switch (c & 0xFFFFFF00)
 1659|      0|	{
 1660|      0|	case 0x0000:
 1661|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1662|      0|	}
 1663|      0|	return 0;
 1664|      0|}
 1665|       |
 1666|       |static ucd_property properties_Sk(codepoint_t c)
 1667|      0|{
 1668|      0|	switch (c & 0xFFFFFF00)
 1669|      0|	{
 1670|      0|	case 0x0000:
 1671|      0|		if (c == 0x005E)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_PATTERN_SYNTAX;
 1672|      0|		if (c == 0x0060)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_PATTERN_SYNTAX;
 1673|      0|		if (c == 0x00A8)                return UCD_PROPERTY_DIACRITIC;
 1674|      0|		if (c == 0x00AF)                return UCD_PROPERTY_DIACRITIC;
 1675|      0|		if (c == 0x00B4)                return UCD_PROPERTY_DIACRITIC;
 1676|      0|		if (c == 0x00B8)                return UCD_PROPERTY_DIACRITIC;
 1677|      0|		break;
 1678|      0|	case 0x0200:
 1679|      0|		if (c >= 0x02C2 && c <= 0x02C5) return UCD_PROPERTY_DIACRITIC;
 1680|      0|		if (c >= 0x02D2 && c <= 0x02DF) return UCD_PROPERTY_DIACRITIC;
 1681|      0|		if (c >= 0x02E5 && c <= 0x02EB) return UCD_PROPERTY_DIACRITIC;
 1682|      0|		if (c == 0x02ED)                return UCD_PROPERTY_DIACRITIC;
 1683|      0|		if (c >= 0x02EF && c <= 0x02FF) return UCD_PROPERTY_DIACRITIC;
 1684|      0|		break;
 1685|      0|	case 0x0300:
 1686|      0|		if (c == 0x0375)                return UCD_PROPERTY_DIACRITIC;
 1687|      0|		if (c >= 0x0384 && c <= 0x0385) return UCD_PROPERTY_DIACRITIC;
 1688|      0|		break;
 1689|      0|	case 0x1F00:
 1690|      0|		if (c == 0x1FBD)                return UCD_PROPERTY_DIACRITIC;
 1691|      0|		if (c >= 0x1FBF && c <= 0x1FC1) return UCD_PROPERTY_DIACRITIC;
 1692|      0|		if (c >= 0x1FCD && c <= 0x1FCF) return UCD_PROPERTY_DIACRITIC;
 1693|      0|		if (c >= 0x1FDD && c <= 0x1FDF) return UCD_PROPERTY_DIACRITIC;
 1694|      0|		if (c >= 0x1FED && c <= 0x1FEF) return UCD_PROPERTY_DIACRITIC;
 1695|      0|		if (c >= 0x1FFD && c <= 0x1FFE) return UCD_PROPERTY_DIACRITIC;
 1696|      0|		break;
 1697|      0|	case 0x3000:
 1698|      0|		if (c >= 0x309B && c <= 0x309C) return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_ID_START;
 1699|      0|		break;
 1700|      0|	case 0xA700:
 1701|      0|		if (c >= 0xA720 && c <= 0xA721) return UCD_PROPERTY_DIACRITIC;
 1702|      0|		break;
 1703|      0|	case 0xAB00:
 1704|      0|		if (c == 0xAB5B)                return UCD_PROPERTY_DIACRITIC;
 1705|      0|		break;
 1706|      0|	case 0xFF00:
 1707|      0|		if (c == 0xFF3E)                return UCD_PROPERTY_DIACRITIC | UCD_PROPERTY_OTHER_MATH;
 1708|      0|		if (c == 0xFF40)                return UCD_PROPERTY_DIACRITIC;
 1709|      0|		if (c == 0xFFE3)                return UCD_PROPERTY_DIACRITIC;
 1710|      0|		break;
 1711|      0|	case 0x01F300:
 1712|      0|		return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER | UCD_PROPERTY_EMOJI_COMPONENT;
 1713|      0|	}
 1714|      0|	return 0;
 1715|      0|}
 1716|       |
 1717|       |static ucd_property properties_Sm(codepoint_t c)
 1718|      0|{
 1719|      0|	switch (c & 0xFFFFFF00)
 1720|      0|	{
 1721|      0|	case 0x0000:
 1722|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1723|      0|	case 0x2000:
 1724|      0|		if (c == 0x2044)                return UCD_PROPERTY_PATTERN_SYNTAX;
 1725|      0|		if (c == 0x2052)                return UCD_PROPERTY_PATTERN_SYNTAX;
 1726|      0|		if (c == 0x207B)                return UCD_PROPERTY_DASH;
 1727|      0|		if (c == 0x208B)                return UCD_PROPERTY_DASH;
 1728|      0|		break;
 1729|      0|	case 0x2100:
 1730|      0|		if (c == 0x2118)                return UCD_PROPERTY_OTHER_ID_START;
 1731|      0|		if (c == 0x2194)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1732|      0|		if (c >= 0x2190)                return UCD_PROPERTY_PATTERN_SYNTAX;
 1733|      0|		break;
 1734|      0|	case 0x2200:
 1735|      0|		if (c == 0x2212)                return UCD_PROPERTY_DASH | UCD_PROPERTY_PATTERN_SYNTAX;
 1736|      0|		if (c >= 0x22EE && c <= 0x22F1) return UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_ELLIPSIS;
 1737|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1738|      0|	case 0x2300:
 1739|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1740|      0|	case 0x2500:
 1741|      0|		if (c >= 0x25FB && c <= 0x25FC) return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1742|      0|		if (c >= 0x25FD && c <= 0x25FE) return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1743|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1744|      0|	case 0x2600:
 1745|      0|		if (c == 0x266F)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1746|      0|	case 0x2700:
 1747|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1748|      0|	case 0x2900:
 1749|      0|		if (c >= 0x2934 && c <= 0x2935) return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1750|      0|		if (c == 0x2982)                return UCD_PROPERTY_PATTERN_SYNTAX | ESPEAKNG_PROPERTY_COLON;
 1751|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1752|      0|	case 0x2A00:
 1753|      0|	case 0x2B00:
 1754|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1755|      0|	}
 1756|      0|	return 0;
 1757|      0|}
 1758|       |
 1759|       |static ucd_property properties_So_002600(codepoint_t c)
 1760|      0|{
 1761|      0|	switch (c & 0xFFFFFFF0)
 1762|      0|	{
 1763|      0|	case 0x2600:
 1764|      0|		if (c <= 0x2604)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1765|      0|		if (c == 0x2605)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1766|      0|		if (c == 0x2606)                return UCD_PROPERTY_OTHER_MATH;
 1767|      0|		if (c == 0x260E)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1768|      0|		break;
 1769|      0|	case 0x2610:
 1770|      0|		if (c == 0x2611)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1771|      0|		if (c == 0x2613)                return 0;
 1772|      0|		if (c == 0x2614)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1773|      0|		if (c == 0x2615)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1774|      0|		if (c == 0x2618)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1775|      0|		if (c == 0x261D)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 1776|      0|		break;
 1777|      0|	case 0x2620:
 1778|      0|		if (c == 0x2620)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1779|      0|		if (c >= 0x2622 && c <= 0x2623) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1780|      0|		if (c == 0x2626)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1781|      0|		if (c == 0x262A)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1782|      0|		if (c >= 0x262E)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1783|      0|		break;
 1784|      0|	case 0x2630:
 1785|      0|		if (c >= 0x2638 && c <= 0x263A) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1786|      0|		break;
 1787|      0|	case 0x2640:
 1788|      0|		if (c == 0x2640)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1789|      0|		if (c == 0x2642)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1790|      0|		if (c >= 0x2648)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1791|      0|		break;
 1792|      0|	case 0x2650:
 1793|      0|		if (c <= 0x2653)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1794|      0|		if (c == 0x265F)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1795|      0|		break;
 1796|      0|	case 0x2660:
 1797|      0|		if (c == 0x2606)                return UCD_PROPERTY_OTHER_MATH;
 1798|      0|		if (c == 0x2660)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1799|      0|		if (c >= 0x2661 && c <= 0x2662) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1800|      0|		if (c == 0x2663)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1801|      0|		if (c >= 0x2665 && c <= 0x2666) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1802|      0|		if (c == 0x2668)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1803|      0|		if (c >= 0x266D && c <= 0x266E) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1804|      0|		break;
 1805|      0|	case 0x2670:
 1806|      0|		if (c == 0x267B)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1807|      0|		if (c == 0x267E)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1808|      0|		if (c == 0x267F)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1809|      0|		break;
 1810|      0|	case 0x2680:
 1811|      0|		if (c >= 0x2686)                return 0;
 1812|      0|		break;
 1813|      0|	case 0x2690:
 1814|      0|		if (c == 0x2693)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1815|      0|		if (c >= 0x2692 && c <= 0x2697) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1816|      0|		if (c == 0x2699)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1817|      0|		if (c >= 0x269B && c <= 0x269C) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1818|      0|		break;
 1819|      0|	case 0x26A0:
 1820|      0|		if (c == 0x26A0)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1821|      0|		if (c == 0x26A1)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1822|      0|		if (c >= 0x26AA && c <= 0x26AB) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1823|      0|		break;
 1824|      0|	case 0x26B0:
 1825|      0|		if (c >= 0x26B0 && c <= 0x26B1) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1826|      0|		if (c >= 0x26BD && c <= 0x26BE) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1827|      0|		break;
 1828|      0|	case 0x26C0:
 1829|      0|		if (c >= 0x26C4 && c <= 0x26C5) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1830|      0|		if (c == 0x26C8)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1831|      0|		if (c == 0x26CE)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1832|      0|		if (c == 0x26CF)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1833|      0|		break;
 1834|      0|	case 0x26D0:
 1835|      0|		if (c == 0x26D1)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1836|      0|		if (c == 0x26D3)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1837|      0|		if (c == 0x26D4)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1838|      0|		break;
 1839|      0|	case 0x26E0:
 1840|      0|		if (c == 0x26E9)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1841|      0|		if (c == 0x26EA)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1842|      0|		break;
 1843|      0|	case 0x26F0:
 1844|      0|		if (c <= 0x26F1)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1845|      0|		if (c == 0x26F4)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1846|      0|		if (c <= 0x26F5)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1847|      0|		if (c >= 0x26F7 && c <= 0x26F8) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1848|      0|		if (c == 0x26F9)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 1849|      0|		if (c == 0x26FA)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1850|      0|		if (c == 0x26FD)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1851|      0|		break;
 1852|      0|	}
 1853|      0|	return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1854|      0|}
 1855|       |
 1856|       |static ucd_property properties_So_002700(codepoint_t c)
 1857|      0|{
 1858|      0|	switch (c & 0xFFFFFFF0)
 1859|      0|	{
 1860|      0|	case 0x2700:
 1861|      0|		if (c == 0x2702)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1862|      0|		if (c <= 0x2704)                return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1863|      0|		if (c == 0x2705)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1864|      0|		if (c >= 0x270A && c <= 0x270B) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 1865|      0|		if (c >= 0x270C && c <= 0x270D) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 1866|      0|		if (c >= 0x2708 && c <= 0x270D) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1867|      0|		if (c == 0x270E)                return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1868|      0|		if (c == 0x270F)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1869|      0|		break;
 1870|      0|	case 0x2710:
 1871|      0|		if (c <= 0x2711)                return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1872|      0|		if (c == 0x2712)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1873|      0|		if (c == 0x2714)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1874|      0|		if (c == 0x2716)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1875|      0|		if (c == 0x271D)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1876|      0|		break;
 1877|      0|	case 0x2720:
 1878|      0|		if (c == 0x2721)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1879|      0|		if (c == 0x2728)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1880|      0|		break;
 1881|      0|	case 0x2730:
 1882|      0|		if (c == 0x2733)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1883|      0|		if (c == 0x2734)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1884|      0|		break;
 1885|      0|	case 0x2740:
 1886|      0|		if (c == 0x2744)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1887|      0|		if (c == 0x2747)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1888|      0|		if (c == 0x274C)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1889|      0|		if (c == 0x274E)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1890|      0|		break;
 1891|      0|	case 0x2750:
 1892|      0|		if (c >= 0x2753 && c <= 0x2754) return ESPEAKNG_PROPERTY_QUESTION_MARK | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1893|      0|		if (c == 0x2755)                return ESPEAKNG_PROPERTY_EXCLAMATION_MARK | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1894|      0|		if (c == 0x2757)                return ESPEAKNG_PROPERTY_EXCLAMATION_MARK | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1895|      0|		break;
 1896|      0|	case 0x2760:
 1897|      0|		if (c == 0x2762)                return ESPEAKNG_PROPERTY_EXCLAMATION_MARK;
 1898|      0|		if (c == 0x2763)                return ESPEAKNG_PROPERTY_EXCLAMATION_MARK | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1899|      0|		if (c == 0x2764)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1900|      0|		if (c >= 0x2765)                return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1901|      0|		break;
 1902|      0|	case 0x2790:
 1903|      0|		if (c >= 0x2795 && c <= 0x2797) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1904|      0|		break;
 1905|      0|	case 0x27A0:
 1906|      0|		if (c == 0x27A1)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1907|      0|		break;
 1908|      0|	case 0x27B0:
 1909|      0|		if (c == 0x27B0)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1910|      0|		if (c == 0x27BF)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1911|      0|		break;
 1912|      0|	}
 1913|      0|	return 0;
 1914|      0|}
 1915|       |
 1916|       |static ucd_property properties_So(codepoint_t c)
 1917|      0|{
 1918|      0|	switch (c & 0xFFFFFF00)
 1919|      0|	{
 1920|      0|	case 0x0000:
 1921|      0|		if (c == 0x00A9)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1922|      0|		if (c == 0x00AE)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1923|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1924|      0|	case 0x2100:
 1925|      0|		if (c == 0x2122)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1926|      0|		if (c == 0x2129)                return UCD_PROPERTY_OTHER_MATH;
 1927|      0|		if (c == 0x212E)                return UCD_PROPERTY_OTHER_ID_START;
 1928|      0|		if (c == 0x21A8)                return UCD_PROPERTY_PATTERN_SYNTAX;
 1929|      0|		if (c == 0x21A9)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1930|      0|		if (c == 0x21AA)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1931|      0|		if (c >= 0x2195 && c <= 0x2199) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1932|      0|		if (c >= 0x219C && c <= 0x21AD) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1933|      0|		if (c >= 0x21B0 && c <= 0x21B1) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1934|      0|		if (c >= 0x21B6 && c <= 0x21B7) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1935|      0|		if (c >= 0x21AF && c <= 0x21BB) return UCD_PROPERTY_PATTERN_SYNTAX;
 1936|      0|		if (c >= 0x21BC && c <= 0x21CD) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1937|      0|		if (c >= 0x21D0 && c <= 0x21D1) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1938|      0|		if (c == 0x21D3)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1939|      0|		if (c >= 0x21D5 && c <= 0x21DB) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1940|      0|		if (c == 0x21DD)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1941|      0|		if (c >= 0x21E4 && c <= 0x21E5) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1942|      0|		if (c >= 0x21D5 && c <= 0x21F3) return UCD_PROPERTY_PATTERN_SYNTAX;
 1943|      0|		break;
 1944|      0|	case 0x2300:
 1945|      0|		if                (c <= 0x2307) return UCD_PROPERTY_PATTERN_SYNTAX;
 1946|      0|		if (c >= 0x231A && c <= 0x231B) return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1947|      0|		if (c >= 0x230C && c <= 0x231F) return UCD_PROPERTY_PATTERN_SYNTAX;
 1948|      0|		if (c >= 0x2322 && c <= 0x2327) return UCD_PROPERTY_PATTERN_SYNTAX;
 1949|      0|		if (c == 0x2328)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1950|      0|		if (c >= 0x232B && c <= 0x237B) return UCD_PROPERTY_PATTERN_SYNTAX;
 1951|      0|		if (c == 0x2388)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1952|      0|		if (c >= 0x237D && c <= 0x239A) return UCD_PROPERTY_PATTERN_SYNTAX;
 1953|      0|		if (c >= 0x23B4 && c <= 0x23B5) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1954|      0|		if (c == 0x23B7)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1955|      0|		if (c == 0x23CF)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1956|      0|		if (c == 0x23D0)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1957|      0|		if (c >= 0x23B4 && c <= 0x23DB) return UCD_PROPERTY_PATTERN_SYNTAX;
 1958|      0|		if (c == 0x23E2)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1959|      0|		if (c >= 0x23E9 && c <= 0x23EC) return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1960|      0|		if (c == 0x23F0)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1961|      0|		if (c == 0x23F3)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1962|      0|		if (c >= 0x23E9 && c <= 0x23F3) return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1963|      0|		if (c >= 0x23F8 && c <= 0x23FA) return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1964|      0|		if (c >= 0x23E3)                return UCD_PROPERTY_PATTERN_SYNTAX;
 1965|      0|		break;
 1966|      0|	case 0x2400:
 1967|      0|		if (c >= 0x2400 && c <= 0x244A) return UCD_PROPERTY_PATTERN_SYNTAX;
 1968|      0|		if (c == 0x24C2)                return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_UPPERCASE | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1969|      0|		if (c >= 0x24B6 && c <= 0x24CF) return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_UPPERCASE;
 1970|      0|		if (c >= 0x24D0 && c <= 0x24E9) return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_LOWERCASE;
 1971|      0|		break;
 1972|      0|	case 0x2500:
 1973|      0|		if (c >= 0x25A0 && c <= 0x25A1) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1974|      0|		if (c >= 0x25AA && c <= 0x25AB) return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1975|      0|		if (c >= 0x25AE && c <= 0x25B5) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1976|      0|		if (c == 0x25B6)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1977|      0|		if (c >= 0x25BC && c <= 0x25BF) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1978|      0|		if (c == 0x25C0)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1979|      0|		if (c >= 0x25C6 && c <= 0x25C7) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1980|      0|		if (c >= 0x25CA && c <= 0x25CB) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1981|      0|		if (c >= 0x25CF && c <= 0x25D3) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1982|      0|		if (c == 0x25E2)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1983|      0|		if (c == 0x25E4)                return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1984|      0|		if (c >= 0x25E7 && c <= 0x25EC) return UCD_PROPERTY_OTHER_MATH | UCD_PROPERTY_PATTERN_SYNTAX;
 1985|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1986|      0|	case 0x2600:
 1987|      0|		return properties_So_002600(c) | UCD_PROPERTY_PATTERN_SYNTAX;
 1988|      0|	case 0x2700:
 1989|      0|		return properties_So_002700(c) | UCD_PROPERTY_PATTERN_SYNTAX;
 1990|      0|	case 0x2800:
 1991|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1992|      0|	case 0x2B00:
 1993|      0|		if (c >= 0x2B05 && c <= 0x2B07) return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 1994|      0|		if (c >= 0x2B1B && c <= 0x2B1C) return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1995|      0|		if (c == 0x2B50)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1996|      0|		if (c == 0x2B55)                return UCD_PROPERTY_PATTERN_SYNTAX | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 1997|      0|		return UCD_PROPERTY_PATTERN_SYNTAX;
 1998|      0|	case 0x2E00:
 1999|      0|		if (c >= 0x2E80 && c <= 0x2E99) return UCD_PROPERTY_RADICAL;
 2000|      0|		if (c >= 0x2E9B && c <= 0x2EF3) return UCD_PROPERTY_RADICAL;
 2001|      0|		break;
 2002|      0|	case 0x2F00:
 2003|      0|		if                (c <= 0x2FD5) return UCD_PROPERTY_RADICAL;
 2004|      0|		if (c >= 0x2FF0 && c <= 0x2FF1) return UCD_PROPERTY_IDS_BINARY_OPERATOR;
 2005|      0|		if (c >= 0x2FF2 && c <= 0x2FF3) return UCD_PROPERTY_IDS_TRINARY_OPERATOR;
 2006|      0|		if (c >= 0x2FF4 && c <= 0x2FFB) return UCD_PROPERTY_IDS_BINARY_OPERATOR;
 2007|      0|		break;
 2008|      0|	case 0x3000:
 2009|      0|		if (c >= 0x3012 && c <= 0x3013) return UCD_PROPERTY_PATTERN_SYNTAX;
 2010|      0|		if (c == 0x3020)                return UCD_PROPERTY_PATTERN_SYNTAX;
 2011|      0|		break;
 2012|      0|	case 0x3200:
 2013|      0|		if (c == 0x3297)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2014|      0|		if (c == 0x3299)                return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2015|      0|		break;
 2016|      0|	case 0x01F000:
 2017|      0|		if (c == 0x01F004)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2018|      0|		if (c == 0x01F0CF)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2019|      0|		return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2020|      0|	case 0x01F100:
 2021|      0|		if (c == 0x01F12F)                  return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2022|      0|		if (c >= 0x01F130 && c <= 0x01F149) return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_UPPERCASE;
 2023|      0|		if (c >= 0x01F150 && c <= 0x01F169) return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_UPPERCASE;
 2024|      0|		if (c >= 0x01F170 && c <= 0x01F171) return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_UPPERCASE | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2025|      0|		if (c >= 0x01F17E && c <= 0x01F17F) return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_UPPERCASE | UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2026|      0|		if (c >= 0x01F170 && c <= 0x01F189) return UCD_PROPERTY_OTHER_ALPHABETIC | UCD_PROPERTY_OTHER_UPPERCASE;
 2027|      0|		if (c == 0x01F18E)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2028|      0|		if (c >= 0x01F191 && c <= 0x01F19A) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2029|      0|		if (c >= 0x01F1E6)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_REGIONAL_INDICATOR | UCD_PROPERTY_EMOJI_COMPONENT;
 2030|      0|		break;
 2031|      0|	case 0x01F200:
 2032|      0|		if (c == 0x01F201)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2033|      0|		if (c == 0x01F202)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2034|      0|		if (c == 0x01F21A)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2035|      0|		if (c == 0x01F22F)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2036|      0|		if (c == 0x01F237)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2037|      0|		if (c >= 0x01F232 && c <= 0x01F23A) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2038|      0|		if (c >= 0x01F250 && c <= 0x01F251) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2039|      0|		if (c >= 0x01F260)                  return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2040|      0|		break;
 2041|      0|	case 0x01F300:
 2042|      0|		if                  (c <= 0x01F320) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2043|      0|		if (c == 0x01F321)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2044|      0|		if (c >= 0x01F32D && c <= 0x01F335) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2045|      0|		if (c >= 0x01F337 && c <= 0x01F37C) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2046|      0|		if (c == 0x01F385)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2047|      0|		if (c >= 0x01F37E && c <= 0x01F393) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2048|      0|		if (c >= 0x01F324 && c <= 0x01F393) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2049|      0|		if (c >= 0x01F396 && c <= 0x01F397) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2050|      0|		if (c >= 0x01F399 && c <= 0x01F39B) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2051|      0|		if (c >= 0x01F3C2 && c <= 0x01F3C4) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2052|      0|		if (c == 0x01F3C7)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2053|      0|		if (c >= 0x01F3A0 && c <= 0x01F3C9) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2054|      0|		if (c == 0x01F3CA)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2055|      0|		if (c >= 0x01F3CB && c <= 0x01F3CC) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2056|      0|		if (c >= 0x01F3CF && c <= 0x01F3D3) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2057|      0|		if (c >= 0x01F3E0 && c <= 0x01F3F0) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2058|      0|		if (c >= 0x01F39E && c <= 0x01F3F0) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2059|      0|		if (c == 0x01F3F3)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2060|      0|		if (c == 0x01F3F4)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2061|      0|		if (c == 0x01F3F5)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2062|      0|		if (c == 0x01F3F7)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2063|      0|		if (c >= 0x01F3F8 && c <= 0x01F3FA) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2064|      0|		return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2065|      0|	case 0x01F400:
 2066|      0|		if (c == 0x01F43F)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2067|      0|		if (c == 0x01F441)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2068|      0|		if (c >= 0x01F442 && c <= 0x01F443) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2069|      0|		if (c >= 0x01F446 && c <= 0x01F450) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2070|      0|		if (c >= 0x01F466 && c <= 0x01F469) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2071|      0|		if (c == 0x01F46E)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2072|      0|		if (c >= 0x01F470 && c <= 0x01F478) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2073|      0|		if (c == 0x01F47C)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2074|      0|		if (c >= 0x01F481 && c <= 0x01F483) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2075|      0|		if (c >= 0x01F485 && c <= 0x01F487) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2076|      0|		if (c == 0x01F4AA)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2077|      0|		if (c == 0x01F4FE)                  return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2078|      0|		if (c == 0x01F4FD)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2079|      0|		return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2080|      0|	case 0x01F500:
 2081|      0|		if                  (c <= 0x01F53D) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2082|      0|		if                  (c <= 0x01F545) return 0;
 2083|      0|		if (c >= 0x01F549 && c <= 0x01F54A) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2084|      0|		if (c >= 0x01F54B && c <= 0x01F54E) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2085|      0|		if (c >= 0x01F550 && c <= 0x01F567) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2086|      0|		if (c >= 0x01F56F && c <= 0x01F570) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2087|      0|		if (c >= 0x01F574 && c <= 0x01F575) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2088|      0|		if (c >= 0x01F573 && c <= 0x01F579) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2089|      0|		if (c == 0x01F57A)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2090|      0|		if (c == 0x01F587)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2091|      0|		if (c >= 0x01F58A && c <= 0x01F58D) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2092|      0|		if (c == 0x01F590)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2093|      0|		if (c >= 0x01F595 && c <= 0x01F596) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2094|      0|		if (c == 0x01F5A4)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2095|      0|		if (c == 0x01F5A5)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2096|      0|		if (c == 0x01F5A8)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2097|      0|		if (c >= 0x01F5B1 && c <= 0x01F5B2) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2098|      0|		if (c == 0x01F5BC)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2099|      0|		if (c >= 0x01F5C2 && c <= 0x01F5C4) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2100|      0|		if (c >= 0x01F5D1 && c <= 0x01F5D3) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2101|      0|		if (c >= 0x01F5DC && c <= 0x01F5DE) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2102|      0|		if (c == 0x01F5E1)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2103|      0|		if (c == 0x01F5E3)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2104|      0|		if (c == 0x01F5E8)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2105|      0|		if (c == 0x01F5EF)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2106|      0|		if (c == 0x01F5F3)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2107|      0|		if (c == 0x01F5FA)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2108|      0|		if (c >= 0x01F5FB)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2109|      0|		return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2110|      0|	case 0x01F600:
 2111|      0|		if (c >= 0x01F645 && c <= 0x01F647) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2112|      0|		if (c >= 0x01F64B && c <= 0x01F64F) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2113|      0|		if                  (c <= 0x01F64F) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2114|      0|		if (c >= 0x01F650 && c <= 0x01F67F) return 0;
 2115|      0|		if (c == 0x01F6A3)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2116|      0|		if (c >= 0x01F6B4 && c <= 0x01F6B6) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2117|      0|		if (c == 0x01F6C0)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2118|      0|		if (c >= 0x01F680 && c <= 0x01F6C5) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2119|      0|		if (c == 0x01F6CC)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2120|      0|		if (c >= 0x01F6CB && c <= 0x01F6CF) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2121|      0|		if (c >= 0x01F6D0 && c <= 0x01F6D2) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2122|      0|		if (c >= 0x01F6E0 && c <= 0x01F6E5) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2123|      0|		if (c == 0x01F6E9)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2124|      0|		if (c >= 0x01F6EB && c <= 0x01F6EC) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2125|      0|		if (c == 0x01F6F0)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2126|      0|		if (c == 0x01F6F3)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2127|      0|		if (c >= 0x01F6F4 && c <= 0x01F6F9) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2128|      0|		return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2129|      0|	case 0x01F700:
 2130|      0|		if (c >= 0x01F7D5 && c <= 0x01F7D8) return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2131|      0|		break;
 2132|      0|	case 0x01F900:
 2133|      0|		if (c <= 0x01F90B)                  return 0;
 2134|      0|		if (c >= 0x01F918 && c <= 0x01F91C) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2135|      0|		if (c >= 0x01F91E && c <= 0x01F91F) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2136|      0|		if (c == 0x01F926)                  return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2137|      0|		if (c >= 0x01F930 && c <= 0x01F939) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2138|      0|		if (c == 0x01F93B)                  return 0;
 2139|      0|		if (c >= 0x01F93D && c <= 0x01F93E) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2140|      0|		if (c == 0x01F946)                  return 0;
 2141|      0|		if (c >= 0x01F9B0 && c <= 0x01F9B3) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_COMPONENT;
 2142|      0|		if (c >= 0x01F9B5 && c <= 0x01F9B6) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2143|      0|		if (c >= 0x01F9B8 && c <= 0x01F9B9) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2144|      0|		if (c >= 0x01F9D1 && c <= 0x01F9DD) return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION | UCD_PROPERTY_EMOJI_MODIFIER_BASE;
 2145|      0|		return UCD_PROPERTY_EMOJI | UCD_PROPERTY_EXTENDED_PICTOGRAPHIC | UCD_PROPERTY_EMOJI_PRESENTATION;
 2146|      0|	case 0x01FA00:
 2147|      0|		return UCD_PROPERTY_EXTENDED_PICTOGRAPHIC;
 2148|      0|	}
 2149|      0|	return 0;
 2150|      0|}
 2151|       |
 2152|       |static ucd_property properties_Zs(codepoint_t c)
 2153|      0|{
 2154|      0|	if (c == 0x0020) return UCD_PROPERTY_WHITE_SPACE | UCD_PROPERTY_PATTERN_WHITE_SPACE;
 2155|      0|	return UCD_PROPERTY_WHITE_SPACE;
 2156|      0|}
 2157|       |
 2158|       |ucd_property ucd_properties(codepoint_t c, ucd_category category)
 2159|      0|{
 2160|      0|	switch (category)
 2161|      0|	{
 2162|      0|	case UCD_CATEGORY_Cc: return properties_Cc(c);
 2163|      0|	case UCD_CATEGORY_Cf: return properties_Cf(c);
 2164|      0|	case UCD_CATEGORY_Cn: return properties_Cn(c);
 2165|      0|	case UCD_CATEGORY_Ll: return properties_Ll(c);
 2166|      0|	case UCD_CATEGORY_Lm: return properties_Lm(c);
 2167|      0|	case UCD_CATEGORY_Lo: return properties_Lo(c) | properties_Lo_ideographic(c);
 2168|      0|	case UCD_CATEGORY_Lu: return properties_Lu(c);
 2169|      0|	case UCD_CATEGORY_Mc: return properties_Mc(c);
 2170|      0|	case UCD_CATEGORY_Me: return properties_Me(c);
 2171|      0|	case UCD_CATEGORY_Mn: return properties_Mn(c);
 2172|      0|	case UCD_CATEGORY_Nd: return properties_Nd(c);
 2173|      0|	case UCD_CATEGORY_Nl: return properties_Nl(c);
 2174|      0|	case UCD_CATEGORY_No: return properties_No(c);
 2175|      0|	case UCD_CATEGORY_Pc: return properties_Pc(c);
 2176|      0|	case UCD_CATEGORY_Pd: return properties_Pd(c);
 2177|      0|	case UCD_CATEGORY_Pe: return properties_Pe(c);
 2178|      0|	case UCD_CATEGORY_Pf: return properties_Pf(c);
 2179|      0|	case UCD_CATEGORY_Pi: return properties_Pi(c);
 2180|      0|	case UCD_CATEGORY_Po: return properties_Po(c);
 2181|      0|	case UCD_CATEGORY_Ps: return properties_Ps(c);
 2182|      0|	case UCD_CATEGORY_Sc: return properties_Sc(c);
 2183|      0|	case UCD_CATEGORY_Sk: return properties_Sk(c);
 2184|      0|	case UCD_CATEGORY_Sm: return properties_Sm(c);
 2185|      0|	case UCD_CATEGORY_So: return properties_So(c);
 2186|      0|	case UCD_CATEGORY_Zl: return UCD_PROPERTY_WHITE_SPACE | UCD_PROPERTY_PATTERN_WHITE_SPACE;
 2187|      0|	case UCD_CATEGORY_Zp: return UCD_PROPERTY_WHITE_SPACE | UCD_PROPERTY_PATTERN_WHITE_SPACE | ESPEAKNG_PROPERTY_PARAGRAPH_SEPARATOR;
 2188|      0|	case UCD_CATEGORY_Zs: return properties_Zs(c);
 2189|      0|	default:              return 0; /* Co Cs Ii Lt */
 2190|      0|	};
 2191|      0|}

/home/kmamadoudram/MasterCSI/semestre2/ter/test/espeak-ng/tests/my_fuzzer.c:
    1|       |/*
    2|       | * Copyright (C) 2018 Sascha Brawer
    3|       | *
    4|       | * This program is free software; you can redistribute it and/or modify
    5|       | * it under the terms of the GNU General Public License as published by
    6|       | * the Free Software Foundation; either version 3 of the License, or
    7|       | * (at your option) any later version.
    8|       | *
    9|       | * This program is distributed in the hope that it will be useful,
   10|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   11|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   12|       | * GNU General Public License for more details.
   13|       | *
   14|       | * You should have received a copy of the GNU General Public License
   15|       | * along with this program; if not, write see:
   16|       | *             <http://www.gnu.org/licenses/>.
   17|       | */
   18|       |
   19|       |#include "config.h"
   20|       |
   21|       |#include <stdint.h>
   22|       |#include <stdlib.h>
   23|       |#include <string.h>
   24|       |#include <libgen.h>
   25|       |
   26|       |#include <espeak-ng/espeak_ng.h>
   27|       |
   28|       |/***** CONFIG *****/
   29|       |#define LANGUAGE			"en"
   30|       |#define MAX_LEN				8192
   31|      0|#define ESPEAK_DATA_PATH	"/usr/lib/x86_64-linux-gnu/espeak-ng-data/"
   32|       |
   33|       |#define N_FUZZED_LANG		4
   34|       |static const char *langs[N_FUZZED_LANG+1] = {
   35|       |	"en",
   36|       |	"fr",
   37|       |	"ru",
   38|       |	"Georgian",
   39|       |	NULL
   40|       |};
   41|       |
   42|       |static int initialized = 0;
   43|       |
   44|      0|static int SynthCallback(short *wav, int numsamples, espeak_EVENT *events) {
   45|      0|	(void)wav; // unused
   46|      0|	(void)numsamples; // unused
   47|      0|	(void)events; // unused
   48|      0|
   49|      0|	return 0;
   50|      0|}
   51|       |
   52|       |
   53|       |/* See http://llvm.org/docs/LibFuzzer.html */
   54|       |extern int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size);
   55|       |extern int LLVMFuzzerInitialize(const int* argc, char*** argv);
   56|       |
   57|       |char *filepath = NULL;
   58|       |
   59|       |extern int LLVMFuzzerInitialize(const int* argc, char*** argv)
   60|      0|{
   61|      0|	(void)argc; // unused
   62|      0|	//filepath = dirname(strdup((*argv)[0]));
   63|      0|
   64|      0|	return 0;
   65|      0|}
   66|       |
   67|      0|extern int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
   68|      0|	if (!initialized) {
   69|      0|		const char *hasDataPath = getenv("ESPEAK_DATA_PATH");
   70|      0|		if (!hasDataPath) {
   71|      0|			setenv("ESPEAK_DATA_PATH",ESPEAK_DATA_PATH,0);
   72|      0|		}
   73|      0|		espeak_Initialize(AUDIO_OUTPUT_SYNCHRONOUS, 0, NULL, 0);
   74|      0|		initialized = 1;
   75|      0|		fprintf(stderr, "ESPEAK_DATA_PATH=%s\n", getenv("ESPEAK_DATA_PATH"));
   76|      0|
   77|      0|	}
   78|      0|
   79|      0|	char *str = malloc(size+1);
   80|      0|	memcpy(str, data, size);
   81|      0|	str[size] = 0;
   82|      0|	int synth_flags = espeakCHARS_AUTO ;
   83|      0|	//for (int i=0; i<N_FUZZED_LANG; i++)
   84|      0|	{
   85|      0|	//	espeak_SetVoiceByName(langs[i]);
   86|      0|		espeak_Synth((char*) str, size+1, 0, POS_CHARACTER, 0,
   87|      0|					synth_flags, NULL, NULL);
   88|      0|	}
   89|      0|		free(str);
   90|      0|
   91|      0|
   92|      0|	return 0; 	
   93|      0|}

